{
  "Docs/getting-started.html": {
    "href": "Docs/getting-started.html",
    "title": "Getting Started | hallowed",
    "summary": "Getting Started This is a dummy sentences Subtitle"
  },
  "Docs/introduction.html": {
    "href": "Docs/introduction.html",
    "title": "Introduction | hallowed",
    "summary": "Introduction"
  },
  "api/Hallowed.Core.Container.html": {
    "href": "api/Hallowed.Core.Container.html",
    "title": "Class Container | hallowed",
    "summary": "Class Container Represents a scene graph node that can group and transform multiple DisplayObject instances. Containers allow hierarchical transformations, positioning, and rendering order management. Inheritance object DisplayObject Container SceneBase Implements IDisposable Inherited Members DisplayObject.IsDisposed DisplayObject.WorldTransform DisplayObject.Parent DisplayObject.Children DisplayObject.Visible DisplayObject.Position DisplayObject.X DisplayObject.Y DisplayObject.Scale DisplayObject.Rotation DisplayObject.Origin DisplayObject.Width DisplayObject.Height DisplayObject.GetWorldBounds() DisplayObject.Update(GameTime) DisplayObject.Draw(SpriteBatch) DisplayObject.AddChild(DisplayObject) DisplayObject.AddChild(IEnumerable<DisplayObject>) DisplayObject.AddChild(params DisplayObject[]) DisplayObject.RemoveChild(DisplayObject, bool) DisplayObject.RemoveChild(IEnumerable<DisplayObject>, bool) DisplayObject.RemoveChild(bool, params DisplayObject[]) DisplayObject.MarkDirty() DisplayObject.UpdateWorldTransform() DisplayObject.DecomposeMatrix2D(Matrix, out Vector2, out float, out Vector2) DisplayObject.Dispose() DisplayObject.Dispose(bool) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: Hallowed.Core Assembly: Hallowed.dll Syntax public class Container : DisplayObject, IDisposable Remarks A Container can contain both Sprite and other Container objects, forming a recursive display tree. Transformations applied to the Container (such as position, rotation, or scale) affect all of its children. Methods | Edit this page View Source GetBounds() Declaration public override Rectangle GetBounds() Returns Type Description Rectangle Overrides DisplayObject.GetBounds() Implements IDisposable"
  },
  "api/Hallowed.Core.DisplayObject.html": {
    "href": "api/Hallowed.Core.DisplayObject.html",
    "title": "Class DisplayObject | hallowed",
    "summary": "Class DisplayObject The abstract base class for all renderable objects. Every object that can be rendered should inherit from this class. Inheritance object DisplayObject Container Sprite Implements IDisposable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: Hallowed.Core Assembly: Hallowed.dll Syntax public abstract class DisplayObject : IDisposable Constructors | Edit this page View Source DisplayObject() Declaration protected DisplayObject() Properties | Edit this page View Source Children The objects children. Declaration public List<DisplayObject> Children { get; protected set; } Property Value Type Description List<DisplayObject> | Edit this page View Source Height Declaration public virtual float Height { get; set; } Property Value Type Description float | Edit this page View Source IsDisposed Declaration public bool IsDisposed { get; } Property Value Type Description bool | Edit this page View Source Origin The display object origin. Declaration public virtual Vector2 Origin { get; set; } Property Value Type Description Vector2 | Edit this page View Source Parent The Display object parent. Declaration public DisplayObject Parent { get; } Property Value Type Description DisplayObject | Edit this page View Source Position Declaration public Vector2 Position { get; set; } Property Value Type Description Vector2 | Edit this page View Source Rotation The display object rotation. Declaration public float Rotation { get; set; } Property Value Type Description float | Edit this page View Source Scale The display object scale. Declaration public Vector2 Scale { get; set; } Property Value Type Description Vector2 | Edit this page View Source Visible return whether or not the object will render to the screen. Declaration public bool Visible { get; set; } Property Value Type Description bool | Edit this page View Source Width Declaration public virtual float Width { get; set; } Property Value Type Description float | Edit this page View Source WorldTransform the world matrix of the object. Declaration public Matrix WorldTransform { get; } Property Value Type Description Matrix | Edit this page View Source X The display object x position. This property is an alias for setting the object X position. Declaration public float X { get; set; } Property Value Type Description float | Edit this page View Source Y The display object y position. This property is an alias for setting the object Y position. Declaration public float Y { get; set; } Property Value Type Description float Methods | Edit this page View Source AddChild(DisplayObject) add a child to the end of the children list. Declaration public virtual void AddChild(DisplayObject child) Parameters Type Name Description DisplayObject child | Edit this page View Source AddChild(params DisplayObject[]) add a collection of children to the end of the children list. Declaration public virtual void AddChild(params DisplayObject[] children) Parameters Type Name Description DisplayObject[] children the collection of display object to add | Edit this page View Source AddChild(IEnumerable<DisplayObject>) add a collection of children to the end of the children list. Declaration public virtual void AddChild(IEnumerable<DisplayObject> children) Parameters Type Name Description IEnumerable<DisplayObject> children the collection of display object to add | Edit this page View Source DecomposeMatrix2D(Matrix, out Vector2, out float, out Vector2) Declaration protected void DecomposeMatrix2D(Matrix matrix, out Vector2 position, out float rotation, out Vector2 scale) Parameters Type Name Description Matrix matrix Vector2 position float rotation Vector2 scale | Edit this page View Source Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. Declaration public void Dispose() | Edit this page View Source Dispose(bool) Declaration protected virtual void Dispose(bool disposing) Parameters Type Name Description bool disposing | Edit this page View Source Draw(SpriteBatch) draw the object and all of its children. Declaration public virtual void Draw(SpriteBatch spriteBatch) Parameters Type Name Description SpriteBatch spriteBatch Remarks if an object or its children visible flag is set to false it wont be draw but still be updated. | Edit this page View Source ~DisplayObject() Declaration protected ~DisplayObject() | Edit this page View Source GetBounds() Declaration public abstract Rectangle GetBounds() Returns Type Description Rectangle | Edit this page View Source GetWorldBounds() Declaration public Rectangle GetWorldBounds() Returns Type Description Rectangle | Edit this page View Source MarkDirty() Mark the object and all its children as dirty and force a recompute of the their transforms. changing the transform of the object will trigger a recompute the transform. Declaration public void MarkDirty() | Edit this page View Source RemoveChild(DisplayObject, bool) Remove the specified child from the children list. Declaration public virtual void RemoveChild(DisplayObject child, bool dispose = false) Parameters Type Name Description DisplayObject child the child to remove bool dispose whether or not to dispose the child | Edit this page View Source RemoveChild(bool, params DisplayObject[]) Remove the specified children from the children list. Declaration public virtual void RemoveChild(bool dispose = false, params DisplayObject[] children) Parameters Type Name Description bool dispose whether or not to dispose the children DisplayObject[] children the collection of childre to remove | Edit this page View Source RemoveChild(IEnumerable<DisplayObject>, bool) Remove the specified children from the children list. Declaration public virtual void RemoveChild(IEnumerable<DisplayObject> children, bool dispose = false) Parameters Type Name Description IEnumerable<DisplayObject> children the collection of children to remove bool dispose whether or not to dispose the children | Edit this page View Source Update(GameTime) update the object and all of its children. Declaration public virtual void Update(GameTime gameTime) Parameters Type Name Description GameTime gameTime | Edit this page View Source UpdateWorldTransform() Declaration protected virtual void UpdateWorldTransform() Implements IDisposable"
  },
  "api/Hallowed.Core.GameEngine.html": {
    "href": "api/Hallowed.Core.GameEngine.html",
    "title": "Class GameEngine | hallowed",
    "summary": "Class GameEngine The main class for the game that handles all game logic and rendering. Inheritance object Game GameEngine Implements IDisposable Inherited Members Game.Dispose() Game.Dispose(bool) Game.Exit() Game.ResetElapsedTime() Game.SuppressDraw() Game.RunOneFrame() Game.Run() Game.Run(GameRunBehavior) Game.Tick() Game.BeginDraw() Game.EndDraw() Game.BeginRun() Game.EndRun() Game.UnloadContent() Game.OnExiting(object, ExitingEventArgs) Game.OnActivated(object, EventArgs) Game.OnDeactivated(object, EventArgs) Game.LaunchParameters Game.Components Game.InactiveSleepTime Game.MaxElapsedTime Game.IsActive Game.IsMouseVisible Game.TargetElapsedTime Game.IsFixedTimeStep Game.Services Game.Content Game.GraphicsDevice Game.Window Game.Activated Game.Deactivated Game.Disposed Game.Exiting object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: Hallowed.Core Assembly: Hallowed.dll Syntax public class GameEngine : Game, IDisposable Constructors | Edit this page View Source GameEngine() Declaration public GameEngine() Properties | Edit this page View Source Graphics The graphics device manager. Declaration public GraphicsDeviceManager Graphics { get; set; } Property Value Type Description GraphicsDeviceManager | Edit this page View Source Root Declaration public Container Root { get; set; } Property Value Type Description Container | Edit this page View Source SpriteBatch the sprite batch for rendering most the children. Declaration public SpriteBatch SpriteBatch { get; set; } Property Value Type Description SpriteBatch Methods | Edit this page View Source Draw(GameTime) Called when the game should draw a frame. Draws the Microsoft.Xna.Framework.DrawableGameComponent instances attached to this game. Override this to render your game. Declaration protected override void Draw(GameTime gameTime) Parameters Type Name Description GameTime gameTime A Microsoft.Xna.Framework.GameTime instance containing the elapsed time since the last call to Microsoft.Xna.Framework.Game.Draw(Microsoft.Xna.Framework.GameTime) and the total time elapsed since the game started. Overrides Microsoft.Xna.Framework.Game.Draw(Microsoft.Xna.Framework.GameTime) | Edit this page View Source Initialize() Override this to initialize the game and load any needed non-graphical resources. Initializes attached Microsoft.Xna.Framework.GameComponent instances and calls Microsoft.Xna.Framework.Game.LoadContent(). Declaration protected override void Initialize() Overrides Microsoft.Xna.Framework.Game.Initialize() | Edit this page View Source LoadContent() Override this to load graphical resources required by the game. Declaration protected override void LoadContent() Overrides Microsoft.Xna.Framework.Game.LoadContent() | Edit this page View Source Update(GameTime) Called when the game should update. Updates the Microsoft.Xna.Framework.GameComponent instances attached to this game. Override this to update your game. Declaration protected override void Update(GameTime gameTime) Parameters Type Name Description GameTime gameTime The elapsed time since the last call to Microsoft.Xna.Framework.Game.Update(Microsoft.Xna.Framework.GameTime). Overrides Microsoft.Xna.Framework.Game.Update(Microsoft.Xna.Framework.GameTime) Implements IDisposable"
  },
  "api/Hallowed.Core.IRenderable.html": {
    "href": "api/Hallowed.Core.IRenderable.html",
    "title": "Interface IRenderable | hallowed",
    "summary": "Interface IRenderable Namespace: Hallowed.Core Assembly: Hallowed.dll Syntax public interface IRenderable Properties | Edit this page View Source Parent Declaration Container Parent { get; set; } Property Value Type Description Container | Edit this page View Source Visible Declaration bool Visible { get; set; } Property Value Type Description bool Methods | Edit this page View Source Draw(SpriteBatch) Declaration void Draw(SpriteBatch spriteBatch) Parameters Type Name Description SpriteBatch spriteBatch | Edit this page View Source Update(GameTime) Declaration void Update(GameTime gameTime) Parameters Type Name Description GameTime gameTime"
  },
  "api/Hallowed.Core.html": {
    "href": "api/Hallowed.Core.html",
    "title": "Namespace Hallowed.Core | hallowed",
    "summary": "Namespace Hallowed.Core Classes Container Represents a scene graph node that can group and transform multiple DisplayObject instances. Containers allow hierarchical transformations, positioning, and rendering order management. DisplayObject The abstract base class for all renderable objects. Every object that can be rendered should inherit from this class. GameEngine The main class for the game that handles all game logic and rendering. Interfaces IRenderable"
  },
  "api/Hallowed.Game1.html": {
    "href": "api/Hallowed.Game1.html",
    "title": "Class Game1 | hallowed",
    "summary": "Class Game1 Inheritance object Game Game1 Implements IDisposable Inherited Members Game.Dispose() Game.Dispose(bool) Game.Exit() Game.ResetElapsedTime() Game.SuppressDraw() Game.RunOneFrame() Game.Run() Game.Run(GameRunBehavior) Game.Tick() Game.BeginDraw() Game.EndDraw() Game.BeginRun() Game.EndRun() Game.UnloadContent() Game.OnExiting(object, ExitingEventArgs) Game.OnActivated(object, EventArgs) Game.OnDeactivated(object, EventArgs) Game.LaunchParameters Game.Components Game.InactiveSleepTime Game.MaxElapsedTime Game.IsActive Game.IsMouseVisible Game.TargetElapsedTime Game.IsFixedTimeStep Game.Services Game.Content Game.GraphicsDevice Game.Window Game.Activated Game.Deactivated Game.Disposed Game.Exiting object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: Hallowed Assembly: Hallowed.dll Syntax public class Game1 : Game, IDisposable Constructors | Edit this page View Source Game1() Declaration public Game1() Methods | Edit this page View Source Draw(GameTime) Called when the game should draw a frame. Draws the Microsoft.Xna.Framework.DrawableGameComponent instances attached to this game. Override this to render your game. Declaration protected override void Draw(GameTime gameTime) Parameters Type Name Description GameTime gameTime A Microsoft.Xna.Framework.GameTime instance containing the elapsed time since the last call to Microsoft.Xna.Framework.Game.Draw(Microsoft.Xna.Framework.GameTime) and the total time elapsed since the game started. Overrides Microsoft.Xna.Framework.Game.Draw(Microsoft.Xna.Framework.GameTime) | Edit this page View Source Initialize() Override this to initialize the game and load any needed non-graphical resources. Initializes attached Microsoft.Xna.Framework.GameComponent instances and calls Microsoft.Xna.Framework.Game.LoadContent(). Declaration protected override void Initialize() Overrides Microsoft.Xna.Framework.Game.Initialize() | Edit this page View Source LoadContent() Override this to load graphical resources required by the game. Declaration protected override void LoadContent() Overrides Microsoft.Xna.Framework.Game.LoadContent() | Edit this page View Source Update(GameTime) Called when the game should update. Updates the Microsoft.Xna.Framework.GameComponent instances attached to this game. Override this to update your game. Declaration protected override void Update(GameTime gameTime) Parameters Type Name Description GameTime gameTime The elapsed time since the last call to Microsoft.Xna.Framework.Game.Update(Microsoft.Xna.Framework.GameTime). Overrides Microsoft.Xna.Framework.Game.Update(Microsoft.Xna.Framework.GameTime) Implements IDisposable"
  },
  "api/Hallowed.Graphics.AnimatedSprite.html": {
    "href": "api/Hallowed.Graphics.AnimatedSprite.html",
    "title": "Class AnimatedSprite | hallowed",
    "summary": "Class AnimatedSprite Inheritance object DisplayObject Sprite AnimatedSprite Implements IDisposable Inherited Members Sprite.Texture Sprite.Color Sprite.Frame Sprite.Orientation Sprite.Anchor Sprite.Origin Sprite.GetBounds() Sprite.Update(GameTime) Sprite.Draw(SpriteBatch) Sprite.GetSpriteEffects() Sprite.Dispose(bool) Sprite.UpdateOriginFromAnchor() Sprite.UpdateAnchorFromOrigin() DisplayObject.IsDisposed DisplayObject.WorldTransform DisplayObject.Parent DisplayObject.Children DisplayObject.Visible DisplayObject.Position DisplayObject.X DisplayObject.Y DisplayObject.Scale DisplayObject.Rotation DisplayObject.Width DisplayObject.Height DisplayObject.GetWorldBounds() DisplayObject.AddChild(DisplayObject) DisplayObject.AddChild(IEnumerable<DisplayObject>) DisplayObject.AddChild(params DisplayObject[]) DisplayObject.RemoveChild(DisplayObject, bool) DisplayObject.RemoveChild(IEnumerable<DisplayObject>, bool) DisplayObject.RemoveChild(bool, params DisplayObject[]) DisplayObject.MarkDirty() DisplayObject.UpdateWorldTransform() DisplayObject.DecomposeMatrix2D(Matrix, out Vector2, out float, out Vector2) DisplayObject.Dispose() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: Hallowed.Graphics Assembly: Hallowed.dll Syntax public class AnimatedSprite : Sprite, IDisposable Constructors | Edit this page View Source AnimatedSprite() Declaration public AnimatedSprite() Properties | Edit this page View Source Animations Declaration public IReadOnlyDictionary<string, SpriteAnimationData> Animations { get; } Property Value Type Description IReadOnlyDictionary<string, SpriteAnimationData> Methods | Edit this page View Source AddAnimation(string, SpriteAnimationData) Declaration public void AddAnimation(string name, SpriteAnimationData animation) Parameters Type Name Description string name SpriteAnimationData animation Implements IDisposable"
  },
  "api/Hallowed.Graphics.Sprite.html": {
    "href": "api/Hallowed.Graphics.Sprite.html",
    "title": "Class Sprite | hallowed",
    "summary": "Class Sprite Represents a 2D renderable object that displays a texture in the scene graph. A Sprite is the primary visual element used for rendering images, supporting transformations (position, rotation, scale), color tinting, and orientation flips. Inheritance object DisplayObject Sprite AnimatedSprite Implements IDisposable Inherited Members DisplayObject.IsDisposed DisplayObject.WorldTransform DisplayObject.Parent DisplayObject.Children DisplayObject.Visible DisplayObject.Position DisplayObject.X DisplayObject.Y DisplayObject.Scale DisplayObject.Rotation DisplayObject.Width DisplayObject.Height DisplayObject.GetWorldBounds() DisplayObject.AddChild(DisplayObject) DisplayObject.AddChild(IEnumerable<DisplayObject>) DisplayObject.AddChild(params DisplayObject[]) DisplayObject.RemoveChild(DisplayObject, bool) DisplayObject.RemoveChild(IEnumerable<DisplayObject>, bool) DisplayObject.RemoveChild(bool, params DisplayObject[]) DisplayObject.MarkDirty() DisplayObject.UpdateWorldTransform() DisplayObject.DecomposeMatrix2D(Matrix, out Vector2, out float, out Vector2) DisplayObject.Dispose() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: Hallowed.Graphics Assembly: Hallowed.dll Syntax public class Sprite : DisplayObject, IDisposable Remarks The Sprite class inherits from DisplayObject, meaning it participates in the world transform hierarchy. The texture is automatically disposed when the sprite is disposed, so it should not be shared across multiple sprites unless handled externally. Constructors | Edit this page View Source Sprite() Declaration public Sprite() | Edit this page View Source Sprite(TextureAtlas, string) Declaration public Sprite(TextureAtlas textureAtlas, string regionName) Parameters Type Name Description TextureAtlas textureAtlas string regionName | Edit this page View Source Sprite(Texture2D) The sprite constructor. Declaration public Sprite(Texture2D texture) Parameters Type Name Description Texture2D texture the sprite texture Properties | Edit this page View Source Anchor Declaration public Vector2 Anchor { get; set; } Property Value Type Description Vector2 | Edit this page View Source Color Declaration public Color Color { get; set; } Property Value Type Description Color | Edit this page View Source Frame Declaration public Rectangle Frame { get; set; } Property Value Type Description Rectangle | Edit this page View Source Orientation Declaration public SpriteOrientation Orientation { get; set; } Property Value Type Description SpriteOrientation | Edit this page View Source Origin The display object origin. Declaration public override Vector2 Origin { get; set; } Property Value Type Description Vector2 Overrides DisplayObject.Origin | Edit this page View Source Texture The sprite texture. Declaration public virtual Texture2D Texture { get; set; } Property Value Type Description Texture2D Methods | Edit this page View Source Dispose(bool) Declaration protected override void Dispose(bool disposing) Parameters Type Name Description bool disposing Overrides DisplayObject.Dispose(bool) | Edit this page View Source Draw(SpriteBatch) draw the object and all of its children. Declaration public override void Draw(SpriteBatch spriteBatch) Parameters Type Name Description SpriteBatch spriteBatch Overrides DisplayObject.Draw(SpriteBatch) Remarks if an object or its children visible flag is set to false it wont be draw but still be updated. | Edit this page View Source GetBounds() Declaration public override Rectangle GetBounds() Returns Type Description Rectangle Overrides DisplayObject.GetBounds() | Edit this page View Source GetSpriteEffects() Declaration protected virtual SpriteEffects GetSpriteEffects() Returns Type Description SpriteEffects | Edit this page View Source Update(GameTime) update the object and all of its children. Declaration public override void Update(GameTime gameTime) Parameters Type Name Description GameTime gameTime Overrides DisplayObject.Update(GameTime) | Edit this page View Source UpdateAnchorFromOrigin() Declaration protected void UpdateAnchorFromOrigin() | Edit this page View Source UpdateOriginFromAnchor() Declaration protected void UpdateOriginFromAnchor() Implements IDisposable"
  },
  "api/Hallowed.Graphics.SpriteAnchor.html": {
    "href": "api/Hallowed.Graphics.SpriteAnchor.html",
    "title": "Class SpriteAnchor | hallowed",
    "summary": "Class SpriteAnchor Provides common anchor point presets for sprites. Anchors are normalized (0-1 range) positions within a sprite. Inheritance object SpriteAnchor Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: Hallowed.Graphics Assembly: Hallowed.dll Syntax public static class SpriteAnchor Fields | Edit this page View Source BottomCenter Bottom-center (0.5, 1) - Useful for characters standing on ground Declaration public static readonly Vector2 BottomCenter Field Value Type Description Vector2 | Edit this page View Source BottomLeft Bottom-left corner (0, 1) Declaration public static readonly Vector2 BottomLeft Field Value Type Description Vector2 | Edit this page View Source BottomRight Bottom-right corner (1, 1) Declaration public static readonly Vector2 BottomRight Field Value Type Description Vector2 | Edit this page View Source Center Center (0.5, 0.5) - Useful for rotation and centering Declaration public static readonly Vector2 Center Field Value Type Description Vector2 | Edit this page View Source CenterLeft Center-left (0, 0.5) Declaration public static readonly Vector2 CenterLeft Field Value Type Description Vector2 | Edit this page View Source CenterRight Center-right (1, 0.5) Declaration public static readonly Vector2 CenterRight Field Value Type Description Vector2 | Edit this page View Source TopCenter Top-center (0.5, 0) Declaration public static readonly Vector2 TopCenter Field Value Type Description Vector2 | Edit this page View Source TopLeft Top-left corner (0, 0) - Default anchor point Declaration public static readonly Vector2 TopLeft Field Value Type Description Vector2 | Edit this page View Source TopRight Top-right corner (1, 0) Declaration public static readonly Vector2 TopRight Field Value Type Description Vector2"
  },
  "api/Hallowed.Graphics.SpriteAnimationData.html": {
    "href": "api/Hallowed.Graphics.SpriteAnimationData.html",
    "title": "Struct SpriteAnimationData | hallowed",
    "summary": "Struct SpriteAnimationData Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Namespace: Hallowed.Graphics Assembly: Hallowed.dll Syntax public struct SpriteAnimationData Fields | Edit this page View Source frameRate Declaration public float frameRate Field Value Type Description float | Edit this page View Source frames Declaration public List<Rectangle> frames Field Value Type Description List<Rectangle> | Edit this page View Source loop Declaration public bool loop Field Value Type Description bool | Edit this page View Source onAnimationEnd Declaration public Action onAnimationEnd Field Value Type Description Action"
  },
  "api/Hallowed.Graphics.SpriteOrientation.html": {
    "href": "api/Hallowed.Graphics.SpriteOrientation.html",
    "title": "Enum SpriteOrientation | hallowed",
    "summary": "Enum SpriteOrientation Namespace: Hallowed.Graphics Assembly: Hallowed.dll Syntax public enum SpriteOrientation Fields Name Description Both FlipHorizontal FlipVertical Normal"
  },
  "api/Hallowed.Graphics.TextureAtlas.html": {
    "href": "api/Hallowed.Graphics.TextureAtlas.html",
    "title": "Class TextureAtlas | hallowed",
    "summary": "Class TextureAtlas The utility class that manage a texture atlas. Inheritance object TextureAtlas Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: Hallowed.Graphics Assembly: Hallowed.dll Syntax public class TextureAtlas Constructors | Edit this page View Source TextureAtlas(Texture2D) The texture atlas constructor. Declaration public TextureAtlas(Texture2D texture) Parameters Type Name Description Texture2D texture the atlas texture Properties | Edit this page View Source Regions The atlas regions. Declaration public IReadOnlyDictionary<string, Rectangle> Regions { get; } Property Value Type Description IReadOnlyDictionary<string, Rectangle> | Edit this page View Source Texture The Atlas texture Declaration public Texture2D Texture { get; } Property Value Type Description Texture2D Methods | Edit this page View Source AddRegion(string, Rectangle) Add a region to the atlas. Declaration public void AddRegion(string name, Rectangle region) Parameters Type Name Description string name the region name Rectangle region the region rect Exceptions Type Condition ArgumentException | Edit this page View Source GetRegion(string, out Rectangle) Get the Atlas region by name. Declaration public bool GetRegion(string name, out Rectangle region) Parameters Type Name Description string name the region name Rectangle region the region rectangle to copy the value to Returns Type Description bool return the textures region coordinates | Edit this page View Source Parse(string) Parse a json file to create the atlas such as Texture Packer. Declaration public void Parse(string json) Parameters Type Name Description string json"
  },
  "api/Hallowed.Graphics.TextureWrapper.html": {
    "href": "api/Hallowed.Graphics.TextureWrapper.html",
    "title": "Class TextureWrapper | hallowed",
    "summary": "Class TextureWrapper Wrapper class for allow easy texture manipulation. This class is optional and not required for creating sprites. it however, has a lot of useful methods to help with texture manipulation. var textureWrapper = new TextureWrapper(Content.Load(\"texture\")); var sprite = new Sprite(textureWrapper.Texture); var texture2 = Content.Load(\"texture2\"); textureWrapper.blit(texture2, new Rectangle(0, 0, 100, 100), new Rectangle(0, 0, 100, 100); Inheritance object TextureWrapper Implements IDisposable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: Hallowed.Graphics Assembly: Hallowed.dll Syntax public class TextureWrapper : IDisposable Constructors | Edit this page View Source TextureWrapper(GraphicsDevice, Texture2D) The texture wrapper constructor. Declaration public TextureWrapper(GraphicsDevice device, Texture2D texture) Parameters Type Name Description GraphicsDevice device The graphic device Texture2D texture the texture to wrap | Edit this page View Source TextureWrapper(GraphicsDevice, int, int) The texture wrapper constructor. Declaration public TextureWrapper(GraphicsDevice device, int width, int height) Parameters Type Name Description GraphicsDevice device The graphic device int width the texture wrapper width (automatically adjust when assigning a texture) int height the texture wrapper height (automatically adjust when assigning a texture) Properties | Edit this page View Source Height the texture height. Declaration public int Height { get; } Property Value Type Description int | Edit this page View Source Texture The texture Declaration public Texture2D Texture { get; set; } Property Value Type Description Texture2D | Edit this page View Source Width the texture width. Declaration public int Width { get; } Property Value Type Description int Methods | Edit this page View Source Blit(Texture2D, Rectangle, Rectangle) copy a region of one texture to another. Declaration public void Blit(Texture2D source, Rectangle sourceRect, Rectangle destRect) Parameters Type Name Description Texture2D source Rectangle sourceRect Rectangle destRect | Edit this page View Source Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. Declaration public void Dispose() | Edit this page View Source GetFrameRanges(Vector2, int, int) return an array of frames Rectangle Data for animation based on a range of frames. Declaration public List<Rectangle> GetFrameRanges(Vector2 frameSize, int startIndex, int endIndex) Parameters Type Name Description Vector2 frameSize the frame size int startIndex int endIndex Returns Type Description List<Rectangle> | Edit this page View Source GetFrameRanges(int, int, int, int) returns an array of frames Rectangle Data for animation based on a range of frames. Declaration public List<Rectangle> GetFrameRanges(int frameWidth, int frameHeight, int startIndex, int endIndex) Parameters Type Name Description int frameWidth int frameHeight int startIndex int endIndex Returns Type Description List<Rectangle> Implements IDisposable"
  },
  "api/Hallowed.Graphics.html": {
    "href": "api/Hallowed.Graphics.html",
    "title": "Namespace Hallowed.Graphics | hallowed",
    "summary": "Namespace Hallowed.Graphics Classes AnimatedSprite Sprite Represents a 2D renderable object that displays a texture in the scene graph. A Sprite is the primary visual element used for rendering images, supporting transformations (position, rotation, scale), color tinting, and orientation flips. SpriteAnchor Provides common anchor point presets for sprites. Anchors are normalized (0-1 range) positions within a sprite. TextureAtlas The utility class that manage a texture atlas. TextureWrapper Wrapper class for allow easy texture manipulation. This class is optional and not required for creating sprites. it however, has a lot of useful methods to help with texture manipulation. var textureWrapper = new TextureWrapper(Content.Load(\"texture\")); var sprite = new Sprite(textureWrapper.Texture); var texture2 = Content.Load(\"texture2\"); textureWrapper.blit(texture2, new Rectangle(0, 0, 100, 100), new Rectangle(0, 0, 100, 100); Structs SpriteAnimationData Enums SpriteOrientation"
  },
  "api/Hallowed.Rendering.Camera2D.html": {
    "href": "api/Hallowed.Rendering.Camera2D.html",
    "title": "Class Camera2D | hallowed",
    "summary": "Class Camera2D Inheritance object Camera2D Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: Hallowed.Rendering Assembly: Hallowed.dll Syntax public class Camera2D Constructors | Edit this page View Source Camera2D(Viewport) Declaration public Camera2D(Viewport viewport) Parameters Type Name Description Viewport viewport"
  },
  "api/Hallowed.Rendering.Container.html": {
    "href": "api/Hallowed.Rendering.Container.html",
    "title": "Class Container | hallowed",
    "summary": "Class Container Inheritance object DisplayObject Container SceneBase Implements IDisposable Inherited Members DisplayObject.IsDisposed DisplayObject.WorldTransform DisplayObject.Parent DisplayObject.Children DisplayObject.Visible DisplayObject.Position DisplayObject.X DisplayObject.Y DisplayObject.Scale DisplayObject.Rotation DisplayObject.Origin DisplayObject.Width DisplayObject.Height DisplayObject.GetWorldBounds() DisplayObject.Update(GameTime) DisplayObject.Draw(SpriteBatch) DisplayObject.AddChild(DisplayObject) DisplayObject.AddChild(IEnumerable<DisplayObject>) DisplayObject.AddChild(params DisplayObject[]) DisplayObject.RemoveChild(DisplayObject, bool) DisplayObject.RemoveChild(IEnumerable<DisplayObject>, bool) DisplayObject.RemoveChild(bool, params DisplayObject[]) DisplayObject.MarkDirty() DisplayObject.UpdateWorldTransform() DisplayObject.DecomposeMatrix2D(Matrix, out Vector2, out float, out Vector2) DisplayObject.Dispose() DisplayObject.Dispose(bool) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: Hallowed.Rendering Assembly: Hallowed.dll Syntax public class Container : DisplayObject, IDisposable Methods | Edit this page View Source GetBounds() Declaration public override Rectangle GetBounds() Returns Type Description Rectangle Overrides DisplayObject.GetBounds() Implements IDisposable"
  },
  "api/Hallowed.Rendering.DisplayObject.html": {
    "href": "api/Hallowed.Rendering.DisplayObject.html",
    "title": "Class DisplayObject | hallowed",
    "summary": "Class DisplayObject The abstract base class for all renderable objects. Every object that can be rendered should inherit from this class. Inheritance object DisplayObject Sprite Container Implements IDisposable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: Hallowed.Rendering Assembly: Hallowed.dll Syntax public abstract class DisplayObject : IDisposable Constructors | Edit this page View Source DisplayObject() Declaration protected DisplayObject() Properties | Edit this page View Source Children The objects children. Declaration public List<DisplayObject> Children { get; protected set; } Property Value Type Description List<DisplayObject> | Edit this page View Source Height Declaration public virtual float Height { get; set; } Property Value Type Description float | Edit this page View Source IsDisposed Declaration public bool IsDisposed { get; } Property Value Type Description bool | Edit this page View Source Origin The display object origin. Declaration public virtual Vector2 Origin { get; set; } Property Value Type Description Vector2 | Edit this page View Source Parent The Display object parent. Declaration public DisplayObject Parent { get; } Property Value Type Description DisplayObject | Edit this page View Source Position Declaration public Vector2 Position { get; set; } Property Value Type Description Vector2 | Edit this page View Source Rotation The display object rotation. Declaration public float Rotation { get; set; } Property Value Type Description float | Edit this page View Source Scale The display object scale. Declaration public Vector2 Scale { get; set; } Property Value Type Description Vector2 | Edit this page View Source Visible return whether or not the object will render to the screen. Declaration public bool Visible { get; set; } Property Value Type Description bool | Edit this page View Source Width Declaration public virtual float Width { get; set; } Property Value Type Description float | Edit this page View Source WorldTransform the world matrix of the object. Declaration public Matrix WorldTransform { get; } Property Value Type Description Matrix | Edit this page View Source X The display object x position. This property is an alias for setting the object X position. Declaration public float X { get; set; } Property Value Type Description float | Edit this page View Source Y The display object y position. This property is an alias for setting the object Y position. Declaration public float Y { get; set; } Property Value Type Description float Methods | Edit this page View Source AddChild(DisplayObject) add a child to the end of the children list. Declaration public virtual void AddChild(DisplayObject child) Parameters Type Name Description DisplayObject child | Edit this page View Source AddChild(params DisplayObject[]) add a collection of children to the end of the children list. Declaration public virtual void AddChild(params DisplayObject[] children) Parameters Type Name Description DisplayObject[] children the collection of display object to add | Edit this page View Source AddChild(IEnumerable<DisplayObject>) add a collection of children to the end of the children list. Declaration public virtual void AddChild(IEnumerable<DisplayObject> children) Parameters Type Name Description IEnumerable<DisplayObject> children the collection of display object to add | Edit this page View Source DecomposeMatrix2D(Matrix, out Vector2, out float, out Vector2) Declaration protected void DecomposeMatrix2D(Matrix matrix, out Vector2 position, out float rotation, out Vector2 scale) Parameters Type Name Description Matrix matrix Vector2 position float rotation Vector2 scale | Edit this page View Source Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. Declaration public void Dispose() | Edit this page View Source Dispose(bool) Declaration protected virtual void Dispose(bool disposing) Parameters Type Name Description bool disposing | Edit this page View Source Draw(SpriteBatch) draw the object and all of its children. Declaration public virtual void Draw(SpriteBatch spriteBatch) Parameters Type Name Description SpriteBatch spriteBatch Remarks if an object or its children visible flag is set to false it wont be draw but still be updated. | Edit this page View Source ~DisplayObject() Declaration protected ~DisplayObject() | Edit this page View Source GetBounds() Declaration public abstract Rectangle GetBounds() Returns Type Description Rectangle | Edit this page View Source GetWorldBounds() Declaration public Rectangle GetWorldBounds() Returns Type Description Rectangle | Edit this page View Source MarkDirty() Mark the object and all its children as dirty and force a recompute of the their transforms. changing the transform of the object will trigger a recompute the transform. Declaration public void MarkDirty() | Edit this page View Source RemoveChild(DisplayObject, bool) Remove the specified child from the children list. Declaration public virtual void RemoveChild(DisplayObject child, bool dispose = false) Parameters Type Name Description DisplayObject child the child to remove bool dispose whether or not to dispose the child | Edit this page View Source RemoveChild(bool, params DisplayObject[]) Remove the specified children from the children list. Declaration public virtual void RemoveChild(bool dispose = false, params DisplayObject[] children) Parameters Type Name Description bool dispose whether or not to dispose the children DisplayObject[] children the collection of childre to remove | Edit this page View Source RemoveChild(IEnumerable<DisplayObject>, bool) Remove the specified children from the children list. Declaration public virtual void RemoveChild(IEnumerable<DisplayObject> children, bool dispose = false) Parameters Type Name Description IEnumerable<DisplayObject> children the collection of children to remove bool dispose whether or not to dispose the children | Edit this page View Source Update(GameTime) update the object and all of its children. Declaration public virtual void Update(GameTime gameTime) Parameters Type Name Description GameTime gameTime | Edit this page View Source UpdateWorldTransform() Declaration protected virtual void UpdateWorldTransform() Implements IDisposable"
  },
  "api/Hallowed.Rendering.IRenderable.html": {
    "href": "api/Hallowed.Rendering.IRenderable.html",
    "title": "Interface IRenderable | hallowed",
    "summary": "Interface IRenderable Namespace: Hallowed.Rendering Assembly: Hallowed.dll Syntax public interface IRenderable Properties | Edit this page View Source Parent Declaration Container Parent { get; set; } Property Value Type Description Container | Edit this page View Source Visible Declaration bool Visible { get; set; } Property Value Type Description bool Methods | Edit this page View Source Draw(SpriteBatch) Declaration void Draw(SpriteBatch spriteBatch) Parameters Type Name Description SpriteBatch spriteBatch | Edit this page View Source Update(GameTime) Declaration void Update(GameTime gameTime) Parameters Type Name Description GameTime gameTime"
  },
  "api/Hallowed.Rendering.PingPongBuffer.html": {
    "href": "api/Hallowed.Rendering.PingPongBuffer.html",
    "title": "Class PingPongBuffer | hallowed",
    "summary": "Class PingPongBuffer A ping-pong buffer for efficient render texture operations in MonoGame. Maintains two render textures and alternates between them to avoid read/write conflicts. Inheritance object PingPongBuffer Implements IDisposable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: Hallowed.Rendering Assembly: Hallowed.dll Syntax public class PingPongBuffer : IDisposable Remarks The ping-pong pattern allows you to read from one texture (Source) while writing to another (Target), then swap them for the next iteration. This is essential for iterative post-processing, feedback loops, and blitting multiple textures together without memory reallocation overhead. Examples Initialize the buffer and blit textures together: var buffer = new PingPongBuffer(graphicsDevice, 1024, 1024); // Render to the target texture graphicsDevice.SetRenderTarget(buffer.Target); graphicsDevice.Clear(Color.Transparent); spriteBatch.Begin(); spriteBatch.Draw(texture1, Vector2.Zero, Color.White); spriteBatch.Draw(texture2, new Vector2(512, 0), Color.White); spriteBatch.End(); graphicsDevice.SetRenderTarget(null); buffer.Swap(); // Swap so Target becomes Source for next iteration Texture2D result = buffer.Source; // Result is now ready to use buffer.Dispose(); Constructors | Edit this page View Source PingPongBuffer(GraphicsDevice, int, int, SurfaceFormat) The ping pong buffer constructor. Declaration public PingPongBuffer(GraphicsDevice device, int width, int height, SurfaceFormat format = SurfaceFormat.Color) Parameters Type Name Description GraphicsDevice device int width int height SurfaceFormat format Properties | Edit this page View Source HasSource Check if the buffer has been initialized. Declaration public bool HasSource { get; } Property Value Type Description bool | Edit this page View Source Height the buffer height. Declaration public int Height { get; } Property Value Type Description int | Edit this page View Source Source Gets the current source texture (read from this). Declaration public RenderTarget2D Source { get; } Property Value Type Description RenderTarget2D | Edit this page View Source Target Gets the current target texture (write to this). Declaration public RenderTarget2D Target { get; } Property Value Type Description RenderTarget2D | Edit this page View Source Width the buffer width. Declaration public int Width { get; } Property Value Type Description int Methods | Edit this page View Source Assign(Texture2D) First assign a texture to the source and target buffers. Declaration public void Assign(Texture2D texture) Parameters Type Name Description Texture2D texture | Edit this page View Source Clear() Clear the current source to transparent. Declaration public void Clear() | Edit this page View Source ClearAll() Clear both buffers. Declaration public void ClearAll() | Edit this page View Source Dispose() Dispose the buffer. Declaration public void Dispose() | Edit this page View Source Resize(int, int, SurfaceFormat) Resize both buffers. Declaration public void Resize(int width, int height, SurfaceFormat format = SurfaceFormat.Color) Parameters Type Name Description int width int height SurfaceFormat format | Edit this page View Source Swap() Swap source and target buffers. Declaration public void Swap() Implements IDisposable"
  },
  "api/Hallowed.Rendering.Utilities.PingPongBuffer.html": {
    "href": "api/Hallowed.Rendering.Utilities.PingPongBuffer.html",
    "title": "Class PingPongBuffer | hallowed",
    "summary": "Class PingPongBuffer Provides a double-buffered render target system (\"ping-pong\" buffer) for iterative texture operations and post-processing in MonoGame. Inheritance object PingPongBuffer Implements IDisposable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: Hallowed.Rendering.Utilities Assembly: Hallowed.dll Syntax public class PingPongBuffer : IDisposable Remarks The ping-pong technique alternates between two render targets — one for reading (Source) and one for writing (Target) — avoiding GPU read/write conflicts. This allows chained rendering passes, feedback effects, and texture blitting without reallocating textures or copying data between frames. Examples Example usage: var buffer = new PingPongBuffer(graphicsDevice, 1024, 1024); // Draw to the current target graphicsDevice.SetRenderTarget(buffer.Target); spriteBatch.Begin(); spriteBatch.Draw(texture1, Vector2.Zero, Color.White); spriteBatch.Draw(texture2, new Vector2(512, 0), Color.White); spriteBatch.End(); graphicsDevice.SetRenderTarget(null); // Swap read/write targets for the next iteration buffer.Swap(); // Use the final composed texture Texture2D result = buffer.Source; Constructors | Edit this page View Source PingPongBuffer(GraphicsDevice, int, int, SurfaceFormat) The ping pong buffer constructor. Declaration public PingPongBuffer(GraphicsDevice device, int width, int height, SurfaceFormat format = SurfaceFormat.Color) Parameters Type Name Description GraphicsDevice device int width int height SurfaceFormat format Properties | Edit this page View Source HasSource Check if the buffer has been initialized. Declaration public bool HasSource { get; } Property Value Type Description bool | Edit this page View Source Height the buffer height. Declaration public int Height { get; } Property Value Type Description int | Edit this page View Source Source Gets the current source texture (read from this). Declaration public RenderTarget2D Source { get; } Property Value Type Description RenderTarget2D | Edit this page View Source Target Gets the current target texture (write to this). Declaration public RenderTarget2D Target { get; } Property Value Type Description RenderTarget2D | Edit this page View Source Width the buffer width. Declaration public int Width { get; } Property Value Type Description int Methods | Edit this page View Source Assign(Texture2D) First assign a texture to the source and target buffers. Declaration public void Assign(Texture2D texture) Parameters Type Name Description Texture2D texture | Edit this page View Source Clear() Clear the current source to transparent. Declaration public void Clear() | Edit this page View Source ClearAll() Clear both buffers. Declaration public void ClearAll() | Edit this page View Source Dispose() Dispose the buffer. Declaration public void Dispose() | Edit this page View Source Resize(int, int, SurfaceFormat) Resize both buffers. Declaration public void Resize(int width, int height, SurfaceFormat format = SurfaceFormat.Color) Parameters Type Name Description int width int height SurfaceFormat format | Edit this page View Source Swap() Swap source and target buffers. Declaration public void Swap() Implements IDisposable See Also Ping-pong scheme (Wikipedia)"
  },
  "api/Hallowed.Rendering.Utilities.html": {
    "href": "api/Hallowed.Rendering.Utilities.html",
    "title": "Namespace Hallowed.Rendering.Utilities | hallowed",
    "summary": "Namespace Hallowed.Rendering.Utilities Classes PingPongBuffer Provides a double-buffered render target system (\"ping-pong\" buffer) for iterative texture operations and post-processing in MonoGame."
  },
  "api/Hallowed.Rendering.html": {
    "href": "api/Hallowed.Rendering.html",
    "title": "Namespace Hallowed.Rendering | hallowed",
    "summary": "Namespace Hallowed.Rendering Classes Camera2D"
  },
  "api/Hallowed.Scenes.SceneBase.html": {
    "href": "api/Hallowed.Scenes.SceneBase.html",
    "title": "Class SceneBase | hallowed",
    "summary": "Class SceneBase Inheritance object DisplayObject Container SceneBase Implements IDisposable Inherited Members Container.GetBounds() DisplayObject.IsDisposed DisplayObject.WorldTransform DisplayObject.Parent DisplayObject.Children DisplayObject.Visible DisplayObject.Position DisplayObject.X DisplayObject.Y DisplayObject.Scale DisplayObject.Rotation DisplayObject.Origin DisplayObject.Width DisplayObject.Height DisplayObject.GetWorldBounds() DisplayObject.Update(GameTime) DisplayObject.Draw(SpriteBatch) DisplayObject.AddChild(DisplayObject) DisplayObject.AddChild(IEnumerable<DisplayObject>) DisplayObject.AddChild(params DisplayObject[]) DisplayObject.RemoveChild(DisplayObject, bool) DisplayObject.RemoveChild(IEnumerable<DisplayObject>, bool) DisplayObject.RemoveChild(bool, params DisplayObject[]) DisplayObject.MarkDirty() DisplayObject.UpdateWorldTransform() DisplayObject.DecomposeMatrix2D(Matrix, out Vector2, out float, out Vector2) DisplayObject.Dispose() DisplayObject.Dispose(bool) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: Hallowed.Scenes Assembly: Hallowed.dll Syntax public abstract class SceneBase : Container, IDisposable Properties | Edit this page View Source Game Declaration protected Game Game { get; set; } Property Value Type Description Game | Edit this page View Source Graphics Declaration protected GraphicsDeviceManager Graphics { get; set; } Property Value Type Description GraphicsDeviceManager | Edit this page View Source SpriteBatch Declaration protected SpriteBatch SpriteBatch { get; set; } Property Value Type Description SpriteBatch Methods | Edit this page View Source Initialize() Declaration public void Initialize() | Edit this page View Source LoadContent() Declaration public void LoadContent() Implements IDisposable"
  },
  "api/Hallowed.Scenes.SceneManager.html": {
    "href": "api/Hallowed.Scenes.SceneManager.html",
    "title": "Class SceneManager | hallowed",
    "summary": "Class SceneManager Inheritance object SceneManager Implements IGameComponent Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: Hallowed.Scenes Assembly: Hallowed.dll Syntax public class SceneManager : IGameComponent Constructors | Edit this page View Source SceneManager(GameEngine) Declaration public SceneManager(GameEngine game) Parameters Type Name Description GameEngine game Properties | Edit this page View Source Scene Declaration public SceneBase Scene { get; } Property Value Type Description SceneBase Methods | Edit this page View Source Goto(SceneBase) Declaration public void Goto(SceneBase scene) Parameters Type Name Description SceneBase scene | Edit this page View Source Initialize() Initializes the component. Used to load non-graphical resources. Declaration public void Initialize() Implements Microsoft.Xna.Framework.IGameComponent"
  },
  "api/Hallowed.Scenes.html": {
    "href": "api/Hallowed.Scenes.html",
    "title": "Namespace Hallowed.Scenes | hallowed",
    "summary": "Namespace Hallowed.Scenes Classes SceneBase SceneManager"
  },
  "api/Hallowed.html": {
    "href": "api/Hallowed.html",
    "title": "Namespace Hallowed | hallowed",
    "summary": "Namespace Hallowed Classes Game1"
  },
  "index.html": {
    "href": "index.html",
    "title": "This is the HOMEPAGE. | hallowed",
    "summary": "This is the HOMEPAGE. Refer to Markdown for how to write markdown files. Quick Start Notes: Add images to the images folder if the file is referencing an image."
  },
  "templates/SingulinkFX/README.html": {
    "href": "templates/SingulinkFX/README.html",
    "title": "SingulinkFX | hallowed",
    "summary": "SingulinkFX SingulinkFX is a fully responsive DocFX template used for Singulink projects to produce documentation that is familiar to those used to browsing Microsoft's .NET documentation. Features: Responsive layout for all device sizes. Easily configurable colors and sidebar width. Empty table columns are removed, so if you don't comment the parameters or return value on some methods then it won't display an empty description column. The table of contents supports 4 levels of items to properly facilitate usage together with the separatePages member layout. Contains optional style overrides optimized for displaying articles. Includes Bootstrap Icons. Live Demo (Singulink.IO.FileSystem) About Singulink We are a small team of engineers and designers dedicated to building beautiful, functional and well-engineered software solutions. We offer very competitive rates as well as fixed-price contracts and welcome inquiries to discuss any custom development / project support needs you may have. Visit https://github.com/Singulink to see our full list of publicly available libraries and other open-source projects. Installation Download the source or the zipped file from the releases page. In your DocFX project folder, create a directory named templates, if it doesn't already exist. Copy the singulinkfx folder from this repository into the templates folder. In your docfx.json configuration file, add the singulinkfx path into the build.template property: \"template\": [\"default\", \"templates/singulinkfx\"] A real-world example of a .NET library using this template with articles can be found in the Singulink.IO.FileSystem repository (check out the Docs folder). If you are new to DocFX you might also find it helpful for properly setting up the table of contents. Versions and Upgrading Version 3.x For use with DocFX v2.75+. Warning There is an issue with DocFX v2.78+ at the moment that breaks the intended table of contents experience of this theme, so it is recommended to either stay on v2.77 or download our custom build of DocFX v2.78.3 (requires .NET 9) that includes the fix to the issue. If you use some newer C#/.NET features like allows ref struct then v2.77 will fail to build metadata so the custom build is required until the fix is merged into DocFX main and a new release is published. Version 2.x For use with DocFX v2.62 and above. The memberpage-extras plugin has been removed for version 2+ of the template. DocFX v2.62 no longer shows explicit interface members by default. Furthermore, the functionality to group explicit interface implementations into their own section in the table of contents has been merged into the DocFX codebase and DocFX now has an option for including explicit interface implementations is in the works so the pluginis no longer necessary moving forward. Version 1.x For DocFX versions older than v2.62 you should use v1.1 of this template. Customization Configuration The following is a sample docfx.json global metadata section that demonstrates the usage of the options this theme offers: \"globalMetadata\": { \"_appTitle\": \"Singulink.IO.FileSystem\", \"_appName\": \"File System\", \"_appFaviconPath\": \"images/favicon.png\", \"_appLogoPath\": \"images/logo.png\", \"_appFooter\": \"<strong>DocFX + Singulink = ♥</strong>\", \"_copyrightFooter\": \"© Singulink. All rights reserved.\", \"_enableSearch\": true, \"_disableSideFilter\": false, \"_enableNewTab\": true, \"_disableContribution\": false, \"_disableBreadcrumb\": false, } Colors and Layout You can change any color as well as the width of the side bar and font sizes for desktop and mobile views. The values are defined in the styles/config.css file. The recommended approach to changing the default values is to create another directory inside templates for your sub-theme that overrides these values in a styles/main.css file, and add your theme to the end of the list of templates in docfx.json. Your main.css file will be automatically referenced in the output, there is no need to override any other template files. Custom Javascript The styles/main.js file can be used to add your own custom Javascript. The recommended approach is to create another directory inside templates for your sub-theme, add a styles/main.js file, and add your theme to the end of the list of templates in docfx.json. Your main.js file will be automatically referenced in the output, there is no need to override any other template files. Article Styling Wrap your HTML or markdown in a <div class=\"article\"></div> to activate styles that change heading styles and spacing to something more suitable for articles instead of API member docs. Supports up to 5 heading levels (h1 to h5 for HTML or # to ##### for markdown). More Screenshots Desktop Mobile Attribution Special thanks to @jbltx for creating DiscordFX which was a great starting point for this template."
  },
  "templates/docs.monogame.github.io/CONTRIBUTING.html": {
    "href": "templates/docs.monogame.github.io/CONTRIBUTING.html",
    "title": "MonoGame Documentation | hallowed",
    "summary": "MonoGame Documentation This is the source for the documentation published on MonoGame.net. It is rebuilt when the code changes and is published nightly to the website. General Rules The following rules must be observed at all times when contributing documentation to the MonoGame project. Write in a neutral, technical tone. Avoid humor, personal opinions, and colloquial language. Never plagiarize any documentation from another source. Do not use automatic documentation tools as they are ineffective. Breaking these rules can result in your contribution being rejected. Contributing guidelines For further details for guidance and advice when contributing to the MonoGame Framework Documentation / API repository, please see the official guide: MonoGame Documentation official contributing guide License All documentation contributed to the MonoGame project is subject to the Creative Commons Attribution-NonCommercial-ShareAlike license. By contributing you are agreeing to the terms of that license. MonoGame Documentation by the MonoGame Foundation is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike License."
  },
  "templates/docs.monogame.github.io/README.html": {
    "href": "templates/docs.monogame.github.io/README.html",
    "title": "docs.monoGame.github.io | hallowed",
    "summary": "docs.monoGame.github.io This repository contains the documentation for MonoGame. Building From Source The MonoGame website is built using the .NET tool DocFX to generate the base MonoGame documentation and the API reference documentation. This means you will need the following prerequisites to build locally from source .NET SDK version 6.0 or higher installed (download) (recommended 8.0+) With your environment setup properly, the following explains how to build from source Clone this repository git clone https://github.com/MonoGame/docs.monogame.github.io.git Install DotNet dependencies dotnet tool restore Build and serve the documentation The easiest way to build and serve the documentation locally is using the provided scripts: On Windows (PowerShell): .\\serve.ps1 On macOS/Linux (Bash): ./serve.sh These scripts will automatically: Initialize MonoGame submodules if needed Build required assemblies for API documentation Generate the complete documentation Start a local web server Alternative: Build-only (without serving) If you only want to build the documentation without serving: On Windows (PowerShell): .\\build.ps1 On macOS/Linux (Bash): ./build.sh Or manually using DocFX: dotnet docfx docfx.json Note The build scripts automatically handle submodule initialization and MonoGame assembly building. They only perform these steps when necessary, making subsequent builds faster. Note Docfx hosting does not support hot reload, so to refresh the hosted site you will need to run docfx docfx.json in a separate terminal or stop and rerun the agent (ctrl-c) Document styling The use of DocFX with the updated MonoGame docs site has afforded the use of some custom stylings to improve consistency and more stylized docs: Document Frontmatter now drives the Title, Description and whether or not a MS license statement is needed in the document. --- title: How to create a Render Target description: Demonstrates how to create a render target using a RenderTarget2D. requireMSLicense: true --- DocFX admonitions are supported for adding Notes, Info Panels etc, for more details see the MS docs on DocFX markdown: DocFX Markdown style guide As an example of a document written using the above notes, please refer to the HowTo: Create a Render Target tutorial Tip No additional text is needed at the bottom of document pages as the licenses and requirements are automatically added by the DocFX build system LICENSE The MonoGame project is under the Microsoft Public License except for a few portions of the code. See the LICENSE file for more details."
  },
  "templates/docs.monogame.github.io/api/index.html": {
    "href": "templates/docs.monogame.github.io/api/index.html",
    "title": "Reference | hallowed",
    "summary": "Welcome to the MonoGame reference documentation! This area provides detailed information on each class and method in the API. Please view the documentation for how to get started and step-by-step guidance."
  },
  "templates/docs.monogame.github.io/articles/console_access.html": {
    "href": "templates/docs.monogame.github.io/articles/console_access.html",
    "title": "Console Access | hallowed",
    "summary": "MonoGame is free to use on all platforms from the public repository, but the code for supporting console platforms is only accessible to authorized console developers. These platforms are provided as private code repositories that add integrations with the console vendor's APIs and platform-specific documentation. Application process The process for access to the private console repositories is as follows: Apply to the vendor developer program (required for publishing). Through the program, request access to the MonoGame console repositories. Important The MonoGame Foundation cannot directly give anyone access to the private console repositories without prior approval from the vendor due to NDA requirements set out by each vendor. The instructions below will help you gain access to each platform. Nintendo Switch Your first step is to register as a Nintendo Developer for Nintendo Switch. Once you are in the program, you can go to the middleware page and fill out the MonoGame - Nintendo Developer Authorization form. We will then contact you with further instructions. PlayStation 4, PlayStation 5 To access PlayStation platforms you must register as a PlayStation Partner. Once you are registered, you can submit a request in the PlayStation 4 forums and the PlayStation 5 forums. We will process these requests to give you access and further instructions. Xbox One, Xbox Series X To publish on Xbox, you must first be a member of the ID@Xbox Program. Once you are active in the program you can email idsetup@xbox.com and copy the MonoGame console@monogame.net account requesting Xbox Developer verification for access to MonoGame for Xbox. Once Microsoft approves your development status we will respond with further instructions. Questions If you have any further questions feel free to contact us at console@monogame.net."
  },
  "templates/docs.monogame.github.io/articles/contributing.html": {
    "href": "templates/docs.monogame.github.io/articles/contributing.html",
    "title": "Contributing to MonoGame Documentation | hallowed",
    "summary": "Thank you for choosing to contribute to the MonoGame project! This page provides guidance on how you can help to improve the documentation for MonoGame. Getting Started Note If you are new to making contributions to open source projects, it is recommended to understand the following concepts before submitting your contribution: How to fork a repo. Creating a new branch for your fork from main. Creating a new file or editing an existing one using the GitHub markup editor. How to submit your contributions for review through a pull request. Articles and API References The MonoGame documentation contains two types of documents: articles and API references. Articles include manuals, guides, and tutorials on how to use the MonoGame Framework to create games. API references provide detailed explanation of each class and method found in the MonoGame Framework. The documentation is written in the C# XML format and is inline to the MonoGame source code. Generating the Documentation Site The pages for articles and API references are hosted on a documentation site that is generated using DocFX. To generate a local copy of the documentation site: Fork the docs.monogame.github.io repository. Follow the instructions in the site's readme for preparing your environment and generating the documentation. If you intend to make contributions to the API References, then run git submodule update --init --recursive command to update the external/MonoGame submodule to your local fork. Use the dotnet docfx docfx.json --serve command to serve a local copy of the documentation site. Browse the running site from http://localhost:xxxx. Tip Verify your changes in your local documentation site before submitting a pull request with said changes. It is recommended to include screenshots of the pages in the pull request to help reviewers confirm these changes. General Rules The following rules must be observed at all times when contributing documentation to the MonoGame project. Write in a neutral, technical tone. Avoid humor, personal opinions, and colloquial language. Never plagiarize any documentation from another source. Do not use automatic documentation tools as they are ineffective. Warning Breaking these rules can result in your contribution being rejected. General Style Guide Because there are many contributors to the MonoGame documentation, it can be difficult to maintain a coherent writing style throughout the documentation site. In addition to the General Rules, this style guide serves to inform contributors of the conventions needed to maintain this writing style. So please review the following expectations before contributing any documentation. Every Word Should Contain Value Every word in the reference documentation should provide information beyond the API itself. Documentation that only rehashes or rephrases what is already apparent in the class, method, parameter, or property name has zero value and wastes time for both the writer and reader. The First Sentence Is the Most Important There is no guarantee that the reader will read beyond the first sentence of the reference documentation. This is why that first sentence is the most important and should convey the most key piece of information. Take your time to write the most concise and clear first sentence possible. This helps users tremendously and goes a long way towards having great documentation. Surface Information Hidden in the Code Being inline with the code allows you to easily look for critical information within it that the user might not know from looking at the API alone. Take your time to explore inner method calls and platform specific sections of the code. The time to write the documentation is once you feel you fully understand the code you are documenting. If you don't feel you understand the code then leave the documentation for someone else to write. Focus on What Adds Value to the Consumer Limit documentation to public methods and functions unless there is a specific reason to include internal methods, while documenting internals helps with the readability of the code, it provides limited use to consumers of the MonoGame Framework. Documentation Is Referenced Not Read Remember that the user is searching for an answer for a specific question. It is your job to predict these questions and provide them clear answers. Descriptions Should Add Value and Understanding Describing a thing by naming the thing does not help the developer to understand what the concept is that you are describing, for example: \"The Genre class provides information about a genre\" Which does not help someone reading the documentation if they do not know what a Genre is. Be descriptive and improve the readers understanding for what something is and WHY it is. API Reference Style Guide In addition to the General Style Guide, please consider the following conventions used for code associated with the API reference docs. XML Tag Guidance By default, the standard Microsoft recommendations should be used for filling in XML tags for each class, method and property. With a few points to call out: <see> and <cref/> should be used whenever an API reference is used in the documentation To ensure that API documentation is linked to whichever reference is used, <see> and <cref/> references should be used. This helps users navigate the methods, especially when looking up initializers or use of a property or method. Avoid self referencing <cref/> unless it provides value <cref/> blocks are there to add links and create references to other classes, functions and methods that help inform the developer for what those concepts are. Adding a <cref/> for the same class or property you are describing just creates a circular reference that does not add value. References to other methods or properties in the same class is fine, just avoid self if possible. Use descriptors in <see/> and <cref/> statements for better readability By default, a <cref/> or <see/> reference will use only the type you are referencing when rendered to the user, e.g. <cref=\"Album.Genre\"/> will render as Genre. Instead, use the descriptor in the style to render what you actually mean, for example: <cref=\"Album.Genre\">Album.Genre</cref> which will always render as Album.Genre which is much clearer, it is the same for <see/> tags. 120 width comments for easy reading Comments should be limited to 120 width, with overflow moving to the next line to make reading easier, for example: <summary> Packed vector type containing unsigned normalized values ranging from 0 to 1. The x and z components use 5 bits, and the y component uses 6 bits. </summary> Note If the cref description would cause the line to exceed the 120 recommendation, this is generally ok, so long as the rendered line does not exceed the limit. The limit however, is more of a guideline than a hard rule, so common sense should be applied to keep the limit near 120 characters. Use the packed multi-line style with surrounding tags To keep the documentation packed and readable, each parameter should be contained to a single line, for example: <summary> Creates a new instance of Bgr565. </summary> <param name=\"x\">The x component</param> <param name=\"y\">The y component</param> <param name=\"z\">The z component</param> Interface Documentation If documentation is already provided by an interface or inherited class, then the <inheritdoc /> tag should be used. Critically, DO NOT duplicate documentation as it increases maintenance later, for example: /// <inheritdoc /> public void InterfaceDefinedMethod() /// <inheritdoc cref=\"IDisposable.Dispose()\"/> public void Dispose() This applies to all derived elements within a class, property or method. Inherited Properties Where a property or type is already documented in an enum or static, to avoid duplication the <inheritdoc cref=\"\"/> style should be used, for example: public struct VertexPositionColorNormalTexture : IVertexType { /// <inheritdoc cref=\"VertexPosition.Position\" /> public Vector3 Position; /// <inheritdoc cref=\"VertexPositionColor.Color\" /> public Color Color; /// <inheritdoc cref=\"VertexPositionNormalTexture.Normal\" /> public Vector3 Normal; /// <inheritdoc cref=\"VertexPositionTexture.Texture\" /> public Vector2 TextureCoordinate; /// <inheritdoc cref=\"IVertexType.VertexDeclaration\" /> public static readonly VertexDeclaration VertexDeclaration; Protected Methods Requiring Documentation by the Linter By default, we do not document Finalizers or other protected methods, the recommendation is to apply an empty <summary /> tag to suppress the warnings raised by the linter, for example: /// <summary /> ~Foo() => Dispose(false); License All documentation contributed to the MonoGame project is subject to the Creative Commons Attribution-NonCommercial-ShareAlike license. By contributing you are agreeing to the terms of that license. MonoGame Documentation by the MonoGame Team is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike License."
  },
  "templates/docs.monogame.github.io/articles/getting_started/1_setting_up_your_os_for_development_arch.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_started/1_setting_up_your_os_for_development_arch.html",
    "title": "Setting up your OS for development on Arch Linux | hallowed",
    "summary": "Tip Arch Linux is a rolling release distribution. This guide was tested in October 2025 with kernel version 6.15.9-arch1-1. To develop with MonoGame in C#, you will need to install the .NET SDK. As of MonoGame 3.8.2 the minimum supported version is .NET 8. Install .NET 8 SDK Open a new Terminal window. Enter the following command in the terminal to install the latest .NET 8 SDK: sudo pacman -Syu sudo pacman -S dotnet-sdk-8.0 Install additional workloads If you intend to also work with platforms such as Android or iOS, you will need to install the additional .NET workload templates for those platforms which include additional features and simulators to support those platforms. Just run the following commands from the terminal for the platforms below you wish to install. Important For mobile development with iOS and Android, you must also install the MAUI workload even though MonoGame does not use MAUI. The MAUI workload contains the debugging tools required to run and debug mobile .NET applications. Without it, you will not be able to properly debug your MonoGame mobile projects. Android iOS Maui Android, iOS, and Maui dotnet workload install android dotnet workload install ios dotnet workload install maui dotnet workload install android ios maui Note You can use dotnet workload search to detect any other available workloads you wish to use. Setup Wine For Effect Compilation Effect (shader) compilation requires access to DirectX. This means it will not work natively on macOS and Linux systems, but it can be used through Wine. MonoGame provides a setup script that can be executed to setup the Wine environment for Effect (shader) compilation. Open a terminal window Install Wine and required dependencies sudo pacman -S wget curl 7zip wine Important Arch Linux recently transitioned the Wine package to a pure wow64 build to align with upstream Wine development. Because of this, when you install Wine using pacman, you will not get a separate wine64 executable that the MonoGame tools will expect. Reference: https://archlinux.org/news/transition-to-the-new-wow64-wine-and-wine-staging/ This means you will need to create a symlink for MonoGame to reference with the following command sudo ln -s /usr/bin/wine /usr/local/bin/wine64 Now that the prerequisites are installed, download the mgfxc_wine_setup.sh script and execute it by entering the following command in the terminal: wget -qO- https://monogame.net/downloads/net8_mgfxc_wine_setup.sh | bash Tip When running the Wine setup script, you may see a popup asking to install Wine Mono for .NET support. You can cancel/close this popup. It's not needed because the MonoGame script installs the actual Windows .NET SDK instead. Note This script will create a new directory called .winemonogame in your home directory. If you ever wish to undo the setup this script performed, just simply delete that directory. After the script completes, you must add the MGFXC_WINE_PATH environment variable to your system environment for it to be accessible to all applications: echo 'MGFXC_WINE_PATH=\"'$HOME'/.winemonogame\"' | sudo tee -a /etc/environment Important Unlike other Linux distributions, such as Ubuntu, Arch Linux may not automatically load environment variables from your user profile at ~/.profile for all applications. Adding MGFXC_WINE_PATH to /etc/environment ensures it is available system-wide, including for GUI applications (such as the MGCB Editor) and IDEs For the environment variable to take effect, you can either log out and back in (recommended) or reboot your system. After logging back in, verify the environment variable is set: echo $MGFXC_WINE_PATH Note When running the above command you should see an output similar to the following /home/yourusername/.winemonogame Next Steps Choose from one of the two IDE options on Arch Linux: Setting up VSCode Setting up Rider Troubleshooting Issue: \"wine64 not found error\" If the setup script fails with wine64 not found, ensure you created the symlink from step 2 above sudo ln -s /usr/bin/wine /usr/local/bin/wine64 Issue: Shader compilation fails with \"MGFXC effect compiler requires a valid wine installation\" This means the MGFXC_WINE_PATH environment variable is not set. Ensure you: Added it to /etc/environment as shown above in step 4 Logged out and logged back in Can see it with echo $MGFXC_WINE_PATH Issue: Wine creates a .wine-mgfxc directory instead of using .winemonogame This is another symptom of the environment variable not being set. Follow the steps in the previous issue to resolve it. Issue: Wine version too old The MonoGame setup script requires Wine 8.0 or later. Check your version: wine --version If it's too old, update your system: sudo pacman -Syu"
  },
  "templates/docs.monogame.github.io/articles/getting_started/1_setting_up_your_os_for_development_macos.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_started/1_setting_up_your_os_for_development_macos.html",
    "title": "Setting up your OS for development on MacOS | hallowed",
    "summary": "To develop with MonoGame in C#, you will need to install the .NET SDK. As of MonoGame 3.8.2 the minimum supported version is .NET 8. Install .NET 8 SDK Navigate to https://dotnet.microsoft.com/en-us/download/dotnet/8.0 Download the .NET SDK Installer for your current platform of macOS Once the .pkg file finishes downloading, run it and follow the prompts to install the .NET SDK Install additional workloads If you intend to also work with platforms such as Android or iOS, you will need to install the additional .NET workload templates for those platforms which include additional features and simulators to support those platforms. Just run the following commands from the terminal for the platforms below you wish to install. Important For mobile development with iOS and Android, you must also install the MAUI workload even though MonoGame does not use MAUI. The MAUI workload contains the debugging tools required to run and debug mobile .NET applications. Without it, you will not be able to properly debug your MonoGame mobile projects. Android iOS Maui Android, iOS, and Maui dotnet workload install android dotnet workload install ios dotnet workload install maui dotnet workload install android ios maui Note You can use dotnet workload search to detect any other available workloads you wish to use. Apple Silicon Known Issues For the time being, MonoGame requires that you install the x64 version of the .NET runtime if you are running on an Apple Silicon mac in order to be able to build content. It is also required that Rosetta is enabled. Navigate to https://dotnet.microsoft.com/en-us/download/dotnet/8.0 Download the .NET Runtime Installer for macOS x64 Once the .pkg file finishes downloading, run it and follow the prompts to install the .NET Runtime Setup Wine For Effect Compilation Effect (shader) compilation requires access to DirectX. This means it will not work natively on macOS and Linux systems, but it can be used through Wine. MonoGame provides a setup script that can be executed to setup the Wine environment for Effect (shader) compilation. Install brew.sh Enter the following command: brew install wget p7zip curl && brew install --cask wine-stable && xattr -dr com.apple.quarantine \"/Applications/Wine Stable.app\" Now that the prerequisites are installed, download the mgfxc_wine_setup.sh script and execute it by entering the following command in the terminal: wget -qO- https://monogame.net/downloads/net8_mgfxc_wine_setup.sh | bash This will create new directory called .winemonogame in your home directory. If you ever wish to undo the setup this script performed, just simply delete that directory. Next Steps Choose from one of the two IDE options on macOS: Setting up VSCode Setting up Rider"
  },
  "templates/docs.monogame.github.io/articles/getting_started/1_setting_up_your_os_for_development_ubuntu.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_started/1_setting_up_your_os_for_development_ubuntu.html",
    "title": "Setting up your OS for development on Ubuntu | hallowed",
    "summary": "Tip The minimum version of Ubuntu that is supported by MonoGame is 20.04. To develop with MonoGame in C#, you will need to install the .NET SDK. As of MonoGame 3.8.2 the minimum supported version is .NET 8. Install .NET 8 SDK Open a new Terminal window. Enter the following command in the terminal to install the latest .NET 8 SDK: sudo apt-get update && sudo apt-get install -y dotnet-sdk-8.0 Install additional workloads If you intend to also work with platforms such as Android or iOS, you will need to install the additional .NET workload templates for those platforms which include additional features and simulators to support those platforms. Just run the following commands from the terminal for the platforms below you wish to install. Important For mobile development with iOS and Android, you must also install the MAUI workload even though MonoGame does not use MAUI. The MAUI workload contains the debugging tools required to run and debug mobile .NET applications. Without it, you will not be able to properly debug your MonoGame mobile projects. Android iOS Maui Android, iOS, and Maui dotnet workload install android dotnet workload install ios dotnet workload install maui dotnet workload install android ios maui Note You can use dotnet workload search to detect any other available workloads you wish to use. Setup Wine For Effect Compilation Effect (shader) compilation requires access to DirectX. This means it will not work natively on macOS and Linux systems, but it can be used through Wine. MonoGame provides a setup script that can be executed to setup the Wine environment for Effect (shader) compilation. Open a terminal window Enter the following command sudo apt install wget curl p7zip-full wine64 Tip If you receive an error stating that either of the packages do not have an install candidate, you may need to enable the universe apt repository. To do this, enter the following commands in the terminal sudo add-apt-repository universe sudo apt update Then try installing the packages again. Now that the prerequisites are installed, download the mgfxc_wine_setup.sh script and execute it by entering the following command in the terminal: wget -qO- https://monogame.net/downloads/net8_mgfxc_wine_setup.sh | bash This will create new directory called .winemonogame in your home directory. If you ever wish to undo the setup this script performed, just simply delete that directory. Next Steps Choose from one of the two IDE options on Ubuntu: Setting up VSCode Setting up Rider"
  },
  "templates/docs.monogame.github.io/articles/getting_started/1_setting_up_your_os_for_development_windows.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_started/1_setting_up_your_os_for_development_windows.html",
    "title": "Setting up your OS for development on Windows | hallowed",
    "summary": "To develop with MonoGame in C#, you must install the .NET SDK. As of MonoGame 3.8.2 the minimum supported version is .NET 8. Important If your chosen IDE for development is Visual Studio then you can skip this step as .NET 8 is included with the Visual Studio Installer. Install .NET 8 SDK You can follow the instructions below based on your operating system to install the .NET 8.0 SDK Navigate to https://dotnet.microsoft.com/en-us/download/dotnet/8.0 Click the .NET SDK x64 download button to download. This will take you to the download page where the dotnet-sdk-8.x.yyy-win-x64.exe will download. When the download completes, run the dotnet-sdk-8.x.yyy-win-x64.exe installer and complete the steps to install .NET on your machine. When the installation completes, open a new Command Prompt window and run the command dotnet to verify the installation was successful. Install additional workloads If you intend to also work with platforms such as Android or iOS, you will need to install the additional .NET workload templates for those platforms which include additional features and simulators to support those platforms. Just run the command-line command for the platforms below you wish to install. Important For mobile development with iOS and Android, you must also install the MAUI workload even though MonoGame does not use MAUI. The MAUI workload contains the debugging tools required to run and debug mobile .NET applications. Without it, you will not be able to properly debug your MonoGame mobile projects. Android iOS Maui Android, iOS, and Maui dotnet workload install android dotnet workload install ios dotnet workload install maui dotnet workload install android ios maui Note You can use dotnet workload search to detect any other available workloads you wish to use. Next Steps Choose from one of the three IDE options on Windows: Setting up Visual Studio Setting up VSCode Setting up Rider"
  },
  "templates/docs.monogame.github.io/articles/getting_started/2_choosing_your_ide_rider.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_started/2_choosing_your_ide_rider.html",
    "title": "Setting up your development environment for Rider | hallowed",
    "summary": "This is a guide on setting up your development environment for creating games with MonoGame using Rider by JetBrains. By following this guide, you will learn how to install the tools for developing C# applications and configure Rider with recommended extensions for C# development. By the end, you will be fully equipped to start creating games with MonoGame using Rider. Install Rider You can download and install Rider from: https://www.jetbrains.com/rider/download Note Rider is free for personal use, you do have to register and create an account, but otherwise all features will be unlocked. Setting up Rider for development with MonoGame Open up terminal (or Powershell on Windows) Run the following command to install templates: dotnet new install MonoGame.Templates.CSharp Tip Alternatively, consider using the Preview Packages provided by MonoGame to get access to the latest developments. How to install MonoGame Preview packages Creating a new MonoGame project To get you started with Rider, here are the steps for setting up a new Rider MonoGame project. Open up Rider Click on the \"New Solution\" button Select \"MonoGame Cross-Platform Desktop Application\" on the list on the left Press \"Create\" You can now press F5 to compile and debug your game, happy coding :) Note If you are experiencing issues with compiling effects under Linux for JetBrains Rider, you might need to add the MGFXC_WINE_PATH environment variable to /etc/environment for it to be picked up. See 5777151094034-Rider-cannot-see-all-Environmental-Variables for details. Update Project Tool references The MonoGame Content Editor (MGCB) it a tool delivered through NuGet for your project using the tools configuration held in your dotnet-tools.json file (located in the .config folder of your project). Once you have created your project you should run the following terminal/command-line command to ensure the tool (and the pipeline) is setup and read for your project: dotnet tool restore Note If you ever change the version of the tools or want to upgrade them by editing the dotnet-tools.json configuration, you MUST run this command again to update the tools. Next Steps Next, get to know MonoGame's code structure and project layout: Understanding the code"
  },
  "templates/docs.monogame.github.io/articles/getting_started/2_choosing_your_ide_visual_studio.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_started/2_choosing_your_ide_visual_studio.html",
    "title": "Setting up Visual Studio on Windows | hallowed",
    "summary": "MonoGame can work with most .NET compatible tools, but we recommend Visual Studio 2022 Note Alternatively, you can use JetBrains Rider or Visual Studio Code. Check out the guides for Setting up VSCode / Setting up Rider using these links. Install Visual Studio 2022 Before using MonoGame with Visual Studio you need to ensure you have installed the latest Visual Studio 2022 along with the required components. When installing Visual Studio, the following workloads are required depending on your desired target platform(s): Mandatory for all platforms: .Net desktop development Optional .Net Multi-platform App UI Development if you wish to target Android, iOS, or iPadOS. Universal Windows Platform development if you wish to build for Windows store or Xbox. Warning Targeting Windows If you are targeting the standard Windows DirectX backend, you will also need the DirectX June 2010 runtime for audio and gamepads to work properly. Work is underway however to update to support DirectX 12 on Windows and Xbox very soon. Install MonoGame extension for Visual Studio 2022 To create new MonoGame projects from within Visual Studio 2022, you will need to install the MonoGame Framework C# project templates extension. The following steps demonstrate how to install the extension. Launch Visual Studio 2022 Select Continue without code. This will launch Visual Studio without any project or solution opened. Click \"Extensions -> Manage Extensions in the Visual Studio 2022 menu bar. This will open the Manage Extensions dialog window. Use the search box in the top-right corner of the Manage Extensions dialog window to search for MonoGame, then click the MonoGame Framework C# project templates extension as shown below and download it to install it. After it is downloaded, an alert will appear at the bottom of the Manage Extensions window that states \"Your changes will be scheduled. The modifications will begin when all Microsoft Visual Studio windows are closed.\" Click the Close button, then close Visual Studio 2022. After closing Visual Studio 2022, a VSIX Installer window will open confirming that you want to install the MonoGame Framework C# project templates extension. Click the Modify button to accept the install. You now have the MonoGame templates installed and are ready to create new projects. Tip Alternatively, consider using the Preview Packages provided by MonoGame to get access to the latest developments. How to install MonoGame Preview packages Creating a new MonoGame project To get you started with Visual Studio, here are the steps for setting up a new MonoGame project. Start Visual Studio 2022 and select New Project... in the upper left corner. You should see the \"Create a new project\" dialog pop up. From here, select the Templates > Visual C# > MonoGame category, and then select MonoGame Cross Platform Desktop Project. Next, type in a name for your project. For this tutorial, Pong will be used (note: project names cannot contain spaces). After you have entered the name, click on the ... button next to the Location text field and choose the folder you want to save the project in. Finally, click OK to create the project. If everything went correctly, you should see a project named Pong open up like in the picture below. To run your game, simply press the big Play Button in the toolbar, or press F5. You should now see your game window running. Next Steps Next, get to know MonoGame's code structure and project layout: Understanding the code"
  },
  "templates/docs.monogame.github.io/articles/getting_started/2_choosing_your_ide_vscode.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_started/2_choosing_your_ide_vscode.html",
    "title": "Setting up your development environment for VSCode | hallowed",
    "summary": "This is a guide on setting up your development IDE for creating games with MonoGame using Visual Studio Code. By following this guide, you will learn how to install the necessary tools for developing C# applications and configure Visual Studio Code with recommended extensions for C# development. By the end, you will be fully equipped to start creating games with MonoGame using Visual Studio Code. Install Visual Studio Code Windows macOS Ubuntu Arch Linux Open your web browser and navigate to https://code.visualstudio.com/. Click the Download for Windows button. This will redirect you to the download page where the installer will automatically download. When the download completes, run the installer and complete the steps to install Visual Studio Code. Open your web browser and navigate to https://code.visualstudio.com/. Click the Download Mac Universal button. This will redirect you to the page where the application archive (.zip) file will begin downloading. Extract the contents of the VSCode archive that downloaded by double-clicking it inside a Finder window. This will extract the Visual Studio Code.app file. Drag the Visual Studio Code.app file into the Applications folder, making it available in the macOS Launchpad. Open your web browser and navigate to https://code.visualstudio.com/. Click the Download .deb button. Double click the .deb file and press the Install button. On Arch Linux, you have two options for installing Visual Studio Code: Option 1: Code OSS (Open Source Version) Code OSS is the fully open-source version available under the MIT License. It's available in the official Arch repositories and can be installed with a single command: sudo pacman -S code Important Code OSS cannot use the proprietary Microsoft C# Dev Kit extension. However, it can use the base C# extension (formerly OmniSharp, now LSP-based), which provides IntelliSense, syntax highlighting, debugging, and code navigation, sufficient for MonoGame development. Option 2: Visual Studio Code (Official Microsoft Version) - Recommended The official Microsoft version includes proprietary features like settings sync, Microsoft account integration, and support for the C# Dev Kit extension. It's available through the AUR (Arch User Repository). First, ensure you have an AUR helper installed. If you don't have one, install yay: sudo pacman -S git base-devel git clone https://aur.archlinux.org/yay.git cd yay makepkg -si Install Visual Studio Code using yay: yay -S visual-studio-code-bin Tip For the best MonoGame development experience with full C# Dev Kit support (enhanced project management, integrated testing, better solution support), install the official Visual Studio Code. Code OSS works but has limitations with Microsoft extensions. Setting up VS Code for development with MonoGame Open Visual Studio Code Open up its terminal window (Ctrl + `) Run the following command to install MonoGame Templates dotnet new install MonoGame.Templates.CSharp Tip Alternatively, consider using the Preview Packages provided by MonoGame to get access to the latest developments. How to install MonoGame Preview packages Install Visual Studio Code C# Extensions To transform Visual Studio Code from a simple text editor into a powerful development environment for C# projects, you must install the Visual Studio Code C# extension. This extension enhances the editor by providing syntax highlighting, code analysis, IntelliSense, and other features that significantly improve the development experience and productivity when working with C#. Open Visual Studio Code. Click the Extensions icon in the Activity Bar on the left. In the Search Box type C#. Click Install for the C# Dev Kit extension. Installing this will also install the base C# extension. Note For Arch Linux Code OSS users: The C# Dev Kit extension is not compatible with Code OSS. Instead, install only the base C# extension (by Microsoft), which provides all the core functionality needed for MonoGame development including IntelliSense, debugging, and code navigation. (Optional) Install the \"MonoGame for VSCode\" extension A community member has built a VSCode extension for VS code to enable: Automatically install MonoGame templates Create new projects from the file menu or command palette Open the MGCB editor with the click of a button (very useful) You can find this extension by following the steps above and searching for \"MonoGame for VS Code\" by r88. Note While not built by the MonoGame team, we regularly use this extension ourselves and fully support it. (Optional) Install the \".NET MAUI\" extension to help with mobile development This extension is provided by Microsoft and is built on top of the C# and C# Dev Kit extensions. They will be installed as dependencies if they were not already installed. While primarily designed for MAUI development, it provides essential mobile debugging capabilities that MonoGame mobile projects can utilize. The .NET MAUI extension adds features for building mobile apps, including: F5 debugging support - Debug your MonoGame mobile apps on emulators, simulators, and physical devices Easy target switching - Change debug/deploy targets between different mobile platforms Enhanced C# Dev Kit integration - Leverages Solution Explorer, Test Explorer, and advanced language features Note This extension is recommended if you wish to do iOS or Android development. It is required for debugging support when working on mobile games. Warning For Arch Linux Code OSS users: The .NET MAUI extension requires C# Dev Kit and therefore is not compatible with Code OSS. You will need to use the official Visual Studio Code for mobile development support. Creating a new MonoGame project Open up an empty folder in Visual Studio Code Open up its terminal window (Ctrl + `) Run the following command to create an empty project for desktop platforms: dotnet new mgdesktopgl Once the files are created, open up the Game1.cs file and wait a second for the C# extension to load You can now press F5, select C# and then your projects name if Visual Studio Code asks you, and it should start up your brand new game! Update Project Tool references The MonoGame Content Editor (MGCB) it a tool delivered through NuGet for your project using the tools configuration held in your dotnet-tools.json file (located in the .config folder of your project). Once you have created your project you should run the following terminal/command-line command to ensure the tool (and the pipeline) is setup and read for your project: dotnet tool restore Note If you ever change the version of the tools or want to upgrade them by editing the dotnet-tools.json configuration, you MUST run this command again to update te tools. Next Steps Next, get to know MonoGame's code structure and project layout: Understanding the code"
  },
  "templates/docs.monogame.github.io/articles/getting_started/3_understanding_the_code.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_started/3_understanding_the_code.html",
    "title": "Understanding the Code | hallowed",
    "summary": "Note For help with creating a project, please look at the Creating a New Project section of the Getting Started guide. Within the Game1.cs class file, which is the core of any MonoGame project, you will find several critical sections necessary for your game to run: Using statements - which provide easy access to the various components of MonoGame. The Game Class definition - the heart of any MonoGame project. The Game constructor and key variables - which tell the project how to start. The Initialize method - to initialize the game upon its startup. The Load and Unload Content methods - which are used to add and remove assets from the running game from the Content project. The Update method - which is called on a regular interval to update your game state, e.g. take player inputs, move ships, or animate entities. The Draw method - which is called on a regular interval to take the current game state and draw your game entities to the screen. Read further for more details and examples while looking through the code of your new project. Using Statements using Microsoft.Xna.Framework; using Microsoft.Xna.Framework.Graphics; using Microsoft.Xna.Framework.Storage; using Microsoft.Xna.Framework.Input; These using statements make it easier to use the code that MonoGame has to offer. They are prefixed with Microsoft.Xna.Framework because MonoGame is an open source re-implementation of Microsoft's XNA framework, and in order to maintain compatibility with the XNA code, it uses the same namespaces. The Game1 Class public class Game1 : Game The main Game1 class inherits from the Game class, which provides all the core methods for your game (ie. Load/Unload Content, Update, Draw etc.). You usually only have one Game class per game, so its name is not that important. Instance Variables GraphicsDeviceManager graphics; SpriteBatch spriteBatch; The two default variables that the blank template starts with are the GraphicsDeviceManager and SpriteBatch. Both of these variables are used for drawing to the screen, as you will see in a later tutorial. Constructor public Game1() { graphics = new GraphicsDeviceManager(this); Content.RootDirectory = \"Content\"; IsMouseVisible = true; } The main game constructor is used to initialize the starting variables. In this case, a new GraphicsDeviceManager is created, the root directory containing the game's content files is set, and the mouse cursor is set to visible. Initialize Method protected override void Initialize() { // TODO: Add your initialization logic here base.Initialize(); } The Initialize method is called after the constructor but before the main game loop (Update/Draw). This is where you can query any required services and load any non-graphic related content. LoadContent Method protected override void LoadContent() { // Create a new SpriteBatch, which can be used to draw textures. spriteBatch = new SpriteBatch(GraphicsDevice); // TODO: use this.Content to load your game content here } The LoadContent method is used to load your game content. It is called only once per game, within the Initialize method, before the main game loop starts. Update Method protected override void Update(GameTime gameTime) { if (GamePad.GetState(PlayerIndex.One).Buttons.Back == ButtonState.Pressed || Keyboard.GetState().IsKeyDown(Keys.Escape)) Exit(); // TODO: Add your update logic here base.Update(gameTime); } The Update method is called multiple times per second, and it is used to update your game state (checking for collisions, gathering input, playing audio, etc.). Draw Method protected override void Draw(GameTime gameTime) { GraphicsDevice.Clear(Color.CornflowerBlue); // TODO: Add your drawing code here base.Draw(gameTime); } Similar to the Update method, the Draw method is also called multiple times per second. This, as the name suggests, is responsible for drawing content to the screen. Next Steps Next, learn how to add and import content into your game project: Adding Content"
  },
  "templates/docs.monogame.github.io/articles/getting_started/4_adding_content.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_started/4_adding_content.html",
    "title": "Adding Content | hallowed",
    "summary": "Note this tutorial continues from where 3. Understanding the Code left off. MonoGame Content Builder Tool (MGCB Editor) The MGCB Editor is used to organize and build content for use with MonoGame. It is accessed by either: Double-clicking a \".mgcb\" file from within the Visual Studio solution explorer (providing that you installed MonoGame's Visual Studio extension). Right-clicking a \".mgcb\" file from within the Visual Studio code and selecting \"Open in MGCB Editor\" (provided you have installed the VSCode extension) Use 'dotnet mgcb-editor' to open Editor, than open \".mgcb\" file from menu. Alternatively, you can build it directly from source if needed. This is all technically optional, since you can edit the .mgcb files manually if you wish, but the editor is highly recommended for ease of use. Adding content First, you will need some content for your game. For this tutorial, use the following image of a ball: Copy the image to your machine by using right-click > Save Image As and save it somewhere locally with the name “ball.png”. Open the MGCB Editor In Visual Studio you can up your game project and look at the Solution Explorer window. Expand the Content folder and open up Content.mgcb file by double-clicking on it. Right-clicking a \".mgcb\" file from within the Visual Studio code and selecting \"Open in MGCB Editor\". You should now see the MGCB Editor window open up. Note If a text file opens instead, then right-click on Content.mgcb and select Open With, then select MGCB Editor in the list, click Set as Default and then click OK, then try again. If you do not see the MGCB Editor option when you right-click and select Open With, then please review the Tools documentation for installing the MGCB Editor tool for your operating system. Understanding the MGCB Editor Your game content is managed from this external tool. You can add content to your game in one of the following ways: Add Existing Item toolbar button Edit > Add > Existing Item... menu button right-click > Add > Existing Item... context menu Make sure the \"Content\" Node is selected to the left, then click the Add Existing Item toolbar button. You should now be prompted to select a file. Select the ball.png image that you downloaded a moment ago. Once you have confirmed your selection, you will be asked whether to copy the file, add a link to it, or skip it. Make sure Copy the file to the directory option is selected and click Add. Now click the Save toolbar button and close the MGCB Editor tool. Adding the content in your game Now that you have added the asset to the Content project, it is time to load it into your game. First, open up the Game1.cs class file and declare a new ballTexture variable of type Texture2D in the Game1 class, so you can store the ball image into memory. public class Game1 : Game { Texture2D ballTexture; private GraphicsDeviceManager _graphics; private SpriteBatch _spriteBatch; Next, find the LoadContent method. Here, use Content.Load() function to load the \"ball\" sprite and store it in the ballTexture parameter. Content.Load() requires you to specify what type of content you are trying to load, in this case it is a Texture2D. protected override void LoadContent() { // Create a new SpriteBatch, which can be used to draw textures. _spriteBatch = new SpriteBatch(GraphicsDevice); // TODO: use this.Content to load your game content here ballTexture = Content.Load<Texture2D>(\"ball\"); } Finally, find the Draw method to draw the ball onto the screen. This is done by: Opening a SpriteBatch (an image drawing collection function) by calling the Begin function. Adding the images you want to draw and specifying where you want to draw them. Then finally finishing the SpriteBatch to commit the textures you want drawn to the screen by calling the End function. Note: if you add multiple images, they will be drawn in the order you place them from back to front (each drawn on top of each other). As shown below: protected override void Draw(GameTime gameTime) { graphics.GraphicsDevice.Clear(Color.CornflowerBlue); // TODO: Add your drawing code here _spriteBatch.Begin(); _spriteBatch.Draw(ballTexture, new Vector2(0, 0), Color.White); _spriteBatch.End(); base.Draw(gameTime); } Now run the game. You should get the following: Next Steps Next, learn how to get your first basic game concept running: Adding Basic Code"
  },
  "templates/docs.monogame.github.io/articles/getting_started/5_adding_basic_code.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_started/5_adding_basic_code.html",
    "title": "Adding Basic Code | hallowed",
    "summary": "Note this tutorial continues from where 5. Adding Content left off. Positioning the content First, you need to add few new variables in the Game1.cs class file: A Vector2 for position and a float for speed. public class Game1 : Game { Texture2D ballTexture; Vector2 ballPosition; float ballSpeed; } Next, you need to initialize them. Find the Initialize method and add the following lines. protected override void Initialize() { // TODO: Add your initialization logic here ballPosition = new Vector2(_graphics.PreferredBackBufferWidth / 2, _graphics.PreferredBackBufferHeight / 2); ballSpeed = 100f; base.Initialize(); } With this, you are setting the ball's starting position to the center of the screen based on the dimensions of the screen determined by the current BackBufferWidth and BackBufferHeight that was obtained from the Graphics Device (the current resolution the game is running at). Lastly, change the Draw method to draw the ball at the correct position. Find the Draw method and update the spriteBatch.Draw call to: _spriteBatch.Draw(ballTexture, ballPosition, Color.White); Now run the game. As you can see, the ball is not quite centered yet. That is because the default origin of a texture is its top-left corner, or (0, 0) relative to the texture. The ball texture is drawn with its top-left corner exactly centered, rather than its actual center. You can specify a different origin when drawing, as shown in the following code snippet. The new origin takes into account the height and width of the image when drawing: _spriteBatch.Draw( ballTexture, ballPosition, null, Color.White, 0f, new Vector2(ballTexture.Width / 2, ballTexture.Height / 2), Vector2.One, SpriteEffects.None, 0f ); Note For more details on drawing textures, check out the How To Draw a Sprite series which goes in to greater detail. This change adds a few extra parameters to the spriteBatch.Draw call, but do not worry about that for now. This new code sets the actual center (width / 2 and height / 2) of the image as its origin (drawing point). Now the image will get drawn to the center of the screen. Getting user input via keyboard Time to set up some movement. Find the Update method in the Game1.cs class file and add: protected override void Update(GameTime gameTime) { if (GamePad.GetState(PlayerIndex.One).Buttons.Back == ButtonState.Pressed || Keyboard.GetState().IsKeyDown(Keys.Escape)) Exit(); // TODO: Add your update logic here // The time since Update was called last. float updatedBallSpeed = ballSpeed * (float)gameTime.ElapsedGameTime.TotalSeconds; var kstate = Keyboard.GetState(); if (kstate.IsKeyDown(Keys.Up)) { ballPosition.Y -= updatedBallSpeed; } if (kstate.IsKeyDown(Keys.Down)) { ballPosition.Y += updatedBallSpeed; } if (kstate.IsKeyDown(Keys.Left)) { ballPosition.X -= updatedBallSpeed; } if (kstate.IsKeyDown(Keys.Right)) { ballPosition.X += updatedBallSpeed; } base.Update(gameTime); } The following is a line-by-line analysis of the above code. Calculating speed based on framerate float updatedBallSpeed = ballSpeed * (float)gameTime.ElapsedGameTime.TotalSeconds; This code caches how much time, in seconds, since the last Update call was run, which gives us the duration of a single frame drawn to the screen. This is then multiplied by the ballSpeed value to allow us to control just how fast the ball moves each frame. The reason why ballSpeed is multiplied by gameTime.ElapsedGameTime.TotalSeconds is because, when not using fixed time step, the time between Update calls varies. To account for this, the ballSpeed is multiplied by the amount of time that has passed since the last Update call. The result is that the ball appears to move at the same speed regardless of what framerate the game happens to be running at. Note Try experimenting with what happens if you do not multiply the ballSpeed by gameTime.ElapsedGameTime.TotalSeconds, to see the difference it makes. Getting Keyboard state var kstate = Keyboard.GetState(); This code fetches the current keyboard state (Keyboard.GetState()) and stores it into a variable called kstate. Checking Keyboard state if (kstate.IsKeyDown(Keys.Up)) This line checks to see if the Up Arrow key is pressed. Updating the graphics position to draw to ballPosition.Y -= updatedBallSpeed; If the Up Arrow key is pressed, the ball moves using the value you assigned to by the calculated ballSpeed variable. The rest of the lines of code do the same thing but for the Down, Left and Right Arrow keys, and down, left, and right movement, respectively. If you run the game, you should be able to move the ball with the arrow keys. Getting user input via Joystick / GamePad Another option for user input is the <xref:Microsoft.Xna.Framework.Input.Joystick> or <xref:Microsoft.Xna.Framework.Input.GamePad> classes. Setting up input for Joysticks and GamePads is very similar to setting up keyboard input, the following example is designed while using a single joystick connected to the host, to support more, you will need to evaluate all the connected joysticks and read their input (see <xref:Microsoft.Xna.Framework.Input.JoystickState#Microsoft_Xna_Framework_Input_JoystickState_IsConnected> for reference). Find the Update method in the Game1.cs class file and add: if(Joystick.LastConnectedIndex == 0) { JoystickState jstate = Joystick.GetState((int) PlayerIndex.One); float updatedBallSpeed = ballSpeed * (float)gameTime.ElapsedGameTime.TotalSeconds; if (jstate.Axes[1] < 0) { ballPosition.Y -= updatedBallSpeed; } else if (jstate.Axes[1] > 0) { ballPosition.Y += updatedBallSpeed; } if (jstate.Axes[0] < 0) { ballPosition.X -= updatedBallSpeed; } else if (jstate.Axes[0] > 0) { ballPosition.X += updatedBallSpeed; } } The following is a line-by-line analysis of the above code. Check Joysticks connection state if(Joystick.LastConnectedIndex == 0) This code assumes that we have a single controller plugged into our device. LastConnectedIndex is the index of the last connected controller. The default is -1, which would mean no controller is plugged in. If there is no controller, the code inside the if statement will be skipped over. Get the current state of Joystick 1 JoystickState jstate = Joystick.GetState((int) PlayerIndex.One); This code fetches the current first joystick state Joystick.GetState((int) PlayerIndex.One) and stores it into a variable called jstate. Check the current value of \"Axis\" 2 if (jstate.Axes[1] < 0) This line checks whether the \"second\" Joystick axis is less than 0. Note The Joystick class stores multiple axis of direction for anything with an integer based range. For any number of 2D axis sticks, it stores it in an x,y format inside of an integer array. The axis of movement for 2D joysticks goes from -32768 to 32768 on most modern controllers. Aiming the Joystick upwards results in a negative value on the Y-axis (Axes[1]). The rest of the lines of the code do the same thing but for their relevant x and y directions. If you run the game, you should be able to move the ball with the left Joystick on your controller if one is plugged in. For GamePads, just use the GamePad versions of the same JoyStick classes, but remember, GamePads usually have multiple \"sticks\" for the left and right hand sides of the controller. Handling \"Dead Zones\" with Joysticks/GamePads You will probably notice that the ball slightly moves on its own when controlled via a JoyStick or GamePad, which is likely be the result of your Joystick having a slight drift, a common scenario. You can fix that by adding a deadzone and changing the conditions to use this deadzone (a value range that needs to be exceeded in order to \"act\" on the Joystick/Keyboard input). public class Game1 : Game { ... Texture2D ballTexture; Vector2 ballPosition; float ballSpeed; int deadZone; Next, you need to initialize the deadzone. Find the Initialize method and add the following line. deadZone = 4096; Now, replace the conditions for the Joystick movement in Update to the following: if (jstate.Axes[1] < -deadZone) { ballPosition.Y -= updatedBallSpeed; } else if (jstate.Axes[1] > deadZone) { ballPosition.Y += updatedBallSpeed; } if (jstate.Axes[0] < -deadZone) { ballPosition.X -= updatedBallSpeed; } else if (jstate.Axes[0] > deadZone) { ballPosition.X += updatedBallSpeed; } If you run the game and move the Joystick around, you should notice that your Joystick has to move a decent distance before the ball starts moving. This is what a deadZone does, it allows for there to be a minimum distance before the input is reflected in the game. Note Try experimenting with what happens when you change the value of the deadZone. Mess around and find an amount that fits your project. Handling screen borders You will probably notice that the ball is not confined to the window. You can fix that by setting bounds onto the ballPosition after it has already been moved to ensure it cannot go further than the width or height of the screen. if (kstate.IsKeyDown(Keys.Right)) { ballPosition.X += updatedBallSpeed; } if (ballPosition.X > _graphics.PreferredBackBufferWidth - ballTexture.Width / 2) { ballPosition.X = _graphics.PreferredBackBufferWidth - ballTexture.Width / 2; } else if (ballPosition.X < ballTexture.Width / 2) { ballPosition.X = ballTexture.Width / 2; } if (ballPosition.Y > _graphics.PreferredBackBufferHeight - ballTexture.Height / 2) { ballPosition.Y = _graphics.PreferredBackBufferHeight - ballTexture.Height / 2; } else if (ballPosition.Y < ballTexture.Height / 2) { ballPosition.Y = ballTexture.Height / 2; } base.Update(gameTime); Now run the game to test for yourself that the ball cannot go beyond the window bounds any more. Happy Coding ^^ Next Steps We recommend browsing through the Getting to know MonoGame section to learn more and get some tips and tricks from the MonoGame team. Getting to know MonoGame What Is articles How To articles Further Reading Check out the Tutorials section for many more helpful guides and tutorials on building games with MonoGame. We have an expansive library of helpful content, all provided by other MonoGame developers in the community. Additionally, be sure to check out the official MonoGame Samples page for fully built sample projects built with MonoGame and targeting our most common platforms."
  },
  "templates/docs.monogame.github.io/articles/getting_started/content_pipeline/adding_ttf_fonts.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_started/content_pipeline/adding_ttf_fonts.html",
    "title": "Adding TTF Fonts | hallowed",
    "summary": "MonoGame supports more than one method of using fonts, the following is an explanation of how to use TrueType fonts. Using TrueType Fonts with MonoGame To be able to use a TrueType font, MonoGame requires the TrueType font file and a .spritefont file. TrueType fonts may be installed on the system, or added manually in to the same directory as the .spritefont file. Create the .spritefont file by selecting \"Edit -> Add -> New Item\" from the MGCB Editor menu, then select SpriteFont Description from the list and click Create. Open the newly created .spritefont file in your text editor of choice, find this line and change it to your selected .ttf font. If the font is installed on the system, just type the name of the font. <FontName>Arial</FontName> Usage Example Make a class variable of type <xref:Microsoft.Xna.Framework.Graphics.SpriteFont> SpriteFont font; Load the font with <xref:Microsoft.Xna.Framework.Content.ContentManager> font = myGame.Content.Load<SpriteFont>(\"Fonts/myFont\") Draw text with <xref:Microsoft.Xna.Framework.Graphics.SpriteBatch> spriteBatch.Begin(); // Finds the center of the string in coordinates inside the text rectangle Vector2 textMiddlePoint = font.MeasureString(text) / 2; // Places text in center of the screen Vector2 position = new Vector2(myGame.Window.ClientBounds.Width / 2, myGame.Window.ClientBounds.Height / 2); spriteBatch.DrawString(font, \"MonoGame Font Test\", position, Color.White, 0, textMiddlePoint, 1.0f, SpriteEffects.None, 0.5f) spriteBatch.End();"
  },
  "templates/docs.monogame.github.io/articles/getting_started/content_pipeline/custom_effects.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_started/content_pipeline/custom_effects.html",
    "title": "Custom Effects | hallowed",
    "summary": "A core element of Microsoft XNA is the effect system which is used for all rendering. For MonoGame we have the burden of supporting stock and custom effects for desktop GLSL, mobile GLSL, DirectX HLSL, and custom formats like that of the PlayStation Mobile. There currently is no effect system or shader language that supports all the platforms we require, forcing us to build a new custom effect system. MGFX MGFX is MonoGame's own \"FX\" runtime and tools which with the following core goals: Support a similar technique, passes, shaders structure as Microsoft FX files. Have a textual format for ease of editing. Have a compiled and optimized binary format for runtime use. Be cross-platform and support multiple shader languages and bytecodes. Easy to extend for future platforms and features. Stock Effects MonoGame has the following effects built-in and fully supported on current platforms: SpriteEffect BasicEffect AlphaTestEffect DualTextureEffect EnvironmentMapEffect SkinnedEffect Under the hood these effects use the same system and tools as one would for a custom Effect. The source and pre-compiled versions of these effects can be found in the 'MonoGame.Framework\\Platform\\Graphics\\Effect\\Resources' folder. If your game requires an extra little bit of performance you can easily hand edit the existing effects to remove unnecessary features or optimize for specific hardware and rebuild them with the MGFX tool. Custom Effects To use a custom effect with MonoGame you must do one of the following: Run the effect file through the MonoGame Effect content processor for loading via the <xref:Microsoft.Xna.Framework.Content.ContentManager> (Recommended). Process your effect file with the MGFXC tool and load them yourself at runtime. Effect Writing Tips These are some tips for writing or converting effects for use with MonoGame. The supported shader models when targeting DX are the following: vs_4_0_level_9_1 and ps_4_0_level_9_1 vs_4_0_level_9_3 and ps_4_0_level_9_3 vs_4_0 and ps_4_0 (requires HiDef GraphicsProfile at runtime) vs_4_1 and ps_4_1 (requires HiDef GraphicsProfile at runtime) vs_5_0 and ps_5_0 (requires HiDef GraphicsProfile at runtime) When targeting GL platforms we automatically translate FX files to GLSL using a library called MojoShader. The supported feature levels are the following: vs_2_0 and ps_2_0 vs_3_0 and ps_3_0 You can use preprocessor checks to add conditional code or compilation depending on defined symbols. MonoGame defines the following symbols when compiling effects: 2MGFX HLSL and SM4 for DirectX OpenGL and GLSL for OpenGL As an example, you can conditionally set shader models depending on the platform with the following code: #if OPENGL #define VS_SHADERMODEL vs_3_0 #define PS_SHADERMODEL ps_3_0 #else #define VS_SHADERMODEL vs_4_0_level_9_1 #define PS_SHADERMODEL ps_4_0_level_9_1 #endif technique { pass { VertexShader = compile VS_SHADERMODEL MainVS(); PixelShader = compile PS_SHADERMODEL MainPS(); } }; Custom symbols can be defined from the MGCB Editor or via MGFXC. Make sure the pixel shaders inputs exactly match the vertex shader outputs so the parameters are passed in the correct registers. The parameters need to have the same size and order. Omitting parameters might not break compilation, but can cause unexpected results. Note that on GL platforms default values on Effect parameters do not work. Either set the parameter from code or use a real constant like a #define. The effect compiler is aggressive about removing unused parameters, be sure the parameters you are setting are actually used. Preshaders are not supported. If you think you have found a bug porting a shader, please let us know."
  },
  "templates/docs.monogame.github.io/articles/getting_started/content_pipeline/index.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_started/content_pipeline/index.html",
    "title": "Adding Content | hallowed",
    "summary": "A big part of your game is your content. This includes standard files like textures, sound effects, music, videos, and custom effects as well as custom content like level and enemy files. MonoGame implements its own content pipeline for transforming your unoptimized assets into platform optimized content. This is critical in building a game which runs as fast as possible under tight resource constraints. This section will cover the following topics: Why use the Content Pipeline Using MGCB Editor TrueType Fonts Custom Effects Localization"
  },
  "templates/docs.monogame.github.io/articles/getting_started/content_pipeline/localization.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_started/content_pipeline/localization.html",
    "title": "Localization | hallowed",
    "summary": "Localization is an important part of any game. While it can be possible to design a game that is region independent, it is quite hard. At some point you will need to produce localized text and graphics. MonoGame has a simple localization system built in. If you want to develop your own system you are still able to do so. But the default system should be good enough for most use cases. Creating resx files MonoGame runs on .net/Mono on most platforms. Localization is handled by those platforms via the use of resx files. There are walkthroughs on MSDN which walk you through the process. A simplified version is presented here. Create a .resx file in the IDE e.g Foo.resx and add it to your game project. Note this needs to be added to the main app projects. The Foo.resx file should have an Action of EmbeddedResouce and a Generator value of ResXFileCodeGenerator. Here is a snippet from the .csproj: <EmbeddedResource Include=\"Foo.resx\"> <Generator>ResXFileCodeGenerator</Generator> <LastGenOutput>Foo.Designer.cs</LastGenOutput> </EmbeddedResource> Add any string resources to that file. These are in the form of a Key/Value pair. You can use the built-in editor or manually edit the .resx file by hand. It is an xml file so you can view the contents easily. <data name=\"Wall_Style\" xml:space=\"preserve\"> <value>Wall Style : {0}</value> </data> When the resx is processed by the generator, it produces a Foo.Designer.cs file which is then included in your project. You can then access the \"string\" value by using code as follows: var s = MyProject.Foo.Wall_Style; Note in the example we have a place holder ({0}) for additional text. You can still use te property of Foo.Wall_Style with things like string.Format. int i = 1; var s = string.Format (MyProject.Foo.Wall_Style, i); All this means you do not need to hardcode the string directly. When accessing the MyProject.Foo.Wall_Style property, the code will look up the value from the embedded resx file automatically. You can add support for a new language by adding a new resx file which uses the language/region code as a suffix, e.g Foo.de-DE.resx. This new file will contain the translations for that language/region. In the above example we are targetting German. Universal Windows Platform (UWP) considerations Unfortunately UWP does not support resx files any more. They have a new file called a resw. The format is similar but incompatible to resx. As a result, you will need to duplicate the data into a set of additional resw files to get the translation to work on UWP. The process is like the standard resx process. Upgrading your SpriteFont files By default, the SpriteFont processor uses a limited set of characters to generate the font. While this is fine for English languages it will probably not include special characters needed for other languages (French, Arabic, Korean etc). As a result MonoGame has a LocalizedFontProcessor which does something slightly different. The process looks at the resx files you provide it with and generates an optimized spritefont which only contains the characters your game uses. To make use of this functionality you need to tell the spritefont which resx files to use. Open the .spritefont with a xml/text editor and add lines like this inside the Asset node: <ResourceFiles> <Resx>..\\Foo.resx</Resx> <Resx>..\\Foo.de-DE.resx</Resx> </ResourceFiles> Note the paths are relative to the .spritefont directory. In the example above the resx files are in the directory above the .spritefont. You should end up with a .spritefont file like this <?xml version=\"1.0\" encoding=\"utf-8\"?> <XnaContent xmlns:Graphics=\"Microsoft.Xna.Framework.Content.Pipeline.Graphics\"> <Asset Type=\"Graphics:LocalizedFontDescription\"> <FontName>Verdana</FontName> <Size>14</Size> <Spacing>1</Spacing> <Style>Regular</Style> <CharacterRegions> <CharacterRegion> <Start>&#32;</Start> <End>&#32;</End> </CharacterRegion> </CharacterRegions> <ResourceFiles> <Resx>..\\Foo.resx</Resx> <Resx>..\\Foo.de-DE.resx</Resx> </ResourceFiles> </Asset> </XnaContent> Once that is done you then need to change the .mgcb file so that the SpriteFontProcessor is replaced with the LocalizedFontProcessor. This can be done by editing the .mgcb file or using the MGCB Editor. After that you can just compile your content as normal. If the processor has any trouble resolving or reading the resx files you will get an error. Loading the Font Loading the font can be done in the normal way. The end result of the process is an .xnb file containing a normal SpriteFont. var font = Content.Load<SpriteFont>(\"Foo\"); Other Localized assets Not all localized assets will be fonts. In certain situations you might need to swap out an entire textures or spritesheets. For these cases a new method has been added to the ContentManager, LoadLocalized. The idea behind this method is that it will look for localized files BEFORE loading the default one. So for example say you have an asset, MyCharacter. You have a MyCharacter.xnb file which contains the data for that item. You can also has a MyCharacter.de-DE.xnb file which contains the German version of that asset. This asset could be a Texture, Audio or any other game asset. You can then use LoadLocalized to load the localized version of the asset. var myCharacter = Content.LoadLocalized<Texture2D>(\"MyCharacter\"); The decision on which localized asset to load is made by looking for a file with the following patterns <AssetName>.<CurrentCulture.Name> <AssetName>.<CurrentCulture.TwoLetterISOLanguageName> These values are retrieved from CultureInfo.CurrentCulture.Name // eg. \"en-US\" CultureInfo.CurrentCulture.TwoLetterISOLanguageName // eg. \"en\" which are part of the System.Globalization namespace. On a side note you can also use the LoadLocalized to load language specific SpriteFonts. They just need to be named in the same way as we have described above."
  },
  "templates/docs.monogame.github.io/articles/getting_started/content_pipeline/using_mgcb_editor.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_started/content_pipeline/using_mgcb_editor.html",
    "title": "Using MGCB Editor | hallowed",
    "summary": "The MGCB Editor is used to organize and build content for use with MonoGame. It is accessed by either: Double-clicking a \".mgcb\" file from within the Visual Studio solution explorer (providing that you installed MonoGame's Visual Studio extension). Right-clicking a \".mgcb\" file from within the Visual Studio code and selecting \"Open in MGCB Editor\" (provided you have installed the VSCode extension) Alternatively, you can build it directly from source if needed. Create A Project To start a new project just select “New...” from the “File” menu. This will give you a new empty project to add content to. Importing an XNA (.contentproj) content project If you are starting from an existing XNA project, the MGCB Editor supports importing your existing .contentproj. Again you can access this from the “File” menu: This creates a new project, adding all your content and content settings from the XNA project. If you happened to be using custom processors, you may need to edit the assembly references to link to the correct paths which we discuss next. Project Settings You can edit the content project settings directly from the property grid editor after selecting the project node in the tree view: This is where you set up the folders for output, the platform to target, the assembly references for custom processors, etc. Note that currently, the MGCB Editor is not set up to support multiple target platforms. This means you may need to manage multiple content projects or manually change the target platform between builds. If you are using MonoGame.Content.Builder.Task to build content as part of building your project, the correct platform will automatically be targeted. Adding Content Items Once you have a project set up you can add content to it for building. You can do this from the “Edit” menu: Selecting “New Item...” will bring up the New Item dialog which displays a list of new items that can be created: When you select “Existing Item...”, you can select an existing item from disk to add to the content project. Built-in Content Importers and Processors MonoGame provides default Importers (File Read) and Processors (File Transform) methods for handling almost all standard content which is automatically selected for known content types. In most cases, you do not need to alter these settings when adding content. The lists below highlight the default configuration options for each file type. If you wish to create your own Importers and Processors for custom file types, please see the \"Custom Content Processors\" section. File Types The MonoGame Content Builder (MGCB) pipeline supports many different file types within a content project, along with several default processing options for those files: Images Images come in a variety of formats such as png or jpg, most of which are natively supported by the MonoGame content pipeline. Additionally, the following options are configurable per image asset when imported: Property Description ColorKeyColor Background color used for transparency ColorKeyEnabled If enabled, any colors identified using the Color Key will be marked as transparent (Alpha 0). The default value is false GenerateMipmaps If enabled, this will generate MipMaps for the selected texture. The default value is false MakeSquare if enabled this will make best efforts to expand the image to a square. The default value is false PremultiplyAlpha If enabled this will treat the selected texture as an Alpha Mask. The default value is false ResizeToPowerOfTwo If enabled this will resize the image dimensions to the next largest power of 2 size, e.g. 128x128 or 512x512. The default value is false TextureFormat Selected format of the Texture to process, e.g. raw Color, DXT. The default value is color Audio MonoGame supports several audio formats to cope with a wide variety of audio needs, from Wav files for effects to MP3's for songs/background music. The type of audio you use will depend on the audio needs for your project. Audio can be configured to use either the Sound Effect processor which imports audio as a <xref:Microsoft.Xna.Framework.Audio.SoundEffect> which is generally used for short and quick audio sounds. Alternatively, by selecting the Song processor, the audio will be imported as a Song which is used for long-running audio using the Media Player class. Property Description DebugMode Depending on the setting, this will either leave the audio uncompressed (for speed) when debugging or optimized for a production build. The default value is false Quality The quality of compression to be used when compiling the asset. The default value is best Models Property Description ColorKeyColor Background color used for transparency ColorKeyEnabled If enabled, any colors identified using the Color Key will be marked as transparent (Alpha 0). The default value is false DefaultEffect The default effect class to apply to this model. The default value is BasicEffect GenerateMipmaps If enabled, this will generate MipMaps for the selected texture. The default value is false GenerateTangentFrames Generate model tangents for use in Normal Mapping. The default value is false PremultiplyTextureAlpha If enabled this will treat the selected texture as an Alpha Mask. The default value is false PremultiplyVertexColors If enabled this will treat the selected texture as a Vertex Color Mask. The default value is false ResizeTexturesToPowerOfTwo If enabled this will resize the models texture(s) dimensions to the next largest power of 2 size, e.g. 128x128 or 512x512 RotationX Default model X Axis Rotation–Number, in degrees of rotation. The default value is 0 RotationY Default model Y Axis Rotation–Number, in degrees of rotation. The default value is 0 RotationZ Default model Z Axis Rotation–Number, in degrees of rotation. The default value is 0 Scale Default model scale. The default value is 1.0f SwapWindingOrder Boolean value indicating if the winding order is swapped. This is useful for models that appear to be drawn inside out. The default value is false. TextureFormat Selected format of the Texture to process, e.g. raw Color, DXT. The default value is compressed Fonts MonoGame uses a Font descriptor file to describe the type of font to import, the font in question needs to be installed in the machines Font library for it to enable the project to build, else this will result in a Font importer error. It is recommended you keep a copy of the Font file in the content folder for reference to avoid issues with missing Fonts, that way any developer on the project can re-add the Font to their machine when needed. Property Description PremultiplyAlpha If enabled this will treat the font texture that is generated as an Alpha Mask. The default value is false TextureFormat Selected format of the font Texture to process, e.g. raw Color, DXT. The default value is compressed See the TrueType fonts section for more detail on working with Fonts. Additionally, check out the Localization section for details on working with managing translated text within your project using resx files. Effects Effects in MonoGame are shaders that have been built with a supported shader language (HLSL / GLSL) which will then be pre-processed into a common shader language / effect used by MonoGame. Property Description DebugMode Depending on the setting, this will either leave the audio uncompressed (for speed) when debugging, or optimise for a production build. The default value is false Defines Custom compiler defines to enable specific code paths (#if) in the shader file, if appropriate. The default value is empty See the Effects section for more detail on the built-in effects with MonoGame and how to generate your own custom effects. Video MonoGame uses a custom video player which converts video files into a format that can be used and rendered by MonoGame using a series of VideoTextures. There are no configurable properties for the Video Player currently. Text (e.g. XML) One of the most powerful processors in MonoGame is the text processor, ideally used for XML files used to manage Game Class content in text files rather than writing it all in code. So long as the XML file conforms to the MonoGame (XNA) standard, it will generate data within the game for use in the solution. For an example on how to use XML in your MonoGame project, check out this article. Custom Content Processors Just like XNA, the MonoGame content pipeline supports custom content processors. To use them you need to rebuild them correctly to work against MonoGame. The first step is removing all Microsoft.Xna.Framework.XXX references and replacing them with references to MonoGame.Framework and MonoGame.Framework.Content.Pipeline. This is required as you will no longer be building against Microsoft XNA. Once your references are working, you then need to change your assembly target platform. MonoGame does not support x86 (aka 32bit) assemblies in the content pipeline. This is mainly to allow of processing really big content as well as to simplify the number of configurations and native code dependencies. For this reason, you should try to target “Any CPU” with your custom content assembly. After you have done these fixes, you should be able to add these new processors to the content project “References”. Building Content The MGCB Editor has 3 actions related to building content: Build, Rebuild and Clean: Build - This will build all content that needs to be built and put it in the output directory (bin by default). Content will be skipped if it has not changed since the last build. The time source content was last edited is saved in the intermediate directory (obj by default) to determine if content changed since the last build. Rebuild - Cleans the project first and then Builds it again. Clean - Cleaning the project will empty the output and intermediate directories. Linking Content To Your Game Once you have built your content, you have a few different ways to add it to your game project. They all have the same goal, to get the built XNB's in your project output folder so a <xref:Microsoft.Xna.Framework.Content.ContentManager> can easily find and load them. MonoGameContentReference The simplest method is to set up your game project from one of the templates that come with the SDK. When you create a new project, it will include a Content.mgcb file with its Build Action set to MonoGameContentReference and a reference to MonoGame.Content.Builder.Task which processes MonoGameContentReference items. This build action is defined in the .targets file here. The MonoGameContentReference is set up so that when the project is built, the MGCB will automatically build any new/modified content and copy the resulting XNB's to the project output directory, so they can be used in the project. This way you do not even have to manually build the content with the MGCB Editor. Just add your content to the .mgcb with the MGCB Editor and the rest will happen when you build your project. The content files do not need to be added to your project. Manual Copy If you do not want to use the automated process, you can build the content project with the MGCB Editor and copy the XNB's to the output folder of your project manually. Add As Content If you are using Visual Studio, you can bypass the content pipeline all together and simply the files to your C# game project directly (or as links). Create a folder in the project called Content then right-click on the folder and select Add > Existing Item. You will now see a file dialog from which you can add your content files. Note that if you do not want Visual Studio to make a local copy of the files. Make sure to use “Add As Link” when “Linking” files. Once the files are added you will need to select them all and change their properties in the properties window to: \"Build Action\" to Content \"Copy to Output Directory\" to Copy if newer Add With Wildcard The more automatic option is to edit your game .csproj manually and have it include you content automatically using wildcards. To do this just open the .csproj with any text editor, then add the following after any other **<ItemGroup>**: <ItemGroup> <Content Include=\"Content\\**\\*.xnb\"> <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory> </Content> </ItemGroup> Then any files you put in a Content folder within your game project will automatically be included in the build. Reporting Bugs If you run into any problems with MGCB or the MGCB Editor, please ask for help on the community site or submit a bug report on GitHub."
  },
  "templates/docs.monogame.github.io/articles/getting_started/content_pipeline/why_content_pipeline.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_started/content_pipeline/why_content_pipeline.html",
    "title": "Why use the Content Pipeline | hallowed",
    "summary": "The MonoGame team continues to put a lot of effort into a cross-platform content pipeline, but why would you use the Content Pipeline when MonoGame also supports loading assets natively, like .png, .mp3, .wav? Well, it all boils down to a couple of words, performance and efficiency. Textures Most image formats (like PNGs) are generally not optimized for games, most GPUs have specific hardware supported compressed formats for textures. PNGs or JPEGs just get uncompressed when passed to the GPU. By using the hardware compression you often get 4x to 8x more textures space for your game as well as faster load times and smaller packages. When we load the .png from storage at runtime, the texture is then loaded into memory and decompressed/unpacked from its compressed png format into raw bytes. Note that 262 KB is quite a bit bigger than the compressed size. A new texture is then created for that data because your device cannot decompress on the fly (yet) so it has to use that data as is. Creating the texture uses 262kb of graphics memory on the GPU. That does not sound too bad, but if you are using larger textures say 1024×1024, then you are using 4 MB or more of GPU memory for that one texture. Multiply that over the number of textures in your game and you soon run out of texture memory on the GPU. If this happens then the GPU has to swap that data out into system memory (if it supports that) or throw an error when you try to create textures that will not fit into available memory. So to sum up: using .pngs = smaller package size & higher memory usage & less textures If you pre-process the texture using the content pipeline, because we know that we are targeting iOS and we know the GPU on those devices support using PVRTC texture compression, we can compress the textures ready for the GPU to use. So we take our sample .png and compress it at build time using PVRTC and we end up with a 32kb file (size depends on the texture, alpha channel, etc). Hmm, that is a lot bigger than the .png on disk, but that is not the whole story. The difference here is that there is no need to unpack/decompress it at runtime which saves on load time, also, we can create a texture from that data directly so we only use 32kb of texture memory on the GPU and not 262kb. That is a massive saving. Summing up: compressed textures = larger package size (maybe) & lower runtime memory usage & more textures This applies to all platforms as most desktop GPUs support DXT texture compression, so the content pipeline will produce DXT compressed textures which can be loaded and used directly. The Android platform currently does not have consistent support for compressed textures at the moment so MonoGame has to decompress DXT textures on the device and use it directly, when this changes MonoGame will adapt. In the Content Pipeline tool, MonoGame will automatically pick the correct texture format to use, so for opaque textures, it will use ETC1 (which is supported on all android devices but does not support alpha channels) but for textures with an alpha channel, it will use RGBA4444 (dithered). It will also allow the user to override this default and enable picking from a wide variety of compression options manually such as PVRTC, ATITC, DXT/S3TC, ETC1, and RGBA4444. This will give the developer the choice of what to use/support. Audio All platforms support different audio formats, if you are handling this yourself you will need to manually convert all your files and include the right formats for each platform. A better option would be to keep one source file (be it .mp3, .wmv, etc) and then convert it to a supported format for the target platform at build time. This creates longer build times, but at least we know the music will work. MonoGame uses ffmpeg to do the heavy lifting when converting between formats as it can pretty much convert any type to any other type which is really cool. The build times are only for the first time the asset is processed, the Content Pipeline will preserve the generated content for subsequent builds until the source is changed Most platforms have audio processing that is optimized to certain compressed formats. By not using them you loose performance and system memory. If you save the sound effects as ADPCM, these run pretty optimally on Windows systems. The problem however, is that once you try to take your game to another platform where ADPCM is not optimal. You will need to manually re-export all your game content into the new optimal format for that platform (assuming you kept all your original content uncompressed). Shaders There are a number of shading languages that you can use depending on the platform you are targeting: For OpenGL based systems that is GLSL For DirectX based systems it is HLSL There is also CG from Nvidia. The Effect system in XNA/MonoGame was designed around the HLSL language as it is based around the .fx format, which allows a developer to write both vertex and pixel shaders in one place. Historically both GLSL and HLSL have separate vertex and pixel shaders. HLSL until recently compiled and linked these at build time, however, GLSL does this at runtime. Without a content pipeline or some form of tooling a developer would need to write two shaders, one for HLSL and one for GLSL. The good news is the MonoGame MGFX.exe tool can create a shader in .fx format and also enable it to work in GLSL. It does this by using an open-source library called libmojoshader, which does some funky HLSL to GLSL instruction conversion to create an OpenGL-based shader, but rather than doing that at runtime, we do it at build time so we do not need to deploy mojoshader with the OpenGL based games. All this saves you the hassle of having to write and maintain two shaders. From MonoGame 3.8, the MGFX tool can build content on any platform. For MonoGame 3.7 or earlier, MGFX only runs on a windows box, this is because it needs the DirectX shader tooling to compile the HLSL before passing it to libmojoshader for conversion (for OpenGL platform targets). Models MonoGame, thanks to the excellent assimp project, supports a much wider range of models including .x, .fbx and .3ds. However, some of these formats might produce some weirdness at render time as only .fbx has been fully tested. Also note that assimp does not support the older version .fbx format which ships with most of the original XNA samples, so you will need to convert those to the new format manually. A nice trick to upgrade the old .fbx is to open them in Visual Studio 2012+ and then save it again under a new name. This article walks through some of the quick, easy, and FREE methods for updating older .fbx files. When the MonoGame content pipeline processes a Model file, it is converted into an optimized internal format that will contain the Vertices, Texture Coordinates, and Normals. The pipeline will also pull out the textures used in the model and put those through the pipeline too, so you get optimized textures automatically. Summary This is why using the content pipeline and XNB's is superior. You feed uncompressed source content to the MonoGame content pipeline, tell it what platform you are building for and it takes care of converting it to the most optimal format for that platform. When you decide to ship to another platform it is a one-click change to rebuild your content optimized for that platform. Hopefully, you have a good idea of why you should use the content pipeline in your games. Using the raw assets is ok when you are putting together a simple demo or proof of concept but sooner or later you will need to start optimizing your content. My advice would be to use the Pipeline tooling from the outset so you get used to it. Information on the Pipeline tool can be found here."
  },
  "templates/docs.monogame.github.io/articles/getting_started/index.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_started/index.html",
    "title": "Getting Started | hallowed",
    "summary": "First, select the operating system and toolset you will be working with to create your first MonoGame project, then continue reading to understand the basic layout of a MonoGame project. Supported platforms MonoGame supports the following platforms by default: Windows macOS Linux iOS iPadOS Android Xbox* PlayStation 4* PlayStation 5* Nintendo Switch* Important Platforms marked with a \"\"* require developer access from their host vendor platforms. See Supported Platforms for more information. Setting up and creating your first MonoGame Project By the end of this tutorial set, you will have a working project to build for your target platform and will be ready to tackle your next steps. 1. Setting up your OS for development Windows macOS Ubuntu 2. Choosing your IDE for development Visual Studio for Windows VS Code Rider 3. Building your game Understanding the Code Adding Content Adding Basic Code 4. Packaging Games Packaging Games for Distribution 5. Advanced Topics Preparing for Consoles Using Development Nuget Packages"
  },
  "templates/docs.monogame.github.io/articles/getting_started/packaging_games.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_started/packaging_games.html",
    "title": "Package games for distribution | hallowed",
    "summary": "Desktop games To publish desktop games, it is recommended that you build your project as a self-contained .NET application. As such, your game will require absolutely no external dependencies and should run out-of-the-box as-is. Building and packaging Windows macOS Ubuntu From the .NET CLI: dotnet publish -c Release -r win-x64 -p:PublishReadyToRun=false -p:TieredCompilation=false --self-contained You can then zip the content of the publish folder and distribute the archive as-is. If you are targeting WindowsDX, note that players will need the DirectX June 2010 runtime to be installed on their machine for audio and gamepads to work properly. We recommend that you distribute your game as an application bundle. Application bundles are directories with the following file structure: YourGame.app (this is your root folder) - Contents - Resources - Content (this is where all your content and XNB's should go) - YourGame.icns (this is your app icon, in ICNS format) - MacOS - YourGame (the main executable for your game) - Info.plist (the metadata of your app, see below for contents) So first lets create our directory structure. mkdir -p bin/Release/YourGame.app/Contents/MacOS/ mkdir -p bin/Release/YourGame.app/Contents/Resources/Content Next we need to publish our application for both arm64 (Apple Silicon) and x64 (Intel). From the .NET CLI: dotnet publish -c Release -r osx-x64 -p:PublishReadyToRun=false -p:TieredCompilation=false --self-contained dotnet publish -c Release -r osx-arm64 -p:PublishReadyToRun=false -p:TieredCompilation=false --self-contained Next we need to combine the two binaries into one Universal Binary which will work on both arm64 and x64 machines. We can do this using the xcode utility lipo. lipo -create bin/Release/net8.0/osx-arm64/publish/YourGame bin/Release/net8.0/osx-x64/publish/YourGame -output bin/Release/YourGame.app/Contents/MacOS/YourGame The above command will combine the two output executables into one. It assumes you are using the standard Output path for your application. If you are using a custom Output folder, you will need to make adjustments to the above command. Copy over your content cp -R bin/Release/net8.0/Content bin/Release/YourGame.app/Contents/Resources/Content The Info.plist file is a standard macOS file containing metadata about your game. Here is an example file with required and recommended values set: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"> <plist version=\"1.0\"> <dict> <key>CFBundleDevelopmentRegion</key> <string>en</string> <key>CFBundleExecutable</key> <string>YourGame</string> <key>CFBundleIconFile</key> <string>YourGame</string> <key>CFBundleIdentifier</key> <string>com.your-domain.YourGame</string> <key>CFBundleInfoDictionaryVersion</key> <string>6.0</string> <key>CFBundleName</key> <string>YourGame</string> <key>CFBundlePackageType</key> <string>APPL</string> <key>CFBundleShortVersionString</key> <string>1.0</string> <key>CFBundleSignature</key> <string>FONV</string> <key>CFBundleVersion</key> <string>1</string> <key>LSApplicationCategoryType</key> <string>public.app-category.games</string> <key>LSMinimumSystemVersion</key> <string>10.15</string> <key>NSHumanReadableCopyright</key> <string>Copyright © 2022</string> <key>NSPrincipalClass</key> <string>NSApplication</string> <key>LSRequiresNativeExecution</key> <true/> <key>LSArchitecturePriority</key> <array> <string>arm64</string> </array> </dict> </plist> Note For more information about Info.plist files, see the Apple documentation. After completing these steps, your .app folder should appear as an executable application on macOS. However it does need an icon. So we need to create an .icns file. We can use online tools to do this or you can use the following: mkdir -p bin/Release/YourGame.iconset sips -z 16 16 Icon.png --out bin/Release/YourGame.iconset/icon_16x16.png sips -z 32 32 Icon.png --out bin/Release/YourGame.iconset/icon_16x16@2x.png sips -z 32 32 Icon.png --out bin/Release/YourGame.iconset/icon_32x32.png sips -z 64 64 Icon.png --out bin/Release/YourGame.iconset/icon_32x32@2x.png sips -z 128 128 Icon.png --out bin/Release/YourGame.iconset/icon_128x128.png sips -z 256 256 Icon.png --out bin/Release/YourGame.iconset/icon_128x128@2x.png sips -z 256 256 Icon.png --out bin/Release/YourGame.iconset/icon_256x256.png sips -z 512 512 Icon.png --out bin/Release/YourGame.iconset/icon_256x256@2x.png sips -z 512 512 Icon.png --out bin/Release/YourGame.iconset/icon_512x512.png sips -z 1024 1024 Icon.png bin/Release/YourGame.iconset/icon_512x512@2x.png iconutil -c icns bin/Release/YourGame.iconset --output bin/Release/YourGame.app/Contents/Resources/YourGame.icns Note This code is expecting an Icon.png file to be in the same directory. This file should be 1024 x 1024 pixels. For archiving, we recommend using the .tar.gz format to preserve the execution permissions (you will likely run into permission issues if you use .zip at any point). From the .NET CLI: dotnet publish -c Release -r linux-x64 -p:PublishReadyToRun=false -p:TieredCompilation=false --self-contained You can then archive the content of the publish folder and distribute the archive as-is. We recommend using the .tar.gz archiving format to preserve the execution permissions. Special notes about .NET parameters .NET proposes several parameters when publishing apps that may sound helpful, but have many issues when it comes to games (because they were never meant for games in the first place, but for small lightweight applications). PublishAot and PublishTrimmed Important The WindowsDX target is not compatible with PublishAot or PublishTrimmed because it uses Windows Forms, which is (as of .NET 9) not compatible with these options. If you need trimming or AOT compilation for desktop platforms, please consider using the DesktopGL target instead of WindowsDX. The PublishAot option optimises your game code \"Ahead of Time\" for performance. It allows you to ship your game without the need to JIT (Just In Time compile), and will basically natively compile your game. PublishAot binaries are much faster, which is typically desired for games. It however comes with limitations, like the inability to use runtime reflection and runtime code generation (IL emition). PublishAot makes use of PublishTrimmed, which is another option that strip binaries of unused code to make much lighter executables and assemblies. Trimming can be aggressive and might remove types if the compiler can't detect if they are used (e.g. if you are using reflection or generics). MonoGame is mostly compatible with PublishAot and PublishTrimmed, and will just work in most cases. It may however crash at runtime if you are using custom content importers that use generic collections. If you are using PublishAot and you are running into runtime exceptions occuring when loading content saying that a type is missing, the solution is to call ContentTypeReaderManager.AddTypeCreator() on that type before trying to load your content. This will tell the AOT compiler to include that type. Besides MonoGame itself, it may happen that the third party libraries that you are using are not compatible with AOT or trimming. In that case, you should refer to those libraries maintainers for workarounds, or replace them with compatible libraries. Overall, AOT and trimming have similar limitations you need to watchout for: Using XmlSerializer in your game will probably cause issues. Since it uses reflection it will be difficult for the Trimmer to figure out what needs to be kept. It is recommended that, instead of using the Deserialize method, you write your own custom deserializer using XDocument or XmlReader. Alternatively you can use the Content Pipeline and create a custom Processor and Reader to convert the Xml into a binary format that can be loaded via the usual Content.Load<T> method. Dynamically loading assemblies via Assembly.LoadFile. No run-time code generation, for example, System.Reflection.Emit. You can also refer to the Preparing for consoles documentation, which leverage AOT and has the same limitations. If your game runs with PublishAot, you'll be well ahead into porting your game to consoles. For more information, please see Native AOT deployment and Trim self-contained deployments. ReadyToRun (R2R) ReadyToRun is advertised as improving application startup time, but slightly increasing binary size. We recommend not using it for games because it produces micro stutters when your game is running. ReadyToRun code is of low quality and makes the Just-In-Time compiler (JIT) trigger regularly to promote the code to a higher quality. Whenever the JIT runs, it produces potentially very visible stutters. Disabling ReadyToRun solves this issue (at the cost of a slightly longer startup time, but typically very negligible). ReadyToRun is disabled by default. You can configure it by setting the PublishReadyToRun property in your .csproj file. MonoGame templates for .NET projects explicitly set this to false. Tiered compilation Tiered compilation is a companion system to ReadyToRun and works on the same principle to enhance startup time. We suggest disabling it to avoid any stutter while your game is running. Tiered compilation is enabled by default. To disable it, set the TieredCompilation property to false in your .csproj. MonoGame templates for .NET projects explicitly set this to false. PublishSingleFile PublishSingleFile packages your game into a single executable file with all dependencies and content integrated. While it sounds very convenient, be aware that it's not magical and is in fact a hidden self-extracting zip archive. As such, it may make app startup take a lot longer if your game is large, and may fail to launch on systems where user permissions don't allow extracting files (or if there is not enough storage space available). We highly recommend not using it for better compatibility across systems. If you need to reduce the footprint of your game, please refer to PublishAot and PublishTrimmed instead. Mobile games Please refer to the Xamarin documentation: Android iOS"
  },
  "templates/docs.monogame.github.io/articles/getting_started/platforms.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_started/platforms.html",
    "title": "Supported Platforms | hallowed",
    "summary": "MonoGame supports building games for the following systems: Desktop PCs Mobiles Gaming consoles* Windows macOS Linux iOS iPadOS Android Xbox PlayStation 4 PlayStation 5 Nintendo Switch Important *Gaming consoles are restricted to registered developers and are not publicly available nor publicly documented. To get access to those platforms, please contact your console account manager(s). MonoGame documentation for closed platforms is available in their respective repositories. Understanding MonoGame's platform types There are different implementations of MonoGame that we call target platforms (or just platforms). The platforms mostly correspond to the systems MonoGame supports but some platforms support multiple systems. For instance, the DesktopGL platform can be used to build games that will run either on Windows, macOS, or Linux with the same base code and project. Each platform comes with its own project template that you can choose when starting a project. Below is a list of public platforms with their corresponding NuGet package, the dotnet new template identifier, and an explanation of the platform. WindowsDX DesktopGL Android iOS Beside these target platforms, MonoGame provides additional templates for shared game logic and extensions to the MonoGame Content Pipeline that can be used across all platforms. Understanding MonoGame's platform types Platform details WindowsDX DesktopGL Android iOS Other templates .NET Class Library Shared Project Content Pipeline Extension Platform details WindowsDX Supported Systems NuGet Package Template ID Windows MonoGame.Framework.WindowsDX mgwindowsdx WindowsDX uses WinForms to manage the game window, DirectX (9.0c or newer) is used for graphics, and XAudio is used for audio. Note DX 12 for Windows and Xbox coming very soon. You can target Windows* 8.1 and up with this platform. WindowsDX requires the DirectX June 2010 runtime to both build and run games. Make sure that your players have it installed (otherwise you might be missing sound and gamepad rumble support). DesktopGL Supported Systems NuGet Package Template ID Windows, macOS, Linux MonoGame.Framework.DesktopGL mgdesktopgl DesktopGL uses SDL for windowing, OpenGL for graphics, and OpenAL-Soft for audio. DesktopGL supports Windows (8.1 and up), macOS (Catalina 10.15 and up) and Linux (64bit-only). DesktopGL requires at least OpenGL 2.0 with the ARB_framebuffer_object extension (or alternatively at least OpenGL 3.0). DesktopGL is a convenient way to publish builds for Windows, macOS, and Linux from a single project and source code. It also allows to cross-compile any build from any of these operating systems (e.g. you can build a Linux game from Windows). You can target Windows 8.1 (and up), macOS Catalina 10.15 (and up), and Linux with this platform. DesktopGL currently does not have a VideoPlayer implementation. Note New native platform with upgraded libraries and Metal/Vulkan support coming very soon. Android Supported Systems NuGet Package Template ID Android MonoGame.Framework.Android mgandroid The Android platform uses Xamarin.Android. OpenGL is used for graphics, and OpenAL for audio. Building for Android requires the .NET Xamarin component to be installed. You can install it with the Visual Studio installer (if you are using Visual Studio) or with the CLI command dotnet workload install android (if you are working with Rider, VS Code, or the CLI). Building for Android also requires the Java 11 JDK (we recommend that you use the Microsoft's distribution) as well as the Android SDK 31. Note New native platform with upgraded libraries and Metal/Vulkan support coming very soon. iOS Supported Systems NuGet Package Template ID iOS, iPadOS MonoGame.Framework.iOS mgios The iOS platform uses Xamarin.iOS. OpenGL is used for graphics, and OpenAL for audio. Building for iOS requires the .NET Xamarin component to be installed. You can install it with the Visual Studio installer (if you are using Visual Studio) or with the CLI command dotnet workload install ios (if you are working with Rider, VS Code, or the CLI). The latest version of Xcode will also be required. You can test and deploy an iOS game on Windows by pairing your Visual Studio 2022 with a mac on your local network. This feature is not available for Rider, Visual Studio Code, or the CLI. Note New native platform with upgraded libraries and Metal/Vulkan support coming very soon. Other templates .NET Class Library Template ID: mglib A project template to create .NET libraries to distribute code through a DLL. This can be used to redistribute libraries or to share code between multiple projects (like different platforms). Note See the MonoGame Samples for examples of how a .NET class library is used to share code between platforms. Shared Project Template ID: mgshared A project template to create a shared project which can be used to share code between multiple other projects. The difference with .NET Standard libraries is that shared projects do not produce an intermediate DLL and the code is directly shared and built into the other projects it reference. Content Pipeline Extension Template ID: mgpipeline A project template for writing custom logic for handling content and building it into XNB files. Note See What Is the Content Pipeline? for more infomation and read about What is a Custom Importer here."
  },
  "templates/docs.monogame.github.io/articles/getting_started/preparing_for_consoles.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_started/preparing_for_consoles.html",
    "title": "Preparing for consoles | hallowed",
    "summary": "MonoGame for gaming consoles uses a dedicated .NET runtime that is not maintained by Microsoft. Therefore, a 100% accuracy and reliability is not guaranteed. Moreover, the console runtime makes use of ahead-of-time native compilation (AOT), which means that some .NET features will not, and cannot work on consoles. This article explains the most common pitfalls and suggested guidelines to optimize your chances of having a smoother porting experience. Note Gaming consoles are restricted to registered developers and are not publicly available nor publicly documented. To get access to those platforms, please contact your console account manager(s). MonoGame documentation for closed platforms is available in their respective repositories. No use of runtime reflection The main show stopper when it comes to porting a .NET game to consoles, is the use of runtime reflection. Reflection is, at large, unsupported in an AOT context. Which means that anywhere you or a third party library uses reflection, your game will crash. In order to make sure that your game abides to that rule, you can try to publish an AOT'd version of it for desktop computers and verify how it fares. To publish with AOT: Add <PublishAot>true</PublishAot> to your .csproj. Then run dotnet publish from the command-line/terminal. This will natively compile your game in a fashion similar to consoles. The output executable will be in your output folder, within a sub-folder named publish. From there, you can try running this executable. If it does not start or crashes later on, you likely are using reflection or another unsupported feature in a AOT runtime. Native executables can debugged by: Starting an empty Visual Studio with no code. Opening the compiled exe. Then hitting \"Start debugging\". It should show you on which C# lines it crashed. It is important to note that you should test every aspect of your game, and not just if it starts. Run through all the menus/screens, scene transitions and gameplay. Another way to make sure that everything is safe is to enable <EnableTrimAnalyzer>true</EnableTrimAnalyzer> in your .csproj, and then rebuild (not just build) your game and check the build output for AOT warnings. Those warnings will tell you which parts of your code might trigger crashes or unexpected results when running on AOT compilation. You should seek to resolve all of them. No runtime compilation / IL emit Generating code at runtime is a scenario that is also not supported in AOT contexts, it is also forbidden by console manufacturers. Like reflection, trying to make a PublishAot build is a good way to verify that your game is compliant because any use of IL emit will crash. No use of dynamic assembly loading Loading assemblies at runtime with Assembly.Load() is not supported. Third party libraries Many third party libraries heavily rely on using reflection or IL emit, this is a common practice for JSON or XML parsers for example (and they are the most common source of third party incompatibilities). It is advised to choose very carefully the libraries that you are using when porting to consoles. If you do not select them with this in mind, you might run into a situation in which you will have to rewrite entire chunks of data handling. The best way to make sure if they will work, is to search if they are \"AOT-compatible\", or try to compile with the <EnableTrimAnalyzer>true</EnableTrimAnalyzer> setting in your .csproj and check if there are any warnings related to those libraries. For example, here are some parsing libraries known for their compliance with AOT compilation and good handling of memory: TurboXML TinyJSON On the contrary, Newtonsoft JSON is known to be unsupported (there are modified forks around, but we overall recommend to not use it for games). Native libraries If you are using native libraries, make sure that they provide builds for consoles, or make sure that you can compile and run them on consoles yourself. Even though a library might be open-source, it is unlikely they will just compile and run on consoles. It is suggested to only use native libraries that have been proven to run on consoles. LINQ While LINQ mostly works on consoles, it should be noted that due to AOT compilation, LINQ queries can not be optimized and performance can be very slow. Moreover, LINQ is very garbage-prone and if your game has stuttering issues you might want to reduce your usage of LINQ. Avoiding garbage generation Even though your game has good performance on PC and does not show stutters, you might want to be very cautious about how your game handles memory. The garbage collector is slower on consoles and if your game generates a lot of garbage memory, there will be visible stutters. To verify that your game is not too garbage-prone, you can run Visual Studio's Performance Profiler (Debug/Performance Profiler...) and check the \".NET Object Allocation Tracking\" tool. From there, you can check which parts of your code generate garbage and you can pinpoint where to optimize. In order to avoid garbage, here are some best practices: Only use strings as const. Do not use strings dynamically (e.g. string concatenation, patterns...), this is the most common source of garbage. Avoid allocating anything with the new keyword during your game loop, e.g. pre-allocate everything ahead of using them during gameplay. Pool your dynamic objects, e.g. do not destroy your projectiles or particles, instead place them into another \"unused\" list and reuse them instead of creating new instances when needed. Avoid using LINQ. If you are using collections, initialize them with a large enough capacity to avoid their internal data structure being silently recreated. Mind your foreach loops, depending on the data you are looping on, the loop might create garbage when duplicating an item. Or better yet, use a for loop for tigher control. Do not rely on system calls If your game calls directly to system functions, like kernel, win32 or Unix commands, you might want to get rid of them. Consider I/O to be asynchronous Saving player data/settings, or unlocking achievements are operations that should be considered asynchronous. Most, if not all consoles, consider system accesses to be asynchronous. Even though it is not on PC, you should prepare your game to handle asynchronous operation (e.g. consider saving game data in a thread which will not block the game). If you consider all your I/O and system operations as asynchronous, you will likely be spared some headache. Suggestions If you have other tips or suggestions when building for consoles, then let the MonoGame team know by raising an issue and we will improve this article even further over time."
  },
  "templates/docs.monogame.github.io/articles/getting_started/tools/index.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_started/tools/index.html",
    "title": "Tools | hallowed",
    "summary": "MonoGame distributes tooling to help manage and build content for your game. These tools are available as .NET Tools and are automatically installed if you are using the MonoGame templates. Usage instructions are on the following pages: MonoGame Content Builder (MGCB): used to build content pipeline content. MGCB Editor: The MonoGame Content Builder (MGCB) Editor is a graphical front end to edit mgcb files. MonoGame Effect Compiler (MGFXC): used to compile stand alone effects (shaders)."
  },
  "templates/docs.monogame.github.io/articles/getting_started/tools/mgcb.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_started/tools/mgcb.html",
    "title": "MonoGame Content Builder (MGCB) | hallowed",
    "summary": "The MonoGame Content Builder is a command line tool for building XNB content on Windows, Mac, and Linux desktop systems. Typically, it is executed by the MGCB Editor when editing content or by MonoGame.Content.Builder.Task during the build process of a MonoGame project. Alternatively you can use it yourself from the command line for specialized build pipelines or for debugging content processing. Installation MGCB can be installed as a .NET tool. Make sure you have the .NET SDK installed. You can download it here. In a terminal run dotnet tool install -g dotnet-mgcb to install MGCB. Then you can execute MGCB by simply running mgcb. Command Line Options The options are processed “left to right”. When an option is repeated, it is overwritten. Output Directory /outputDir:<directory_path> Specifies the directory where all content is written. Defaults to the current working directory. Intermediate Directory /intermediateDir:<directory_path> Specifies the directory where all intermediate files are written. Defaults to the current working directory. Rebuild Content /rebuild Force a full rebuild of all content. Clean Content /clean Delete all previously built content and intermediate files. Only the /intermediateDir and /outputDir need to be defined for clean to do its job. Incremental Build /incremental Only build content that changed since the last build. Assembly Reference /reference:<assembly_path> An optional parameter which adds an assembly reference which contains importers, processors, or writers needed during content building. Target Platform /platform:<target_Platform> Set the target platform for this build. It must be a member of the <xref:Microsoft.Xna.Framework.Content.Pipeline.TargetPlatform> enum: Windows iOS Android DesktopGL WindowsStoreApp PlayStation4 PlayStation5 XboxOne Switch If not set, it will default to Windows. NOTE: PlayStation 4, PlayStation 5, Xbox One, and Switch support is only available to licensed console developers. Target Graphics Profile /profile:<graphics_Profile> Set the target graphics profile for this build. It must be a member of the <xref:Microsoft.Xna.Framework.Graphics.GraphicsProfile> enum: HiDef Reach If not set, it will default to HiDef. Target Build Configuration /config:<build_config> The optional build configuration name from the build system. This is sometimes used as a hint in content processors. Content Compression /compress Uses LZ4 compression to compress the contents of the XNB files. Content build times will increase with this option enabled. Compression is not recommended for Android as the app package is already compressed. This is not compatible with LZX compression used in XNA content. Content Importer Name /importer:<class_name> An optional parameter which defines the class name of the content importer for reading source content. If the option is omitted or used without a class name the default content importer for the source type is used. Content Processor Name /processor:<class_name> An optional parameter which defines the class name of the content processor for processing imported content. If the option is omitted used without a class name the default content processor for the imported content is used. Note that when you change the processor all previously defined /processorParam are cleared. Content Processor Parameter /processorParam:<name>=<value> An optional parameter which defines a parameter name and value to set on a content processor. Note all defined processor parameters are cleared when the /processor is set. Build Content File /build:<content_filepath> /build:<content_filepath>;<destination_filepath> Instructs the content builder to build the specified content file using the previously set switches and options. Optional destination path may be specified if you want to change the output file path. Launch Debugger /launchdebugger Allows a debugger to attach to the MGCB executable before content is built. Response File /@:<response_filepath> This defines a text response file (sometimes called a command file) that contains the same options and switches you would normally find on the command line. Each switch is specified on a new line. Comment lines are prefixed with #. These lines are ignored. You can specify multiple response files or mix normal command line switches with response files. An example response file could look like this: # Directories /outputDir:bin/foo /intermediateDir:obj/foo /rebuild # Build a texture /importer:TextureImporter /processor:TextureProcessor /processorParam:ColorKeyEnabled=false /build:Textures\\wood.png /build:Textures\\metal.png /build:Textures\\plastic.png Preprocessor Macros Response files support preprocessor macros to allow conditionals within a response file. $if <name>=<value> $endif Preprocessor symbols can be defined from the command line with the define option or in a response file with the $set directive. <example command line> MGCB.exe /define:BuildEffects=No /@:example.mgcb <example.mgcb file> $if BuildEffects=Yes /importer:EffectImporter /processor:EffectProcessor /build:Effects\\custom.fx # all other effects here.... $endif $set BuildEffects=Yes $if BuildEffects=Yes # ... # This is executed $endif For booleans you can omit a value to set a symbol and to check if it is set: $set BuildEffects $if BuildEffects # ... # This is executed $endif Customizing your Build Process When building content from your project with MonoGame.Content.Builder.Task, there are a few ways to hook into the build process. MonoGame.Content.Builder.Task runs a target called RunContentBuilder just before your project builds. If you want to do any processing before or after this process you can use the BeforeTargets and AfterTargets mechanism provided by msbuild to run your own targets. <Target Name=\"MyBeforeTarget\" BeforeTargets=\"RunContentBuilder\"> <Message Text=\"MyBeforeTarget Ran\"/> </Target> <Target Name=\"MyAfterTarget\" AfterTargets=\"RunContentBuilder\"> <Message Text=\"MyAfterTarget Ran\"/> </Target> If you want to customize the arguments sent to the MGCB.exe as part of the build process you can use the <MonoGameMGCBAdditionalArguments> property to define those. For example to pass in the current project configuration you could include the following code in a PropertyGroup in your .csproj file. <MonoGameMGCBAdditionalArguments>-config:$(Configuration)</MonoGameMGCBAdditionalArguments>"
  },
  "templates/docs.monogame.github.io/articles/getting_started/tools/mgcb_editor.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_started/tools/mgcb_editor.html",
    "title": "MGCB Editor | hallowed",
    "summary": "The MGCB Editor has the following features: Create, open, and save MGCB projects. Import existing XNA .contentproj. Tree view showing content of project. Property grid for editing content settings. Full undo/redo support. Build, rebuild, and clean the project. Rebuild selected items. Create new content like fonts and xml. Support for custom importers/processors/writers. Template format for adding new custom content types. Installation Instructions The MGCB Editor is automatically installed (if you are using MonoGame's templates) and accessible by double-clicking an .mgcb file from Visual Studio 2022 if you have the extension installed, or right-clicking and selecting \"Open in MGCB editor\" in VSCode if you have the MonoGame Content Builder (editor) extension installed. Alternatively, you can open the MGCB Editor from the .NET command line. This will only work if you are using the MonoGame templates and executing the command from the root directory of your project: dotnet mgcb-editor Note You will need to buid the project at least once in order for the .NET system to download and register the tool with your project utilizing the dotnet-tools.json configuration file located in the .config folder, or use the dotnet tool restore command shown below. dotnet tool restore See Using MGCB Editor for more information."
  },
  "templates/docs.monogame.github.io/articles/getting_started/tools/mgfxc.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_started/tools/mgfxc.html",
    "title": "MonoGame Effects Compiler (MGFXC) | hallowed",
    "summary": "The MGFXC tool is used to compile DirectX Effect files (shaders) for usage with MonoGame. It will compile shaders into mgfxo files ready to be consumed by the Effect class. The MGCB Editor uses MGFXC to compile effects and wrap them into an xnb file, so they can be loaded using the ContentManager. If you compile effects directly with MGFXC you can load effects using the Microsoft.Framework.Xna.Graphics.Effect constructor that takes a byte array with the effect code. Effects compiled directly are not content files and can not be loaded by the ContentManager. Installation MGFXC can be installed as a .NET tool. Make sure you have the .NET SDK installed. You can download it here. In a terminal run dotnet tool install -g dotnet-mgfxc to install MGFXC. Command Line The command line options are: mgfxc <SourceFile> <OutputFile> [/Debug] [/Profile:<DirectX_11,OpenGL,PlayStation4>] Source File The input effect file in typical FX format with samplers, techniques, and passes defined. This parameter is required. Output File The path to write the compiled effect to. This parameter is required. NOTE: The generated file is not an XNB file for use with the ContentManager. If the /Debug flag is passed the resulting compiled effect file will contain extra debug information and the fewest possible optimizations. Platform Profile The /Profile option defines the platform we're targeting with this effect file. It can be one of the following: DirectX_11 OpenGL PlayStation4 XboxOne Switch NOTE: PlayStation 4, Xbox One, and Switch support is only available to licensed console developers. Help If you use /?, /help, or simply pass no parameters to MGFXC you will get information about these command-line options. Runtime Use The resulting compiled effect file can be used from your game code like so: byte[] bytecode = File.ReadAllBytes(\"mycompiled.mgfx\"); var effect = new Effect(graphicsDevice, bytecode); This is how the stock effects (BasicEffect, DualTextureEffect, etc) are compiled and loaded."
  },
  "templates/docs.monogame.github.io/articles/getting_started/using_development_nuget_packages.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_started/using_development_nuget_packages.html",
    "title": "Using the Development Nuget Packages | hallowed",
    "summary": "Overview When the MonoGame develop branch builds, it publishes development NuGet packages to the MonoGame NuGet Feed on GitHub. If you want to test a new feature or just be on the very latest code you can use this Feed to do that. Tip Alternatively, consider using the Preview Packages provided by MonoGame to get access to the latest preview release rather than the raw development code. How to install MonoGame Preview packages Adding a NuGet Source Create a NuGet.config in the root or top level directory of your project. Note NuGet will automatically walk up the directory tree to find NuGet.config files. Add the following content: <?xml version=\"1.0\" encoding=\"utf-8\"?> <configuration> <packageSources> <add key=\"MonoGameGitHub\" value=\"https://nuget.pkg.github.com/MonoGame/index.json\" /> </packageSources> </configuration> Next (in the root or top level directory), create a Directory.Build.props file and add the following content. <Project> <PropertyGroup> <MonoGamePackageVersion>1.0.0.1233-develop</MonoGamePackageVersion> </PropertyGroup> </Project> Directory.Build.props is an MSBuild file which will be imported by all projects in your game. It is like a file that contains global variables. In this case the version of MonoGame we want to use. Note To find out the latest version number, you can look at one of the packages at https://github.com/orgs/MonoGame/packages?repo_name=MonoGame. Or to get the information from the GitHub feed, you can run the following command. nuget search \"MonoGame.Framework\" -PreRelease -Source MonoGameGitHub This will give you the following output ==================== Source: MonoGameGitHub -------------------- > MonoGame.Framework.Android | 1.0.0.1278-develop | Downloads: 164 The MonoGame runtime for Android. -------------------- > MonoGame.Framework.Content.Pipeline | 1.0.0.1278-develop | Downloads: 69 The Monogame Content Pipeline for Windows, Mac and Linux is used to compile raw content to xnb files... -------------------- > MonoGame.Framework.DesktopGL | 1.0.0.1278-develop | Downloads: 337 The MonoGame runtime supporting Windows, Linux and macOS using SDL2 and OpenGL. -------------------- > MonoGame.Framework.Native | 1.0.0.1278-develop | Downloads: 1 The MonoGame Native platform. -------------------- > MonoGame.Framework.WindowsDX | 1.0.0.1278-develop | Downloads: 76 The MonoGame runtime for Windows using DirectX API's. -------------------- > MonoGame.Framework.WindowsUniversal | 3.8.1.1128-develop | Downloads: 54 The MonoGame runtime for UWP (Universal Windows Platform) which supports Windows 10 and Xbox One. -------------------- > MonoGame.Framework.iOS | 1.0.0.1278-develop | Downloads: 153 The MonoGame runtime for iOS amd iPadOS. -------------------- The version number you want to use is listed in the output. Note As packages are published, the version number will always change. Unfortunately, due to limitations in the way NuGet works, we cannot use a wildcard with a pre-release package (so you cannot do 1.0.0.*-develop). So this is the best way to find the latest version you want to use. Next update all the PackageReference entries in your csproj's which use MonoGame to use $(MonoGamePackageVersion) MSBuild property. For example: <ItemGroup> <PackageReference Include=\"MonoGame.Framework.DesktopGL\" Version=\"$(MonoGamePackageVersion)\" /> <PackageReference Include=\"MonoGame.Content.Builder.Task\" Version=\"$(MonoGamePackageVersion)\" /> </ItemGroup> If you try to build now you will get an error. This is because the NuGet feeds on GitHub are not public. You need to be a valid GitHub user to use them. Authentication You need to create a Personal Access Token (PAT) on your GitHub account in order to use the NuGet feed. See the following documentation on how to create your PAT. managing-your-personal-access-tokens Note You need to create a \"PAT (Classic)\" token in order for it to work with the Nuget feed. See creating-a-personal-access-token-classic for details. Once you have your PAT, you can create a new NuGet.config file in the directory ABOVE your game project directory. To be clear, this file should NOT be in your source tree. It should be outside of any directory which is under source control. Projects NuGet.config <-- THIS IS WHERE YOU PUT THE FILE. MyGame .git Directory.Build.props NuGet.config MyGame.DesktopGL MyGame.DesktopGL.csproj Important Do Not... DO NOT place a NuGet.config file with valid packageSourceCredentials in your source control. The contents of the file are as follows, replace %GITHUB_USER% with your GitHub username and the %GITHUB_TOKEN% with your token. <?xml version=\"1.0\" encoding=\"utf-8\"?> <configuration> <packageSourceCredentials> <MonoGameGitHub> <add key=\"Username\" value=\"%GITHUB_USER%\" /> <add key=\"ClearTextPassword\" value=\"%GITHUB_TOKEN%\" /> </MonoGameGitHub> </packageSourceCredentials> </configuration> The really good thing about placing these credentials outside of source control is that they are safe. But also any new projects you create under that folder can also make use of these credentials. So it is a good idea to keep them in one place. Note For more information, you can read consuming-packages-authenticated-feeds."
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/howto/HowTo_AsyncProgramming.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/howto/HowTo_AsyncProgramming.html",
    "title": "How to work with Asynchronous Methods in MonoGame | hallowed",
    "summary": "Overview This topic describes how you can work with asynchronous methods in MonoGame. MonoGame provides many methods that operate asynchronously for operations that may take longer than the desired render-cycle length. Asynchronous methods consist of four elements: A Begin call that begins the asynchronous process. Begin methods return an IASyncResult object that can be used to poll for completion if a callback function is not used to detect the completion of the operation. An End call that ends the asynchronous process and returns objects or data requested by the Begin call. Calling the corresponding End method for each Begin method is important to prevent deadlocks and other undesirable behavior. An optional callback method that is called by the system when the asynchronous operation completes. This is passed to the Begin call. An optional, arbitrary tracking object that can be supplied to Begin to uniquely identify a particular asynchronous request. This object is part of the IASyncResult returned by Begin, and is also present in the callback method's IASyncResult parameter. Because of this, it also can be used to pass arbitrary data to the callback method when the asynchronous process completes. The two most common methods of working with asynchronous methods are to check for completion by polling or by callback. This topic describes both methods. Note For more exhaustive information about Event Based asynchronous methods, see Asynchronous Programming Design Patterns on MSDN. Alternatively, review the alternative Task-Based Asynchronous patter approach. To poll for asynchronous method completion Call the asynchronous Begin method, and save the returned IASyncResult object to a variable that will be checked for completion. In your update code, check IsCompleted. When IsCompleted is true, call the End method that corresponds to the Begin method called in step 1. To use a callback to check for asynchronous method completion Call the asynchronous Begin method, passing it an AsyncCallback method that will be called when the asynchronous process is completed. AsyncCallback methods must return void, and take a single parameter: IASyncResult. In the callback, call the End method that corresponds to the Begin method called in step 1. The End method typically returns any data or objects requested by the Begin call. See Also Asynchronous Programming Design Patterns Task-based asynchronous pattern (TAP) in .NET"
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/howto/HowTo_AutomaticRotation.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/howto/HowTo_AutomaticRotation.html",
    "title": "How to manage automatic rotation and scaling | hallowed",
    "summary": "Overview This topic describes automatic rotation and scaling in the MonoGame Framework. Rotation and scaling are done in hardware at no performance cost to the game. Setting the Preferred Device Orientations If your game supports more than one display orientation, as specified by SupportedOrientations and described with DisplayOrientation, the MonoGame Framework automatically rotates and scales the game when the OrientationChanged event is raised. When the device's orientation is changed The current back buffer resolution is scaled, and can be queried by using PreferredBackBufferWidth and PreferredBackBufferHeight. These values will not be the same as the non-scaled screen resolution, which can be queried by using DisplayMode or ClientBounds. Orientation defaults If you leave SupportedOrientations set to DisplayOrientation.Default, orientation is automatically determined from your PreferredBackBufferWidth and PreferredBackBufferHeight. If the PreferredBackBufferWidth is greater than the PreferredBackBufferHeight, the game will run in the landscape orientation and automatically switch between LandscapeLeft and LandscapeRight depending on the position which the user holds the phone. To run a game in the portrait orientation, set the PreferredBackBufferWidth to a value smaller than the PreferredBackBufferHeight. See Also XNA Orientation Sample Concepts What Is a Back Buffer? Reference SupportedOrientations DisplayOrientation"
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/howto/HowTo_CollisionDetectionOverview.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/howto/HowTo_CollisionDetectionOverview.html",
    "title": "How to test collisions with Bounding Volumes | hallowed",
    "summary": "Overview Collision detection determines whether objects in a game world overlap each other. The MonoGame Framework provides several classes and methods to speed implementation of collision detection systems in games. Bounding Volume Classes Non-Bounding Volume Classes Contains and Intersects Methods Adding New Collision Data Structures Bounding Volume Classes The MonoGame Framework has three classes that represent three-dimensional volumes. Use a bounding volume class to approximate the volume occupied by a complex object using a volume that is less complex and faster for performing collision checking. All of the bounding volume classes support intersection and containment tests with each other and the plane and ray classes. Bounding Sphere The BoundingSphere Structure represents the space occupied by a sphere. There are several benefits of using a bounding sphere for collision detection. Sphere to sphere checks are very fast. To check for collision between two spheres, the distance between the centers of the spheres is compared to the sum of the radii of both spheres. If the distance is less than the combined radii of both spheres, the spheres intersect. The BoundingSphere Structure class is compact. It stores only a vector representing its center and its radius. Unlike a bounding box, a bounding sphere does not need to be recreated if the model rotates. If the model being bounded rotates, the bounding sphere will still be large enough to contain it. Moving a bounding sphere is inexpensive. Just add a value to the center. There is one major drawback to using the bounding sphere class for collision detection. Unless the object being approximated is sphere shaped, the bounding sphere will have some empty space, which could result in false positive results. Long narrow objects will have the most empty space in their bounding spheres. Bounding Box The BoundingBox Structure represents the space occupied by a box. The bounding box class is axis aligned. Each face of the bounding box is perpendicular to the x-axis, the y-axis, or the z-axis. There are several benefits of using the bounding box for collision detection. The bounding box class fits rectangular shapes aligned with the axis very well. Compared to the bounding sphere class, the bounding box class provides a much tighter fit for non-rotated rectangular objects. Because the bounding box class is axis aligned, you can make certain assumptions that result in collision checks between bounding boxes being quicker than a bounding box that can be rotated. There are a few drawbacks of using the bounding box for collision detection. Rotating a bounding box causes it to no longer be axis aligned. Because of this, if you rotate a model being bounded, you will need to recreate the bounding box. Doing so can be slow, since all the points in an object are iterated through to get the bounding box. If the model has not changed orientation, you can translate the bounding box instead of recreating it. If the model being bounded is not aligned to the axis, the bounding box will have some empty space. The amount of empty space will be greatest when the object is rotated 45 degrees from an axis. Empty space in the bounding box can result in false positives when checking for collision. Bounding Frustum Use a BoundingFrustum Class to create a bounding volume that corresponds to the space visible to the camera. You create a bounding frustum from the combined view and projection matrix that the camera is using currently. If the camera moves or rotates, you need to recreate the bounding frustum. The bounding frustum is not used to determine when two objects collide, but rather when an object intersects with the volume of space viewable by the camera. Objects that do not intersect and are not contained by the bounding frustum are not visible to the camera and do not need to be drawn. For complex models, this can reduce the number of pixels that need to be rendered. Non-Bounding Volume Classes Plane The Plane Structure describes a 2D plane. The plane is defined by a normal vector (perpendicular to the plane) and a point on the plane. The plane class supports intersection tests with the bounding volume classes. The plane class’s intersection test returns the tested object's position relative to the plane. The return value indicates whether the object intersects the plane. If the object does not intersect the plane, the return value indicates whether the object is on the plane’s front side or back side. Ray The Ray Structure describes a ray starting at a point in space. The ray structure supports intersection tests with the bounding volume classes. The return value of the ray intersection tests is the distance the intersection occurred at, or null if no intersection occurred. Model In addition to the information needed to draw a model, the Model Class contains bounding volumes for its parts. When a model is imported, the content pipeline calculates the bounding sphere for each of the model's parts. To check for collision between two models, you can compare the bounding spheres for one model to all of the bounding spheres of the other model. Contains and Intersects Methods Bounding volume classes have methods to support two types of collision tests: intersection tests and containment tests. The intersects methods check whether the two objects being tested overlap in any way. As soon as the test finds that the objects do intersect, it returns without trying to determine the degree of the intersection. The contains methods determine whether the objects simply intersect or whether one of the objects is completely contained by the other. Since the intersects methods need only determine whether an intersection occurred, they tend to be faster than the contains methods. Adding New Collision Data Structures When implementing other bounding volume classes and intersection tests, you will probably need to add a custom content pipeline processor. For example, your game might need to use convex hulls for collision detection. You could use a custom processor to determine the convex hull and then place it in the model's tag field. Then, when the model is loaded at run time, the convex hull information would be available in the model. For more information, see Extending a Standard Content Processor."
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/howto/HowTo_ExitNow.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/howto/HowTo_ExitNow.html",
    "title": "How to exit a Game Immediately | hallowed",
    "summary": "Overview Demonstrates how to exit a game in response to user input. Exiting a Game Without Finishing the Current Update Note Some platforms react differently to Game.Exit, so be sure to test on a device! Derive a class from Game. Create a method that checks KeyboardState.IsKeyDown for the state of the ESC key. If the ESC key has been pressed, call Game.Exit and return true. bool checkExitKey(KeyboardState keyboardState, GamePadState gamePadState) { // Check to see whether ESC was pressed on the keyboard // or BACK was pressed on the controller. if (keyboardState.IsKeyDown(Keys.Escape) || gamePadState.Buttons.Back == ButtonState.Pressed) { Exit(); return true; } return false; } Call the method in Game.Update, and return from Update if the method returned true. GamePadState gamePadState = GamePad.GetState(PlayerIndex.One); KeyboardState keyboardState = Keyboard.GetState(); // Check to see if the user has exited if (checkExitKey(keyboardState, gamePadState)) { base.Update(gameTime); return; } Create a method to handle the Game.Exiting event. The Exiting event is issued at the end of the tick in which Game.Exit is called. void Game1_Exiting(object sender, EventArgs e) { // Add any code that must execute before the game ends. } Note The default MonoGame project template already includes code to exit your game (as shown below), however depending on your game, you may wish to change this default logic. if (GamePad.GetState(PlayerIndex.One).Buttons.Back == ButtonState.Pressed || Keyboard.GetState().IsKeyDown(Keys.Escape)) Exit(); See Also Input Overview Reference Game.Exit"
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/howto/HowTo_Install_Preview_Release.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/howto/HowTo_Install_Preview_Release.html",
    "title": "How to install a preview release of MonoGame from NuGet | hallowed",
    "summary": "Overview MonoGame provides preview deployments for testing releases prior to the full release of a new version. This gives developers early access to new features before they are made officially available. Warning While preview releases still undergo the same rigorous testing used for full releases, some features may not work as expected as it is still classed as developmental code. Preview releases should not be used for production deployments.* The preview packages are intended for testing and validating fixes/updates and new features in your projects without drastically affecting them. Updating NuGet package dependencies To use the preview packages delivered via NuGet you need to update or replace your existing MonoGame references for your project: The Platform NuGet package reference - e.g. MonoGame.Framework.DesktopGL The Builder Task package - MonoGame.Content.Builder.Task (Only required if using the Content Pipeline) The simplest way is from the command line in the folder where your csproj is located (if you have multiple projects, please repeat for each) using the following syntax: dotnet add package MonoGame.Framework.DesktopGL -v 3.8.4-preview.1 dotnet add package MonoGame.Content.Builder.Task -v 3.8.4-preview.1 Replacing the preview version with the specific version you wish to install. Note For Visual Studio, use Tools -> NuGet Package Manager -> Manage NuGet Packages for Solution/Project, then click on the Updates tab and update each package. Make sure to select \"Include Prerelease\" for the preview packages to be detected. Update dotnet-tools.json for Content Manager To ensure symmetry between the project version and the Content Pipeline Editor (MGCB) the dotnet-tools.json configuration in your project .config directory will also need updating. This is simply a matter of updating the tools references, again from the command line in the projects folder, as follows: dotnet tool install dotnet-mgcb --version 3.8.4-preview.1 dotnet tool install dotnet-mgcb-editor --version 3.8.4-preview.1 dotnet tool install dotnet-mgcb-editor-linux --version 3.8.4-preview.1 dotnet tool install dotnet-mgcb-editor-windows --version 3.8.4-preview.1 dotnet tool install dotnet-mgcb-editor-mac --version 3.8.4-preview.1 Replacing the preview version with the specific version you wish to install. Note Alternatively, simply edit the dotnet-tools.json file and replace the \"version\" value across the file. Important Make sure to run dotnet tool restore any time you make changes to the dotnet-tools.json to refresh the installation of the Content Builder and Editor. Installing the preview templates This step is optional, if you intend to generate a new project using the latest templates, including any automated or templates setup Simply run the following from the command line: dotnet new install MonoGame.Templates.CSharp::3.8.4-preview.1 Replacing the preview version of MonoGame at the end of the command with the specific version you wish to install. Visual Studio Extensions with Preview releases At this time, the Visual Studio marketplace does not support preview versions of extensions, if you wish to test a preview version of the Visual Studio Extension, you can install it manually. The Extension can be downloaded from the latest GitHub Actions build used to generate the preview build. Go to the MonoGame GitHub repository and select the \"Actions\" tab. Find the build with the associated tag, e.g. v3.8.4-preview.1 In the Artifacts for the build, you should see the extensions installer MonoGame.Templates.VSExtension.vsix Click on the \"Download Icon\" on the far right-hand side of the row. Once downloaded, run the vsix which will update your installation of the extensions package. See Also Getting Started with MonoGame Using Development NuGet Packages"
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/howto/HowTo_MobileBestPractices.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/howto/HowTo_MobileBestPractices.html",
    "title": "How to apply Best Practices for MonoGame Games | hallowed",
    "summary": "Overview The practices discussed here will help you have the most success possible with your MonoGame game. This overview covers the following topics. Polish Your Game Build Intuitive and Fun Controls Support Changing Screen Orientation Audio Tips Respond Correctly to Back Button Use Diligently Save Game State Polish Your Game It is difficult to over emphasize how important polish is for a successful game. The best game ideas and the most stable code do not compare to a game with an extra level of polish. Polish can be defined as putting in the extra effort to make your game look and feel its best. It also is: The difference between a basic menu with buttons that just work and the same menu with polish. It may take time to add a small flourish of animation for each button press, sound effect, and styled buttons to a menu, but doing so makes a big difference. Smooth menu operation and intuitive controls. Smooth transitions among screens, modes, and levels. Build Intuitive and Fun Controls Avoid simulating traditional controls such as thumbsticks in MonoGame games. That type of control takes away useful space from the gameplay area and is not platform friendly. Use gestures for user input. Games that are engaging and naturally fun have controls that are natural to the platform. Control Description Touch Touch control systems will feel natural to MonoGame users. Design games from the beginning to take full advantage of the touch screen. The touch screen is the primary way users interact with their phone, and users expect to interact with games in the same way. Back Button Although there are other buttons on the device, only the Back button is available to the game. Use the Back button for pausing and exiting the game. Gestures Design your gameplay to use touch gestures in natural ways. For example: allowing players to draw paths on the screen to direct gameplay, or allowing for group selection by stretching an on-screen rectangle around play pieces. Consider allowing navigation by dragging the landscape, and allowing users to rotate by touching and rotating two fingers. Support Changing Screen Orientation MonoGame supports three screen orientation views: portrait, landscape left, and landscape right. Portrait view is the default view for applications. The Start button is always presented in portrait view. In portrait view, the page is oriented vertically with the steering buttons displayed at the bottom of the phone. In both landscape views, the Status Bar and Application Bar remain on the side of the screen that has the Power and Start buttons. Landscape left has the Status Bar on the left, and landscape right has the Status Bar on the right. Routinely check current screen orientation and enable gameplay regardless of how the phone is held. Note For more detailed information on screen rotation see Automatic Rotation and Scaling. Audio Tips Audio can enrich an application and add needed polish. Playing audio should also dependent on user preference. Consider these tips when building audio into your game: Play sound effects at an average volume to avoid forcing the player to adjust the devices volume during the game. Allow sound effects and background music to be turned on and off by users. Play directional sounds that reflect a location of the originating element on the screen. Note For more detailed information on audio see Creating and Playing Sounds. Respond Correctly to Back Button Use Games must respond to use of the Back button, or \"esc\" on Windows. MonoGame consistently uses Back to move backward through the UI. Games must implement this behavior as follows: During gameplay, the game can do one of the following: Present a contextual pause menu (dialog). Pressing the Back button again while in the pause menu closes the menu and resumes the game. Navigate the user to the prior menu screen. Pressing the Back button again should continue to return the user to the previous menu or page. Outside of gameplay, such as within the game's menu system, pressing Back must return to the previous menu or page. At the game’s initial (start) screen, pressing Back must exit the game. It is a good practice in case the player exits the game to automatically save the game state while the pause menu is shown. Diligently Save Game State On MonoGame, a game might be exited at any time. An incoming call may interrupt gameplay, or the user might quit the game by using the Home or Search buttons to use other applications. We recommend saving game state whenever possible to protect the user's time investment in the game. We also recommend that you make a distinction between the automatically saved game state and the user's explicitly saved games. Automatically saved games should be viewed as a backup in case the game ends unexpectedly, but should not replace the user's ability to save the game at a chosen time or place. If you implement automatic game saving, check for an automatically saved state when the game launches. If found, let the user choose to resume the game from the automatically saved state or from a specific manually saved game, if present. During the save process, we also recommend that you display a visual cue warning users not to press the Search or Home button because the action could cause the game to exit before the save is complete. See Also Creating a your first MonoGame Game Setting Aspect ratios for your game"
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/howto/HowTo_PlayerResize.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/howto/HowTo_PlayerResize.html",
    "title": "How to resize a Game | hallowed",
    "summary": "Overview On Desktop, it is normally possible for the user to change how the game window is sized, either by moving from full-screen to windowed, or by altering the resolution of their screen. In these cases an event is fired to enable you to handle these changes. Note Ideally, your games drawing should always take account of the Aspect Ratio and dimensions of the displayed screen, regardless of device, else content may not be always drawn where you expect it to. To handle player window resizing to a game Derive a class from Game. Set Game.GameWindow.AllowUserResizing to true. Add an event handler for the ClientSizeChanged event of Game.Window. this.Window.AllowUserResizing = true; this.Window.ClientSizeChanged += new EventHandler<EventArgs>(Window_ClientSizeChanged); Implement a method to handle the ClientSizeChanged event of Game.Window. void Window_ClientSizeChanged(object sender, EventArgs e) { // Make changes to handle the new window size. } See Also How to articles for the Graphics Pipeline Concepts What Is 3D Rendering? What Is a Back Buffer? What Is a Viewport? Reference GameWindow GraphicsDeviceManager"
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/howto/HowTo_TimingOut.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/howto/HowTo_TimingOut.html",
    "title": "How to exit a Game After a Time Out | hallowed",
    "summary": "Overview Games are meant to be played, but some users had a tendency to walk away from their controllers or go and do something IRL, when this happens, especially if your game is very dynamic, it is good practice to monitor for a lack of interactivity and pause the game (unless you want the player to die horribly for not paying attention). To make a game time out Create a class that derives from Game. Determine the desired time-out limit in milliseconds. // Time out limit in ms. static private int TimeOutLimit = 4000; // 4 seconds Add a variable for tracking the elapsed time since the most recent user activity. // Amount of time that has passed. private double timeoutCount = 0; When user input is checked, set a flag indicating whether any user activity has taken place. GamePadState blankGamePadState = new GamePadState( new GamePadThumbSticks(), new GamePadTriggers(), new GamePadButtons(), new GamePadDPad()); In Update, if there has not been any user activity, increment the tracking variable by the elapsed time since the last call to Update. If there has been some user activity, set the tracking variable to zero. // Check to see if there has been any activity if (checkActivity(keyboardState, gamePadState) == false) { timeoutCount += gameTime.ElapsedGameTime.Milliseconds; } else timeoutCount = 0; Check whether the value of the tracking variable is greater than the time-out limit. If the variable is greater than the limit, perform some time-out logic such as playing an idle animation or, in this case, exit the game. // Timeout if idle long enough if (timeoutCount > TimeOutLimit) { Exit(); base.Update(gameTime); return; } See Also Input Overview Reference Game.Exit"
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/howto/HowTo_VariableStepGameLoop.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/howto/HowTo_VariableStepGameLoop.html",
    "title": "How to update a game with Variable or Fixed Timing | hallowed",
    "summary": "Overview Demonstrates how to set up the runtime to call your Update method using variable or fixed timing. There are two techniques for setting how often your Update method is called. Fixed timing (Default) means that Update is called each time a fixed interval of time has passed. Fixed timing guarantees that Update will be called, however, you may drop frames if the previous work needs to be interrupted to call Update. Variable timing means to call Update as soon as other work finishes; this implies that it is up to a game developer to ensure that your render loop happens quickly enough so that Update will be called often enough to exceed your minimum frame rate. To use a fixed time step Note Fixed timing is the default set to 60 FPS (or 0.0166667 seconds per frame). Create a class that derives from Game. Set IsFixedTimeStep to true. this.IsFixedTimeStep = true; This causes the Update method to be called each time the fixed time interval has passed. Set TargetElapsedTime to a fixed interval of time. This example sets the time between calls to 16 milliseconds. this.TargetElapsedTime = TimeSpan.FromSeconds(1 / 30.0); // Update() is called every 30 times each second / 30 FPS Note In older samples, you might see TargetElapsedTime registered as TimeSpan.FromTicks(333333), which is the same as 30 FPS. To use a variable time step A variable timestep has as much benefits as it has drawbacks and care must be taken as it will directly affect your rendering if you are not careful. Create a class that derives from Game. Set IsFixedTimeStep to false. This causes the Update method to be called as often as possible, instead of being called on a fixed interval. this.IsFixedTimeStep = false; Note The Ship Game sample implements a variable time step depending on the vsync setting of the device. It is a good place to start when evaluating variable timings for your game. The Racing Game sample on the XNA Game Studio Archive (still based on XNA 4) is written to ONLY work in a Fixed Time loop due to its physics implementation. Beware it is an awesome project. See Also Ship Game Racing Game Concepts What Is the GameLoop? Reference Game.IsFixedTimeStep Game.TargetElapsedTime GraphicsDeviceManager"
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/howto/audio/HowTo_ChangePitchAndVolume.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/howto/audio/HowTo_ChangePitchAndVolume.html",
    "title": "How to adjust Pitch and Volume | hallowed",
    "summary": "Overview In this example, you will walk through the basics of dynamic sounds, using the more advanced SoundEffectInstance cl;ass over the basic SoundEffect.Play method used in Playing a Sound. Using SoundEffectInstance The SoundEffect.Play method allows you to specify the pitch and volume of a sound to play. However, after you call Play you cannot modify the sound. Using SoundEffectInstance for a given SoundEffect, allows you to change the pitch and volume of a sound at any time during playback. Note The pitch of a sound changes the frequency of the sound, which in turn changes the speed of the sound. The volume of a sound changes the amplitude of the sound, which in turn changes the loudness of the sound. Requirements This sample uses a sound file named tx0_fire1.wav, which you can download from this link here. (save-as) But you can use your own if you wish. Change Pitch and Volume of Sound Declare a SoundEffect and a Stream file by using the method shown in Playing a Sound. In addition to the method described in Playing a Sound, declare a SoundEffectInstance and a Sound Effect field member. We also create two float fields for pitch and volume to store the pitch and volume of the sound effect and assign initial values to them. // place these usings at the top of the file using System.IO; using Microsoft.Xna.Framework; using Microsoft.Xna.Framework.Audio; using Microsoft.Xna.Framework.Graphics; using Microsoft.Xna.Framework.Input; // place these fields at the top of the class private SoundEffect soundEffect; private SoundEffectInstance soundEffectInstance; private float pitch = 0.75f; private float volume = 0.5f; Note Usings are declared at the top of the file to ensure that the necessary namespaces are available to the class. The fields are declared at the top of the class to ensure that they are accessible to all methods in the class. In the Game.LoadContent method, set the SoundEffectInstance object to the return value of SoundEffect.CreateInstance. In the Game.LoadContent method, set the SoundEffectInstance object to the return value of SoundEffect.CreateInstance. We also optionally define a variable soundFile to store the location of the sound file being used with the TitleContainer.OpenStream method, which is accessed with the using keyword, and include a field member variable called soundEffect, to hold the stream. using Stream soundfile = TitleContainer.OpenStream(@\"Content\\tx0_fire1.wav\"); soundEffect = SoundEffect.FromStream(soundfile); soundEffectInstance = soundEffect.CreateInstance(); [IMPORTANT] As we need the raw wav file and not a compressed version to access its stream, make sure to set the 'Build Action' in the MGCB tool to 'COPY' Adjust the sound to the desired level using the SoundEffectInstance.Pitch and SoundEffectInstance.Volume properties. // Pitch takes values from -1 to 1 soundEffectInstance.Pitch = pitch; // Volume only takes values from 0 to 1 soundEffectInstance.Volume = volume; Play the sound using SoundEffectInstance.Stop. // Play Sound soundEffectInstance.Play(); Note An instance will play once, to loop the sound, you can use the SoundEffectInstance.IsLooped property to set the sound to loop. Also note that the sound will not repeat until the sound has finished playing. You can utilise the SoundEffectInstance.State property to check if the sound is playing, paused or stopped. Use the SoundEffectInstance.Stop method to stop the sound. An Extended Example Below the Game.Draw method, create a new method called IsKeyPressed, which will check if a specified key is pressed and return a boolean value of true if it has been pressed. private bool IsKeyPressed(Keys key) { return Keyboard.GetState().IsKeyDown(key); } In the Game.Update method, we will add a check to see if the Space key is pressed and adjust the pitch and volume of the sound effect accordingly. The pitch and volume values are adjusted by +0.1f each time the Space key is pressed. The pitch values are clamped to a minimum value of -1.0f and a maximum value of 1.0f, and the volume values are then clamped to a minimum value of 0f and a maximum value of 1.0f. This is done to ensure that the pitch and volume values are within valid ranges. // Check if the SpaceKey is pressed and play the instance if (IsKeyPressed(Keys.Space)) { pitch += 0.1f; volume += 0.1f; pitch = MathHelper.Clamp(pitch, -1.0f, 1.0f); volume = MathHelper.Clamp(volume, 0f, 1.0f); soundEffectInstance.Pitch = pitch; soundEffectInstance.Volume = volume; soundEffectInstance.Play(); } Note The MathHelper.Clamp method is used to ensure that the pitch and volume values are within the valid range. The pitch value is clamped between -1 and 1, while the volume value is clamped between 0 and 1. Important The check for the keypress does not prevent the call to the method repeating so any value entered may peak the value in a single key press. To prevent this, you can add a delay to the key press check, or use a boolean value to check if the key has been pressed and released. See Also Playing a Sound Demonstrates how to play a simple sound by using SoundEffect. Looping a Sound Demonstrates how to loop a sound. Stream data from a Wav Demonstrates how to load a wav file through a file stream. Creating and Playing Sounds Provides overviews about audio technology, and presents predefined scenarios to demonstrate how to use audio. Reference SoundEffect Class Provides a loaded sound resource. SoundEffectInstance Class Provides a single playing, paused, or stopped instance of a SoundEffect sound."
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/howto/audio/HowTo_LoopASound.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/howto/audio/HowTo_LoopASound.html",
    "title": "How to loop Sounds | hallowed",
    "summary": "Overview In this example we will go over the basics of how to make sound effects loop rather than the default play once. Simple Sound Looping Not much extra code is needed to continuously loop a sound file in your game. Since the SoundEffect class does not provide looping support, you will need to allocate a SoundEffectInstance object. The following procedure builds on the sample code provided in the Playing a Sound topic. To loop a sound Follow the instructions show in Playing a Sound topic. Declare a SoundEffectInstance object to hold an instance of the sound file. private SoundEffectInstance soundEffectInstance; To be able to loop a sound you will need to declare a SoundEffectInstance object, and set it to the return value of SoundEffect.CreateInstance. add this after loading the sound file in the LoadContent method. soundEffectInstance = soundEffect.CreateInstance(); Set SoundEffectInstance.IsLooped to true which will cause the sound effect to play forever or until you stop it or close the game. soundEffectInstance.IsLooped = true; Play the sound instance (removing the old soundEffect.Play() call). // Play the sound effect instance soundEffectInstance.Play(); Note Obviously you would not normally call play in the LoadContent method, we just use here as an example. See Also Playing a Sound Demonstrates how to play a simple sound by using SoundEffect. Reference SoundEffect Class Provides a loaded sound resource. SoundEffectInstance Class Provides a single playing, paused, or stopped instance of a SoundEffect sound."
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/howto/audio/HowTo_Microphone.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/howto/audio/HowTo_Microphone.html",
    "title": "How to work with Microphones | hallowed",
    "summary": "Supported Microphone Devices The Microphone API is only implemented on OpenAL based platforms at this time. This includes iOS/Android and Desktop projects using DesktopGL. Capabilities of the Microphone API The MonoGame Microphone API has the following functionality: Captures the audio stream from a microphone. Submits and controls a stream of audio buffers for playback using the DynamicSoundEffectInstance object. Plays back audio. Microphone API Process Workflow The Microphone API behaves like a simple audio recorder with a configurable capture buffer. It has been designed with the following development process workflow: Select the microphone connected to the device. Configure the microphone's capture buffer size. Control the recording using standard transport controls (Start and Stop). Retrieve the captured audio using the GetData method. Also, you can use the BufferReady event handler of the Microphone class if you want to be notified when the audio capture buffer is ready to be processed. See Also Creating and Playing Sounds Provides overviews about audio technology, and presents predefined scenarios to demonstrate how to use audio. Reference DynamicSoundEffectInstance Provides properties, methods, and events for play back of the audio buffer. Microphone Provides properties, methods, and fields and events for capturing audio data with microphones."
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/howto/audio/HowTo_PlayASong.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/howto/audio/HowTo_PlayASong.html",
    "title": "How to play a Song / music | hallowed",
    "summary": "Overview In this example we will demonstrate the ability to load a media file such as an MP3, OGG or WMA file. The MediaPlayer class manages long running music or media. Will start audio playback when using the Play method. If the user currently is playing a different song, the Stop method can be used to stop the current song. Note Only one song can be played at any time using the MediaPlayer. Requirements This sample uses a mp3 file named rock_loop_stereo.mp3, which you can download from this link here. (save-as) But you can use your own if you wish. To add a music file to your project Open your MonoGame game in your editor of choice. Open the Content.mgcb file by either double-clicking on it, or right-clicking and selecting `Open in MGCB editor\". (depending on your editor) Click Add in the menu bar, and then click Existing Item. (alternatively, use the icon for the same task in the editor) Navigate to the music (mp3) file you want to add, and then select it. The selected audio file is inserted into your project. By default, it is processed by the Content Pipeline as a Song To play a song The following demonstrates how to play a song from the media file in the content project. Declare a Song parameter as a reference for the media file to load. private Song song; Load the media file using Content.Load in the 'LoadContent' method. song = Content.Load<Song>(\"rock_loop_stereo\"); Check if the MediaPlayer is currently playing (or has a paused track), and then call \"Stop\" if needed. As soon as the MediaPlayer is ready, play the music. // check the current state of the MediaPlayer. if(MediaPlayer.State != MediaState.Stopped) { MediaPlayer.Stop(); // stop current audio playback if playing or paused. } // Play the selected song reference. MediaPlayer.Play(song); See Also Media Overview Provides a high-level overview about the capabilities—such as playing music and video and accessing pictures—of the Media API in MonoGame. Reference MediaPlayer Class Provides methods and properties to play, pause, resume, and stop songs. MediaPlayer also exposes shuffle, repeat, volume, play position, and visualization capabilities."
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/howto/audio/HowTo_PlayASound.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/howto/audio/HowTo_PlayASound.html",
    "title": "How to play a Sound(effect) | hallowed",
    "summary": "Overview In this example we will take our first steps into audio nirvana and play a simple one-time-only SoundEffect. Requirements This sample uses a sound file named tx0_fire1.wav, which you can download from this link here. (save-as) But you can use your own if you wish. To add a sound file to your project Open your MonoGame game in your editor of choice. Open the Content.mgcb file by either double-clicking on it, or right-clicking and selecting `Open in MGCB editor\". (depending on your editor) Click Add in the menu bar, and then click Existing Item. (alternatively, use the icon for the same task in the editor) Navigate to the sound file you want to add, and then select it. The selected audio file is inserted into your project. By default, it is processed by the Content Pipeline, and built wave files are accessed automatically when the game is built. To play a simple sound Declare a SoundEffect object to hold the sound file. // Audio objects SoundEffect soundEffect; Load the sound file using Content.Load in the 'LoadContent' method. soundEffect = Content.Load<SoundEffect>(\"tx0_fire1\"); Play the sound. // Play the sound soundEffect.Play(); Note Obviously you would not normally call play in the LoadContent method, we just use here as an example. See Also Looping a Sound Demonstrates how to loop a sound. Reference SoundEffect Class Provides a loaded sound resource. SoundEffectInstance Class Provides a single playing, paused, or stopped instance of a SoundEffect sound."
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/howto/audio/HowTo_Record_Microphone.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/howto/audio/HowTo_Record_Microphone.html",
    "title": "How to record Sound with a Microphone | hallowed",
    "summary": "Overview The following procedure shows the bare basics of using the microphone to record audio. In practice, you will want to use UI elements (such as buttons) to start and stop audio recording. As handling microphone audio can become quite complex, this tutorial is split into two halves: Part 1 walks through the required code in order to record audio from the default microphone and then stop recording. Part 2 is a more in-depth sample which also processes the recorded audio and plays it back to you. Part 1, Guide to recording audio from the microphone Get the device's default microphone by using Microphone.Default. Microphone activeMicrophone; activeMicrophone = Microphone.Default; if (activeMicrophone != null) { } else { // No microphone is attached to the device } Set the size (duration) of the Microphone buffer and wire up the event to handle the data as it becomes available. THen declare a buffer array to hold the audio data from these settings. // Set the capture buffer size for low latency. // Microphone will call the game back when it has captured at least that much audio data. activeMicrophone.BufferDuration = TimeSpan.FromMilliseconds(100); // Subscribe to the event that's raised when the capture buffer is filled. activeMicrophone.BufferReady += BufferReady; // We will put the mic samples in this buffer. We only want to allocate it once. micSamples = new byte[activeMicrophone.GetSampleSizeInBytes(activeMicrophone.BufferDuration)]; The Buffer Ready handler can then process the prepared microphone data for storage, transmission or playback, getting the sample data from the Microphone and storing it in the prepared buffer array (micSamples). /// <summary> /// This is called each time a microphone buffer has been filled. /// </summary> void BufferReady(object sender, EventArgs e) { try { // Copy the captured audio data into the pre-allocated array. int sampleDataSize = activeMicrophone.GetData(micSamples); } catch (NoMicrophoneConnectedException) { // Microphone was disconnected - let the user know. } } Begin recording audio, calling method Microphone.Start. private void StartRecording() { // Can't start a microphone that doesn't exist. if (activeMicrophone == null) { return; } try { activeMicrophone.Start(); } catch (NoMicrophoneConnectedException) { // Microphone was disconnected - let the user know. } } While the microphone is recording, Microphone.GetData (Byte[], Int32, Int32) is called in the aforementioned BufferReady handler as the audio data becomes available. int sampleDataSize = activeMicrophone.GetData(micSamples); When you are finished recording, set the microphone state to stopped by calling method Stop. private void StopRecording() { // Can't stop a microphone that doesn't exist. if (activeMicrophone == null) { return; } try { // Stop the microphone activeMicrophone.Stop(); } catch (NoMicrophoneConnectedException) { UpdateMicrophoneStatus(); } } Part 2, Full example of outputting the microphone to audio As promised, the following is a fully working sample that: Starts recording and outputting audio from the active microphone when \"space is pressed\". Stops recording when \"P\" is pressed. Adds an \"Extension method\" to determine if a Microphone is connected. A \"PickFirstConnectedMicrophone\" method to choose a specific microphone. Can be modified so you can switch mic's An \"InitializeMicrophone\" method to initialize and setup the microphone, updated to work in \"Update\" so it can continually monitor the Mic connection. Enjoy, all code commented where applicable for reference. using System; using Microsoft.Xna.Framework; using Microsoft.Xna.Framework.Audio; using Microsoft.Xna.Framework.Graphics; using Microsoft.Xna.Framework.Input; namespace MonoGameMicrophoneExample; public class Game1 : Game { private GraphicsDeviceManager graphics; private SpriteBatch spriteBatch; SpriteFont font; // The most recent microphone samples. byte[] micSamples; // DynamicSoundEffectInstance is used to playback the captured audio after processing it for echo. DynamicSoundEffectInstance dynamicSound; // Microphone used for recording. Microphone activeMicrophone; // Used to communicate the microphone status to the user. string microphoneStatus = string.Empty; const string instructions = @\"Press 'Space' to start and 'P' to stop recording\"; #region MonoGame Boilerplate public Game1() { graphics = new GraphicsDeviceManager(this); Content.RootDirectory = \"Content\"; IsMouseVisible = true; } protected override void Initialize() { // TODO: Add your initialization logic here base.Initialize(); } protected override void LoadContent() { spriteBatch = new SpriteBatch(GraphicsDevice); // Make sure to create a SpriteFont in the Content project and set its build action to \"Content\". font = Content.Load<SpriteFont>(\"File\"); } protected override void Update(GameTime gameTime) { if (GamePad.GetState(PlayerIndex.One).Buttons.Back == ButtonState.Pressed || Keyboard.GetState().IsKeyDown(Keys.Escape)) Exit(); // Constantly check for a good microphone to start recording. InitializeMicrophone(); // Check and update microphone status. UpdateMicrophoneStatus(); if (IsKeyPressed(Keys.Space)) { StartRecording(); } if (IsKeyPressed(Keys.P)) { StopRecording(); } base.Update(gameTime); } protected override void Draw(GameTime gameTime) { GraphicsDevice.Clear(Color.CornflowerBlue); // TODO: Add your drawing code here spriteBatch.Begin(SpriteSortMode.Deferred, BlendState.AlphaBlend); spriteBatch.DrawString(font, instructions, new Vector2(10f, 20f), Color.White); spriteBatch.DrawString(font, microphoneStatus, new Vector2(10f, 50f), Color.White); spriteBatch.End(); base.Draw(gameTime); } #endregion MonoGame Boilerplate #region Input Handling private bool IsKeyPressed(Keys key) { return Keyboard.GetState().IsKeyDown(key); } private void StartRecording() { // Can't start a microphone that doesn't exist. if (activeMicrophone == null) { return; } try { activeMicrophone.Start(); } catch (NoMicrophoneConnectedException) { UpdateMicrophoneStatus(); } } private void StopRecording() { // Can't stop a microphone that doesn't exist. if (activeMicrophone == null) { return; } try { // Stop the microphone activeMicrophone.Stop(); } catch (NoMicrophoneConnectedException) { UpdateMicrophoneStatus(); } } #endregion Input Handling #region Microphone Handling /// <summary> /// Keep track of the microphone status to communicate to the user. /// </summary> private void UpdateMicrophoneStatus() { // We don't have any microphones connected to the system. if (activeMicrophone == null) { microphoneStatus = \"Waiting for microphone connection...\"; } else { try { // Update the status - if the microphone gets disconnected this will throw microphoneStatus = string.Format(\"{0} is {1}\", activeMicrophone.Name, activeMicrophone.State); } catch (NoMicrophoneConnectedException) { // Microphone got disconnected - Let's ask the user to reconnect it. microphoneStatus = string.Format(\"Please reconnect {0}\", activeMicrophone.Name); } } } /// <summary> /// This is called each time a microphone buffer has been filled. /// </summary> void BufferReady(object sender, EventArgs e) { try { // Copy the captured audio data into the pre-allocated array. int sampleDataSize = activeMicrophone.GetData(micSamples); // Process the captured audio for playback dynamicSound.SubmitBuffer(micSamples, 0, sampleDataSize); } catch (NoMicrophoneConnectedException) { // Microphone was disconnected - let the user know. UpdateMicrophoneStatus(); } } /// <summary> /// Look for a good microphone to start recording. /// </summary> /// <returns></returns> private Microphone PickFirstConnectedMicrophone() { // Let's pick the default microphone if it's ready. if (Microphone.Default != null && Microphone.Default.IsConnected()) { return Microphone.Default; } // Default microphone seems to be disconnected so look for another microphone that we can use. // And if the default was null then the list will be empty and we'll skip the search. foreach (Microphone microphone in Microphone.All) { if (microphone.IsConnected()) { return microphone; } } // There are no microphones hooked up to the system! return null; } /// <summary> /// Finds a good microphone to use and sets up everything to start recording and playback. /// Once a microphone is selected the game uses it throughout its lifetime. /// If it gets disconnected it will tell the user to reconnect it. /// </summary> private void InitializeMicrophone() { // We already have a microphone, skip out early. if (activeMicrophone != null) { return; } try { // Find the first microphone that's ready to rock. activeMicrophone = PickFirstConnectedMicrophone(); if (activeMicrophone != null) { // Set the capture buffer size for kow latency. // Microphone will call the game back when it has captured at least that much audio data. activeMicrophone.BufferDuration = TimeSpan.FromMilliseconds(100); // Subscribe to the event that's raised when the capture buffer is filled. activeMicrophone.BufferReady += BufferReady; // We will put the mic samples in this buffer. We only want to allocate it once. micSamples = new byte[activeMicrophone.GetSampleSizeInBytes(activeMicrophone.BufferDuration)]; // Create a DynamicSoundEffectInstance in the right format to playback the captured audio. dynamicSound = new DynamicSoundEffectInstance(activeMicrophone.SampleRate, AudioChannels.Mono); dynamicSound.Play(); } } catch (NoMicrophoneConnectedException) { // Uh oh, the microphone was disconnected in the middle of initialization. // Let's clean up everything so we can look for another microphone again on the next update. activeMicrophone.BufferReady -= BufferReady; activeMicrophone = null; } } #endregion Microphone Handling } #region Helper Microphone Extension Method public static class MicrophoneExtensions { // Provides a simple method to check if a microphone is connected. // There is no guarantee that the microphone will not get disconnected at any time. // This method helps in simplifying the microphone enumeration code. public static bool IsConnected(this Microphone microphone) { try { MicrophoneState state = microphone.State; return true; } catch (NoMicrophoneConnectedException) { return false; } } } #endregion Helper Microphone Extension Method See Also Working with Microphones Provides basic information about microphone usage in games. HowTo_StreamDataFromWav a sample demonstrating the uses of the DynamicSoundEffectInstance Reference Microphone Provides properties, methods, and fields and events for capturing audio data with microphones. DynamicSoundEffectInstance Provides properties, methods, and events for play back of the audio buffer."
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/howto/audio/HowTo_StreamDataFromWav.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/howto/audio/HowTo_StreamDataFromWav.html",
    "title": "How to stream Data from a WAV File | hallowed",
    "summary": "Overview In this example we will demonstrate the uses of the DynamicSoundEffectInstance which is an advanced method for strictly controlling what audio data is going to be played. One approach is to tightly control the memory being used for playing audio, rather than loading an entire track into memory, you only need to load a sufficient amount to play audio for the current frame or frames. Very useful when every bit of memory data counts. Another approach (Which was used in the Nokia AlphaLabs Experiment - Vequencer) enables you to dynamically compose audio at runtime, especially useful when you want to control pacing and the number of instruments playing. But buyer beware, it can be tricky to get this right. (but awesome when it works) Requirements This sample uses a sound file named rock_loop_mono.wav, which you can download from this link here. (save-as) But you can use your own if you wish. Opening a wave file for streaming Create global variables to hold the DynamicSoundEffectInstance, position, count, and data. DynamicSoundEffectInstance dynamicSound; int position; int count; byte[] byteArray; In the Game.LoadContent method of your game, open the audio data using TitleContainer.OpenStream. System.IO.Stream waveFileStream = TitleContainer.OpenStream(@\"Content\\rock_loop_mono.wav\"); Create a new binary reader to read from the audio stream. BinaryReader reader = new BinaryReader(waveFileStream); Read the wave file header from the buffer. int chunkID = reader.ReadInt32(); int fileSize = reader.ReadInt32(); int riffType = reader.ReadInt32(); int fmtID = reader.ReadInt32(); int fmtSize = reader.ReadInt32(); int fmtCode = reader.ReadInt16(); int channels = reader.ReadInt16(); int sampleRate = reader.ReadInt32(); int fmtAvgBPS = reader.ReadInt32(); int fmtBlockAlign = reader.ReadInt16(); int bitDepth = reader.ReadInt16(); if (fmtSize == 18) { // Read any extra values int fmtExtraSize = reader.ReadInt16(); reader.ReadBytes(fmtExtraSize); } int dataID = reader.ReadInt32(); int dataSize = reader.ReadInt32(); Store the audio data of the wave file to a byte array. byteArray = reader.ReadBytes(dataSize); Create the new dynamic sound effect instance using the sample rate and channel information extracted from the sound file. dynamicSound = new DynamicSoundEffectInstance(sampleRate, (AudioChannels)channels); Store the size of the audio buffer that is needed in the count variable, etting data in 100 ms chunks. count = dynamicSound.GetSampleSizeInBytes(TimeSpan.FromMilliseconds(100)); Set up the dynamic sound effect's \"buffer needed\" event handler, so audio data is only read when it needs more data. dynamicSound.BufferNeeded += new EventHandler<EventArgs>(DynamicSound_BufferNeeded); Implement the buffer needed event handler after the LoadContent method. void DynamicSound_BufferNeeded(object sender, EventArgs e) { dynamicSound.SubmitBuffer(byteArray, position, count / 2); dynamicSound.SubmitBuffer(byteArray, position + count / 2, count / 2); position += count; if (position + count > byteArray.Length) { position = 0; } } Below the Game.Draw method, create a new method called IsKeyPressed, which will check if a specified key is pressed and return a boolean value of true if it has been pressed. private bool IsKeyPressed(Keys key) { return Keyboard.GetState().IsKeyDown(key); } Use the controller buttons to play and stop the sound stream in the Update method. // Pressing the spacebar will start the DynamicSoundEffectInstance playing if (IsKeyPressed(Keys.Space)) { dynamicSound.Play(); } // Pressing \"P\" will stop the audio playing. if (IsKeyPressed(Keys.P)) { dynamicSound.Pause(); } See Also Playing a Sound Demonstrates how to play a simple sound by using SoundEffect. Reference DynamicSoundEffectInstance Provides properties, methods, and events for play back of the audio buffer. BufferNeeded Event that occurs when the number of audio capture buffers awaiting playback is less than or equal to two. OpenStream Returns a stream to an existing file in the default title storage location."
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/howto/audio/index.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/howto/audio/index.html",
    "title": "How To tasks for Audio | hallowed",
    "summary": "In This Section No game is truly complete without sound, whether is is a melodious background track, one off sound effects or even recapturing the players voice through a microphone. Without sound games lack depth (although also remember for accessibility, some hear sounds through audio description!, make sure to be inclusive.) The following articles showcase some of the best ways to get sound out of your game: Playing a Sound Demonstrates how to play a simple sound by using SoundEffect. Looping a Sound Demonstrates how to loop a sound. Adjusting Pitch and Volume Demonstrates how to change pitch and volume of a playing sound. Playing a Song Demonstrates how to play a song from a media file. Streaming Data from a WAV File Demonstrates how to stream audio from a wave (.wav) file. Accessing Microphone devices Topics that provide guidance on writing code to support access to microphones for MonoGame. Recording Sound with a Microphone Demonstrates the basics of recording audio using a microphone attached to a device."
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/howto/content_pipeline/HowTo_Add_XML.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/howto/content_pipeline/HowTo_Add_XML.html",
    "title": "How to add a custom XML Content File to a Project? | hallowed",
    "summary": "Custom game data that is expressed in an XML format can be easily integrated into your game through the MonoGame Content Pipeline. This example demonstrates the procedure for integrating custom XML data into the content project of a simple game for the Windows platform. Important This tutorial assumes you are using Visual Studio as your IDE, for VSCode, follow this guide from Microsoft for creating multi-project solutions from the command-line utilizing the MonoGame Project and MonoGame Class library templates. To define game data Within the MonoGame solution, you create a new Windows Game Library project. Right-click the solution node, point to Add, click New Project, and then select the MonoGame Game Library template. Tip A MonoGame Game Library project is created instead of a Content Pipeline Extension Library project so that the class we will define can be used by both the Content Importer that runs at build-time and the Content Loader at game runtime. Important For MonoGame 3.8.2 and below, make sure to keep the project at .NET 6 or below. The MGCB tool for 3.8.2 CANNOT understand or read .NET 8 libraries as it is compiled with .NET 6. The Game project can use a higher version, but library projects must stay at .NET 6 else they cannot be read. In the Name box, type MyDataTypes, and then click OK. In the Solution Explorer, delete the existing Game1.cs as it is not needed. right-click and select Add -> Add New Item to add a new class, call it PetData.cs Double click on PetData.cs and replace its contents with the following code to define the PetData class. namespace MyDataTypes { public class PetData { public string Name; public string Species; public float Weight; public int Age; } } Build the MyDataTypes project for debug or release to generate the library's dll file (note which profile you used). Add an XML file using the custom data to the game content In this procedure, the MyDataTypes library is added as a reference in the content project. Build the MyDataTypes project, making not of whether it is a Debug or Release build. Note It is recommended to always use the same built type for building library projects, as they normally only contain \"types\" it is safe to just build them as Release. The reason being that you cannot CHANGE the reference once made in the MGCB editor and it is not affected by the Build Type used to generate the project. In the Solution Explorer or your game project, right-click the game content folder, point to Add, and then click New Item. In the Add New Item dialog box, type pets.xml as the file name, and then click OK. Replace the contents of the template file with the following XML code: <?xml version=\"1.0\" encoding=\"utf-8\" ?> <XnaContent> <Asset Type=\"MyDataTypes.PetData[]\"> <Item> <Name>Fifi</Name> <Species>Dog</Species> <Weight>11</Weight> <Age>6</Age> </Item> <Item> <Name>Bruno</Name> <Species>Dog</Species> <Weight>21</Weight> <Age>12</Age> </Item> <Item> <Name>Chloe</Name> <Species>Cat</Species> <Weight>6</Weight> <Age>3</Age> </Item> <Item> <Name>Pickles</Name> <Species>Hamster</Species> <Weight>0.4</Weight> <Age>1</Age> </Item> </Asset> </XnaContent> Tip TO learn how to generate the custom MonoGame XML content from your own classes, refer to the How to Generate custom XML guide. Open the MGCB Editor from the Game project (not the library) by selecting the .mgcb file and either Double-clicking it (Visual Studio) or Right-clicking it and selecting Open (VSCode). Tip If you have any issues opening the MGCB content project, please refer to the How to load content guide. In the MGCB Editor, select the \"Content\" node and the top and then locate the References section in the Properties window, as shown below: MGCB Editor window properties Click the References VALUE field and a new window should pop up allowing you to manage the references for the MGCB project: MGCB editor references window In the Reference Editor window, click Add, and navigate to the MyDataTypes project and locate the built dll, normally under bin/release/net8.0 (or DEBUG if you use the debug build). Once selected, click Open and the reference should be added to the Reference Editor as shown above. Tip If the folder is empty, return to visual studio and build the MyDataTypes project, if it is not built, there is no dll. And make sure to choose either the debug or release folder depending on how the class library is built. Click on Add Existing from the Edit -> Add options in the menu (or the Add Existing toolbar button) and select the pets.xml file. When you press F6 to build the solution, it should build successfully, including the custom game content imported from the XML file. Important Adding the the class library of the data types project to the Content project is critical, else the Content Pipeline does not know how to serialize or deserialize the custom data you have defined. Although it is possible to simply serialize value types or value type arrays without this step. To load the data at runtime, see the tutorial Loading XML Content at Runtime. See Also Using an XML File to Specify Content Adding Content to a Game"
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/howto/content_pipeline/HowTo_ExtendFontProcessor.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/howto/content_pipeline/HowTo_ExtendFontProcessor.html",
    "title": "How to Extend the Font Description Processor to Support Additional Characters? | hallowed",
    "summary": "In a font description (.spritefont) file, the <CharacterRegions> area can be used to add additional characters to a font description. This enables you to use a SpriteFont to render an additional range of characters. For some languages, this approach is not ideal. For example, Chinese and Japanese both have many thousands of characters. Adding the full range of characters to <CharacterRegions> dramatically increases the size of the font asset and the time required to build the font asset. A better solution adds individual characters whenever the specific characters are needed. You can create a custom content processor to implement this solution. In this example, a file called messages.txt contains all the text rendered by the game. The custom processor adds all the characters contained in the text in this file to a FontDescription. Then it processes the object in the standard way using the base FontDescriptionProcessor functionality. All the characters in messages.txt will then be available to the SpriteFont object at run time. Important This tutorial assumes you are using Visual Studio as your IDE, for VSCode please adapt the IDE interactions appropriately. Using the Font Description Processor create a new MonoGame project called FontGame using the MonoGame template of your choice (for simplicity choose a desktop template) Add a new SpriteFont called DefaultFont to a game project by opening the MGCB Editor, then right-click the Content node, click Add, and then click New Item. Add the new SpriteFont to the game by selecting the SpriteFont Description (.spritefont) template, name the font DefaultFont and then click Add. Modify this file to use an existing font and any additional characteristics you prefer. For more information, see Sprite Font XML Schema Reference. Add a new text file named messages.txt to the game project by right-clicking on the FontGame project node in Solution Explorer, click Add, and then click New Item. Select the Text File template, enter messages.txt for the file name, and then click Add to add the text file to the game. In the new text file, enter any messages that will be printed by the font described in the Sprite Font file. We will use the method File.ReadAllText to read the text in this file. This method requires a carriage return (\"\\r\") or line feed (\"\\n\") after the last string, so be sure to follow the last line of text in the file with a carriage return or line feed. To create the new content processor project The Content Pipeline is part of the build process and it is separate from your game code, therefore you need to create a new assembly that contains the code developed in this topic. Creating this new assembly project is the first step in developing a new processor. To add the new processor project to the game solution, go to Solution Explorer, right-click the Solution node, click Add, and then click New Project. In the dialog box, select the template MonoGame Content Pipeline Extension (MonoGame Team)), enter MyFontProcessor in the Name field, and then click OK. The new project automatically contains references to the MonoGame Framework run-time and design-time Content Pipeline assemblies. To extend the font processor Open the Processor1.cs which is the template Content Processor example. Add the following lines of code, after the last using statement: using System.IO; using System.ComponentModel; Remove the placeholder code that assigns the processor input (TInput) and output (TOutput) types, including the `Process\" method. They will not be needed. Change the base class of Processor1 from ContentProcessor<TInput, TOutput> to FontDescriptionProcessor, which identifies it as a SpriteFont processor. [NOTE] You can read all about the different types of built-in processors in the API docs Content.Pipeline.Processors Change the class name and the Processor display name to something a little more unique, so that we know which processor we are selecting, from \"Processor1\" to \"MyFontProcessor\". [ContentProcessor(DisplayName = \"MyFontProcessor\")] internal class MyFontProcessor : FontDescriptionProcessor Add a new processor parameter (property) to the the class declaration and adorn it with C# Attributes to state additional processing parameters for the property. This parameter stores the name of the text file that stores the messages displayed by the game. [DefaultValue(\"messages.txt\")] [DisplayName(\"Message File\")] [Description(\"The characters in this file will be automatically added to the font.\")] public string MessageFile { get { return messageFile; } set { messageFile = value; } } private string messageFile = @\"../messages.txt\"; Note As the \"messages.txt\" file is not in our content project, we need to supply a path \"relative\" to the \"Content\" project where the Content Processor is running from. Hence the path to the file is denoted as @\"../messages.txt\". Add a new Process method override to match the following code: public override SpriteFontContent Process(FontDescription input, ContentProcessorContext context) {} This modification replaces the template parameter and return types with the proper types needed for the extended font processor. Inside the Process method, register a Content Pipeline dependency on messages.txt, which will read specifically from a file by that name from the Game Project. This dependency tells the Content Pipeline that if messages.txt changes, the font must be rebuilt. string fullPath = Path.GetFullPath(MessageFile); context.AddDependency(fullPath); Next, we add functionality to read the contents of the file and add each letter to the input font one by one. Note that the Characters collection keeps track of duplicates automatically, it is not necessary for the user to make sure that each letter is added only once. The Characters collection will contain only one instance of each character, no matter how many times Add has been called. string letters = File.ReadAllText(fullPath, System.Text.Encoding.UTF8); foreach (char c in letters) { input.Characters.Add(c); } Note In this example, messages.txt has been saved with Unicode UTF-8 encoding, which is the default encoding format that is specified in the call to File.ReadAllText. However, the default file encoding format for text files that have been added to a Visual Studio project is Western European (Windows) encoding, corresponding to code page 1252. If your text file uses a different encoding, specify the character encoding as follows: string letters = File.ReadAllText( fullPath, System.Text.Encoding.GetEncoding( 1252 ) ); Finally, call the Base Process method of the FontDescriptionProcessor to build the font with the newly requested characters. return base.Process(input, context); Done. If your txt file is located elsewhere, make sure to update the path to the file appropriately, FROM the content project folder in the Processor project. Final code: using Microsoft.Xna.Framework.Content.Pipeline; using Microsoft.Xna.Framework.Content.Pipeline.Graphics; using Microsoft.Xna.Framework.Content.Pipeline.Processors; using System.ComponentModel; using System.IO; namespace FontProcessor { [ContentProcessor(DisplayName = \"MyFontProcessor\")] internal class MyFontProcessor : FontDescriptionProcessor { public override SpriteFontContent Process(FontDescription input, ContentProcessorContext context) { string fullPath = Path.GetFullPath(MessageFile); context.AddDependency(fullPath); string letters = File.ReadAllText(fullPath, System.Text.Encoding.UTF8); foreach (char c in letters) { input.Characters.Add(c); } return base.Process(input, context); } [DefaultValue(\"messages.txt\")] [DisplayName(\"Message File\")] [Description(\"The characters in this file will be automatically added to the font.\")] public string MessageFile { get { return messageFile; } set { messageFile = value; } } private string messageFile = @\"../messages.txt\"; } } Associate the custom font processor with the sprite font in the MGCB tool Compile the solution to build MyFontProcessor, as you need to add your custom font processor as an available content processor for the content pipeline. Open the MGCB tool for your Content project, click (select) the Content node, navigate down to the properties section and then click in the References property. MGCB Editor window properties Navigate to the dll for the built MyFontProcessor project (which by default is in \\FontGame\\MyFontProcessor\\bin\\debug\\net6.0), select it and click \"open\". [IMPORTANT] Ensure that the processor project is always up to date when the main game is built, you need to create a project dependency. Also use either \"debug\" or \"Release\" build types for the processor project, the MGCB tool will NOT dynamically select it when you change the Projects build type. Build the Content Project to ensure everything is connected as it should be. Select the .spritefont file, and then in the Properties window change the processor toMyFontProcessor in the drop-down list associated with the ContentProcessor field. When you build the solution, the new processor adds the characters in the messages.txt file to the list of characters available to the SpriteFont. See Also Extending a Standard Content Processor Adding New Content Types"
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/howto/content_pipeline/HowTo_Extend_Processor.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/howto/content_pipeline/HowTo_Extend_Processor.html",
    "title": "How To Extend a Standard Content Processor? | hallowed",
    "summary": "MonoGame lets you modify or extend the behavior of any standard Content Pipeline processor that ships with the product. See Standard Content Importers and Content Processors for a description of standard processors. Because there are so many asset variants supported by different digital content creation (DCC) tools, it is often useful to be able to modify how one of the standard processors operates. The following examples illustrate some of the kinds of things you might want to do. Tip The following code samples are provided only for demonstration. Most of the functionality described is already available by using parameters on a standard processor. Adding a Scaling Operation to a Processor There are many reasons why you might want to modify the existing functionality of a standard processor. Here is one example. If your source assets and your game are at different scales, you may want the processor to scale each model automatically at build time. You can implement such automatic scaling by overriding the Process method of the ModelProcessor class, which generates a Model. In the override, you first scale the entire scene, and then invoke the base class functionality to process as usual. The following code illustrates this technique: [ContentProcessor] class ScalingModelProcessor : ModelProcessor { public override ModelContent Process( NodeContent input, ContentProcessorContext context ) { MeshHelper.TransformScene( input, Matrix.CreateScale( 10.0f ) ); return base.Process( input, context ); } } Generating Additional Data In some cases, you may want to add information to a game asset that a standard processor would not. For example, if a custom effect you want to apply requires tangent or binormal data, you can extend the standard model processor to build this additional data into the asset. To do this, you override the Process method of the ModelProcessor class. In the override, navigate the NodeContent hierarchy of the game asset, and call CalculateTangentFrames for each MeshContent object you find. The following code shows how to do this: [ContentProcessor] class ModelProcessorWithTangents : ModelProcessor { public override ModelContent Process( NodeContent input, ContentProcessorContext context ) { GenerateTangentFramesRecursive( input ); return base.Process( input, context ); } private void GenerateTangentFramesRecursive( NodeContent node ) { MeshContent mesh = node as MeshContent; if (mesh != null) { MeshHelper.CalculateTangentFrames( mesh, VertexChannelNames.TextureCoordinate( 0 ), VertexChannelNames.Tangent( 0 ), VertexChannelNames.Binormal( 0 ) ); } foreach (NodeContent child in node.Children) { GenerateTangentFramesRecursive( child ); } } } Changing the Processors Called for Child Objects Another useful technique is to override a standard processor, and to change how child objects are processed just by changing the processors they use. Consider, for example, the hierarchy of calls through which textures in a model are processed: The standard ModelProcessor.Process method is called to process a NodeContent object that represents the root of a scene. ModelProcessor.Process in turn calls the ModelProcessor.ConvertMaterial method once for every MaterialContent object used in the scene. ModelProcessor.ConvertMaterial in turn invokes the MaterialProcessor.Process method on the MaterialContent object passed to it. MaterialProcessor.Process in turn calls the MaterialProcessor.BuildTexture method once for each texture in the MaterialContent.Textures collection in the MaterialContent object passed to it. MaterialProcessor.BuildTexture in turn invokes the ModelTextureProcessor.Process method on the TextureContent object passed to it. One reason you may want to change how this works is that the ModelTextureProcessor.Process method applies texture compression to all textures it processes. This could be DXT1, DXT5, PVRTC, ETC1, RGBA4444 or ATITC depending on target your platform. If textures in your game assets are compressed already, you may want to avoid a second compression. Tip Not all platforms support all types of texture compression. For example DXT1/5 are generally only supported on Desktop graphics cards and some NVidia mobile graphics cards. PVRTC is only supported on iOS and some Android devices with PowerVR graphics cards, and ATITC is only supported on ATI graphics cards. Using the Compressed setting for TextureCompression for the Texture Processor will let the Pipeline pick the best compression for your target platform. To prevent compression of textures during processing Here is how to prevent compression from being applied to model textures during processing. Create an override of the standard MaterialProcessor.BuildTexture method, and invoke the TextureProcessor.Process method, which does no compression, instead of ModelTextureProcessor.Process. Create an override of ModelProcessor.ConvertMaterial that invokes your override of MaterialProcessor.BuildTexture instead of the standard one. The first of these overrides could be coded as: [ContentProcessor] class NoCompressionMaterialProcessor : MaterialProcessor { protected override ExternalReference<TextureContent> BuildTexture( string textureName, ExternalReference<TextureContent> texture, ContentProcessorContext context ) { return context.BuildAsset<TextureContent, TextureContent>( texture, \"TextureProcessor\" ); } } There are several things to note about this code. An ExternalReference is an asset object that is shared between multiple classes, such as a diffuse texture used by more than one material. When such an asset is specified, the Content Manager loads only one copy of the ExternalReference at run time and builds it only once, no matter how many references there are to it. The ContentProcessorContextBuildAsset method lets you invoke a processor by name to build the content in an object. Although textureName, the first argument to BuildTexture, is ignored in the override above, you could use it if you wanted to process textures differently depending on normal maps or other criteria. Given the processor created by your first override above, you could code the second override: [ContentProcessor] class NoCompressionModelProcessor : ModelProcessor { protected override MaterialContent ConvertMaterial( MaterialContent material, ContentProcessorContext context ) { return context.Convert<MaterialContent, MaterialContent>( material, \"NoCompressionMaterialProcessor\" ); } } Because this override is processing MaterialContent objects in memory rather than ExternalReference objects, it uses the ContentProcessorContext.Convert function instead of BuildAsset to invoke the processor created by your first override. After building and installing your new NoCompressionModelProcessor (see Adding a Custom Importer), you can assign it to any models whose textures are already compressed and no further compression is applied. See Also Adding New Content Types What Is Content? What is the Content Pipeline? Standard Content Importers and Content Processors Adding a Custom Importer"
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/howto/content_pipeline/HowTo_GameContent_Add.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/howto/content_pipeline/HowTo_GameContent_Add.html",
    "title": "How to add Content to your game | hallowed",
    "summary": "Tip For help with creating a project, please look at the Creating a New Project section of the Getting Started guide. MonoGame Content Builder Tool (MGCB Editor) The MGCB editor is installed as a \"local\" DotNet tool with your project, utilizing the dotnet-tools.json configuration file located in the .config folder of your project. You will need to install either the Visual Studio 2022 MonoGame extension or the MonoGame Content Builder (editor) extension for VSCode. If you are not using the extension, you will need to manually install and use the MGCB Editor. Note This is technically optional, since you can edit the .mgcb files manually if you wish, but the editor is highly recommended for ease of use. If you are unsure of your setup, please follow one of the \"Setting up your development environment\" articles in the \"Getting Started\" section of the Documentation Site Adding content First, you will need some content for your game. For this tutorial, use the following image of a ball: Copy the image to your machine by using right-click > Save Image As and save it somewhere locally with the name “ball.png”. VSCode Visual Studio Note Requires the MonoGame Content Builder (editor) extension for VSCode. Now open up your game project and look at the Explorer window. Expand the Content folder and open up Content.mgcb file by right-clicking on it and selecting Open in MGCB editor. Note Requires the MonoGame extension for Visual Studio to be installed. Now open up your game project and look at the Solution Explorer window. Expand the Content folder and open up Content.mgcb file by double-clicking on it. If a text file opens instead, then right-click on Content.mgcb and select Open With, then select MGCB Editor in the list, click Set as Default and then click OK, then try again. Note If you do not see the MGCB Editor option when you right-click and select Open With, then please review the Tools documentation for installing the MGCB Editor tool for your operating system. You should now see the MGCB Editor window open up. Your game content is managed from this external tool. You can add content to your game in one of the following ways: Add Existing Item toolbar button Edit > Add > Existing Item... menu button right-click > Add > Existing Item... context menu Make sure the Content MGCB file is selected to the left, then click the Add Existing Item toolbar button. You should now be prompted to select a file. Select the “ball.png” image that you downloaded a moment ago. Once you have confirmed your selection, you will be asked whether to copy the file, add a link to it, or skip it. Make sure \"Copy the file to the directory\" option is selected and click Add. Now click the Save toolbar button and close the MGCB Editor tool. Adding the content in your game Now that you have added the asset to the Content project, it is time to load it into your game. First, open up the Game1.cs class file and declare a new ballTexture variable of type Texture2D in the Game1 class, so you can store the ball image into memory. public class Game1 : Game { Texture2D ballTexture; private GraphicsDeviceManager _graphics; private SpriteBatch _spriteBatch; Next, find the LoadContent method. Here, use Content.Load() function to load the \"ball\" sprite and store it in the ballTexture parameter. Content.Load<T>() requires you to specify what type of content you are trying to load, in this case it is a Texture2D. protected override void LoadContent() { // Create a new SpriteBatch, which can be used to draw textures. _spriteBatch = new SpriteBatch(GraphicsDevice); // TODO: use this.Content to load your game content here ballTexture = Content.Load<Texture2D>(\"ball\"); } Finally, find the Draw method to draw the ball onto the screen. This is done by: Opening a SpriteBatch (an image drawing collection function). Adding the images you want to draw and specifying where you want to draw them. Then finally closing the SpriteBatch to commit the textures you want drawn to the screen. Note If you add multiple images, they will be drawn in the order you place them from back to front (each drawn on top of each other). As shown below: protected override void Draw(GameTime gameTime) { graphics.GraphicsDevice.Clear(Color.CornflowerBlue); // TODO: Add your drawing code here _spriteBatch.Begin(); _spriteBatch.Draw(ballTexture, new Vector2(0, 0), Color.White); _spriteBatch.End(); base.Draw(gameTime); } Now run the game. You should get the following:"
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/howto/content_pipeline/HowTo_GenerateCustomXML.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/howto/content_pipeline/HowTo_GenerateCustomXML.html",
    "title": "How to create a custom XML File? | hallowed",
    "summary": "The IntermediateSerializer class of the MonoGame Framework can be employed by custom tools running under Windows to directly serialize game data to an XML file. An XML file generated in this way then can be included in the game project and imported by XmlImporter Class as part of the Content Pipeline. Because XmlImporter is actually a wrapper for IntermediateSerializer, it is certain that the XML file will be in the correct format to be deserialized by the same facility. The IntermediateSerializer class is controlled through the XmlWriter class of the .NET Framework defined in System.Xml. The properties of the XmlWriterSettings class can be used to specify its output properties. The serializer produces its output according to these rules: All public fields and properties are serialized; a separate XML element is used for each. Protected, private, or internal data is skipped. Get-only or set-only properties are skipped. Properties come before fields. If there is more than one field or property, these are serialized in the order they are declared. Nested types are serialized using nested XML elements. When the class derives from another, members of the base class are serialized before data from the derived type. XML Serialization Example The following steps create a simple program that demonstrates how a program can use the IntermediateSerializer method IntermediateSerializer.Serialize Generic Method to serialize program data to an XML file. Step 1: Create a New Project You will create a new project in Visual Studio. On the File menu, click New, and then click Project. In the New Project dialog box, ensure Windows is selected in the Project types pane, and then click Console Application in the Templates pane. Open the new project, then in the Solution Explorer, right-click the Dependencies folder, and then click Manage NuGet Packages... Click on the Browse tab (if not selected) and search for the MonoGame.Framework.Content.Pipeline package, and then click Install. Accept any dialog prompts for Licenses or dependencies as they appear. Additionally, install the MonoGame.Framework.DesktopGL NuGet package which is required by the Content.Pipeline package. Step 2: Add XML Serialization In the Solution Explorer, double-click Program.cs to edit it. Add using declarations for the System.Xml and Microsoft.Xna.Framework.Content.Pipeline.Serialization.Intermediate namespaces. using System.Xml; using Microsoft.Xna.Framework.Content.Pipeline.Serialization.Intermediate; Define a class to serialize to XML with the properties you wish to store in your custom XML. namespace XMLSerializerTest { class MyData { public int elf = 23; public string hello = \"Hello World\"; } } Within the function Main of the Program class, add the following code. This code employs IntermediateSerializer.Serialize Generic Method to serialize the MyData class as an XML file. class Program { static void Main(string[] args) { MyData ExampleData = new MyData(); XmlWriterSettings settings = new XmlWriterSettings(); settings.Indent = true; using (XmlWriter writer = XmlWriter.Create(\"example.xml\", settings)) { IntermediateSerializer.Serialize(writer, ExampleData, null); } } } Step 3: Generate XML Press F5 to build and execute the program. Examine the example.xml file in the project's bin\\\\Debug\\\\netx.0 folder. Note netx.0 relates to the version of .NET your project is building under, net6.0 for .NET 6 and net8.0 for .NET 8 You should have an output that looks like the following: <?xml version=\"1.0\" encoding=\"utf-8\"?> <XnaContent xmlns:XMLSerializerTest=\"XMLSerializerTest\"> <Asset Type=\"XMLSerializerTest:MyData\"> <elf>23</elf> <hello>Hello World</hello> </Asset> </XnaContent> See Also Concepts Using an XML File to Specify Content Adding Content to a Game Reference IntermediateSerializer Class"
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/howto/content_pipeline/HowTo_LoadContentLibrary.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/howto/content_pipeline/HowTo_LoadContentLibrary.html",
    "title": "How to load content within a Game Library? | hallowed",
    "summary": "There are two advanced techniques to load content files from within a game library, one in which the binary content is separate from the .DLL, and one in which the content is embedded within the .DLL. Loading Content in a custom Game Library Embedding Content in a Game Library Important These approaches assume you are using Visual Studio as your IDE, it is not recommended to use VSCode due to the nature in which assets are added to the project, although you are free to find the .NET commands to achieve this. Loading Content in a custom Game Library In this method, the compiled content used by the game library is distributed in its own .xnb files, separate from the .DLL. This is the preferred method in most cases, as it makes the most efficient use of memory, especially when binary content is large. To create compiled content Create a new solution that contains a game library project. Add a game content project to the solution. In a library project, choose Add, New Item, and select \"Resources File.\" Select the game library project, then right-click and choose Add Content Reference..., and select the game content project you just created. When the solution is built, the resources in the content project will be compiled into binary .xnb files. These files will reside in the \"bin\\x86\\Debug\\Content\" directory of the game library project (if built as an x86 debug project). To load compiled content within the Game Library Create a new class that is the child of DrawableGameComponent. Define a new ContentManager and, within the constructor of the new class, set its RootDirectory to the path where the compiled content is to be stored. For flexibility, the path string may be a parameter passed to the constructor by the game client. public static ContentManager LibContent; public GameLibComponent(Game game, string contentdirectory) : base(game) { LibContent = new ContentManager(game.Services); LibContent.RootDirectory = contentdirectory; } In the Game.LoadContent method, load your content normally using your ContentManager. SpriteBatch spriteBatch; Texture2D LibTexture; protected override void LoadContent() { spriteBatch = new SpriteBatch(GraphicsDevice); LibTexture = LibContent.Load<Texture2D>(\"mytexture\"); } Embedding Content in a Game Library You may also embed binary content resources directly in the Game Library and load them from within. This technique requires the declaration of those resources in a reference file. It allows you to distribute code that displays textures, models, or fonts (such as a DrawableGameComponent) in a .DLL without distributing the .xnb files separately. Note Be aware that all embedded resources are loaded into memory with the .DLL, and cannot be unloaded from main memory. For this reason, this technique is not recommended for most applications, and should only be used when the content to embed is very small. To add content to a Game Library as references Build an existing project containing the content you wish to add. In a library project, choose Add, New Item, and select \"Resources File\". If the Resource Designer is not opened automatically, double-click the .resx file in the Solution Explorer. From the Resource Designer, choose Add Resource, Add Existing File. Navigate to the \"bin\\x86\\Debug\\Content\" directory of the project that built the content you wish to add. This assumes it was built as an x86 Debug project. Select the .xnb files for the content you wish to add to the library. Ensure the dialog box is displaying \"All Files\". Once content has been added to the Resource Designer, any code running from within the Library can load the content with a special ContentManager. To load embedded content within a Game Library Create a new class that is the child of DrawableGameComponent. Define a new ContentManager. Within the constructor of the new class, create a new instance of the ResourceContentManager class and assign it to your ContentManager. The second parameter to the ResourceContentManager constructor identifies the resource project that contains your embedded resources. public static ContentManager LibContent; public GameLibComponent(Game game) : base(game) { ResourceContentManager resxContent; resxContent = new ResourceContentManager(game.Services, ResourceFile.ResourceManager); LibContent = resxContent; } In the Game.LoadContent method, load your content normally using your ContentManager. SpriteBatch spriteBatch; Texture2D LibTexture; protected override void LoadContent() { spriteBatch = new SpriteBatch(GraphicsDevice); LibTexture = LibContent.Load<Texture2D>(\"mytexture\"); } See Also Reference Game Class Game.LoadContent UnloadContent Game Members Microsoft.Xna.Framework Namespace"
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/howto/content_pipeline/HowTo_Load_XML.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/howto/content_pipeline/HowTo_Load_XML.html",
    "title": "How to load XML Content at Runtime? | hallowed",
    "summary": "This example concludes the procedure begun in the tutorial Adding an XML Content File to a Visual Studio Project. Once custom game data is integrated as game content from an XML file through the Content Pipeline, it exists within your game runtime package in binary format. The data can be loaded at runtime through the ContentManager. Important This tutorial assumes you are using Visual Studio as your IDE, for VSCode please adapt the IDE interactions appropriately. Add a SpriteFont for testing While not essential for loading XML, in order to demonstrate the loaded data and write it to the screen, we will add a SpriteFont to enable the drawing of strings. In the Solution Explorer, Double-click the Content.mgcb in the Content folder to open the MGCB editor. Tip If you have any issues opening the MGCB content project, please refer to the How to load content guide. Click on Edit -> New Item, then name the file Font and select SpriteFont Description as the type. Click on Create to finish. Save the content project and then continue. To load the custom data in the game To add the MyDataTypes library as a reference in the game project, In the Solution Explorer, right-click the game project, click Add Reference, click the Projects tab, select MyDataTypes, and then click OK. Then in the Solution Explorer, double-click Game1.cs to edit it. Add the using declaration for the MyDataTypes namespace at the top of the file beneath the existing usings statements. using MyDataTypes; Add a data declaration for an array of type PetData after the other private variables in the Game1 class. private PetData[] pets; In the Game.LoadContent override function, load the custom content. protected override void LoadContent() { // Load the pet data table pets = Content.Load<PetData[]>(\"pets\"); } The custom game data now resides in the array of PetData objects. The data loaded from the XML file into the PetData array can be accessed normally as c# code, for example, the following Draw code will render the data from the XML file to the screen if found, else it will write a warning. protected override void Draw(GameTime gameTime) { GraphicsDevice.Clear(Color.CornflowerBlue); _spriteBatch.Begin(); // Check if the XML data was loaded into the pets data array. if (pets != null) { // For each pet, write its data to the screen. for (int i = 0; i < pets.Length; i++) { var pet = pets[i]; _spriteBatch.DrawString(Content.Load<SpriteFont>(\"Font\"), $\"{pet.Name} / {pet.Species}: Weight [{pet.Weight}] - Age: [{pet.Age}]\", new Vector2(100, 100 + 20 * i), Color.White); } } else { // If no data was loaded (or there was an error) write `No Pets found` to the screen. _spriteBatch.DrawString(Content.Load<SpriteFont>(\"Font\"), \"No pets found\", new Vector2(100, 100), Color.White); } _spriteBatch.End(); base.Draw(gameTime); } The result of loading the XML and rendering the data should display as follows: See Also Using an XML File to Specify Content Adding Content to a Game"
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/howto/content_pipeline/HowTo_PackageTextures_On_Android.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/howto/content_pipeline/HowTo_PackageTextures_On_Android.html",
    "title": "How to package Textures for Android? | hallowed",
    "summary": "The Android ecosystem is unique in that the hardware it runs on can be from many different manufacturers. Unlike iOS or PC, you cannot always guarantee what graphics card a user will be using. For this reason, Android needs to have some special attention when shipping your game. Texture Compression As stated in \"Why use the Content Pipeline\", you need to be aware of the performance limitations on mobile devices. The graphics cards on mobile phones do not have the same kind of capabilities as those on the PC or Consoles. They usually have less memory and less power. So you need to make use of what you have in a more efficient way. One of these ways is to use Texture Compression. As stated in \"Why use the Content Pipeline\", this allows you to fit more textures on the graphics card than you could if you just used raw RGBA textures. How Android deals with textures Fortunately, the Android engineers recognized that supporting all of these texture compression formats was not an easy task. So, with the introduction of the .aab file format, they added the ability to add multiple texture format files to the package. The way the .aab works is that it is not the final .apk. The final .apk will be built from the .aab when the game is delivered to the en- user device. As a result, not all of the files in the .aab will make it to the device. It will filter out things like .so files for other cpu types, and yes, texture formats. The .aab supports the following directory suffixes for texture compression: Texture Format Suffix PVRTC #tcf_pvrtc ATC #tcf_atc ASTC #tcf_astc S3TC #tcf_s3tc DXT1 #tcf_dxt1 ETC1 #tcf_etc1 ETC2 #tcf_etc2 Note see https://developer.android.com/guide/playcore/asset-delivery/texture-compression MonoGame has its own TextureProcessorOutputFormat enumeration. It describes the type of Texture Compression you use when processing an image. The following table shows you how to map that to the Suffix: TextureProcessorOutputFormat Suffix PvrCompressed #tcf_pvrtc AtcCompressed #tcf_atc AstcCompressed #tcf_astc DxtCompressed #tcf_s3tc Etc1Compressed #tcf_etc1 EtcCompressed #tcf_etc2 Compressed or Color No Suffix Adding Texture Compression Suffixes With the latest MonoGame we added support for being able to have one texture with multiple outputs. Previously it would only build the last item, but this has been fixed. In the Content Editor: Add a new folder for your desired Suffix. This is usually in the form of Textures<suffix>. Right-click on the new folder and Add an Existing File. Select the file you want to use for this Suffix and Add it In the Properties of the new file change the TextureFormat to the one that matches the desired Suffix. In the .mgcb file directly you can do the following /processorParam:TextureFormat=PvrCompressed /build:Textures/LogoOnly_64px.png;Textures#tcf_pvrtc/LogoOnly_64px As documented the /build command takes an optional <destination_filepath> after the <content_filepath>. We can use this to provide the target folder for our output. So in the example above, the LogoOnly_64px.png file will be compressed using PvrCompressed and then the output will end up in Textures#tcf_pvrtc. Important Some texture formats have specific size requirements. For example PVRTC Compressed Textures MUST be a Power of 2 and Square (e.g 1024x1024). Many others need to be Power of 2. It is recommended that you make all your textures Power of 2 just to make life easier. Supporting Multiple Texture Compression Types To allow your game to work on as many devices as possible we need to support multiple compression formats. Now that we know how to specify a specific texture compression format for a texture, how do we go about supporting multiple formats? It is really quite simple. We can duplicate the entry for each texture and specify a different /processorParam:TextureFormat and output path. For example, the following code is how we would build both pcrtc and dxt formats. #begin Textures/LogoOnly_64px.png for PvrCompressed /importer:TextureImporter /processor:TextureProcessor /processorParam:TextureFormat=PvrCompressed /build:Textures/LogoOnly_64px.png;Textures#tcf_pvrtc/LogoOnly_64px #begin Textures/LogoOnly_64px.png for DxtCompressed /importer:TextureImporter /processor:TextureProcessor /processorParam:TextureFormat=DxtCompressed /build:Textures/LogoOnly_64px.png;Textures#tcf_s3tc/LogoOnly_64px In the Content Editor: Add a new folder for your desired Suffix. This is usually in the form of Textures<suffix>. Right click on the new folder and Add an Existing File. Select the file you want to use for this Suffix and Add it In the Properties of the new file change the TextureFormat to the one that matches the desired Suffix. As you can see, supporting multiple texture compression formats is quite easy. Sample .mgcb #begin Textures/LogoOnly_64px.png /importer:TextureImporter /processor:TextureProcessor /processorParam:ColorKeyColor=255,0,255,255 /processorParam:ColorKeyEnabled=True /processorParam:GenerateMipmaps=False /processorParam:PremultiplyAlpha=True /processorParam:ResizeToPowerOfTwo=True /processorParam:MakeSquare=False /processorParam:TextureFormat=PvrCompressed /build:Textures/LogoOnly_64px.png;Textures#tcf_pvrtc/LogoOnly_64px Using Android Asset Packs The Google Play Store has some fairly strict limitations on package sizes for Android apps. However there are ways to extend these limits for large games and apps, which are known as Asset Packs. Simply put, an Asset Pack is a way to organize your game content/assets into separate pieces which can be downloaded shortly after installation or dynamically at runtime. For most games using the Install Time packs are the best option. Using them in your game can be quite straight forward. It only requires a little bit of MSBuild markup in your Android platform .csproj. <Target Name=\"_MoveContentIntoPacks\" AfterTargets=\"IncludeContent\"> <ItemGroup> <AndroidAsset Update=\"Content/Music/**/*.*\" AssetPack=\"MyGameAssets\" /> </ItemGroup> </Target> This adds an MSBuild target to your project which will process all the items in the Content/Music folder and subfolders. It will place them in an Asset Pack called MyGameAssets. You can change the name of this pack as you wish. By default, this will be an InstallTime pack. So it will be installed at the same time as your game is. There is no need to do anything else, the assets will be placed in the usual location and opened via Content.Load<T>. If you are using dynamic delivery and install packs at runtime, you will need to open the content from a different location. This is out of scope for this document. If you want to learn more about how to use these features please check out the following links: Android Asset Packs Android Asset Packs for .NET & .NET MAUI Android Apps Play Asset Delivery Sample .mgcb with Multiple Compression Formats #----------------------------- Global Properties ----------------------------# /outputDir:bin/$(Platform) /intermediateDir:obj/$(Platform) /platform:Android /config: /profile:Reach /compress:False #-------------------------------- References --------------------------------# #---------------------------------- Content ---------------------------------# #begin ContentFont.spritefont /importer:FontDescriptionImporter /processor:FontDescriptionProcessor /processorParam:PremultiplyAlpha=True /processorParam:TextureFormat=Compressed /build:ContentFont.spritefont #begin Textures/LogoOnly_64px.png /importer:TextureImporter /processor:TextureProcessor /processorParam:ColorKeyColor=255,0,255,255 /processorParam:ColorKeyEnabled=True /processorParam:GenerateMipmaps=False /processorParam:PremultiplyAlpha=True /processorParam:ResizeToPowerOfTwo=True /processorParam:MakeSquare=False /processorParam:TextureFormat=Compressed /build:Textures/LogoOnly_64px.png #begin Textures/LogoOnly_64px.png /importer:TextureImporter /processor:TextureProcessor /processorParam:ColorKeyColor=255,0,255,255 /processorParam:ColorKeyEnabled=True /processorParam:GenerateMipmaps=False /processorParam:PremultiplyAlpha=True /processorParam:ResizeToPowerOfTwo=True /processorParam:MakeSquare=False /processorParam:TextureFormat=PvrCompressed /build:Textures/LogoOnly_64px.png;Textures#tcf_pvrtc/LogoOnly_64px #begin Textures/LogoOnly_64px.png /importer:TextureImporter /processor:TextureProcessor /processorParam:ColorKeyColor=255,0,255,255 /processorParam:ColorKeyEnabled=True /processorParam:GenerateMipmaps=False /processorParam:PremultiplyAlpha=True /processorParam:ResizeToPowerOfTwo=True /processorParam:MakeSquare=False /processorParam:TextureFormat=DxtCompressed /build:Textures/LogoOnly_64px.png;Textures#tcf_s3tc/LogoOnly_64px #begin Textures/LogoOnly_64px.png /importer:TextureImporter /processor:TextureProcessor /processorParam:ColorKeyColor=255,0,255,255 /processorParam:ColorKeyEnabled=True /processorParam:GenerateMipmaps=False /processorParam:PremultiplyAlpha=True /processorParam:ResizeToPowerOfTwo=True /processorParam:MakeSquare=False /processorParam:TextureFormat=AtscCompressed /build:Textures/LogoOnly_64px.png;Textures#tcf_atsc/LogoOnly_64px Also see MGCB File Format Why use the Content Pipeline"
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/howto/content_pipeline/HowTo_UseCustomXML.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/howto/content_pipeline/HowTo_UseCustomXML.html",
    "title": "How to use an XML File to Specify Content? | hallowed",
    "summary": "Data tables, for example, are custom data that might describe different characters’ attributes or the features of each level in the game. The content and format of this data is specific to the requirements of the game. Custom game data in the form of an XML file also can be loaded into your game through the standard features of the Content Pipeline. When the Content Pipeline is used, the game does not have to parse the XML format in which the game data is originally stored. Data loaded by the game through ContentManager is read in deserialized form directly into a managed code object. In This Section How to Add custom game data as an XML file Describes how to add custom game data as an XML file through the Content Pipeline. Generating a custom XML File Describes how to use IntermediateSerializer from a Windows application to generate XML content to add to a MonoGame application. Adding an XML Content File to a MonoGame Project Describes how to add custom game data as an XML file through the Content Pipeline. Loading XML Content at Runtime Describes how to load custom game data at game runtime through the Content Pipeline. XML Elements for XMLImporter Describes the elements of an XML file that can be processed by the XmlImporter Class. Sprite Font XML Schema Reference Describes the valid tags and values for Sprite-Font (.spritefont) XML files used by the Content Pipeline to create SpriteFont textures. See Also Concepts Adding Content to a Game"
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/howto/content_pipeline/index.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/howto/content_pipeline/index.html",
    "title": "How To articles for the Content Pipeline | hallowed",
    "summary": "In This Section How to add content Demonstrates how to add content, such as images or sounds, to your game. How to use custom XML Demonstrates how to use a custom XML File to Specify Content. How to Load content from a library Demonstrates how to create A localized game using alternative sets of text that are appropriate to the language and culture of the gamer. How to extend a content processor Describes how MonoGame lets you modify or extend the behavior of any standard Content Pipeline processor. How to Extend the Font Description Processor to Support Additional Characters Describes the process of developing a custom content processor needed to add additional characters to a FontDescription object based on the text that is required by the game. How to Package Textures on Android Describes how to support multiple texture compression formats on Android."
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/howto/graphics/HowTo_Animate_Sprite.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/howto/graphics/HowTo_Animate_Sprite.html",
    "title": "Animating a Sprite | hallowed",
    "summary": "Overview In this example, you will draw a sprite to the screen and then animate the sprite using a custom sprite animation class. End result Note Better animations can be done with better images and more frames, have a look at the Platformer Sample Provided by MonoGame for example. Requirements The example assumes the texture you are loading contains multiple frames of the same size in a texture whose size is uniform (also known as a spritesheet), for example, the following spritesheet contains 8 Images of a character in different phases of motion, when player together it looks like it is animated. Save the spritesheet to your content project and name it \"AnimatedCharacter\" (this name will used to reference it in the project). Note The sample also uses a class named AnimatedTexture, which is included with the sample below. The AnimatedTexture.cs is a helper to simplify the loading and drawing of a texture that contains multiple frames of animation. Drawing an Animated Sprite Follow the steps of How To: Draw a Sprite. A good first step to understanding the loading and drawing of textures and setting up your project. Create a new class called AnimatedTexture.cs in your project and replace its contents with the following: using Microsoft.Xna.Framework; using Microsoft.Xna.Framework.Content; using Microsoft.Xna.Framework.Graphics; /// <summary> /// A helper class for handling animated textures. /// </summary> public class AnimatedTexture { // Number of frames in the animation. private int frameCount; // The animation spritesheet. private Texture2D myTexture; // The number of frames to draw per second. private float timePerFrame; // The current frame being drawn. private int frame; // Total amount of time the animation has been running. private float totalElapsed; // Is the animation currently running? private bool isPaused; // The current rotation, scale and draw depth for the animation. public float Rotation, Scale, Depth; // The origin point of the animated texture. public Vector2 Origin; public AnimatedTexture(Vector2 origin, float rotation, float scale, float depth) { this.Origin = origin; this.Rotation = rotation; this.Scale = scale; this.Depth = depth; } public void Load(ContentManager content, string asset, int frameCount, int framesPerSec) { this.frameCount = frameCount; myTexture = content.Load<Texture2D>(asset); timePerFrame = (float)1 / framesPerSec; frame = 0; totalElapsed = 0; isPaused = false; } public void UpdateFrame(float elapsed) { if (isPaused) return; totalElapsed += elapsed; if (totalElapsed > timePerFrame) { frame++; // Keep the Frame between 0 and the total frames, minus one. frame %= frameCount; totalElapsed -= timePerFrame; } } public void DrawFrame(SpriteBatch batch, Vector2 screenPos) { DrawFrame(batch, frame, screenPos); } public void DrawFrame(SpriteBatch batch, int frame, Vector2 screenPos) { int FrameWidth = myTexture.Width / frameCount; Rectangle sourcerect = new Rectangle(FrameWidth * frame, 0, FrameWidth, myTexture.Height); batch.Draw(myTexture, screenPos, sourcerect, Color.White, Rotation, Origin, Scale, SpriteEffects.None, Depth); } public bool IsPaused { get { return isPaused; } } public void Reset() { frame = 0; totalElapsed = 0f; } public void Stop() { Pause(); Reset(); } public void Play() { isPaused = false; } public void Pause() { isPaused = true; } } In your game's constructor, create an instance of the AnimatedTexture class. This example uses (0,0) as the origin of the texture, no rotation, a scale of 2, and a depth of 0.5. // The reference to the AnimatedTexture for the character private AnimatedTexture spriteTexture; // The rotation of the character on screen private const float rotation = 0; // The scale of the character, how big it is drawn private const float scale = 0.5f; // The draw order of the sprite private const float depth = 0.5f; public Game1() { _graphics = new GraphicsDeviceManager(this); Content.RootDirectory = \"Content\"; spriteTexture = new AnimatedTexture(Vector2.Zero, rotation, scale, depth); } Load the texture to provide the image data for the animation. In this example, the AnimatedTexture class loads a single texture and divides it into frames of animation. It uses the last parameter to determine how many frames to draw each second. In this case, it draws eight frames at three frames per second (fps). // The game visible area private Viewport viewport; // The position to draw the character private Vector2 characterPos; // How many frames/images are included in the animation private const int frames = 8; // How many frames should be drawn each second, how fast does the animation run? private const int framesPerSec = 10; protected override void LoadContent() { // Create a new SpriteBatch, which can be used to draw textures. _spriteBatch = new SpriteBatch(GraphicsDevice); // \"AnimatedCharacter\" is the name of the sprite asset in the project. spriteTexture.Load(Content, \"AnimatedCharacter\", frames, framesPerSec); viewport = _graphics.GraphicsDevice.Viewport; characterPos = new Vector2(viewport.Width / 2, viewport.Height / 2); } In your game's Game.Update method, determine which animation frame to display. protected override void Update(GameTime gameTime) { if (GamePad.GetState(PlayerIndex.One).Buttons.Back == ButtonState.Pressed || Keyboard.GetState().IsKeyDown(Keys.Escape)) Exit(); // TODO: Add your update logic here float elapsed = (float)gameTime.ElapsedGameTime.TotalSeconds; spriteTexture.UpdateFrame(elapsed); base.Update(gameTime); } This is handled by AnimatedTexture's UpdateFrame method, which takes the elapsed seconds between updates as a parameter, as shown below in the except from the \"AnimatedTexture\" class. // class AnimatedTexture public void UpdateFrame(float elapsed) { if (isPaused) return; totalElapsed += elapsed; if (totalElapsed > timePerFrame) { frame++; // Keep the Frame between 0 and the total frames, minus one. frame %= frameCount; totalElapsed -= timePerFrame; } } In your game's Game.Draw method, call SpriteBatch.Draw on the AnimatedTexture object. protected override void Draw(GameTime gameTime) { GraphicsDevice.Clear(Color.CornflowerBlue); // TODO: Add your drawing code here _spriteBatch.Begin(); // Replacing the normal SpriteBatch.Draw call to use the version from the \"AnimatedTexture\" class instead spriteTexture.DrawFrame(_spriteBatch, characterPos); _spriteBatch.End(); base.Draw(gameTime); } AnimatedTexture draws the sprite using the subrectangle of the texture that contains the desired animation. // class AnimatedTexture public void DrawFrame(SpriteBatch batch, Vector2 screenPos) { DrawFrame(batch, frame, screenPos); } public void DrawFrame(SpriteBatch batch, int frame, Vector2 screenPos) { int FrameWidth = myTexture.Width / frameCount; Rectangle sourcerect = new Rectangle(FrameWidth * frame, 0, FrameWidth, myTexture.Height); batch.Draw(myTexture, screenPos, sourcerect, Color.White, Rotation, Origin, Scale, SpriteEffects.None, Depth); } There are many ways in which to handle the animation of sprites and they do not all need to be in a single line, some spritesheets use both Rows and Columns, sometimes for different animations for the same characters, or to maintain the same animation for multiple characters (remember it costs memory and time to load multiple textures, so why not just use one for efficiency). Tip Alternatively, some projects use a Custom Content Processor to generate the animation when the spritesheet is imported, which is more of an advanced topic. See Also Drawing a Sprite Concepts What Is a Sprite? Reference SpriteBatch SpriteBatch.Draw Texture2D"
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/howto/graphics/HowTo_AspectRatio.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/howto/graphics/HowTo_AspectRatio.html",
    "title": "How to restrict Aspect Ratio on a Graphics Device | hallowed",
    "summary": "Overview Certain games require a fixed resolution that is only suitable for Wide-Screen devices (e.g. a TV). The steps below show how to implement a custom GraphicsDeviceManager to provide such a restriction. To restrict graphics devices to widescreen aspect ratios in full-screen mode Create a class that derives from GraphicsDeviceManager. public class CustomGraphicsDeviceManager : GraphicsDeviceManager { public CustomGraphicsDeviceManager( Game game ) : base( game ) { } } Add a WideScreenOnly property to the class. The property is used to turn on and off the widescreen-only behavior. private bool isWideScreenOnly; public bool IsWideScreenOnly { get { return isWideScreenOnly; } set { isWideScreenOnly = value; } } Determine the minimum desired aspect ratio. static float WideScreenRatio = 1.6f; //1.77777779f; Override the RankDevices method of GraphicsDeviceManager. Note the call to base.RankDevices. This call ensures that the new version of RankDevices has an already ranked list of available devices with which to work. protected override void RankDevices( List<GraphicsDeviceInformation> foundDevices ) { base.RankDevices( foundDevices ); } Add a check to see if the WideScreenOnly property is true. if (IsWideScreenOnly) { ... } In the if block, loop through all found devices, and check whether the PresentationParameters indicate the device is full-screen. If the device is full-screen, determine the aspect ratio of the device by dividing the BackBufferWidth by the BackBufferHeight. If the aspect ratio is less than the desired aspect ratio, remove the device from the list of found devices. for (int i = 0; i < foundDevices.Count; ) { PresentationParameters pp = foundDevices[i].PresentationParameters; if (pp.IsFullScreen == true) { float aspectRatio = (float)(pp.BackBufferWidth) / (float)(pp.BackBufferHeight); // If the device does not have a widescreen aspect // ratio, remove it. if (aspectRatio < WideScreenRatio) { foundDevices.RemoveAt( i ); } else { i++; } } else i++; } Replace the default GraphicsDeviceManager with the derived GraphicsDeviceManager. To test the new component, set the WideScreenOnly and IsFullScreen properties to true. public Game1() { graphics = new CustomGraphicsDeviceManager(this); Content.RootDirectory = \"Content\"; this.graphics.PreferMultiSampling = false; #if WINDOWS this.graphics.PreferredBackBufferWidth = 1280; this.graphics.PreferredBackBufferHeight = 720; #endif #if ANDROID this.graphics.PreferredBackBufferWidth = 400; this.graphics.PreferredBackBufferHeight = 600; #endif this.graphics.IsFullScreen = true; this.graphics.IsWideScreenOnly = true; graphics.ApplyChanges(); } See Also How to articles for the Graphics Pipeline Concepts What Is 3D Rendering? What Is a Back Buffer? What Is a Viewport? Reference GraphicsDeviceManager"
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/howto/graphics/HowTo_Create_a_BasicEffect.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/howto/graphics/HowTo_Create_a_BasicEffect.html",
    "title": "How to create a Basic Effect | hallowed",
    "summary": "Overview The steps described here apply to effects created with the BasicEffect class using the Effect class to write a custom effect. Note The example draws aliased geometry, to see an example that draws smoother edges because it also applies anti-aliasing, see Enabling Anti-aliasing (Multi-sampling). End result To use BasicEffect Using the basic effect class requires a set of world, view, and projection matrices, a vertex buffer, a vertex declaration, and an instance of the BasicEffect class. Declare these properties at the beginning of the game class. //Matrices for 3D perspective private Matrix worldMatrix, viewMatrix, projectionMatrix; // Vertex data for rendering private VertexPositionColor[] triangleVertices; // A Vertex format structure that contains position, normal data, and one set of texture coordinates private BasicEffect basicEffect; Initialize the world, view, and projection matrices in the Initialize. Next, create a world matrix using the default Matrix.Identity for simplicity. Set the view matrix as a look-at matrix with a camera position of (0, 0, 50), pointing at the origin. The projection matrix is a perspective projection matrix based on a a 45-degree field of view, an aspect ratio equal to the client window, and a set of near and far planes to render the geometry within in view of the camera. protected override void Initialize() { // Setup the matrices to look forward worldMatrix = Matrix.Identity; viewMatrix = Matrix.CreateLookAt(new Vector3(0, 0, 50), Vector3.Zero, Vector3.Up); projectionMatrix = Matrix.CreatePerspectiveFieldOfView( MathHelper.PiOver4, GraphicsDevice.Viewport.AspectRatio, 1.0f, 300.0f); base.Initialize(); } Initialize a BasicEffect with the transformation and light values in the LoadContent method. protected override void LoadContent() { basicEffect = new BasicEffect(_graphics.GraphicsDevice); basicEffect.World = worldMatrix; basicEffect.View = viewMatrix; basicEffect.Projection = projectionMatrix; // primitive color basicEffect.AmbientLightColor = new Vector3(0.1f, 0.1f, 0.1f); basicEffect.DiffuseColor = new Vector3(1.0f, 1.0f, 1.0f); basicEffect.SpecularColor = new Vector3(0.25f, 0.25f, 0.25f); basicEffect.SpecularPower = 5.0f; basicEffect.Alpha = 1.0f; // The following MUST be enabled if you want to color your vertices basicEffect.VertexColorEnabled = true; // Use the built in 3 lighting mode provided with BasicEffect basicEffect.EnableDefaultLighting(); } Note If you wish, you can set up the lighting manually through code, as follows: basicEffect.LightingEnabled = true; if (basicEffect.LightingEnabled) { basicEffect.DirectionalLight0.Enabled = true; // enable each light individually if (basicEffect.DirectionalLight0.Enabled) { // x direction basicEffect.DirectionalLight0.DiffuseColor = new Vector3(1, 0, 0); // range is 0 to 1 basicEffect.DirectionalLight0.Direction = Vector3.Normalize(new Vector3(-1, 0, 0)); // points from the light to the origin of the scene basicEffect.DirectionalLight0.SpecularColor = Vector3.One; } basicEffect.DirectionalLight1.Enabled = true; if (basicEffect.DirectionalLight1.Enabled) { // y direction basicEffect.DirectionalLight1.DiffuseColor = new Vector3(0, 0.75f, 0); basicEffect.DirectionalLight1.Direction = Vector3.Normalize(new Vector3(0, -1, 0)); basicEffect.DirectionalLight1.SpecularColor = Vector3.One; } basicEffect.DirectionalLight2.Enabled = true; if (basicEffect.DirectionalLight2.Enabled) { // z direction basicEffect.DirectionalLight2.DiffuseColor = new Vector3(0, 0, 0.5f); basicEffect.DirectionalLight2.Direction = Vector3.Normalize(new Vector3(0, 0, -1)); basicEffect.DirectionalLight2.SpecularColor = Vector3.One; } } Still in LoadContent, create the per vertex data using the VertexPositionColor format. This example shows the data for the face of a triangle. triangleVertices = new VertexPositionColor[3]; triangleVertices[0].Position = new Vector3(0f, 0f, 0f); triangleVertices[0].Color = Color.Red; triangleVertices[1].Position = new Vector3(10f, 10f, 0f); triangleVertices[1].Color = Color.Yellow; triangleVertices[2].Position = new Vector3(10f, 0f, -5f); triangleVertices[2].Color = Color.Green; Finally, in the Draw Method, call GraphicsDevice.Clear to clear the render target. Set the rasterizer state to turn off culling using the RasterizerState property. Call EffectPass.Apply to set the effect state in preparation for rendering. Draw the geometry by calling GraphicsDevice.DrawUserPrimitives. protected override void Draw(GameTime gameTime) { GraphicsDevice.Clear(Color.SteelBlue); RasterizerState rasterizerState1 = new RasterizerState(); rasterizerState1.CullMode = CullMode.None; GraphicsDevice.RasterizerState = rasterizerState1; foreach (EffectPass pass in basicEffect.CurrentTechnique.Passes) { pass.Apply(); GraphicsDevice.DrawUserPrimitives( PrimitiveType.TriangleList, triangleVertices, 0, 1, VertexPositionColor.VertexDeclaration ); } base.Draw(gameTime); } When the sample is run, the basic geometry is rendered using the custom BasicEffect, feel free to play with the position, content or rendering order to enhance the effect. See Also How to create a State Object Concepts What Is a Configurable Effect? Reference GraphicsDevice BasicEffect RasterizerState"
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/howto/graphics/HowTo_Create_a_RenderTarget.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/howto/graphics/HowTo_Create_a_RenderTarget.html",
    "title": "How to create a Render Target | hallowed",
    "summary": "Overview The example is very basic but the principles are the same, when drawing to a Render Texture we apply the following process. Set the Graphics Device to output to a texture. Clear the buffer (or not depending on the use case). Draw the full screen contents required in the Render Texture, e.g. a map or camera view. Reset the Graphics device to the back buffer (screen). Draw your game as normal. Draw the Render Texture to the screen in the position we desire (e.g. in the lower corner for a mini-map), most likely on top of your game graphics. Tip The technique is very useful, especially if you are doing split-screen gaming and need to draw multiple camera views. Requirements This sample uses a grid texture (available below) to draw to the RenderTarget2D before then rendering the contents of the Render Target to the screen as a texture. Download the Grid texture and add it to your Content Project for this example. (see How to Add Content for more information on this.) Creating a Render Target Declare variables for a render target using the RenderTarget2D class, for this example we will also be using a Texture2D for the \"grid\" texture we will output to the Render Target. private GraphicsDeviceManager _graphics; private SpriteBatch _spriteBatch; private Texture2D grid; private RenderTarget2D renderTarget; Load the \"grid\" texture, which contains vertical and horizontal lines. protected override void LoadContent() { // Create a new SpriteBatch, which can be used to draw textures. _spriteBatch = new SpriteBatch(GraphicsDevice); // using \"grid\" which matches the NAME of the grid texture in the content project. grid = Content.Load<Texture2D>(\"grid\"); } While still in the LoadContent method, create the render target, giving it the same size as either the Texture (shown below) or the display back buffer (if you are rendering full screen), ideally in the Game.LoadContent method or later. renderTarget = new RenderTarget2D( GraphicsDevice, grid.Width, grid.Height); Render the \"grid\" texture to the render target. Rendering to a RenderTarget2D changes the Graphics Device output to write to a texture instead of the screen. Once you have finished rendering to the RenderTarget2D you MUST reset the GraphicsDevice Render Target to null to return to drawing to the screen / back buffer. The example function below, sets the render target on the device, draws the texture (to the render target) using a SpriteBatch. When rendering is complete, it then resets the device render target to null (which resets the device to the back buffer). private void DrawRenderTarget() { // Set the device to the render target GraphicsDevice.SetRenderTarget(renderTarget); // Clear the graphics buffer to a solid color GraphicsDevice.Clear(Color.Black); // Draw the \"grid\" texture to the graphics buffer, currently outputting to the Render Texture. _spriteBatch.Begin(); _spriteBatch.Draw(grid, Vector2.Zero, Color.White); _spriteBatch.End(); // Reset the device to the back buffer GraphicsDevice.SetRenderTarget(null); } Draw the render target texture to the back buffer. With the render target populated using the DrawRenderTarget function, we can then draw the output to the screen. protected override void Draw(GameTime gameTime) { // Populate the RenderTarget DrawRenderTarget(); // Clear the screen GraphicsDevice.Clear(Color.CornflowerBlue); // Draw the contents of the Render Target texture _spriteBatch.Begin(); _spriteBatch.Draw(renderTarget, new Vector2(200, 50), // x,y position new Rectangle(0, 0, 32, 32), // just one grid Color.White // no color scaling ); _spriteBatch.End(); base.Draw(gameTime); } The final output should look like the following: Rendering a 32 by 32 square from the RenderTarget texture to a position 200 x 50 on the screen. See Also How to create a Basic Effect Concepts What Is a Render Target? What Is a Back Buffer? Reference GraphicsDevice RenderTarget2D"
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/howto/graphics/HowTo_Create_a_StateObject.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/howto/graphics/HowTo_Create_a_StateObject.html",
    "title": "How to create a State Object | hallowed",
    "summary": "Overview In this example, we will demonstrate how to create a state object using any of the state object classes: BlendState, DepthStencilState, RasterizerState, or SamplerState. To create a state object Declare three state object variables as fields in your game. This example declares three rasterizer state objects and uses them to change the culling state. RasterizerState rsCullNone; Create a customizable state object. Create a state object from the RasterizerState class and initialize it by explicitly setting the cull mode. rsCullNone = new RasterizerState(); rsCullNone.CullMode = CullMode.None; rsCullNone.FillMode = FillMode.WireFrame; rsCullNone.MultiSampleAntiAlias = false; Respond to the user pressing the A key on a gamepad to change the culling mode. The application starts with culling turned off; toggle between culling modes by pushing the A key on a gamepad. Unlike a customizable state object, use a built-in state object to create an object with a set of predefined state. if (GamePad.GetState(PlayerIndex.One).Buttons.A == ButtonState.Pressed) { changeState = true; } if ((changeState) && (GamePad.GetState(PlayerIndex.One).Buttons.A == ButtonState.Released)) { if (GraphicsDevice.RasterizerState.CullMode == CullMode.None) { GraphicsDevice.RasterizerState = RasterizerState.CullCounterClockwise; } else if (GraphicsDevice.RasterizerState.CullMode == CullMode.CullCounterClockwiseFace) { GraphicsDevice.RasterizerState = RasterizerState.CullClockwise; } else if (GraphicsDevice.RasterizerState.CullMode == CullMode.CullClockwiseFace) { GraphicsDevice.RasterizerState = rsCullNone; } changeState = false; } Try this technique with the HowTo Create a BasicEffect sample and see what kinds of effects the above functionality applies."
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/howto/graphics/HowTo_Draw_3D_Primitives.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/howto/graphics/HowTo_Draw_3D_Primitives.html",
    "title": "Drawing 3D Primitives using Lists or Strips | hallowed",
    "summary": "Overview A 3D primitive describes how vertex data is ordered. This example demonstrates line and triangle primitive types that are the basis for all drawing calls in the MonoGame Framework. To render primitives, you need to create a basic effect and transformation matrices. This topic follows the steps described in Creating a Basic Effect to create an instance of BasicEffect. This sample uses orthographic projection, but you can also use perspective projection to render primitives. The vertices used in the sample are of type VertexPositionColor Structure which contains per-vertex position and color. Prerequisites This tutorial assumes you are following on from the project created in How to create a Basic Effect Creating Vertices The major steps for this example are: Creating Vertices Drawing a Line List Drawing a Line Strip Drawing A Triangle List Drawing a Triangle Strip To create vertices First we need to setup some data to draw our primitives, essentially a list of points that we will connect together and draw in different ways. Position the camera and create the required transformations. // Matrix to translate the drawn primitives to the center of the screen. private Matrix translationMatrix; // Number of vertex points to draw the primitive with. private int points = 8; // The length of the primitive lines to draw. private int lineLength = 100; protected override void Initialize() { worldMatrix = Matrix.Identity; viewMatrix = Matrix.CreateLookAt( new Vector3(0.0f, 0.0f, 1.0f), Vector3.Zero, Vector3.Up ); projectionMatrix = Matrix.CreateOrthographicOffCenter( 0, (float)GraphicsDevice.Viewport.Width, (float)GraphicsDevice.Viewport.Height, 0, 1.0f, 1000.0f); // Calculate the center of the visible screen using the ViewPort. Vector2 screenCenter = new Vector2(GraphicsDevice.Viewport.Width / 2, GraphicsDevice.Viewport.Height / 2); // Calculate the center of the primitives to be drawn. var primitiveCenter = new Vector2((points / 2 - 1) * lineLength / 2, lineLength / 2); // Create a translation matrix to position the drawn primitives in the center of the screen and the center of the primitives. translationMatrix = Matrix.CreateTranslation(screenCenter.X - primitiveCenter.X, screenCenter.Y - primitiveCenter.Y, 0); base.Initialize(); } Create a list of vertices in 3D space that represent the points to draw. The following code creates eight vertices (determined from the points variable) and stores them in an array of type VertexPositionColor. // The vertex sata array. private VertexPositionColor[] primitiveList; protected override void LoadContent() { ... // <-Existing Load Content from Creating a Basic Effect primitiveList = new VertexPositionColor[points]; for (int x = 0; x < points / 2; x++) { for (int y = 0; y < 2; y++) { primitiveList[(x * 2) + y] = new VertexPositionColor( new Vector3(x * lineLength, y * lineLength, 0), Color.White); } } // Translate the position of the vertices by the translation matrix calculated earlier. for (int i = 0; i < primitiveList.Length; i++) { primitiveList[i].Position = Vector3.Transform(primitiveList[i].Position, translationMatrix); } These eight points form a triangle strip consisting of six triangles drawn along the plane z = 0, with the first point at (0, 0, 0). The camera is positioned at (0, 0, 1) looking at (0, 0, 0). An orthogonal projection matrix is created with the upper-left point at (0, 0) and the lower-right point at the current GraphicsDevice screen dimensions. In addition, a translation matrix shifts the primitiveList point set to the center of the screen. To make the drawing of lines clearer, also change the Clear color in the Draw method to black. Just makes it easier to see drawn lines. protected override void Draw(GameTime gameTime) { GraphicsDevice.Clear(Color.Black); Drawing a Line List The example in this section uses the sample vertex list created by following step 1 in the Creating Vertices steps. To draw a line list Create an index array that indexes into the vertex buffer. This identifies a series of lines. private short[] lineListIndices; protected override void LoadContent() { ... // <-Existing Load Content // Initialize an array of indices of type short. lineListIndices = new short[(points * 2) - 2]; // Populate the array with references to indices in the vertex buffer for (int i = 0; i < points - 1; i++) { lineListIndices[i * 2] = (short)(i); lineListIndices[(i * 2) + 1] = (short)(i + 1); } Render the lines by calling DrawUserIndexedPrimitives, which specifies PrimitiveType.LineList to determine how to interpret the data in the vertex array. GraphicsDevice.DrawUserIndexedPrimitives<VertexPositionColor>( PrimitiveType.LineList, primitiveList, 0, // vertex buffer offset to add to each element of the index buffer points, // number of vertices in pointList lineListIndices, // the index buffer 0, // first index element to read points - 1 // number of primitives to draw ); Drawing a Line Strip The example in this section uses the same point list and renders the same output as the Drawing a Line List procedure. However, it uses a line strip primitive type when it identifies the indices of the vertex array to draw. Fewer indices are stored when you use a line strip. To draw a line strip Create a list of indices to identify the order in which to draw the points in the specified point list. Only half the number of indices used for the line list are needed here because the data consist of a series of connected lines. private short[] lineStripIndices; protected override void LoadContent() { ... // <-Existing Load Content // Initialize an array of indices of type short. lineStripIndices = new short[points]; // Populate the array with references to indices in the vertex buffer. for (int i = 0; i < points; i++) { lineStripIndices[i] = (short)(i); } Note This is equivalent to setting lineStripIndices with the following array that consists of a series of connected lines between pointList[0], pointList[1], and pointList[2], and so forth. lineStripIndices = new short[8]{ 0, 1, 2, 3, 4, 5, 6, 7 }; Render the line strip by calling DrawUserIndexedPrimitives, which specifies PrimitiveType.LineStrip to determine how to interpret the data in the vertex array. Fewer vertices are used to render the same number of primitives rendered earlier by the line list. GraphicsDevice.DrawUserIndexedPrimitives<VertexPositionColor>( PrimitiveType.LineList, primitiveList, 0, // vertex buffer offset to add to each element of the index buffer points, // number of vertices in pointList lineListIndices, // the index buffer 0, // first index element to read points - 1 // number of primitives to draw ); Drawing A Triangle List A triangle list, like a line list, is a primitive type that indicates you need to interpret the vertices in the vertex buffer as a series of separately drawn triangles. To draw a triangle list Create an array to hold the list of indices that identify a series of triangles to draw from the specified point list. private short[] triangleStripIndices; private int triangleWidth = 10; private int triangleHeight = 10; protected override void LoadContent() { ... // <-Existing Load Content triangleListIndices = new short[(width - 1) * (height - 1) * 6]; for (int x = 0; x < width - 1; x++) { for (int y = 0; y < height - 1; y++) { triangleListIndices[(x + y * (width - 1)) * 6] = (short)(2 * x); triangleListIndices[(x + y * (width - 1)) * 6 + 1] = (short)(2 * x + 1); triangleListIndices[(x + y * (width - 1)) * 6 + 2] = (short)(2 * x + 2); triangleListIndices[(x + y * (width - 1)) * 6 + 3] = (short)(2 * x + 2); triangleListIndices[(x + y * (width - 1)) * 6 + 4] = (short)(2 * x + 1); triangleListIndices[(x + y * (width - 1)) * 6 + 5] = (short)(2 * x + 3); } } Note This is equivalent to setting triangleListIndices to the following array, which consists of a series of triangles between pointList[0], pointList[1], and pointList[2], and so forth. triangleListIndices = new short[18]{ 0, 1, 2, 2, 1, 3, 2, 3, 4, 4, 3, 5, 4, 5, 6, 6, 5, 7 }; Render the lines by calling DrawUserIndexedPrimitives This specifies PrimitiveType.TriangleList, which determines how the data in the vertex array is interpreted. GraphicsDevice.DrawUserIndexedPrimitives<VertexPositionColor>( PrimitiveType.TriangleList, primitiveList, 0, // vertex buffer offset to add to each element of the index buffer 8, // number of vertices to draw triangleListIndices, 0, // first index element to read 6 // number of primitives to draw ); Drawing a Triangle Strip A triangle strip is a set of triangles that share multiple vertices. This example shows you how to render an object that looks the same as the object rendered with a triangle list. However, fewer vertices are needed because the triangles share multiple vertices. To draw a triangle strip Create an array to hold the list of indices that identify a strip of triangles. private short[] triangleStripIndices; protected override void LoadContent() { ... // <-Existing Load Content // Initialize an array of indices of type short. triangleStripIndices = new short[points]; // Populate the array with references to indices in the vertex buffer. for (int i = 0; i < points; i++) { triangleStripIndices[i] = (short)i; } Note This is equivalent to setting triangleStripIndices to the following array, which consists of a series of connected triangles between pointList[0], pointList[1], and pointList[2], and so forth. triangleStripIndices = new short[8]{ 0, 1, 2, 3, 4, 5, 6, 7 }; Render the lines by calling DrawUserIndexedPrimitives. This specifies PrimitiveType.TriangleStrip to determine how to interpret the data in the vertex array. Fewer vertices are used to render the same number of primitives rendered earlier by the triangle list. Note In the example code, the triangle strip is rendered by a series of red lines instead of the white lines used for the previous triangle list. The color change indicates a different primitive type was used to achieve the same result. GraphicsDevice.DrawUserIndexedPrimitives<VertexPositionColor>( PrimitiveType.TriangleStrip, primitiveList, 0, // vertex buffer offset to add to each element of the index buffer 8, // number of vertices to draw triangleStripIndices, 0, // first index element to read 6 // number of primitives to draw ); See Also How to enable Anti-aliasing Concepts What Is 3D Rendering? Reference GraphicsDevice DrawUserIndexedPrimitives"
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/howto/graphics/HowTo_Draw_A_Sprite.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/howto/graphics/HowTo_Draw_A_Sprite.html",
    "title": "Drawing a Sprite | hallowed",
    "summary": "Overview In any game, drawing basic textures to the screen is essential knowledge, whether it is for menus and background images, to 2D game textures and characters. In this sample we will walk though the steps needed to load a texture and then render it on the screen. End result Requirements The following texture will be used to render to the screen. Save it to your content project and name it \"Character\" (this name will used to reference it in the project). Note The tutorial assumes you have already created a new MonoGame project using one of the standard templates. To draw a sprite on screen Add the texture to your Content project, as detailed in HowTo Add Content. Load the textures that will be used for drawing sprites in the Game.LoadContent method. In this case, the example uses the Content member to load a texture from the MonoGame Framework Content Pipeline. Important The texture must be in the project, with the same Name passed to ContentManager.Load. In this case the texture should be called \"Character\"!! // The reference to the loaded sprite private Texture2D spriteTexture; // The position to draw the sprite private Vector2 spritePosition; protected override void LoadContent() { // Create a new SpriteBatch, which can be used to draw textures. _spriteBatch = new SpriteBatch(GraphicsDevice); spriteTexture = Content.Load<Texture2D>(\"Character\"); spritePosition = Vector2.Zero; } In the Game.Draw method, you will see a call to GraphicsDevice.Clear, which clears out the screen for the next frame. After GraphicsDevice.Clear, call SpriteBatch.Begin on your SpriteBatch object to ready the next batch of textures to draw. Call SpriteBatch.Draw on your SpriteBatch object, passing the texture to draw, the screen position, and the color to apply. Tip Color.White is used to draw the texture without any color effects. For a deeper explanation of how sprite tinting works, check out the How to Tint a Sprite guide. When all the sprites have been drawn, call SpriteBatch.End on your SpriteBatch object. protected override void Draw(GameTime gameTime) { GraphicsDevice.Clear(Color.CornflowerBlue); // TODO: Add your drawing code here _spriteBatch.Begin(); _spriteBatch.Draw(spriteTexture, spritePosition, Color.White); _spriteBatch.End(); base.Draw(gameTime); } When run, you should now see the character drawn in the top-left of the screen. Note Actually, what you should see is the character drawn from the top-left of the screen. This is because (by default) the Top-Left corner of the sprite is the origin and the sprite is drawn from that position. The Animated Sprite example shows a simple way of offsetting the drawing of a sprite so that its middle is used as its origin instead. Moving the sprite To move the sprite, simply update the spritePosition to a new location, a quick and easy way to do this would be to detect when the arrow keys are pressed and change the position, like so: protected override void Update(GameTime gameTime) { if (GamePad.GetState(PlayerIndex.One).Buttons.Back == ButtonState.Pressed || Keyboard.GetState().IsKeyDown(Keys.Escape)) Exit(); // TODO: Add your update logic here KeyboardState state = Keyboard.GetState(); if (state.IsKeyDown(Keys.Right)) { spritePosition.X += 1; } if (state.IsKeyDown(Keys.Left)) { spritePosition.X -= 1; } if (state.IsKeyDown(Keys.Up)) { spritePosition.Y -= 1; } if (state.IsKeyDown(Keys.Down)) { spritePosition.Y += 1; } base.Update(gameTime); } See How to detect input for more information on working with the various inputs that MonoGame supports. See Also How to tint a sprite How to rotate a sprite How to scale a sprite How to animate a sprite Concepts What Is a Sprite? Reference SpriteBatch SpriteBatch.Draw Texture2D (Character by upklyak from FreePik)"
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/howto/graphics/HowTo_Draw_Sprite_Background.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/howto/graphics/HowTo_Draw_Sprite_Background.html",
    "title": "Drawing a Masked Sprite over a Background | hallowed",
    "summary": "Overview In this example, you will draw a background texture, followed by another sprite on top of the background with its transparent elements not showing by using a Blend State that supports alpha blending. End result Requirements The example assumes the texture you are loading contains multiple images, one for the background and one for the foreground ship texture. Save the textures to your content project and name it \"AnimatedCharacter\" (this name will used to reference it in the project). Note The tutorial assumes you have already viewed the How to draw a Sprite topic. Important The foreground sprite in this example must include masking information, e.g. a PNG or DDS file that supports transparency / an alpha channel. Drawing a Foreground and Background Sprite Follow the steps of How To: Draw a Sprite. A good first step to understanding the loading and drawing of textures and setting up your project. Add some variables and update the LoadContent method to load and initialize the content. // Position of foreground sprite on screen private Vector2 ViperPos; // The texture for the ship private Texture2D shipTexture; // The texture for the background private Texture2D starTexture; protected override void LoadContent() { // Create a new SpriteBatch, which can be used to draw textures. spriteBatch = new SpriteBatch(GraphicsDevice); starTexture = Content.Load<Texture2D>(\"starfield\"); shipTexture = Content.Load<Texture2D>(\"ship\"); Viewport viewport = graphics.GraphicsDevice.Viewport; ViperPos.X = viewport.Width / 2; ViperPos.Y = viewport.Height - 100; } In Game.Draw method of your game class, call SpriteBatch.Begin for the SpriteBatch. Specify BlendState.Opaque. Note This will tell the SpriteBatch to ignore alpha color values when drawing sprites. By default, the z-order of sprites is the order in which they are drawn. Call the Draw method, passing in the starTexture. Then call SpriteBatch.End. public override void Draw (GameTime game) { GraphicsDevice.Clear(Color.CornflowerBlue); _spriteBatch.Begin(blendState: BlendState.Opaque); _spriteBatch.Draw(starTexture, Vector2.Zero, Color.White); _spriteBatch.End(); } After this code, call SpriteBatch.Begin for the SpriteBatch again. This time, specify BlendState.AlphaBlend. This will cause pixels on the sprite with an alpha value less than 255 to become progressively transparent based on the magnitude of the alpha value. An alpha of 0 will make the pixel completely transparent. Important Calling SpriteBatch.Begin with no parameters causes SpriteBatch to default to BlendState.AlphaBlend. Next in the Draw method, we draw the shipTexture, ViperPos with Color.White, finishing off with a call to SpriteBatch.End. public override void Draw (GameTime game) { _spriteBatch.Begin(blendState: BlendState.Opaque); _spriteBatch.Draw(starTexture, Vector2.Zero, Color.White); _spriteBatch.End(); _spriteBatch.Begin(blendState: BlendState.AlphaBlend); _spriteBatch.Draw (shipTexture, ViperPos, Color.White); _spriteBatch.End(); } The end result is a fixed / opaque background with a semi-transparent ship drawn on top for the player. You can of course experiment with layers / parallax transparent backgrounds behind the player too, the choice is up to you. Extra Credit Try using this technique on top of the How To Make A Scrolling Background guide for the beginnings of your very own space shooter :D See Also Drawing a Sprite How To Make A Scrolling Background Concepts What Is a Sprite? Reference SpriteBatch SpriteBatch.Draw Texture2D"
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/howto/graphics/HowTo_Draw_Text.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/howto/graphics/HowTo_Draw_Text.html",
    "title": "Drawing Text with a Sprite | hallowed",
    "summary": "Overview MonoGame provides a quick and easy method for drawing text using any registered Font file installed on the development PC, this is not needed in the final game as the true type font is converted into a texture for rendering, making the process easy and seamless. End result Adding a Sprite Font and Drawing Text Open your Content.mgcb file using the MGCB Editor and click New Item Button. In the Add New Item dialog box, select SpriteFont Description and set the filename to \"MyMenuFont\" in the edit box at the top of the dialog. Note You may find it convenient at this point to change the name of the new file from \"Spritefont1\" to the friendly name of the font you intend to load (keeping the .spritefont file extension). The friendly name identifies the font once it is installed on your computer, for example, Courier New or Times New Roman. When you reference the font in your code, you must use the friendly name you have assigned it. Pipeline tool creates a new .spritefont file for your font. Double-click on your new font file in the MGCB Editor which will open the SpriteFont text file in your default editor. Alternatively, you can right-click and select Open With to choose a different editor. By default the font Arial will be used by the SpriteFont configuration, to change this to another installed font simply type the friendly name of the font to load into the FontName element. For the purposes of this tutorial, I have set the Font size to 54 and left the rest of the SpriteFont settings as the default. Important This is not the name of a font file, but rather the name that identifies the font once it is installed on your computer. You can view the installed fonts on your machine in the Settings -> Personalization -> Fonts configuration on your Windows machine (or relevant place on Mac /Linux) or to install new ones. The content pipeline supports the same fonts as the System.Drawing.Font class, including TrueType fonts, but not bitmap (.fon) fonts. You may find it convenient to save the new .spritefont file using this friendly name. When you reference the font in your code, you must use the friendly name you have assigned it. > [!NOTE] > If you want to use a custom font, you should put the `.ttf` or `.oft` in the same directory as the `.spritefont` file and the build system will pick it up. There is no need to install the font system wide. If necessary, change the Size entry to the point size you desire for your font. If necessary, change the Style entry to the style of font to import. You can specify Regular, Bold, Italic, or Bold, Italic. The Style entry is case sensitive. Specify the character regions to import for this font. Note Character regions specify which characters in the font are rendered by the SpriteFont. You can specify the start and end of the region by using the characters themselves, or by using their decimal values with an &# prefix. The default character region includes all the characters between the space and tilde characters, inclusive. To draw text on the screen Add a Sprite Font to your project as described above. Create a SpriteFont reference to encapsulate the imported font. Create a SpriteBatch object for drawing the font on the screen. In your Game.LoadContent method, call ContentManager.Load, specifying the SpriteFont class and the asset name of the imported font. Create your SpriteBatch object, passing the current GraphicsDevice. // The Sprite Font reference to draw with SpriteFont font1; // The position to draw the text Vector2 fontPos; protected override void LoadContent() { // Create a new SpriteBatch, which can be used to draw textures. _spriteBatch = new SpriteBatch(GraphicsDevice); font1 = Content.Load<SpriteFont>(\"MyMenuFont\"); Viewport viewport = _graphics.GraphicsDevice.Viewport; // TODO: Load your game content here fontPos = new Vector2(viewport.Width / 2, viewport.Height / 2); } In your Game.Draw method, call SpriteBatch.Begin on the SpriteBatch object. If necessary, determine the origin (center) of your text. If you want to draw your text centered on a point, you can find the center of the text by calling SpriteFont.MeasureString and dividing the returned vector by 2. Call SpriteBatch.DrawString to draw your output text, specifying the SpriteFont object for the font you want to use. All other parameters of SpriteBatch.DrawString produce the same effects as a call to SpriteBatch.Draw. Call SpriteBatch.End after all text is drawn. protected override void Draw(GameTime gameTime) { GraphicsDevice.Clear(Color.CornflowerBlue); _spriteBatch.Begin(); // Draw Hello World string output = \"Hello World\"; // Find the center of the string Vector2 FontOrigin = font1.MeasureString(output) / 2; // Draw the string _spriteBatch.DrawString(font1, output, fontPos, Color.LightGreen, 0, FontOrigin, 1.0f, SpriteEffects.None, 0.5f); _spriteBatch.End(); base.Draw(gameTime); } See Also Drawing a Sprite Concepts What Is a Sprite? Reference SpriteBatch SpriteBatch.DrawString SpriteFont ContentManager.Load"
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/howto/graphics/HowTo_Draw_Textured_Quad.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/howto/graphics/HowTo_Draw_Textured_Quad.html",
    "title": "Creating a Custom Effect with Texturing | hallowed",
    "summary": "Overview Drawing a textured quad is a basic technique to have in any Game Developers arsenal, which can be populated by any texture from either the Content Pipeline (loaded from disk) or generated in memory (which we will use here for simplicity). Note Drawing a texture quad is in effect what a SpriteBatch does under the hood, but while a SpriteBatch natively only draws flat to the screen, a Quad can be positioned in any way you see fit. Either approach has its pros and cons. There is a but of setup to draw a quad in MonoGame and there are many ways to achieve it. Note This example draws from community responses to the same question here, on the MonoGame Community site, with a little clean-up to make it simpler. To use a custom effect with a texture Create a custom vertex format declaration and a set of indices to indicate the drawing order. // A Vertex format with Texture information private VertexPositionColorTexture[] drawingQuad; // The indices array for drawing a quad private short[] drawingIndices; public void SetupUserIndexedVertexRectangle(Rectangle r) { drawingQuad = new VertexPositionColorTexture[4]; drawingQuad[0] = new VertexPositionColorTexture(new Vector3(r.Left, r.Top, 0f), Color.White, new Vector2(0f, 0f)); drawingQuad[1] = new VertexPositionColorTexture(new Vector3(r.Left, r.Bottom, 0f), Color.Red, new Vector2(0f, 1f)); drawingQuad[2] = new VertexPositionColorTexture(new Vector3(r.Right, r.Bottom, 0f), Color.Green, new Vector2(1f, 1f)); drawingQuad[3] = new VertexPositionColorTexture(new Vector3(r.Right, r.Top, 0f), Color.Blue, new Vector2(1f, 0f)); drawingIndices = [0, 2, 1, 2, 0, 3]; } To make setup simpler, we will also define two methods to Set the Graphics State and create our basic effect. // The basic effect definition private BasicEffect basicEffect; // A Texture2D that we will generate data into private Texture2D generatedTexture; /// <summary> /// Set the states for the graphics device. /// </summary> private void SetStates() { GraphicsDevice.BlendState = BlendState.Opaque; GraphicsDevice.DepthStencilState = DepthStencilState.Default; GraphicsDevice.SamplerStates[0] = SamplerState.PointWrap; GraphicsDevice.RasterizerState = RasterizerState.CullCounterClockwise; } /// <summary> /// Creates a basic effect for drawing a textured quad. /// </summary> private void SetUpBasicEffect() { basicEffect = new BasicEffect(this.GraphicsDevice); basicEffect.VertexColorEnabled = true; basicEffect.TextureEnabled = true; basicEffect.Texture = generatedTexture; // set up our matrix to match basic effect. Viewport viewport = GraphicsDevice.Viewport; basicEffect.World = Matrix.Identity; Vector3 cameraUp = Vector3.Transform(Vector3.Down, Matrix.CreateRotationZ(0)); basicEffect.View = Matrix.CreateLookAt(Vector3.Forward, Vector3.Zero, cameraUp); basicEffect.Projection = Matrix.CreateScale(1, -1, 1) * Matrix.CreateOrthographicOffCenter(0, viewport.Width, viewport.Height, 0, 0, 1); } Note Note that the basic effect is created with basicEffect.TextureEnabled = true; and the texture to draw using basicEffect.Texture = generatedTexture;, just stating we are drawing a texture and what it is. Next, we will generate a Texture to draw as part of the quad, a simple white texture which the effect will also draw a coloured \"tint\" over thanks to the basicEffect.VertexColorEnabled = true; set in the effect. private Texture2D GenerateTexture2D() { Texture2D t = new Texture2D(this.GraphicsDevice, 250, 250); var cdata = new Color[250 * 250]; for (int i = 0; i < 250; i++) { for (int j = 0; j < 250; j++) { cdata[i * 250 + j] = Color.White; } } t.SetData(cdata); return t; } Note Alternatively, you can just use a texture loaded from the Content Pipeline, just be sure to change the Vertex format used in Step 1 to VertexPositionTexture unless you want the coloured gradient, or simply disable basicEffect.VertexColorEnabled = false;. That is unless you want to apply color tints with the vertex declaration. Putting this together, setup all the relevant artifacts in the LoadContent method. protected override void LoadContent() { // Set render state SetStates(); // Setup basic effect SetUpBasicEffect(); // Create the quad to draw SetupUserIndexedVertexRectangle(new Rectangle(10, 40, 450, 260)); // Generate (or load) the Texture generatedTexture = GenerateTexture2D(); } Finally, draw the primitive quad to the screen using the BasicEffect and generated data. protected override void Draw(GameTime gameTime) { GraphicsDevice.Clear(Color.CornflowerBlue); foreach (EffectPass pass in basicEffect.CurrentTechnique.Passes) { pass.Apply(); GraphicsDevice.DrawUserIndexedPrimitives(PrimitiveType.TriangleList, drawingQuad, 0, 4, drawingIndices, 0, 2); } base.Draw(gameTime); } Marvel at the wonder of your drawn Textured Quad plus vertex effect. See Also How to create a Basic Effect Concepts 3D Pipeline Basics Reference GraphicsDevice BasicEffect"
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/howto/graphics/HowTo_DynamicallyUpdateVertices.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/howto/graphics/HowTo_DynamicallyUpdateVertices.html",
    "title": "How to Dynamically Update Vertex Data | hallowed",
    "summary": "Overview Geometry in a 3D game is defined by vertex data. Sometimes, a game needs to modify vertex data or even generate new vertex data dynamically (at run time). Here are some solutions for dynamically updating vertex data. Updating a Set of Primitives Dynamically The Primitives Sample demonstrates a dynamic vertex buffer that is generated during each rendering frame. The sample renders primitives by first calling Begin, adding the necessary vertices, using the Add method, and then calling End. This forces the buffer to be drawn to the current device. The Flush method calls GraphicsDevice.DrawUserPrimitives method when End is called or when the buffer has no room for new vertices. If there is no room, the buffer is written to the device, it is reset, and the pending vertices are added. Dynamically Rendering a Persistent Set of Primitives The Particle 3D Sample, implements a dynamic vertex buffer that contains custom vertices with a limited lifespan. The application adds and removes particles into a fixed length buffer. The custom shader of the sample renders the active subset of vertices dynamically. Because particles have a limited lifespan, the ParticleSystem class handles all adding, updating, and deleting of the vertex buffer in real time. Generating Geometry Programmatically Sometimes, your game needs to generate geometry because the geometry is not known at design-time or it changes at run time. For this scenario, create a dynamic vertex and index buffer, and use VertexBuffer.SetData and IndexBuffer.SetData to set or change the data at run time. Remarks Create a dynamic vertex or index buffer using DynamicVertexBuffer and DynamicIndexBuffer ; create a static vertex or index buffer using VertexBuffer and IndexBuffer. Use a dynamic buffer for vertex data that is updated every render frame, otherwise, use a static buffer. The samples are located on the App Hub Web site. For a more advanced solution for dynamic vertex updating, download the Generated Geometry Sample. This sample uses the MeshBuilder helper class and a custom processor to generate a terrain map from a bitmap loaded by the content manager. Specifically, examine the Process method, located in TerrainProcessor.cs, which programmatically creates the terrain geometry based on input from the specified bitmap. See Also How to articles for the Graphics Pipeline Concepts What Is 3D Rendering? What Is a Configurable Effect? Reference GraphicsDeviceManager VertexBuffer IndexBuffer DynamicVertexBuffer DynamicIndexBuffer"
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/howto/graphics/HowTo_Enable_Anti_Aliasing.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/howto/graphics/HowTo_Enable_Anti_Aliasing.html",
    "title": "How to enable anti-aliasing | hallowed",
    "summary": "Overview Figure 1. Anti-aliasing the edges of a cube: multi-sampling is disabled on the left, and enabled on the right. Anti-aliasing is a technique for minimizing distortion artifacts caused by aliasing when rendering a high-resolution signal (such as a sharp edge) at a low resolution (such as in a render target with a fixed number of pixel locations). anti-aliasing smooths sharp edges by partially rendering to neighboring pixels. This technique is also called multi-sampling because each pixel value can be the result of multiple samples. To enable anti-aliasing in your game Render 3D geometry. One way to do this is by creating a BasicEffect using the BasicEffect class. For more detail, see Creating a Basic Effect. Set PreferMultiSampling to true in your Game class constructor. graphics.PreferMultiSampling = true; Set the view matrix to place the camera close to the object so you can more clearly see the smoothed, anti-aliased edges. worldMatrix = Matrix.CreateRotationX(tilt) * Matrix.CreateRotationY(tilt); viewMatrix = Matrix.CreateLookAt(new Vector3(1.75f, 1.75f, 1.75f), Vector3.Zero, Vector3.Up); projectionMatrix = Matrix.CreatePerspectiveFieldOfView( MathHelper.ToRadians(45), // 45 degree angle (float)GraphicsDevice.Viewport.Width / (float)GraphicsDevice.Viewport.Height, 1.0f, 100.0f); Draw the geometry by calling GraphicsDevice.DrawPrimitives. RasterizerState rasterizerState1 = new RasterizerState(); rasterizerState1.CullMode = CullMode.None; graphics.GraphicsDevice.RasterizerState = rasterizerState1; foreach (EffectPass pass in basicEffect.CurrentTechnique.Passes) { pass.Apply(); graphics.GraphicsDevice.DrawPrimitives( PrimitiveType.TriangleList, 0, 12 ); } See Also Concepts 3D Pipeline Basics What Is anti-aliasing? Reference GraphicsDeviceManager PreparingDeviceSettings PresentationParameters"
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/howto/graphics/HowTo_FitCameraToScene.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/howto/graphics/HowTo_FitCameraToScene.html",
    "title": "How to position the Camera | hallowed",
    "summary": "Overview Managing cameras in a 3D environment can be one of the most challenging tasks for any MonoGame developer, if your camera is looking the wrong way then you will not see anything on screen, or at least not what you were expecting. A simple technique to handle this is to create a BoundingSphere around your visible game content and then have the camera look at the center of it. To position the camera to view all objects in a scene Create a BoundingSphere class that contains all of the objects in the scene. To create the sphere, loop through all of the objects in the scene, merging the BoundingSphere classes that contain them with CreateMerged. If you are not already tracking the BoundingSphere classes for collision detection, use CreateFromBoundingBox or CreateFromPoints to create them from BoundingBox classes or points. In this example, the BoundingSphere classes are created from BoundingBox classes. BoundingSphere GetSceneSphere() { BoundingSphere sceneSphere = new BoundingSphere(new Vector3(.5f, 1, .5f), 1.5f); for (int z = 0; z < 5; z++) { for (int x = 0; x < 5; x++) { BoundingSphere boundingSphere = sphere.Meshes[0].BoundingSphere; boundingSphere.Center = new Vector3(x * 3, 0, z * 3); sceneSphere = BoundingSphere.CreateMerged( sceneSphere, boundingSphere); } } return sceneSphere; } Set the position of the camera to the center of the BoundingSphere that contains the scene. cameraPosition = sceneSphere.Center; Determine the distance from the center of the BoundingSphere that the camera needs to be to view the entire scene. This distance is equal to the hypotenuse of the triangle formed by the center of the sphere, the desired camera position, and the point where the sphere touches the view frustum. One angle of the triangle is known to be the field of view of the camera divided by two. One leg of the triangle is known to be the radius of the sphere. Given these two measurements, you can calculate the hypotenuse as the radius of the sphere divided by the sine of half the field of view. float distanceToCenter = sceneSphere.Radius / (float)Math.Sin(FOV / 2); Get the Backward vector of the view Matrix and flip its X component. Vector3 back = view.Backward; back.X = -back.X; //flip x's sign To move the camera backward with respect to its orientation, multiply the desired distance by the adjusted back vector from the previous step. The camera is now facing the center of the sphere containing the scene and is far enough back that the sphere fits in the camera's view frustum. cameraPosition += (back * distanceToCenter); See Also Rotating and Moving the Camera Concepts What Is a View Frustum? What Is a Viewport? Reference BoundingSphere Matrix"
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/howto/graphics/HowTo_FullScreen.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/howto/graphics/HowTo_FullScreen.html",
    "title": "How to create a Full-Screen Game | hallowed",
    "summary": "Overview By default, MonoGame will render in a Window pre-set to the default (800 x 480) resolution. If you instead want to render to the full screen, then is it as simple as flipping a switch and the renderer will use the full dimensions of the targeted display device. Note Rendering to the full screen does NOT change the resolution that the game will be drawn in, that is something as a game developer you have to control. This is because the resolution the game draws at will have a direct impact on the content you are rendering, so you need to best control what gets drawn and how. To create a full-screen game Derive a class from Game. After creating the GraphicsDeviceManager, set its PreferredBackBufferWidth and PreferredBackBufferHeight to the desired screen height and width. Note Check the What Is 3D Rendering? guide on the various ways the GraphicsDevice and Back Buffer? can be initialized. Set IsFullScreen to true. public Game1() { _graphics = new GraphicsDeviceManager(this); // Setup up the default resolution for the project _graphics.PreferredBackBufferWidth = 800; _graphics.PreferredBackBufferHeight = 480; // Runs the game in \"full Screen\" mode using the set resolution _graphics.IsFullScreen = true; Content.RootDirectory = \"Content\"; IsMouseVisible = true; } See Also How to articles for the Graphics Pipeline Concepts What Is 3D Rendering? What Is a Back Buffer? What Is a Viewport? Reference GraphicsDeviceManager"
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/howto/graphics/HowTo_Make_Scrolling_Background.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/howto/graphics/HowTo_Make_Scrolling_Background.html",
    "title": "Making a Scrolling Background | hallowed",
    "summary": "Overview In this example, you will draw a texture to the screen and then animate it vertically by scrolling it upwards in a wrapping motion. End result Note Textures that scroll, especially over the screen background are best if they use seamless or tileable textures, For Example. Essentially, textures that wrap around the edges to look like a single texture when joined together. Requirements The example assumes the texture you are loading contains multiple frames of the same size in a texture whose size is uniform (also known as a spritesheet), for example, the following spritesheet contains 8 Images of a character in different phases of motion, when player together it looks like it is animated. Save the texture to your content project and name it \"Starfield\" (this name will used to reference it in the project). Note The sample also uses a class named ScrollingBackground, which is included with the sample below. The ScrollingBackground.cs is a helper to simplify the scrolling of a texture in the vertical direction. Feel free to modify it to work in different directions. Drawing a Scrolling Background Sprite Follow the steps of How To: Draw a Sprite. A good first step to understanding the loading and drawing of textures and setting up your project. Create a new class called ScrollingBackground.cs in your project and replace its contents with the following: using Microsoft.Xna.Framework; using Microsoft.Xna.Framework.Graphics; /// <summary> /// A helper class to scroll a texture vertically /// </summary> public class ScrollingBackground { // Screen Position to draw the background from. private Vector2 screenpos; // The texture origin point. private Vector2 origin; // The size of the texture in pixels (using ony the texture height). private Vector2 texturesize; // The texture to draw as a background. private Texture2D mytexture; // The height of the screen in pixels. private int screenheight; public void Load(GraphicsDevice device, Texture2D backgroundTexture) { mytexture = backgroundTexture; screenheight = device.Viewport.Height; int screenwidth = device.Viewport.Width; // Set the origin so that we're drawing from the // center of the top edge. origin = new Vector2(mytexture.Width / 2, 0); // Set the screen position to the center of the screen. screenpos = new Vector2(screenwidth / 2, screenheight / 2); // Offset to draw the second texture, when necessary. texturesize = new Vector2(0, mytexture.Height); } public void Update(float deltaY) { screenpos.Y += deltaY; screenpos.Y %= mytexture.Height; } public void Draw(SpriteBatch batch, Color color) { // Draw the texture, if it is still onscreen. if (screenpos.Y < screenheight) { batch.Draw(mytexture, screenpos, null, color, 0, origin, 1, SpriteEffects.None, 0f); } // Draw the texture a second time, behind the first, // to create the scrolling illusion. batch.Draw(mytexture, screenpos - texturesize, null, color, 0, origin, 1, SpriteEffects.None, 0f); } } Load the background texture. private ScrollingBackground myBackground; protected override void LoadContent() { _spriteBatch = new SpriteBatch(GraphicsDevice); // TODO: use this.Content to load your game content here myBackground = new ScrollingBackground(); Texture2D background = Content.Load<Texture2D>(\"starfield\"); myBackground.Load(GraphicsDevice, background); } Determine the size of the background texture and the size of the screen. The texture size is determined using the Height and Width properties, and the screen size is determined using the Viewport property on the graphics device. Using the texture and screen information, set the origin of the texture to the center of the top edge of the texture, and the initial screen position to the center of the screen. // class ScrollingBackground private Vector2 screenpos, origin, texturesize; private Texture2D mytexture; private int screenheight; public void Load(GraphicsDevice device, Texture2D backgroundTexture) { mytexture = backgroundTexture; screenheight = device.Viewport.Height; int screenwidth = device.Viewport.Width; // Set the origin so that we're drawing from the // center of the top edge. origin = new Vector2(mytexture.Width / 2, 0); // Set the screen position to the center of the screen. screenpos = new Vector2(screenwidth / 2, screenheight / 2); // Offset to draw the second texture, when necessary. texturesize = new Vector2(0, mytexture.Height); } To scroll the background, change the screen position of the background texture in your Game.Update method. Note This example moves the background down 100 pixels per second by increasing the screen position's Y value. private float scrollingSpeed = 100; protected override void Update(GameTime gameTime) { if (GamePad.GetState(PlayerIndex.One).Buttons.Back == ButtonState.Pressed || Keyboard.GetState().IsKeyDown(Keys.Escape)) Exit(); // The time since Update was called last. float elapsed = (float)gameTime.ElapsedGameTime.TotalSeconds; // TODO: Add your game logic here. myBackground.Update(elapsed * scrollingSpeed); base.Update(gameTime); } The Y value is kept no larger than the texture height, making the background scroll from the bottom of the screen back to the top. // class ScrollingBackground public void Update(float deltaY) { screenpos.Y += deltaY; screenpos.Y %= mytexture.Height; } Draw the background using the origin and screen position calculated in Game.LoadContent and Game.Update. protected override void Draw(GameTime gameTime) { GraphicsDevice.Clear(Color.CornflowerBlue); _spriteBatch.Begin(); myBackground.Draw(_spriteBatch, Color.White); _spriteBatch.End(); base.Draw(gameTime); } In case the texture does not cover the screen, another texture is drawn. This subtracts the texture height from the screen position using the texturesize vector created at load time. This creates the illusion of a loop. // class ScrollingBackground public void Draw(SpriteBatch batch, Color color) { // Draw the texture, if it is still onscreen. if (screenpos.Y < screenheight) { batch.Draw(mytexture, screenpos, null, color, 0, origin, 1, SpriteEffects.None, 0f); } // Draw the texture a second time, behind the first, // to create the scrolling illusion. batch.Draw(mytexture, screenpos - texturesize, null, color, 0, origin, 1, SpriteEffects.None, 0f); } See Also Drawing a Sprite How to animate a sprite Drawing a Masked Sprite over a Background Concepts What Is a Sprite? Reference SpriteBatch SpriteBatch.Draw Texture2D"
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/howto/graphics/HowTo_RenderModel.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/howto/graphics/HowTo_RenderModel.html",
    "title": "How to render a Model using a Basic Effect | hallowed",
    "summary": "Overview This example has three main parts: Importing and processing the model Drawing the resultant managed object as a model with full lighting effect in the game Enabling movement of the model with a game pad. Requirements It is assumed that an existing project is loaded in MonoGame. In this example, the project is called \"CPModel\". Adding a Model Follow the steps in How to add content in order to add a Model to your project. For this example, use the Fuel Carrier model file and its corresponding diffuse texture. But you can use any model file you wish, and set the Content Importer to FBX Importer - MonoGame and the Content Processor is Model - MonoGame (which should be the default for an FBX) and Save the solution. The remaining parts render the model and add some user control of the model. All code modifications for this part occur within the game1.cs file of the game project. Rendering the model Open the game1.cs file. Modify the Game1 class by adding the following code at the beginning of the declaration. private Model gameShip; This member holds the ship model. Modify the LoadContent method by adding the following code. gameShip = Content.Load<Model>(\"fuelcarrier\"); This code loads the model into the gameShip member (using Load). Create a new private method (called DrawModel) in the Game1 class by adding the following code before the existing Game.Draw method. private void DrawModel(Model m) { Matrix[] transforms = new Matrix[m.Bones.Count]; float aspectRatio = GraphicsDevice.Viewport.AspectRatio; m.CopyAbsoluteBoneTransformsTo(transforms); Matrix projection = Matrix.CreatePerspectiveFieldOfView(MathHelper.ToRadians(45.0f), aspectRatio, 1.0f, 10000.0f); Matrix view = Matrix.CreateLookAt(new Vector3(0.0f, 50.0f, zoom), Vector3.Zero, Vector3.Up); foreach (ModelMesh mesh in m.Meshes) { foreach (BasicEffect effect in mesh.Effects) { effect.EnableDefaultLighting(); effect.View = view; effect.Projection = projection; effect.World = gameWorldRotation * transforms[mesh.ParentBone.Index] * Matrix.CreateTranslation(position); } mesh.Draw(); } } This code sets up the lighting effects for each sub-mesh of the model. The gameWorldRotation and Zoom variables are used for player control. This functionality is added later. This render code is designed for only those models with a BasicEffect (set in the MGCB editor as the defaultEffect property for the model). For custom effects, the inner for-each loop should be changed to use the Effect class instead of the BasicEffect class. In addition, you must use EffectParameter objects to manually set the world, view, and projection matrices. Modify the Game1.Draw method by replacing the following code **// TODO: Add your drawing code here with the following code: DrawModel(gameShip); This initializes the model's effects before the model is rendered. Save the solution. At this point, the rendering code for the model is complete, but the user control code still needs implementation. Important The project will not run as this point as there is more to add. Moving the model To begin moving the model, we need to add some controls and User input. Modify the Game1 class by adding the following code after the gameShip declaration. private Vector3 position = Vector3.One; private float zoom = 2500; private float rotationY = 0.0f; private float rotationX = 0.0f; private Matrix gameWorldRotation; float speed = 10f; These members store the current position, zoom, and rotation values. In addition, the gameWorldRotation is updated by the UpdateGamePad method below. Add a private method (called UpdateGamePad) before the call to Game.Update. private void UpdateGamePad() { GamePadState gamePadState = GamePad.GetState(PlayerIndex.One); KeyboardState keyState = Keyboard.GetState(); // Gamepad controls position.X += gamePadState.ThumbSticks.Left.X * speed; position.Y += gamePadState.ThumbSticks.Left.Y * speed; zoom += gamePadState.ThumbSticks.Right.Y * speed; rotationY += gamePadState.ThumbSticks.Right.X * speed; if (gamePadState.Buttons.RightShoulder == ButtonState.Pressed) { rotationX += 1.0f * speed; } else if (gamePadState.Buttons.LeftShoulder == ButtonState.Pressed) { rotationX -= 1.0f * speed; } // Keyboard controls if (keyState.IsKeyDown(Keys.A)) { position.X += 1.0f * speed; } else if (keyState.IsKeyDown(Keys.D)) { position.X -= 1.0f * speed; } if (keyState.IsKeyDown(Keys.W)) { zoom += 1.0f * speed; } else if (keyState.IsKeyDown(Keys.S)) { zoom -= 1.0f * speed; } if (keyState.IsKeyDown(Keys.E)) { rotationY += 1.0f * speed; } else if (keyState.IsKeyDown(Keys.Q)) { rotationY -= 1.0f * speed; } if (keyState.IsKeyDown(Keys.Right)) { position.Y += 1.0f * speed; } else if (keyState.IsKeyDown(Keys.Left)) { position.Y -= 1.0f * speed; } if (keyState.IsKeyDown(Keys.Up)) { rotationX += 1.0f * speed; } else if (keyState.IsKeyDown(Keys.Down)) { rotationX -= 1.0f * speed; } gameWorldRotation = Matrix.CreateRotationX(MathHelper.ToRadians(rotationX)) * Matrix.CreateRotationY(MathHelper.ToRadians(rotationY)); } This code implements an exit method for the game (pressing the A button on a GamePad), and updates the position members with the current input of the game controller. Modify the Update method by adding a call to UpdateGamePad, before the call to Game.Update. UpdateGamePad(); This code updates the state of the position variables with the latest input. Save the solution. Development is complete so you are ready to build and run the game. Control the ship location with the game pad, and exit by pressing the A button. See Also Adding Content to a Game Using Input Concepts What Is a Configurable Effect? What Is a Configurable Effect? Reference BasicEffect Matrix GamePadState KeyboardState"
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/howto/graphics/HowTo_RotateMoveCamera.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/howto/graphics/HowTo_RotateMoveCamera.html",
    "title": "How to rotate and move the Camera | hallowed",
    "summary": "Overview This sample is based on several assumptions. The camera will move frequently, so the camera view Matrix is created and set every time Game.Update is called. The projection Matrix may also change frequently for effects such as zooming. You have added a model to the project, as shown in How To Render a Model For the sake of simplicity, the example limits the camera object to rotation about the y axis (vertical spin) and movement along the z axis (forward and backward). The following steps show you how to render the sample scene. To render the sample scene Determine the location and orientation of the camera. static Vector3 avatarPosition = new Vector3(0, 0, -50); static Vector3 cameraPosition = avatarPosition; Determine the reference Vector3 to which the rotation of the camera is relative. The direction should not change during the game, and usually it will be (0, 0, 1) or (0, 0, −1). // Set the direction the camera points without rotation. Vector3 cameraReference = new Vector3(0, 0, 1); Create a rotation Matrix for the amount of rotation for the camera. Because the camera is limited to one axis of rotation, this matrix represents the rotation of the camera around its own y-axis. Use CreateRotationY to create a rotation Matrix representing the rotation around the y-axis. Matrix rotationMatrix = Matrix.CreateRotationY(avatarYaw); Use the Vector3 Transform and the rotation Matrix to transform the reference vector. This represents the direction the camera is pointing in transformed (or view) space. // Create a vector pointing the direction the camera is facing. Vector3 transformedReference = Vector3.Transform(cameraReference, rotationMatrix); Add the camera's current position to the transformed direction vector. The result is the position to which the camera is pointing. // Calculate the position the camera is looking at. Vector3 cameraLookat = cameraPosition + transformedReference; Create a new view Matrix using CreateLookAt. Use Matrix.CreateLookAt to pass the camera's current position and the transformed direction vector. The third parameter of CreateLookAt is the up direction of the camera. Typically, it is Vector3 Up (0, 1, 0). This matrix Matrix controls how world coordinates are transformed to camera coordinates. // Set up the view matrix and projection matrix. view = Matrix.CreateLookAt(cameraPosition, cameraLookat, new Vector3(0.0f, 1.0f, 0.0f)); Use CreatePerspectiveFieldOfView to create a new projection Matrix. This Matrix controls how camera coordinate values are transformed to screen coordinates. The first parameter is the field of view of the projection Matrix expressed in radians. A typical field of view of 45 degrees would be expressed as π/4 radians. The second parameter is the aspect ratio of the projection Matrix; it corrects for the difference in width and height of a viewspace. The third and fourth parameters specify the near and far distances at which the objects will be visible. // Set distance from the camera of the near and far clipping planes. static float nearClip = 1.0f; static float farClip = 2000.0f; Loop through each 3D model to be rendered using the projection matrix and view matrix created above. An identity matrix simplifies the code for the world matrix. void DrawModel(Model model, Matrix world, Texture2D texture) { foreach (ModelMesh mesh in model.Meshes) { foreach (BasicEffect effect in mesh.Effects) { effect.Projection = proj; effect.View = view; effect.World = world; effect.Texture = texture; effect.TextureEnabled = true; } mesh.Draw(); } }"
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/howto/graphics/HowTo_Rotate_Sprite.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/howto/graphics/HowTo_Rotate_Sprite.html",
    "title": "Rotating a Sprite | hallowed",
    "summary": "Overview Rotating images and sprites is easy enough, but the main thing to keep in mind is that the origin (drawing point) of textures is actually the top-left of the image, corresponding with the starting drawing point which is the top-left of the screen (for 2D anyway). This guide walks you through calculating a new origin for images (the center in this case) and using that to determine to draw and rotate your sprite from. End result Drawing a Rotated Sprite Follow the procedures of Drawing a Sprite. Determine the screen location of the sprite, and the point within the texture that will serve as the origin. By default, the origin of a texture is (0,0), the upper-left corner. When you draw a sprite, the origin point in the texture is placed on the screen coordinate specified by the spritePosition parameter (from the top-left hand corner of the screen). In this example, the origin has been calculated as the center of the texture, and the screen position is the center of the screen. Add the following properties and update your Game.LoadContent method as follows: private Texture2D spriteTexture; private Vector2 spritePosition; private Vector2 spriteOrigin; protected override void LoadContent() { // Create a new SpriteBatch, which can be used to draw textures. spriteBatch = new SpriteBatch(GraphicsDevice); spriteTexture = Content.Load<Texture2D>(\"Character\"); // Get the viewport to determine the drawable space on screen. Viewport viewport = _graphics.GraphicsDevice.Viewport; // Set the Texture origin to be the center of the texture. spriteOrigin.X = spriteTexture.Width / 2; spriteOrigin.Y = spriteTexture.Height / 2; // Set the position of the texture to be the center of the screen. spritePosition.X = viewport.Width / 2; spritePosition.Y = viewport.Height / 2; } In your Game.Update method, determine the rotation angle to use for the sprite. The angle is specified in radians, and it can be greater than two times π, but does not need to be. // The angle at which to rotate and draw the sprite at private float rotationAngle; protected override void Update(GameTime gameTime) { if (GamePad.GetState(PlayerIndex.One).Buttons.Back == ButtonState.Pressed || Keyboard.GetState().IsKeyDown(Keys.Escape)) Exit(); // The time since Update was called last. float elapsed = (float)gameTime.ElapsedGameTime.TotalSeconds; // TODO: Add your game logic here. // Simple roation logic to rotate the sprite in a clockwise direction over time rotationAngle += elapsed; float circle = MathHelper.Pi * 2; rotationAngle %= circle; base.Update(gameTime); } In your Game.Draw method, call SpriteBatch.Draw with the texture, angle, screen position, and origin of the texture. We do not need to specify a value for the sourceRectangle in this instance, so it is set to null. This is used to only draw a section of a texture, to see this in action check the How to animate a sprite guide. protected override void Draw(GameTime gameTime) { GraphicsDevice.Clear(Color.CornflowerBlue); // TODO: Add your drawing code here _spriteBatch.Begin(); // Draw call updated to use a different overload with additional parameters, specifically the \"Rotation angle\" and \"Origin\". _spriteBatch.Draw(spriteTexture, spritePosition, null, Color.White, rotationAngle, spriteOrigin, 1.0f, SpriteEffects.None, 0f); _spriteBatch.End(); base.Draw(gameTime); } When all the sprites have been drawn, call SpriteBatch.End on your SpriteBatch object. You should now see a rotating image in the center of the screen, rotating around the center of the image. For fun, just try rotating the image WITHOUT using the sprite's origin and see what happens. See Also Drawing a Sprite Concepts What Is a Sprite? Reference SpriteBatch SpriteBatch.Draw Texture2D"
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/howto/graphics/HowTo_Rotate_Sprite_Group.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/howto/graphics/HowTo_Rotate_Sprite_Group.html",
    "title": "Rotating a Group of Sprites | hallowed",
    "summary": "Overview Sometimes either an individual character is made up of many sprites/textures, or you simply want to arrange a group of sprites in a grid and have them move as one. The process is simple enough and simply an extension of what is covered in HowTo Rotate a Sprite. Drawing a Rotated Group of Sprites Follow the steps of Drawing a Sprite. Create one array of Vector2 variables that represent the un-rotated positions of the sprites and another to hold the rotated values. private Vector2[] myVectors; private Vector2[] drawVectors; protected override void Initialize() { myVectors = new Vector2[9]; drawVectors = new Vector2[9]; base.Initialize(); } After loading the sprite, calculate the positions of the un-rotated group of sprites based on the sprite's size. private Texture2D spriteTexture; private Vector2 spriteOrigin; private Vector2 spritePosition; protected override void LoadContent() { // Create a new SpriteBatch, which can be used to draw textures. _spriteBatch = new SpriteBatch(GraphicsDevice); spriteTexture = Content.Load<Texture2D>(\"Character\"); viewport = _graphics.GraphicsDevice.Viewport; spriteOrigin.X = spriteTexture.Width / 2; spriteOrigin.Y = spriteTexture.Height / 2; spritePosition.X = viewport.Width / 2; spritePosition.Y = viewport.Height / 2; // Populate the `myVectors` array with a grid of Vector2 positions for the character to draw. These will then be rotated around the center of the screen. int i = 0; while (i < 9) { for (int x = 0; x < 3; x++) { for (int y = 0; y < 3; y++) { myVectors[i] = new Vector2(x * 200, y * 200); // Assign positions i++; } } } } In your Game.Update method, copy the un-rotated vectors and determine the screen position around which all the sprites will rotate. private float rotationAngle = 0f; private Matrix rotationMatrix = Matrix.Identity; protected override void Update(GameTime gameTime) { if (GamePad.GetState(PlayerIndex.One).Buttons.Back == ButtonState.Pressed || Keyboard.GetState().IsKeyDown(Keys.Escape)) Exit(); // The time since Update was called last. float elapsed = (float)gameTime.ElapsedGameTime.TotalSeconds; // TODO: Add your game logic here. rotationAngle += elapsed; float circle = MathHelper.Pi * 2; rotationAngle %= circle; // Copy and rotate the sprite positions. drawVectors = (Vector2[])myVectors.Clone(); RotatePoints(ref spritePosition, rotationAngle, ref drawVectors); base.Update(gameTime); } Transform each vector using a rotation matrix created for the rotation angle. To rotate around the origin, transform each vector relative to the origin by subtracting the origin vector. Add the origin vector to the transformed vector to create the final rotated vector. private static void RotatePoints(ref Vector2 origin, float radians, ref Vector2[] Vectors) { Matrix myRotationMatrix = Matrix.CreateRotationZ(radians); for (int i = 0; i < 9; i++) { // Rotate relative to origin. Vector2 rotatedVector = Vector2.Transform(Vectors[i] - origin, myRotationMatrix); // Add origin to get final location. Vectors[i] = rotatedVector + origin; } } Draw each sprite using the rotated vectors as screen locations. protected override void Draw(GameTime gameTime) { GraphicsDevice.Clear(Color.CornflowerBlue); // TODO: Add your drawing code here _spriteBatch.Begin(); for (int i = 0; i < drawVectors.Length; i++) { _spriteBatch.Draw(spriteTexture, drawVectors[i], null, Color.White, rotationAngle, spriteOrigin, 1.0f, SpriteEffects.None, 0f); } _spriteBatch.End(); base.Draw(gameTime); } When all the sprites have been drawn, call SpriteBatch.End. This results in the Grid of characters that are drawn being rotated Together around a position in the center of the screen, instead of each sprite rotating individually. See Also Drawing a Sprite Concepts What Is a Sprite? Reference SpriteBatch SpriteBatch.Draw Texture2D"
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/howto/graphics/HowTo_Scale_Sprite.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/howto/graphics/HowTo_Scale_Sprite.html",
    "title": "Scaling a Sprite | hallowed",
    "summary": "Overview There are several implementations to apply scaling to 2D sprites / textures, namely: Uniform scale using a single float. NonUniform scale using a Vector 2. By specifying the Rectangle drawing dimensions of the output texture. The examples below detail each of the three methods. End result Drawing a Scaled Sprite with a uniform scale Follow the procedures of Drawing a Sprite. In your Update method, determine how your sprite will be scaled. The normal size of the sprite is multiplied by the scale specified. For example, a value of 1.0 draws the sprite full size, where 0.5 will draw it half-sized and 2.0 will draw it at twice its original size. private Vector2 spritePosition = Vector2.Zero; protected float spriteScale = 0f; protected override void Update(GameTime gameTime) { if (GamePad.GetState(PlayerIndex.One).Buttons.Back == ButtonState.Pressed || Keyboard.GetState().IsKeyDown(Keys.Escape)) Exit(); // The time since Update was called last. float elapsed = (float)gameTime.ElapsedGameTime.TotalSeconds; // TODO: Add your game logic here. spriteScale += elapsed; spriteScale %= 6; base.Update(gameTime); } When drawing the sprite, specify the scale of the sprite as a parameter if the SpriteBatch.Draw call to draw with a floating-point scale parameter to scale the sprite evenly in both the x and y directions. protected override void Draw(GameTime gameTime) { GraphicsDevice.Clear(Color.CornflowerBlue); // TODO: Add your drawing code here _spriteBatch.Begin(); // Updated draw call using the overload that allows passing the \"scale\" of a sprite _spriteBatch.Draw(spriteTexture, spritePosition, null, Color.White, 0f, Vector2.Zero, spriteScale, SpriteEffects.None, 0f); _spriteBatch.End(); base.Draw(gameTime); } When the sprite has been drawn, call SpriteBatch.End on your SpriteBatch object. You should now see the sprite scaling in from the top-left hand corner of the screen moving outwards, the same in both the X and Y directions. It will keep looping in case you miss it. To draw a scaled sprite using a nonuniform scale Alternatively, instead of using a flat scaling factor using a float, we can instead supply a Vector2 value with different scaling values for the X and Y axis, as follows: Follow the procedures of Drawing a Sprite. In your Update method, determine how your sprite will be scaled along each axis and store those values in a Vector2 object. protected Vector2 nonUniformScale = Vector2.One; protected override void Update(GameTime gameTime) { if (GamePad.GetState(PlayerIndex.One).Buttons.Back == ButtonState.Pressed || Keyboard.GetState().IsKeyDown(Keys.Escape)) Exit(); // The time since Update was called last. float elapsed = (float)gameTime.ElapsedGameTime.TotalSeconds; // TODO: Add your game logic here. float basescale = nonUniformScale.Y; basescale += elapsed; basescale %= 6; nonUniformScale.Y = basescale; nonUniformScale.X = basescale * .8f; base.Update(gameTime); } When drawing the sprite, specify the scale of the sprite using the Vector2 object that you updated earlier. Specifying a Vector2 scales the sprite independently in both the x and y directions. protected override void Draw(GameTime gameTime) { GraphicsDevice.Clear(Color.CornflowerBlue); // TODO: Add your drawing code here _spriteBatch.Begin(); _spriteBatch.Draw(spriteTexture, spritePosition, null, Color.White, 0f, Vector2.Zero, nonUniformScale, SpriteEffects.None, 0f); _spriteBatch.End(); base.Draw(gameTime); } When the sprite has been drawn, call SpriteBatch.End on your SpriteBatch object. You should now see the sprite scaling in from the top-left hand corner again and still moving outwards, however, the X and Y directions move at different rates. It will keep looping in case you miss it. To draw a scaled sprite using a destination rectangle Finally, you can control the scale of a sprite by overriding the area in which it is drawn and control the scale values for both the X and Y axis independently, as shown below: Follow the procedures of Drawing a Sprite. In your LoadContent method, construct a rectangle that defines where on screen the sprite will be drawn. This rectangle does not need to be the same shape or size as the original sprite. Each dimension of the sprite is scaled independently to fit the destination rectangle. protected float spriteScale = 1.0f; protected Rectangle drawingRectangle; private Viewport viewport; protected override void LoadContent() { // Create a new SpriteBatch, which can be used to draw textures. _spriteBatch = new SpriteBatch(GraphicsDevice); spriteTexture = Content.Load<Texture2D>(\"Character\"); // Get the viewport (window) dimensions viewport = _graphics.GraphicsDevice.Viewport; // Set the sprite drawing area from the Viewport origin (0,0) to 80% the sprite scale width and 100% of the sprite scale height. drawingRectangle.X = viewport.X; drawingRectangle.Y = viewport.Y; drawingRectangle.Width = (int)spriteScale * 100; drawingRectangle.Height = (int)spriteScale * 80; } When drawing the sprite, specify the destination rectangle as a parameter to SpriteBatch.Draw. The sprite will be drawn, filling the destination rectangle. protected override void Draw(GameTime gameTime) { GraphicsDevice.Clear(Color.CornflowerBlue); // TODO: Add your drawing code here _spriteBatch.Begin(); _spriteBatch.Draw(spriteTexture, drawingRectangle, Color.White); _spriteBatch.End(); base.Draw(gameTime); } When the sprite has been drawn, call SpriteBatch.End on your SpriteBatch object. You should now see the sprite in the top-left hand corner of the screen in a kind of squished style, feel free to play with the values for the drawingRectangle to draw the sprite at different scales. See Also Drawing a Sprite Concepts What Is a Sprite? Reference SpriteBatch SpriteBatch.Draw Texture2D"
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/howto/graphics/HowTo_Scale_Sprites_Matrix.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/howto/graphics/HowTo_Scale_Sprites_Matrix.html",
    "title": "Scaling Sprites Based On Screen Size | hallowed",
    "summary": "Overview Ensuring that the textures you draw to the screen are always scaled the same regardless of screen resolution is key, especially when targeting so many different devices with varying screen sizes. The key to handling this is to generate a scaling matrix based on your \"designed\" screen size and then applying that to the SpriteBatch calls you make when drawing to the screen. This is crucial for Screen UI / UX for example. To demonstrate this, we will design a view in a default resolution of 800 x 600 and define a scaling matrix that works on the same ratio. Note If you intend to work with multiple different scaling resolutions, you will need to define different scaling matrix's appropriately, if you allow the user to redefine what resolution the game runs in. Scaling Sprites Based on Screen Size Set the PreferredBackBufferHeight and PreferredBackBufferWidth properties of GraphicsDeviceManager in the Game constructor to set the default screen size of your game. public Game1() { _graphics = new GraphicsDeviceManager(this) { PreferredBackBufferHeight = 600, PreferredBackBufferWidth = 800 }; Content.RootDirectory = \"Content\"; IsMouseVisible = true; } Set up some variables to hold the debug textures we will draw, and then in your Game.LoadContent method, initialize them: private Viewport viewport; private Vector2[] scalingSpritePositions; private Texture2D squareTexture; private Vector2 spriteOrigin; private Matrix spriteScaleMatrix; protected override void LoadContent() { // Create a new SpriteBatch, which can be used to draw textures. _spriteBatch = new SpriteBatch(GraphicsDevice); viewport = _graphics.GraphicsDevice.Viewport; squareTexture = CreateTexture(GraphicsDevice, 50, 50); spriteOrigin = new Vector2(squareTexture.Width / 2, squareTexture.Height / 2); scalingSpritePositions = new Vector2[4]; scalingSpritePositions[0] = new Vector2(25, 25); scalingSpritePositions[1] = new Vector2(25, viewport.Height - 25); scalingSpritePositions[2] = new Vector2(viewport.Width - 25, 25); scalingSpritePositions[3] = new Vector2(viewport.Width - 25, viewport.Height - 25); UpdateScaleMatrix(); base.LoadContent(); } To help make the debug texture squareTexture easier, we add a little helper function to just generate the texture rather than import it through the Content Pipeline, as follows: public static Texture2D CreateTexture(GraphicsDevice device, int width, int height) { // Initialize a texture Texture2D texture = new Texture2D(device, width, height); // The array holds the color for each pixel in the texture Color[] data = new Color[width * height]; for (int pixel = 0; pixel < data.Length; pixel++) { data[pixel] = Color.White; } // Set the color texture.SetData(data); return texture; } Note This is a really handy reusable function to create simple textures at runtime. Next, we create another method to calculate the Scaling Matrix using Matrix.CreateScale based on the current Graphics Device's resolution, using our original 800x600 as a reference scale. This matrix should be recreated any time the resolution of the GraphicsDevice changes. Note Because you are scaling sprites, you should use only the x and y parameters to create the scaling matrix. Scaling the depth of sprites can result in their depth shifting above 1.0. If that happens, they will not render. private void UpdateScaleMatrix() { // Default resolution is 800x600; scale sprites up or down based on // current viewport float screenScale = _graphics.GraphicsDevice.Viewport.Width / 800f; // Create the scale transform for Draw. // Do not scale the sprite depth (Z=1). spriteScaleMatrix = Matrix.CreateScale(screenScale, screenScale, 1); } To allow you to quickly change the current resolution, in your Game.Update method add the following. This example uses the A and B keys to switch between two resolutions. protected override void Update(GameTime gameTime) { if (GamePad.GetState(PlayerIndex.One).Buttons.Back == ButtonState.Pressed || Keyboard.GetState().IsKeyDown(Keys.Escape)) Exit(); if (Keyboard.GetState().IsKeyDown(Keys.A)) { _graphics.PreferredBackBufferHeight = 768; _graphics.PreferredBackBufferWidth = 1024; _graphics.ApplyChanges(); UpdateScaleMatrix(); } if (Keyboard.GetState().IsKeyDown(Keys.B)) { _graphics.PreferredBackBufferHeight = 600; _graphics.PreferredBackBufferWidth = 800; _graphics.ApplyChanges(); UpdateScaleMatrix(); } base.Update(gameTime); } In your Game.Draw method, call SpriteBatch.Begin, passing the scaling matrix created in Game.LoadContent. Finally, draw your scene normally, then call SpriteBatch.End. All of the sprites you draw will be scaled according to the matrix. protected override void Draw(GameTime gameTime) { GraphicsDevice.Clear(Color.CornflowerBlue); // Initialize the batch with the scaling matrix _spriteBatch.Begin(transformMatrix: spriteScaleMatrix); // Draw a sprite at each corner for (int i = 0; i < scalingSpritePositions.Length; i++) { _spriteBatch.Draw(squareTexture, scalingSpritePositions[i], null, Color.White, 0f, spriteOrigin, 1f, SpriteEffects.None, 0f); } _spriteBatch.End(); base.Draw(gameTime); } See Also Drawing a Sprite Concepts What Is a Sprite? Reference SpriteBatch SpriteBatch.Draw Texture2D Matrix.CreateScale"
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/howto/graphics/HowTo_Select_an_Object_with_a_Mouse.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/howto/graphics/HowTo_Select_an_Object_with_a_Mouse.html",
    "title": "Selecting an Object with a Mouse | hallowed",
    "summary": "Overview A common requirement in game development is to select 3D objects in a scene. This example walks through the most common method for achieving this. Note This example applies only to Desktop or mobile development. The Mouse and MouseState objects are not supported on consoles. On consoles however the same pattern applies, you simply need to use either a fixed point (where the camera is looking, or screen center) or a cursor controlled by a stick to get the position. Detecting Whether a User Clicked a 3D Object Get the current state of the mouse by using GetState. MouseState mouseState = Mouse.GetState(); Get the current screen coordinates of the mouse from X and Y. int mouseX = mouseState.X; int mouseY = mouseState.Y; Note Replace mouse position with a virtual cursor or the screen centre for consoles. Using Viewport.Unproject, determine points in world space on the near and far clipping planes. For the point on the near plane, pass a source vector with x and y set to the mouse position, and z set to 0. For the point on the far plane, pass a source vector with x and y set to the position, and z set to 1. Create a translation matrix for a point that is the origin, (0,0,0). For both points, pass Viewport.Unproject the current projection matrix, the view matrix. // The closest point at which an object can interact. Vector3 nearsource = new Vector3((float)mouseX, (float)mouseY, 0f); // The furthest point at which an object can interact. Vector3 farsource = new Vector3((float)mouseX, (float)mouseY, 1f); Matrix world = Matrix.CreateTranslation(0, 0, 0); // Assuming you have the current Projection and View Matrices available. Vector3 nearPoint = GraphicsDevice.Viewport.Unproject(nearsource, proj, view, world); Vector3 farPoint = GraphicsDevice.Viewport.Unproject(farsource, proj, view, world); Create a Ray whose origin is at the near point and whose direction points to the far point. // Create a ray from the near clip plane to the far clip plane. Vector3 direction = farPoint - nearPoint; direction.Normalize(); Ray pickRay = new Ray(nearPoint, direction); Loop through each object in the scene using the Intersects method to check whether the Ray intersects each object. If it is hit, store the object and the distance at which it was intersected. // Assuming you have an array containing a list of all \"hittable\" objects in your game foreach (var obj in objects) { float? distance = ray.Intersects(obj.BoundingSphere); if (distance.HasValue) { // A cachable list of all object \"HIT\" this frame. intersectedObjects.Add(new Tuple<MyObject, float>(obj, distance.Value)); } } Sort the items that have been hit in order of which is closest. // Sort the intersected objects by distance intersectedObjects.Sort((a, b) => a.Item2.CompareTo(b.Item2)); When you completely loop through the objects, the last object stored will be the closest object underneath the area the user clicked. See Also Rotating and Moving the Camera Concepts What Is 3D Rendering? Reference Ray Ray.Intersects Ray.Intersects Ray.Intersects BoundingBox BoundingSphere Plane"
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/howto/graphics/HowTo_Test_for_Collisions.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/howto/graphics/HowTo_Test_for_Collisions.html",
    "title": "Testing for Collisions | hallowed",
    "summary": "Overview Collision detection is a crucial part of almost any game where the game needs to know whether or not two objects are touching. Normally, a simple distance (Vector3.Distance) check is sufficient, but when you need to know where they are touching or require more accurate information, that is when collision detection becomes critical. Detecting Whether Two Models Collide Track the position of a model as it moves about the game world. struct WorldObject { public Vector3 position; public Vector3 velocity; public Model model; public Texture2D texture2D; public Vector3 lastPosition; public void MoveForward() { lastPosition = position; position += velocity; } public void Backup() { position -= velocity; } public void ReverseVelocity() { velocity.X = -velocity.X; } } Make a nested loop with the first model's meshes as the outer loop and the second model's meshes as the inner loop. Inside the loop, follow these steps. Get the bounding sphere for the current mesh of the first model and the current mesh of the second model. Offset the bounding spheres by the current positions of the models. Call the BoundingSphere.Intersects method to check the pairs of bounding spheres for collision. If the method returns true, the objects are colliding. If the models are colliding, break out of the loop. static void CheckForCollisions(ref WorldObject c1, ref WorldObject c2) { for (int i = 0; i < c1.model.Meshes.Count; i++) { // Check whether the bounding boxes of the two cubes intersect. BoundingSphere c1BoundingSphere = c1.model.Meshes[i].BoundingSphere; c1BoundingSphere.Center += c1.position; for (int j = 0; j < c2.model.Meshes.Count; j++) { BoundingSphere c2BoundingSphere = c2.model.Meshes[j].BoundingSphere; c2BoundingSphere.Center += c2.position; if (c1BoundingSphere.Intersects(c2BoundingSphere)) { c2.ReverseVelocity(); c1.Backup(); c1.ReverseVelocity(); return; } } } } See Also Rotating and Moving the Camera Concepts Bounding Volumes and Collisions"
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/howto/graphics/HowTo_Tile_Sprites.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/howto/graphics/HowTo_Tile_Sprites.html",
    "title": "Tiling a Sprite | hallowed",
    "summary": "Overview This sample uses a texture addressing mode to duplicate a texture across the area defined by SpriteBatch.Draw. Other address modes, such as mirroring, can create interesting results. We will simply define an area (Rectangle) in which to draw our texture, but in a SpriteBatch drawing mode that will keep tiling the texture until it fills the area. End result Requirements Drawing a Tiled a Sprite Follow the procedures of Drawing a Sprite. Setup some new variables to define how we want to draw the tiled area and with which Texture. // Tiling Texture private Texture2D monoGameLogo; // How many tiles wide private int tileCountWidth = 2; // How many tiles high private int tileCountHeight = 2; // Rectangle to draw tiles in private Rectangle targetRectangle; // Position to draw the tiled Rectangle at private Vector2 position; In the LoadContent method, we will load the Texture and then setup our drawing position and target based on the input graphics dimensions. Feel free to play with these values to alter how the tiling area is drawn. // Load the texture to tile. monoGameLogo = Content.Load<Texture2D>(\"MonoGame\"); // Define a drawing rectangle based on the number of tiles wide and high, using the texture dimensions. targetRectangle = new Rectangle(0, 0, monoGameLogo.Width * tileCountWidth, monoGameLogo.Height * tileCountHeight); // Get the drawable area of the screen. Viewport viewport = GraphicsDevice.Viewport; // Center the rectangle on the screen, using both the screen center and the rectangle center. position = new Vector2(-targetRectangle.Width / 2 + viewport.Width / 2, -targetRectangle.Height / 2 + viewport.Height / 2); In the Game.Draw method, call SpriteBatch.Begin to set the sprite state. The destination Rectangle can be any size. In this example, the width and height of the destination rectangle are integer multiples of the source sprite. This will cause the sprite texture to be tiled, or drawn several times, to fill the destination area. The Begin method is also using overrides to define the SamplerState and set it to Wrap (repeat). _spriteBatch.Begin(SpriteSortMode.FrontToBack, BlendState.Opaque, SamplerState.LinearWrap, DepthStencilState.Default, RasterizerState.CullNone); Call SpriteBatch.Draw with the sprite, the destination rectangle, and other relevant parameters. _spriteBatch.Draw(monoGameLogo, Vector2.Zero, targetRectangle, Color.White, 0, Vector2.Zero, 1, SpriteEffects.None, 0); Call SpriteBatch.End on your SpriteBatch object. _spriteBatch.End(); See Also Drawing a Sprite Concepts What Is a Sprite? Reference SpriteBatch SpriteBatch.Draw SpriteSortMode Texture2D"
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/howto/graphics/HowTo_Tint_Sprite.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/howto/graphics/HowTo_Tint_Sprite.html",
    "title": "Tinting a Sprite | hallowed",
    "summary": "Overview Tinting sprites is an easy way to either animate a sprite (when it takes damage) or even to create different characters of different colors. It is quick and efficient to do and all you need is the color to tine with and a single change to your SpriteBatch draw call. End result Drawing a Tinted Sprite Follow the procedures of Drawing a Sprite. In the Game.Update method, determine the color to tint the sprite. In this example, the position of the mouse determines the Red, Green, values to apply to the sprite, the blue is fixed for simplicity. // The color tint to apply to the sprite protected Color tint; protected override void Update(GameTime gameTime) { if (GamePad.GetState(PlayerIndex.One).Buttons.Back == ButtonState.Pressed || Keyboard.GetState().IsKeyDown(Keys.Escape)) Exit(); // TODO: Add your update logic here MouseState mouse = Mouse.GetState(); tint = new Color(mouse.X % 255, mouse.Y % 255, 255); base.Update(gameTime); } In the Game.Draw method, pass the color value created in Game.Update to SpriteBatch.Draw. protected override void Draw(GameTime gameTime) { GraphicsDevice.Clear(Color.CornflowerBlue); // TODO: Add your drawing code here _spriteBatch.Begin(); // Note the final argument in the Draw call is changed from Color.White to the new \"tint\" property _spriteBatch.Draw(spriteTexture, spritePosition, tint); _spriteBatch.End(); base.Draw(gameTime); } When all of the sprites have been drawn, call SpriteBatch.End on your SpriteBatch object. Moving the mouse around the screen will change the color of the Tint that is applied to the sprite / texture each frame. Alternatively, try switching the input to something else, or for a challenge, animate the tint to make it look like the character is taking damage. See Also Drawing a Sprite Concepts What Is a Sprite? Reference SpriteBatch SpriteBatch.Draw Texture2D Color (Character by upklyak from FreePik)"
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/howto/graphics/HowTo_TransformPoint.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/howto/graphics/HowTo_TransformPoint.html",
    "title": "How to transform a Point | hallowed",
    "summary": "Overview Transformation matrices are the cornerstone of 3D rendering and how we manipulate content to be drawn in a 3D environment. Note For a great primer on Transformation matrices, check out: Transformation Matrix Overview - Geeks for Geeks Transforming a Point with a Matrix In MonoGame, matrices are transformed using the Vector3.Transform function with an applied matrix. Create a Matrix by using CreateRotationY or one of the other Create methods. Create Rotation Y will create a matrix that is rotated a number of radians around its center. Pass the point and the Matrix to the Vector3.Transform method. The following code example is a static function that accept a Vector3 and translate its position (or rotate it) by the amount of radians (NOT degrees) provided. static Vector3 RotatePointOnYAxis(Vector3 point, float angle) { // Create a rotation matrix that represents a rotation of angle radians. Matrix rotationMatrix = Matrix.CreateRotationY(angle); // Apply the rotation matrix to the point. Vector3 rotatedPoint = Vector3.Transform(point, rotationMatrix); return rotatedPoint; } See Also Drawing 3D Primitives using Lists or Strips Matrix Creation Methods Matrix CreateRotationX CreateRotationY CreateRotationZ CreateScale CreateTranslation"
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/howto/graphics/HowTo_UseACustomVertex.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/howto/graphics/HowTo_UseACustomVertex.html",
    "title": "How to create a Custom Vertex Declaration | hallowed",
    "summary": "Overview MonoGame includes a few predefined classes for common vertex buffer declarations such as VertexPositionColor and VertexPositionColorTexture. If you need to create a vertex buffer declaration that includes additional user-defined types, create a custom vertex declaration. A custom vertex declaration is a class that implements fully customizable per-vertex data. Furthermore, if you derive the class from IVertexType, you will not need to create a vertex declaration when creating your vertex buffer or drawing the geometry. Requirements The following texture will be used to render to the screen. Save it to your content project and name it \"logo\" (this name will used to reference it in the project). Make sure to add it to your content project. Starting from the Basic Effect tutorial Follow the steps of How to create a Basic Effect. This gives us a starting project that is rendering a 3D scene with a Basic Effect. Create a custom vertex declaration Create a new class file called CustomVertex1.cs Add the required using statements to the top of the file. using Microsoft.Xna.Framework; using Microsoft.Xna.Framework.Graphics; Declare a structure that derives from IVertexType. public struct CustomVertex1 : IVertexType Add members to the struct that describe the per-vertex data. This example uses position as a Vector3 Structure type, a texture coordinate using a Vector2 Structure type, and a vertex declaration using the VertexDeclaration type. private Vector3 vertexPosition; private Vector2 vertexTextureCoordinate; public readonly static VertexDeclaration VertexDeclaration = new VertexDeclaration ( new VertexElement(0, VertexElementFormat.Vector3, VertexElementUsage.Position, 0), new VertexElement(12, VertexElementFormat.Vector2, VertexElementUsage.TextureCoordinate, 0) ); Implement the constructor and public accessor methods. //The constructor for the custom vertex. This allows similar //initialization of custom vertex arrays as compared to arrays of a //standard vertex type, such as VertexPositionColor. public CustomVertex1(Vector3 pos, Vector2 textureCoordinate) { vertexPosition = pos; vertexTextureCoordinate = textureCoordinate; } //Public methods for accessing the components of the custom vertex. public Vector3 Position { get { return vertexPosition; } set { vertexPosition = value; } } public Vector2 TextureCoordinate { get { return vertexTextureCoordinate; } set { vertexTextureCoordinate = value; } } Implement a non-public method for accessing the vertex declaration. VertexDeclaration IVertexType.VertexDeclaration { get { return VertexDeclaration; } } Using the Custom Vertex Buffer Using the Custom Vertex buffer, we will render a cube that is textured with the logo texture. Declare some variables at the top of your Game class. private CustomVertex1[] cubeVertices; private VertexBuffer vertexBuffer; private Texture2D logoTexture; This gives us the necessary data in order to draw our cube. Create a new method called SetupDrawingCube() and we will start with initializing the vertex buffer, passing in the typeof(CustomVertex1) instead of a vertex declaration to describe the vertex buffer data. public void SetupDrawingCube() { vertexBuffer = new VertexBuffer( GraphicsDevice, typeof(CustomVertex1), 36, BufferUsage.None ); Create the per-vertex data; this shows a portion of the code. Vector3 LeftTopFront = new Vector3(-1.0f, 1.0f, 1.0f); Vector3 LeftBottomFront = new Vector3(-1.0f, -1.0f, 1.0f); Vector3 LeftTopBack = new Vector3(-1.0f, 1.0f, -1.0f); Vector3 LeftBottomBack = new Vector3(-1.0f, -1.0f, -1.0f); Vector3 RightTopFront = new Vector3(1.0f, 1.0f, 1.0f); Vector3 RightBottomFront = new Vector3(1.0f, -1.0f, 1.0f); Vector3 RightTopBack = new Vector3(1.0f, 1.0f, -1.0f); Vector3 RightBottomBack = new Vector3(1.0f, -1.0f, -1.0f); Vector2 textureLeftTop = new Vector2(0.0f, 0.0f); Vector2 textureLeftBottom = new Vector2(0.0f, 1.0f); Vector2 textureRightTop = new Vector2(1.0f, 0.0f); Vector2 textureRightBottom = new Vector2(1.0f, 1.0f); // Front face. cubeVertices = new CustomVertex1[36]; cubeVertices[0] = new CustomVertex1(LeftTopFront, textureLeftTop); cubeVertices[1] = new CustomVertex1(LeftBottomFront, textureLeftBottom); cubeVertices[2] = new CustomVertex1(RightTopFront, textureRightTop); cubeVertices[3] = new CustomVertex1(LeftBottomFront, textureLeftBottom); cubeVertices[4] = new CustomVertex1(RightBottomFront, textureRightBottom); cubeVertices[5] = new CustomVertex1(RightTopFront, textureRightTop); // Add the vertices for the BACK face. cubeVertices[6] = new CustomVertex1(LeftTopBack, textureRightTop); cubeVertices[7] = new CustomVertex1(RightTopBack, textureLeftTop); cubeVertices[8] = new CustomVertex1(LeftBottomBack, textureRightBottom); cubeVertices[9] = new CustomVertex1(LeftBottomBack, textureRightBottom); cubeVertices[10] = new CustomVertex1(RightTopBack, textureLeftTop); cubeVertices[11] = new CustomVertex1(RightBottomBack, textureLeftBottom); // Add the vertices for the TOP face. cubeVertices[12] = new CustomVertex1(LeftTopFront, textureLeftBottom); cubeVertices[13] = new CustomVertex1(RightTopBack, textureRightTop); cubeVertices[14] = new CustomVertex1(LeftTopBack, textureLeftTop); cubeVertices[15] = new CustomVertex1(LeftTopFront, textureLeftBottom); cubeVertices[16] = new CustomVertex1(RightTopFront, textureRightBottom); cubeVertices[17] = new CustomVertex1(RightTopBack, textureRightTop); // Add the vertices for the BOTTOM face. cubeVertices[18] = new CustomVertex1(LeftBottomFront, textureLeftTop); cubeVertices[19] = new CustomVertex1(LeftBottomBack, textureLeftBottom); cubeVertices[20] = new CustomVertex1(RightBottomBack, textureRightBottom); cubeVertices[21] = new CustomVertex1(LeftBottomFront, textureLeftTop); cubeVertices[22] = new CustomVertex1(RightBottomBack, textureRightBottom); cubeVertices[23] = new CustomVertex1(RightBottomFront, textureRightTop); // Add the vertices for the LEFT face. cubeVertices[24] = new CustomVertex1(LeftTopFront, textureRightTop); cubeVertices[25] = new CustomVertex1(LeftBottomBack, textureLeftBottom); cubeVertices[26] = new CustomVertex1(LeftBottomFront, textureRightBottom); cubeVertices[27] = new CustomVertex1(LeftTopBack, textureLeftTop); cubeVertices[28] = new CustomVertex1(LeftBottomBack, textureLeftBottom); cubeVertices[29] = new CustomVertex1(LeftTopFront, textureRightTop); // Add the vertices for the RIGHT face. cubeVertices[30] = new CustomVertex1(RightTopFront, textureLeftTop); cubeVertices[31] = new CustomVertex1(RightBottomFront, textureLeftBottom); cubeVertices[32] = new CustomVertex1(RightBottomBack, textureRightBottom); cubeVertices[33] = new CustomVertex1(RightTopBack, textureRightTop); cubeVertices[34] = new CustomVertex1(RightTopFront, textureLeftTop); cubeVertices[35] = new CustomVertex1(RightBottomBack, textureRightBottom); For a triangle list, you need three vertices for a triangle and two triangles to make the front face of a cube. Finally, set the data into the vertex buffer data by calling VertexBuffer.SetData and set the vertex buffer to the device by calling GraphicsDevice.SetVertexBuffer. vertexBuffer.SetData<CustomVertex1>(cubeVertices); graphics.GraphicsDevice.SetVertexBuffer(vertexBuffer); } In LoadContent we need to Load the texture we are going to draw, as well as call the new method we defined to setup the primitive Cube. logoTexture = Content.Load<Texture2D>(\"logo\"); SetupDrawingCube(); At the moment the BasicEffect setup from the previous tutorial only draws Vertex Colors, so we need to change that to pass it the texture we just loaded, as well as enabling Texture drawing Replace: basicEffect.VertexColorEnabled = true; With the following // Enable Texture Drawing - VERY IMPORTANT!! basicEffect.TextureEnabled = true; // Set the texture we loaded (does nothing without the above setting) basicEffect.Texture = logoTexture; Finally, Draw the object by calling GraphicsDevice.DrawPrimitives. foreach (EffectPass pass in basicEffect.CurrentTechnique.Passes) { pass.Apply(); graphics.GraphicsDevice.DrawPrimitives( PrimitiveType.TriangleList, 0, // start vertex 12 // number of primitives to draw, 2 vertexes per side of the cube ); } Extra credit, make it spin At the moment all you can see is the front face of the cube, which is not very exciting. Though Matrix Transforms however, we make our cube spin. First define a variable to manage the current rotation. float rotation = 0f; Next, we will update this rotation each frame in the Update method. // Update rotation angle float deltaTime = (float)gameTime.ElapsedGameTime.TotalSeconds; rotation += deltaTime; Then finally, in the Draw method, we need to calculate the rotation matrix and the translation matrix to rotate the cube by and then apply that to the basic effect drawing the cube. Add the following to the Draw call BEFORE the effect drawing loop. // Create rotation matrices Matrix rotationMatrix = Matrix.CreateRotationX(rotation) * Matrix.CreateRotationY(rotation) * Matrix.CreateRotationZ(rotation); // Apply rotation to the world matrix Matrix worldMatrix = rotationMatrix * Matrix.CreateTranslation(new Vector3(0, 0, 0)); // Update the world matrix in the effect basicEffect.World = worldMatrix; Note This is a very basic example of applying rotation, just for reference. With the changes in place, your cube will look a little more snazzy and rotate in the world. See Also How to create a Basic Effect How to transform a Point Concepts What Is 3D Rendering? Reference IVertexType VertexDeclaration Matrix"
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/howto/graphics/HowTo_UseViewportForSplitscreenGaming.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/howto/graphics/HowTo_UseViewportForSplitscreenGaming.html",
    "title": "How to display Multiple Screens with Viewports | hallowed",
    "summary": "Overview To create multiple screens In your LoadContent method, create two new Viewport objects to define the two new \"split\" regions of the screen. In this example, the screen is split in half vertically. Viewport defaultViewport; Viewport leftViewport; Viewport rightViewport; Matrix projectionMatrix; Matrix halfprojectionMatrix; protected override void LoadContent() { // Create a new SpriteBatch, which can be used to draw textures. spriteBatch = new SpriteBatch(GraphicsDevice); defaultViewport = GraphicsDevice.Viewport; leftViewport = defaultViewport; rightViewport = defaultViewport; leftViewport.Width = leftViewport.Width / 2; rightViewport.Width = rightViewport.Width / 2; rightViewport.X = leftViewport.Width; Create a projection matrix to fit each new viewport. In this case, because the screen is split in half, only one new projection matrix is necessary. It has the same settings as the 4:3 full screen projection matrix, except the aspect ratio is now 2:3. projectionMatrix = Matrix.CreatePerspectiveFieldOfView( MathHelper.PiOver4, 4.0f / 3.0f, 1.0f, 10000f); halfprojectionMatrix = Matrix.CreatePerspectiveFieldOfView( MathHelper.PiOver4, 2.0f / 3.0f, 1.0f, 10000f); } In your Game Game.Draw method, assign one of the viewports to draw as the GraphicsDeviceViewport. Draw your scene as normal, using the camera (or view matrix) associated with this perspective along with the proper projection matrix. protected override void Draw(GameTime gameTime) { GraphicsDevice.Viewport = defaultViewport; GraphicsDevice.Clear(Color.CornflowerBlue); GraphicsDevice.Viewport = leftViewport; DrawScene(gameTime, Camera1.ViewMatrix, halfprojectionMatrix); After drawing the first scene, assign the other viewport to the Viewport property. Draw your scene again with the associated camera or view matrix, and the proper projection matrix. GraphicsDevice.Viewport = rightViewport; DrawScene(gameTime, Camera2.ViewMatrix, halfprojectionMatrix); base.Draw(gameTime); } See Also Concepts What Is a Viewport? Reference GraphicsDevice.Viewport Viewport Structure"
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/howto/graphics/camera/HowTo_Understand_Different_Camera_Modes.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/howto/graphics/camera/HowTo_Understand_Different_Camera_Modes.html",
    "title": "Understanding different camera modes | hallowed",
    "summary": "Overview This example is different from most as it is demonstrating several techniques to update a camera's view and position to achieve different camera modes or operations, including: A Fixed Camera. A Fixed tracking camera - follows the target. A first person camera. A third person camera - with spring. A top-down fixed camera view. A top-down view centered on a target. End result These are the kinds of camera modes demonstrated in this sample: Fixed View Fixed Tracking First Person View Third Person View Top Down Top Down tracking Sample As the sample is quite large and contains several pieces of content for the demonstration, the full source is available here: Basic Camera Example Source Understanding the different camera modes To understand how these different camera modes work, the principle is fairly strait forward. Tip Please review the What is Camera guide for more detail on the concepts discussed here. World The world that the camera and models are contained in usually static (at least for a single \"world\" or game level), for simplicity, this is usually kept at the center of the world which is 0,0,0 or Matrix.Identity. All content is then Transformed / positioned relative to this central world point. Projection The project of the view is also normally fixed for any single camera (although you might use different perspectives for different cameras, e.g. a map view). This is defined once in either a Perspective or Orthographic (with or without depth). This is then applied to the drawing methods to define the bounds of what is drawn to the screen. Tip Elements drawn outside of the camera view / projection are culled or ignored by the graphics device. However, unless you control what data is sent, you are still paying for the performance to send to the graphics card and consider it for drawing. This is where techniques are used to limit the data sent to the graphics card and ONLY send models and textures that you know will be actually drawn and limiting what is discarded. Camera Views The sample separates out the actual work in drawing each camera mode based on what is active at the time in the Update loop, as shown here: switch (currentCameraMode) { case CameraMode.Fixed: UpdateFixedCamera(); break; case CameraMode.Tracking: UpdateTrackingCamera(); break; case CameraMode.FirstPerson: UpdateFirstPersonCamera(); break; case CameraMode.ThirdPerson: UpdateThirdPersonCamera((float)gameTime.ElapsedGameTime.TotalSeconds); break; case CameraMode.TopDownFixed: UpdateTopDownFixedCamera(); break; case CameraMode.TopDownCentred: UpdateTopDownCenteredCamera(); break; } You would not normally do this, it is only done this way for the purposes of the sample. In reality you would only use the mode relevant to the current game view (although a lot of first person games do allow switching between First Person and Third Person), however, as you will see, you are only updating the way the View Matrix is generated along with the camera position, in 3D the content is always drawn the same regardless. The Fixed Camera view This is the simplest way of rendering a camera, you just create a View Matrix using the Camera's current position and looking at the center of the world (or whatever you want it to look at). For example: void UpdateCameraView(Vector3 aCameraPosition, Vector3 aCameraTarget) { // Update the camera view matrix with the `Matrix.LookAt` method. currentCameraView = Matrix.CreateLookAt(aCameraPosition, aCameraTarget, Vector3.Up); } // Set the position of the camera in world space, for the fixed camera view matrix. private Vector3 cameraFixedPosition = new Vector3(0.0f, 1550.0f, 5000.0f); void UpdateFixedCamera() { // Fixed view, the camera is always in the same position and looking the same way, no updates. UpdateCameraView(cameraFixedPosition, Vector3.Zero); } The Tracking Camera Giving the camera something to look at is also quite simple, instead of looking at the center of the world (assuming the world is Matrix.Identity), we instead \"Look at\" the model itself, dymanically updated each frame, as follows: // Set the position of the camera in world space, for the fixed camera view matrix. private Vector3 cameraFixedPosition = new Vector3(0.0f, 1550.0f, 5000.0f); void UpdateTrackingCamera() { // Tracking view, the camera is always in the same position but changes the view matrix to \"look\" towards a target. // Set up our world matrix, view matrix and projection matrix. UpdateCameraView(cameraFixedPosition, modelPosition); } Run once per update, wherever in the world the target ends up, the camera will rotate to LookAt the target. The First Person Camera There are several ways of achieving a first person view, some use the camera as the player and update the camera position, some (as in this example) take the player position and then transform the camera to it. Either way is fine (although in practice, if you want to use multiple camera views, it is better to keep them separate). In this example, we apply all the same transformations to the camera we perform on the \"player\" model to achieve this effect: // 1st Person camera position relative to player model private Vector3 cameraFirstPersonPosition = new Vector3(0.0f, 50.0f, 500.0f); void UpdateFirstPersonCamera() { // First person view, the camera moves based on the Model's position (which is moved by input) and the view matrix is updated to always look \"forward\" from the model. // Create a rotational matrix based on the current model's heading. Matrix rotationMatrix = Matrix.CreateRotationY(modelRotation); // Create a vector pointing the direction the camera is facing. Vector3 transformedReference = Vector3.Transform(cameraFirstPersonPosition, rotationMatrix); // Calculate the position the camera is looking from. currentCameraPosition = transformedReference + modelPosition; // Set up our world matrix, view matrix and projection matrix. UpdateCameraView(currentCameraPosition, modelPosition); } You may want to look at other examples of First Person translation for cameras before deciding what works best for your game. Third Person Camera Compared to the first person camera, the Third Person view is a much simpler approach, as the Model/Player and the Camera have to be kept separate. In most scenarios though, you have more considerations that the basic first person view, such as: Wall clipping Obscuring by other world objects Bad viewing angles These are two complex to go into for now, so you may want to do some further reading. In this sample we have included a simple physics based \"Spring\" system, so that the camera's view follows the player in a much smoother way (it also looks REALLY cool when the players ship \"jumps\" to a new location, try resetting the ships position after moving in the sample in this mode). The code is as follows: // 3rd Person camera position relative to player model private Vector3 cameraThirdPersonPosition = new Vector3(0.0f, 1550.0f, 5000.0f); void UpdateThirdPersonCamera(float aElapsed) { // First person view, the camera is offset behind and above the model and moves with it,the view matrix is updated to always look \"forward\" from the model. // It also includes an optional spring physics system to smooth out the camera movement. // Create a rotational matrix based on the current model's heading. Matrix rotationMatrix = Matrix.CreateRotationY(modelRotation); // Create a vector pointing the direction the camera is facing. Vector3 transformedReference = Vector3.Transform(cameraThirdPersonPosition, rotationMatrix); // If camera spring is enabled, update the position and rotation of the camera over several frames if (cameraSpringEnabled) { // Calculate the position where we would like the camera to be looking from. Vector3 desiredPosition = transformedReference + modelPosition; // Calculate spring force Vector3 stretch = currentCameraPosition - desiredPosition; Vector3 force = -cameraStiffness * stretch - cameraDamping * cameraVelocity; // Apply acceleration Vector3 acceleration = force / cameraMass; cameraVelocity += acceleration * aElapsed; // Apply velocity currentCameraPosition += cameraVelocity * aElapsed; } // If not, just move the camera without smoothing else { // Calculate the position the camera is looking from. currentCameraPosition = transformedReference + modelPosition; } // Set up our world matrix, view matrix and projection matrix. UpdateCameraView(currentCameraPosition, modelPosition); } The main difference between the First Person and Third Person views is that the \"Position\" of the camera is offset behind and above the center of the player, this is then transformed and added to the players current position before constructing the view. Top Down Camera The same as the Fixed Camera view, the camera simply has a position and looks at the center of the world, however, it is positioned far above the world so that it is looking down. Tip In this sample it has been kept as a Perspective Camera and evaluates depth, however, if you are having a Map camera then it is more likely to use an orthographic projection instead. // Top Down camera position relative to player model private Vector3 cameraTopDownPosition = new Vector3(0.0f, 25000.0f, 1.0f); void UpdateTopDownFixedCamera() { // A Top-Down fixed view, the camera is always in the same position and looking down onto the game scene. // Note, there are no boundaries to prevent the model from moving out of view. // Set up our world matrix, view matrix and projection matrix. UpdateCameraView(cameraTopDownPosition, Vector3.Zero); } Top Down Tracked Camera To finish off these camera modes, the top-down tracked view is more of a combination of a third person and top-down view, wherein the camera is way above the world and follows only the target on a 2D plane, like the third person view the camera is simply placed above the model/player and then transforms/updates its position based on the movement of the player. // Top Down camera position relative to player model private Vector3 cameraTopDownPosition = new Vector3(0.0f, 25000.0f, 1.0f); void UpdateTopDownCenteredCamera() { // A Top-Down view that moves according to two dimensional position of the model, looking down onto the model. // Create a rotational matrix based on the current model's heading. Matrix rotationMatrix = Matrix.CreateRotationY(modelRotation); // Create a vector pointing the direction the camera is facing. Vector3 transformedReference = Vector3.Transform(cameraTopDownPosition, rotationMatrix); // Calculate the position the camera is looking from. currentCameraPosition = transformedReference + modelPosition; // Set up our world matrix, view matrix and projection matrix. UpdateCameraView(currentCameraPosition, modelPosition); } See Also How to display Multiple Screens with Viewports Concepts What Is 3D Rendering? What Is a Viewport? What Is a View Frustum? What Is a Render Target? Reference GraphicsDevice.Viewport Matrix SpriteBatch"
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/howto/graphics/index.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/howto/graphics/index.html",
    "title": "How to articles for the Graphics pipeline | hallowed",
    "summary": "In This Section This section demonstrates several graphical concepts divided into the following categories: 2D Sprite Rendering Cameras 3D Rendering 3D Collisions 2D Sprite Rendering This section walks through several core concepts related to sprite rendering, including drawing text to the screen. How To Draw A Sprite Demonstrates how to draw a sprite by using the SpriteBatch class. How To Draw A Sprite Background Demonstrates how to draw a foreground and background sprite using the SpriteBatch class, where only part of the foreground sprite masks the background. How To Tint A Sprite Demonstrates how to tint a sprite using a Color value. How To Rotate A Sprite Demonstrates how to rotate a sprite around its center. How To Rotate A Sprite Group Demonstrates how to rotate a group of sprites around a single point. How To Scale A Sprite Demonstrates how to scale a sprite using a uniform scale. How To Scale A Sprite using A Matrix Demonstrates how to scale sprites using a matrix that is created based on the viewport width. How To Tile Sprites Demonstrates how to draw a sprite repeatedly in the x and y directions in one Draw call. How To Draw Text Demonstrates how to import a SpriteFont into a project and to draw text using the DrawString method. How To Animate A Sprite Demonstrates how to animate a sprite from a texture using a custom class. How To Make A Scrolling Background Demonstrates how to draw a scrolling background sprite using the SpriteBatch class. Cameras Rotating and Moving the Camera Demonstrates how to rotate and move a camera in a 3D environment. You can rotate the camera about its y-axis, and move it forward and backward. You control the camera's position and orientation by using the directional keys on your keyboard or by using the D-pad of your gamepad. How to position the Camera Demonstrates how to position the camera so that all objects in a scene are within the view frustum while maintaining the camera's original orientation. How to create a Render Target Demonstrates how to create a render target using the RenderTarget2D class. How to create a Full-Screen Game Demonstrates how to start a game in full-screen mode. How to restrict Aspect Ratio on a Graphics Device Demonstrates how to create a custom GraphicsDeviceManager that only selects graphics devices with widescreen aspect ratios in full-screen mode. How to display Multiple Screens with Viewports Demonstrates how to use viewports to display different scenes simultaneously using two cameras. 3D Rendering This section walks through several core concepts related 3D rendering and math practices with MonoGame. How to transform a Point This example demonstrates how to use the Vector3 and Matrix classes to transform a point. A matrix transform can include scaling, rotating, and translating information. How to create a Basic Effect Demonstrates how to create and initialize an instance of the BasicEffect class and use it to draw simple geometry. Using a Basic Effect with Texturing Demonstrates how to create and draw a simple quad—two triangles that form a rectangle or square—using DrawUserIndexedPrimitives. How to create a State Object Demonstrates how to create a state object using any of the state object classes: BlendState, DepthStencilState, RasterizerState, or SamplerState. Drawing 3D Primitives using Lists or Strips Demonstrates how to draw 3D primitives using lines and triangles arranged as strips or lists. How to render a Model using a Basic Effect Demonstrates how to load and render a model using the MonoGame Content Pipeline. It is assumed that an existing Windows game project is loaded in MonoGame. How to enable Anti-aliasing Demonstrates how to enable anti-aliasing for your game. How to create a Custom Vertex Declaration Demonstrates how to create a custom vertex declaration and use it to render a 3D object. How to Dynamically Update Vertex Data Geometry in a 3D game is defined by vertex data. Sometimes, a game needs to modify vertex data or even generate new vertex data dynamically (at run time). Here are some solutions for dynamically updating vertex data. 3D Collisions Bounding Volumes and Collisions Collision detection determines whether objects in a game world overlap each other. Selecting an Object with a Mouse Demonstrates how to check whether the mouse is positioned over a 3D object by creating a ray starting at the camera's near clipping plane and ending at its far clipping plane. Testing for Collisions Demonstrates how to use the BoundingSphere class to check whether two models are colliding."
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/howto/index.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/howto/index.html",
    "title": "How To Articles for MonoGame | hallowed",
    "summary": "In This Section Ever wondered how to do a specific thing quickly, or just try to recall how an operation or function is meant to be implemented, these \"How To\" guides are quick and short tutorials on how to use each of the features of the MonoGame Framework. Note These guides are not meant to be a replacement for \"full on\" tutorials, they are intended as short cuts to relevant information only. This section is broken down into 3 distinct categories: Core concepts Game Operations Guidance Core concepts This section details the core concepts to understand how MonoGame projects fit together. Audio A set of articles detailing how to use or implement specific audio features of MonoGame. Content Pipeline Guides on how to use the Content Pipeline and the MGCB tool for getting content into your MonoGame projects. Graphics Detailed tutorials on specific graphics features and operations. Input Tutorials on how to get the most out of specific inputs from MonoGame while running on platforms. Game Operations This section details some of the operational aspects of running a MonoGame game. How to manage automatic rotation and scaling Demonstrates how to manage rotation and scaling based on device orientation. How to exit a Game Immediately Demonstrates how to exit a game in response to user input. How to exit a Game After a Time Out Demonstrates how to exit a game after a period of time (such as inactivity) has passed. How to update a game with Variable or Fixed Timing Demonstrates how to set up the runtime to call your Update method using variable or fixed timing. How to handle resizing of a Game Demonstrates how to handle the resizing of the active game window. Guidance This section contains articles to help make your MonoGame project successful. How to work with Asynchronous Methods in MonoGame This topic describes how you can work with asynchronous methods in MonoGame. How to apply Best Practices for MonoGame Games The practices discussed here will help you have the most success possible with your MonoGame game. How to install MonoGame Preview packages This topic describes how to use a preview release of MonoGame in a new or existing project."
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/howto/input/HowTo_DetectGamePadInput.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/howto/input/HowTo_DetectGamePadInput.html",
    "title": "Detecting input from a GamePad | hallowed",
    "summary": "Overview By using GamePad.GetState a game can determine which buttons are being held down. A game often needs to detect when a user has pressed or released a button. For example, there is the case of an action title that requires users to press and release keys in rapid succession. The example uses a cached GamePadState object to determine if buttons were pressed or released in a given frame. Unlike Keyboards however, multiple GamePads can be connected to a computer or console at the same time, so the GamePad.GetState call requires an Index parameter for which controller is being polled. You also need to query the system the game is currently on for its GamePad.MaximumGamePadCount to determine how many controllers are supported and how many need to be polled for each frame. Also unlike GamePads, GamePads can be disconnected (especially if the battery dies) at any time and most consoles require you to validate this to avoid player issues. Note It is also worth noting, that when maintaining the state of connected gamepads, most console vendors REQUIRE your game to mange GamePad disconnection states (because it was unplugged, lost power, etc), ensuring the user experience is managed when the user CANNOT play. Depending on game design, there may be times when checking for a button press needs to occur more frequently, and other times it does not. It is possible in the case of very fast button presses that more than one key press could occur within one frame. In such a case, the last button press is returned. Writing code that checks as often as possible for button presses is the best way to handle this case. Types of GamePad input Most GamePads include a variety of different input options, including (but not limited to) Thumbsticks - providing ranged motion in two axis. Buttons (including buttons on the Thumbsticks) - Digital on/off buttons (similar to keyboard keys) Triggers - providing ranged motion in a singular axis. Touchpads - in some advanced controllers (such as the PlayStation Dual Shock controller) include a small touchpad. Additionally, most controllers also support haptic feedback (vibration) in the controller, which is different depending on the controller being used and for which system. Note Joysticks also work the same as GamePads, but use their own Joystick and JoystickState classes. Operationally however, they work the same as GamePads. Detecting input changes on a GamePad Declare a GamePadState object to hold the last known GamePad state (in this example, the oldState object). Assign this object a value in your constructor. Call GamePad.GetState to retrieve the current GamePad state (in this example, the newState object). Compare the values in your newState object to the values in the oldState object. Buttons pressed in the newState object that were not pressed in the oldState object were pressed during this frame. Conversely, buttons pressed in the oldState object that are not pressed in the newState object were released during this frame. For Thumbsticks and Triggers, it is not necessary to compare to the previous value unless you also need to calculate the difference, e.g. Was the variable controller moved fast or slow. Reading just the current value is usually enough. Update oldState object to the newState object before leaving Update. using Microsoft.Xna.Framework; using Microsoft.Xna.Framework.Input; namespace GamePadInput { public class Game1 : Microsoft.Xna.Framework.Game { GraphicsDeviceManager graphics; GamePadState oldState; public Game1() { graphics = new GraphicsDeviceManager(this); } protected override void Initialize() { base.Initialize(); oldState = GamePad.GetState(PlayerIndex.One); } protected override void Update(GameTime gameTime) { // Allows the game to exit if (GamePad.GetState(PlayerIndex.One).Buttons.Back == ButtonState.Pressed) { this.Exit(); } UpdateInput(); base.Update(gameTime); } private void UpdateInput() { GamePadState newState = GamePad.GetState(PlayerIndex.One); // Is the A Button down? if (newState.IsButtonDown(Buttons.A)) { if (!oldState.IsButtonDown(Buttons.A)) { // If not down last update, the button has just been pressed. } } else if (oldState.IsButtonDown(Buttons.A)) { // Button was down last update, but not down now, so it has just been released. } // Which direction is the right thumbstick being moved? Vector2 direction = newState.ThumbSticks.Right; // How much is the left trigger being squeezed? float leftTriggerAmount = newState.Triggers.Left; // Update saved state. oldState = newState; } protected override void Draw(GameTime gameTime) { base.Draw(gameTime); } } } The above sample demonstrates sampling just the first connected controller, to support multiple controllers, you will need to sample from all connected controllers (as well as managing their connected state in case one is disconnected) and use an array of GamePadState to maintain the cache of all controllers. Note P.S. Most mobiles these days can support Bluetooth GamePads, so make sure you also support them if you intend to ship your game on mobile!! See Also Detecting a Key Press Working with Touch Input Reference Microsoft.Xna.Framework.Input GamePadState JoystickState"
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/howto/input/HowTo_DetectKeyPress.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/howto/input/HowTo_DetectKeyPress.html",
    "title": "Detecting a Key Press | hallowed",
    "summary": "Overview By using Keyboard.GetState a game can determine which keys are being held down. A game often needs to detect when a user has pressed or released a key. For example, there is the case of an action title that requires users to press and release keys in rapid succession. The example uses a cached KeyboardState object to determine if keys were pressed or released in a given frame. Depending on game design, there may be times when checking for a key press needs to occur more frequently, and other times it does not. It is possible in the case of very fast key presses that more than one key press could occur within one frame. In such a case, the last key press is returned. Writing code that checks as often as possible for key presses is the best way to handle this case. Detecting a Key Press or Release Declare a KeyboardState object to hold the last known keyboard state (in this example, the oldState object). Assign this object a value in your constructor. Call GetState to retrieve the current keyboard state (in this example, the newState object). Compare the values in your newState object to the values in the oldState object. Keys pressed in the newState object that were not pressed in the oldState object were pressed during this frame. Conversely, keys pressed in the oldState object that are not pressed in the newState object were released during this frame. Update oldState object to the newState object before leaving Update. using Microsoft.Xna.Framework; using Microsoft.Xna.Framework.Input; namespace Keypress { public class Game1 : Microsoft.Xna.Framework.Game { GraphicsDeviceManager graphics; KeyboardState oldState; public Game1() { graphics = new GraphicsDeviceManager(this); } protected override void Initialize() { base.Initialize(); oldState = Keyboard.GetState(); } protected override void Update(GameTime gameTime) { // Allows the game to exit if (GamePad.GetState(PlayerIndex.One).Buttons.Back == ButtonState.Pressed) { this.Exit(); } UpdateInput(); base.Update(gameTime); } private void UpdateInput() { KeyboardState newState = Keyboard.GetState(); // Is the SPACE key down? if (newState.IsKeyDown(Keys.Space)) { if (!oldState.IsKeyDown(Keys.Space)) { // If not down last update, key has just been pressed. } else { // If down last update, key is being held. } } else if (oldState.IsKeyDown(Keys.Space)) { // Key was down last update, but not down now, so it has just been released. } // Update saved state. oldState = newState; } protected override void Draw(GameTime gameTime) { base.Draw(gameTime); } } } See Also Detecting a Button Press Working with Touch Input Reference Microsoft.Xna.Framework.Input KeyboardState"
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/howto/input/HowTo_Detect_Gestures.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/howto/input/HowTo_Detect_Gestures.html",
    "title": "Detecting Gestures on a multi-touch Screen | hallowed",
    "summary": "Overview The code in this topic shows you the technique for detecting and using multi-touch gestures. You can download a complete code sample for this topic, including full source code and any additional supporting files required by the sample. MonoGame supports multi-touch gesture-based input on Mobile. The primary class that provides this support is TouchPanel, which provides the ability to: Designate which gestures should be detected. Query to see if any gestures are available for processing. Note Gesture support is provided as a convenient subset of the features possible on a multi-touch input device. For more information about general multi-touch programming, see Working with Touch Input. How to detect Gestures on a multi-touch Screen Set the gestures to enable with TouchPanel.EnabledGestures. This can be one value, or a combination of values, in the GestureType enumeration. Performance can be decreased by enabling all gestures, so it is a good practice to enable only the gestures you will be using in your game. During your game loop, check to see if any gestures are available with TouchPanel.IsGestureAvailable. When IsGestureAvailable is false, there are no more gestures in the queue. If gestures are available, call TouchPanel.ReadGesture to get a GestureSample that contains the data for the gesture. Some gestures will be preceded by another gesture that begins the gesture. For instance, a DoubleTap gesture is always preceded by a Tap gesture. For more information about the various gesture types supported, see GestureType. Example The following code illustrates the procedure for detecting gestures on a multi-touch screen. Enabling gestures in the game's constructor: // set up touch gesture support: make vertical drag and flick the // gestures that we are interested in. TouchPanel.EnabledGestures = GestureType.VerticalDrag | GestureType.Flick; Detecting gestures in the game's Update method: // get any gestures that are ready. while (TouchPanel.IsGestureAvailable) { GestureSample gs = TouchPanel.ReadGesture(); switch (gs.GestureType) { case GestureType.VerticalDrag: // move the poem screen vertically by the drag delta amount. poem.offset.Y -= gs.Delta.Y; break; case GestureType.Flick: // add velocity to the poem screen (only interested in changes to Y velocity). poem.velocity.Y += gs.Delta.Y; break; } } See Also Working with Touch Input Reference Microsoft.Xna.Framework.Input.Touch TouchPanel GestureType GestureSample"
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/howto/input/HowTo_UseMultiTouchInput.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/howto/input/HowTo_UseMultiTouchInput.html",
    "title": "How to work with Touch Input | hallowed",
    "summary": "Overview MonoGame supports multi-touch input on Mobile. The primary class that provides this support is TouchPanel, which can: Determine the touch capabilities of the current device. Get the current state of the touch panel. Detect touch gestures such as flicks, pinches, and drags. (For more information, see Detecting Gestures on a multi-touch Screen.) Determining the Capabilities of the Touch Input Device By using TouchPanel.GetCapabilities you can determine if the touch panel is available. You also can determine the maximum touch count (the number of touches that can be detected simultaneously). To determine the capabilities of the touch device Call TouchPanel.GetCapabilities, which returns a TouchPanelCapabilities structure. Ensure TouchPanelCapabilities.IsConnected is true, indicating that the touch panel is available for reading. You then can use the TouchPanelCapabilities.MaximumTouchCount property to determine how many touch points are supported by the touch panel. All touch panels for mobile return a MaximumTouchCount value of 4 in MonoGame. The following code demonstrates how to determine if the touch panel is connected, and then reads the maximum touch count. ```csharp TouchPanelCapabilities tc = TouchPanel.GetCapabilities(); if(tc.IsConnected) { return tc.MaximumTouchCount; } ``` Getting multi-touch Data from the Touch Input Device You can use TouchPanel.GetState to get the current state of the touch input device. It returns a TouchCollection structure that contains a set of TouchLocation structures, each containing information about position and state for a single touch point on the screen. To read multi-touch data from the touch input device Call TouchPanel.GetState to get a TouchCollection representing the current state of the device. For each TouchLocation in the TouchCollection, read the location and state data provided for each touch point. The following code demonstrates how to get the current state of the touch input device and read touch data from each TouchLocation. It checks to see if a touch location has been pressed or has moved since the last frame, and if so, draws a sprite at the touch location. ```csharp // Process touch events TouchCollection touchCollection = TouchPanel.GetState(); foreach (TouchLocation tl in touchCollection) { if ((tl.State == TouchLocationState.Pressed) || (tl.State == TouchLocationState.Moved)) { // add sparkles based on the touch location sparkles.Add(new Sparkle(tl.Position.X, tl.Position.Y, ttms)); } } ``` See Also Detecting Gestures on a Multi-touch Screen Detecting a Key Press Detecting a Button Press Reference Microsoft.Xna.Framework.Input.Touch TouchPanel TouchPanelCapabilities TouchLocation TouchLocationState"
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/howto/input/index.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/howto/input/index.html",
    "title": "Working with Input | hallowed",
    "summary": "In This Section A game without input is basically just a movie, the user is not interacting and just watching what happens on screen. If the images are not moving, then it is basically just a digital painting. Games are all about interactivity and how we turn the sometimes random presses of buttons, keys, and waving of gyroscopes into interesting reactions on screen. The following articles showcase some of the best ways to get input into your game: Overview of User Input and Input Devices Describes the various types of input devices that can be used with MonoGame. Detecting a Key Press Demonstrates how to detect if a user pressed or released a key on the keyboard. Detecting a Button Press Demonstrates how to detect if a user performed input on a GamePad. Working with Touch Input Demonstrates how to detect and use multi-touch input in a MonoGame game. Detecting Gestures on a Multi-touch Screen Demonstrates how to detect and use multi-touch gestures in a MonoGame game. How to select an Object in 3D Space Demonstrates how to check whether the mouse (or touch location) is positioned over a 3D object by creating a ray starting at the camera's near clipping plane and ending at its far clipping plane."
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/index.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/index.html",
    "title": "Welcome to the MonoGame documentation hub | hallowed",
    "summary": "This new and improved documentation area aims to bridge the gaps in the understanding of the MonoGame Framework, covering all aspects of the features of MonoGame with some support from the original XNA documentation graciously donated by Microsoft. Please check back regularly for updates and more details on the evolution of the MonoGame Framework and its API. In This Section What Is articles Provides simple definitions for most of the central concepts maintained by the MonoGame Framework. The aim with this documentation section is to answer those most basic of questions, what is this thing and what is it for? Ultimately, these guides are here to help peel back the curtains as to what each feature of the MonoGame framework is for. How To articles Short guides for everything you wanted to know about how to do game development with MonoGame, divided up in to simple articles for each activity. These guides are here to give shortcuts to specific questions, like how to draw an image or how do I get input from a device. They are not a replacement for the full featured tutorials that MonoGame is investing in, but there to get to to an answer for how to do specific things quicker. Online Resources Check out the full API documentation here"
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/whatis/audio/index.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/whatis/audio/index.html",
    "title": "Sounds Overview | hallowed",
    "summary": "If your game is to use a few sound files, then the SoundEffect, SoundEffectInstance, and DynamicSoundEffectInstance classes will provide everything you need to play and stream audio during gameplay. Simple Audio Playback The simplest way to play sounds for background music or sound effects is to use SoundEffect and SoundEffectInstance. Source audio files are added like any other game asset to the project. For example code, see Playing a Sound, Looping a Sound, and Adjusting Pitch and Volume. For background music, see Playing a Song. Accessing the Audio Buffer Developers can use DynamicSoundEffectInstance for direct access to an audio buffer. By accessing the audio buffer, developers can manipulate sound, break up large sound files into smaller data chunks, and stream sound. For example code, see Streaming Data from a WAV File. 3D Audio The SoundEffect class provides the ability to place audio in a 3D space. By creating AudioEmitter and AudioListener objects, the API can position a sound in 3D, and can change the 3D position of a sound during playback. Once you create and initialize AudioEmitter and AudioListener, call SoundEffectInstance.Apply3D. Audio Constraints When working with multiple platforms using MonoGame, there are a few constraints around audio that you will need to keep in mind and cater for, namely: Mobile platforms have a maximum of 32 sounds playing simultaneously. Desktop platforms have a maximum of 256 sounds playing simultaneously. Consoles and other platforms have their own constraints, please look at the console sdk documentation for more information, Important An InstancePlayLimitException exception is thrown if this limit is exceeded. Audio Buffer Format The byte[] buffer format used as a parameter for the SoundEffect constructor, Microphone.GetData method, and DynamicSoundEffectInstance.SubmitBuffer method is PCM wave data. Additionally, the PCM format is interleaved and in little-endian. The audio format has the following constraints: The audio channels can be mono (1) or stereo (2). The PCM wave file must have 16-bits per sample. The sample rate must be between 8,000 Hz and 48,000 Hz. The interleaving for stereo data is left channel to right channel. Songs as Background Music Access to the media library, combined with the ability to use playlists, allows games to create interesting background scores that can change with gameplay. Songs can be played directly from the media library, or can be imported by using the Content Pipeline. For more information, see Playing a Song. Concepts Important How to articles to follow. Reference SoundEffect Class Provides a loaded sound resource. SoundEffectInstance Class Provides a single playing, paused, or stopped instance of a SoundEffect sound. DynamicSoundEffectInstance Class Provides properties, methods, and events for play back of the audio buffer. Song Class Provides access to a song in the song library."
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/whatis/content_pipeline/CP_AddCustomProcImp.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/whatis/content_pipeline/CP_AddCustomProcImp.html",
    "title": "What is a Custom Importer? | hallowed",
    "summary": "MonoGame provides standard importers and processors for a number of common file formats used to store such basic game assets as models, materials effects, sprites, textures, and so on. For a list of file formats supported by these standard importers and processors, see Standard Content Importers and Content Processors. To add a custom importer or processor to a game project This procedure assumes you have copied the new importer or processor to a local folder in the game project. Open the MonoGame Pipeline Tool. Load the .mgcb file associated with your game. Click on the Content node and in the Properties panel click on References. Click the Add Button. Navigate to the directory containing the assembly with the custom importer or processor, and then add it. Save. Important For MonoGame 3.8.2 and below, make sure to keep the project at .NET 6 or below. The MGCB tool for 3.8.2 CANNOT understand or read .NET 8 libraries as it is compiled with .NET 6. The Game project can use a higher version, but library projects must stay at .NET 6 else they cannot be read. The new importer or processor now appears as a choice in dialog properties for importing or processing a newly added game asset. See Also Adding New Content Types Standard Content Importers and Content Processors"
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/whatis/content_pipeline/CP_Architecture.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/whatis/content_pipeline/CP_Architecture.html",
    "title": "What is the Content Pipeline Architecture? | hallowed",
    "summary": "The MonoGame Content Pipeline is a set of processes applied when a game that includes art assets is built. The process starts with an art asset in its original form as a file, and continues to its transformation as data that can be retrieved and used within a MonoGame game through the MonoGame Framework Class Library. The Content Pipeline is designed to be extensible, so that it can easily support new input file formats and new types of conversion. Most MonoGame developers can ignore the inner workings of the Content Pipeline. The most commonly used types of game assets and formats are inherently supported by MonoGame. However, if you are a game developer who needs to support a new file format or game-engine capability, it is useful to understand the stages of the Content Pipeline that transform an asset from a digital-content creation (DCC) output file to part of the game binary. Content Pipeline Components A game asset is made available to an MonoGame game after it is added to the Content project. Once the asset is part of the game solution, it is included in the Content Pipeline. Processes fall into two types depending on when they execute: design time components and runtime components. Design-Time Components The design-time components of the MonoGame Content Pipeline that process your game assets execute when you build your MonoGame game as an executable file. These processes perform the initial transformation of an asset from its digital content creation (DCC) format to a managed code object that your game can use upon execution. Design-time components use the Content Pipeline Class Library, which can be used and extended to create custom Content Pipeline design-time components. Content Importer A _Content Importer_ converts game assets from a particular DCC file format into objects in the MonoGame Content Document Object Model (DOM) that standard Content Processors can consume, or into some other custom form that a particular custom Content Processor can consume. An Content Importer typically converts content into managed objects based on the Content DOM, which includes strong typing for such assets as meshes, vertices, and materials. A custom Content Importer, however, may produce custom objects for a particular custom Content Processor to consume. Content Processor A _Content Processor_ takes one specific type of an imported game asset and compiles it into a managed code object that can be loaded and used by MonoGame games. Each Content Processor acts upon a specific object type. For example, the Effect Processor accepts only EffectContent objects, representing a DirectX Effect asset. When you include a game asset file in your MonoGame .mgcb file, its dialog properties page specifies the appropriate Content Importer and Content Processor. Thereafter, when you build your game (by pressing F5), the assigned Content Importer and Content Processor for each asset is invoked automatically. The asset is built into your game in a form that can be loaded at run time by your game. The managed code objects created by the Content Processor are serialized into a compact binary format (also referred to as an intermediate format) file with an .XNB extension by the Content Pipeline Content Compiler. This .XNB file is used by the runtime components of the Content Pipeline that assist your game in retrieving the transformed game assets. The format of data in the .XNB file is tightly coupled to the MonoGame Framework. It is not designed for use by other runtime libraries. Runtime Components Runtime components of the Content Pipeline support loading and using the transformed game asset by your MonoGame game. These components use the MonoGame library, which can be extended to create custom components. Content Loader When the game needs the game asset's managed code object, it must call the ContentManager.Load method to invoke the Content Loader, specifying the object type it expects. The Content Loader then locates and loads the asset from the compact binary format (.XNB) file into the memory space of the game where it can be used. See Also What Is Content? Adding New Content Types Loading Additional Content Types"
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/whatis/content_pipeline/CP_Class_Library.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/whatis/content_pipeline/CP_Class_Library.html",
    "title": "Content Pipeline Class Library | hallowed",
    "summary": "The Content Pipeline class library is a library of classes, interfaces, and value types that are included in MonoGame. This library provides access to MonoGame Framework Content Pipeline functionality and is designed to be the foundation on which Content Pipeline–related applications, components, and controls are built. Namespaces Microsoft.Xna.Framework.Content.Pipeline Provides classes representing base types and building block functionality for use by more specialized object models, such as the Graphics DOM. Microsoft.Xna.Framework.Content.Pipeline.Audio Provides intermediate classes and types for representing and manipulating graphics audio data. Microsoft.Xna.Framework.Content.Pipeline.Graphics Provides intermediate classes and types for representing and manipulating graphics data. Microsoft.Xna.Framework.Content.Pipeline.Processors Provides base classes that represent processors used by the MonoGame Framework Content Pipeline when processing specific game asset types. Microsoft.Xna.Framework.Content.Pipeline.Serialization.Compiler Provides base classes that represent compilers and writers used by the MonoGame Framework Content Pipeline when processing specific game asset types. Microsoft.Xna.Framework.Content.Pipeline.Serialization.Intermediate Provides base classes that represent the creation and writing of intermediate content for game asset types processed by the XNA Framework Content Pipeline. Microsoft.Xna.Framework.Content.Pipeline.Tasks Provides support for importing and processing game assets into the binary format that is used by the Content Loader of a game project. See Also Adding Content to a Game What Is Content?"
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/whatis/content_pipeline/CP_Content_Advanced.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/whatis/content_pipeline/CP_Content_Advanced.html",
    "title": "What are custom content types? | hallowed",
    "summary": "The game asset build process is controlled by Content Pipeline importers and content processors. When you press F5 (or dotnet build) to build a game created with MonoGame, the appropriate Content Pipeline importer and processor for each asset is invoked. Each asset then is automatically built into your game. The flexibility of this process enables you to create and update game assets using a variety of digital content creation (DCC) tools. MonoGame supplies importers for several popular export formats supported by DCC tools, and also lets you develop custom importers for other formats. In This Section What is the Content Pipeline Architecture? Describes the components and execution flow of the MonoGame Content Pipeline. Content Pipeline Document Object Model Describes the built-in object support features for assets in the Content Pipeline. Loading Additional Content Types Describes the options for customizing the Content Pipeline to support nonstandard game assets or special-purpose needs. Tips for Developing Custom Importers and Processors Provides useful information about how to design and debug a custom Content Pipeline importer or processor. Adding a Custom Importer Describes how to add a custom processor or importer to an existing game solution. Extending a Standard Content Processor Describes how MonoGame lets you modify or extend the behavior of any standard Content Pipeline processor that ships with the product. Developing with Parameterized Processors Describes how to develop with parameterized processors, both standard and custom. How to: Extend the Font Description Processor to Support Additional Characters Describes the process of developing a custom content processor needed to add additional characters to a FontDescription object based on the text that is required by the game."
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/whatis/content_pipeline/CP_CustomParamProcs.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/whatis/content_pipeline/CP_CustomParamProcs.html",
    "title": "What are Parameterized Processors? | hallowed",
    "summary": "Programmatically Setting Parameter Values When you need to pass parameter values from one processor to another (also referred to as chaining), use the BuildAsset and BuildAndLoadAsset methods. Pass the parameter and its value using the processorParameters argument of the respective method. For example, a custom model processor would invoke a second processor for model textures with a call to BuildAsset and pass any parameter values in the processorParameters argument. The following code example demonstrates this technique. First, add several parameters to a data dictionary: //create a dictionary to hold the processor parameter OpaqueDataDictionary parameters = new OpaqueDataDictionary(); //add several parameters to the dictionary parameters.Add( \"ColorKeyColor\", Color.Magenta ); parameters.Add( \"ColorKeyEnabled\", true ); parameters.Add( \"ResizeToPowerOfTwo\", true ); After adding the necessary parameters, pass the dictionary to the chained processor: context.BuildAsset<TextureContent, TextureContent=\"\">( texture, typeof( TextureProcessor ).Name, parameters, null, null ); This call passes all parameters (stored in parameters) to a texture processor. Again, any parameters not recognized by the receiving processor are ignored. Therefore, if the parameter ColorKeyCode is entered into the dictionary as _ColourKeyCode_, it is ignored by the receiving processor. Declaring Process Parameters Adding one or more parameters to your custom processor requires additional code in your processor's definition. Parameters support the following types: bool byte sbyte char decimal double float int uint long ulong short ushort string enum Vector2, Vector3, and Vector4 Color Parameters of other types are ignored by the processor. Tip Apply the Browsable attribute (with a value of false) to an individual parameter to prevent that parameter from being displayed in the Properties window. The following code example defines a simple custom processor that switches the coordinate system of a model using a single parameter (called switchCoordinateSystem): public class SwitchCoordSystemProcessor : ModelProcessor { #region Processor Parameters private bool switchCoordinateSystem = false; [DisplayName(\"Switch Coordinate System\")] [DefaultValue(false)] [Description(\"Switches the coordinate system of a model.\")] public bool SwitchCoordinateSystem { get { return switchCoordinateSystem; } set { switchCoordinateSystem = value; } } //additional class code follows... In this code, the SwitchCoordSystemProcessor class is derived from ModelProcessor. This indicates that the processor accepts a model as input. The next few lines declare a single property called SwitchCoordinateSystem of type bool. Note that every parameter must have a set method. The property also has several attributes applied to it: Attribute name Usage DisplayName Name of the property when it appears in the Properties window of the MonoGame Pipeline tool. If not specified, the internal property name, declared in the source code, is used. For this example, \"Switch Coordinate System\" would be displayed. DefaultValue A user interface (UI) hint specifying the possible default value of the property. This value is used only as a UI hint; it will not be set on the property, nor will it override the default value declared in the code. Description Descriptive text displayed when you select the property in the Properties window of the MonoGame Pipeline Tool. This completes the definition of the SwitchCoordinateSystem property. In the next code example, the class definition is continued with an override of the Process method: //additional class code precedes... public override ModelContent Process(NodeContent input, ContentProcessorContext context) { if (switchCoordinateSystem) { Matrix switchMatrix = Matrix.Identity; switchMatrix.Forward = Vector3.Backward; MeshHelper.TransformScene(input, switchMatrix); } return base.Process(input, context); } This code passes the SwitchCoordinateSystem property (declared earlier) value to TransformScene, which is a helper method that applies a transform to a scene hierarchy. See Also Adding New Content Types Parameterized Content Processors"
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/whatis/content_pipeline/CP_Customizing.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/whatis/content_pipeline/CP_Customizing.html",
    "title": "Loading Additional Content Types? | hallowed",
    "summary": "MonoGame provides standard Content Pipeline components that import and process the most commonly used game asset file types. These file types include, for example, Content Importers for the Autodesk (.fbx) format and the DirectX (.x) format. A complete list of file types is available in the Standard Content Importers and Content Processors topic. Most digital Content creation (DCC) tools are capable of creating output in at least one of these standard formats. Choosing to Customize A custom Content Importer is required for game assets available only in formats unsupported by MonoGame standard Content Importers. One may already be available from a third party. Custom Content Importers can be developed by DCC vendors, game-engine developers, and interested game hobbyists. Once a custom Content Importer is installed on your computer, you can associate art files with the Content Importer to invoke it when you build the art files (see Adding a Custom Importer). You may need to write your own custom MonoGame Content Pipeline components to: Support a new type of game asset or format from a DCC tool. Derive special-purpose content from another piece of content at the time the game is built. Here are some typical scenarios, and a summary of which Content Pipeline components require customization. Component When to customize Output options Content Importer A game asset created by a DCC tool is available only in a format unsupported by a MonoGame standard Content Importer. Content Document Object Model (DOM) object that can be consumed by a standard Content Processor. A custom object that must be consumed by a custom Content Processor. Content Processor Must process the custom output of a custom Content Importer. Needs to process the output of a standard Content Importer in a special-purpose way. A standard Content Processor output type. A custom Content Processor output type that must be consumed by a custom Content Loader at game run time. Content Loader Must load custom output of a customized Content Processor. A custom Content Loader is implemented by extending the ContentManager.Load method to load the new custom data type. A standard MonoGame Framework class object. A custom class object. Customization Scenarios This section examines some typical examples where customization is needed, and illustrates which Content Pipeline components must be changed. Supporting a New File Format In this example, a nonstandard file format contains information that can be represented by a standard Content DOM type. As illustrated, only a custom Content Importer that can read the nonstandard file format and output a Content DOM object (in this case, a TextureContent object) is required. The remainder of the Content Pipeline process can be performed by a standard Content Processor and Content Loader. Creating Special-Purpose Data from Standard Objects For this example, a texture object that represents a map of normalized vectors derived from the original texture object is created. Since the texture is contained in a standard format for the game asset, a standard Content Importer can be used to create the TextureContent object. A custom Content Processor (NormalMapProcessor) creates the special-purpose data, but uses the standard TextureContent class to contain the result so that it can be loaded by the standard Content Loader. Supporting Custom Data from a Nonstandard Game Asset Illustrated in this example is a nonstandard game asset file containing data that does not correspond to any standard data types. To read the nonstandard game asset file, a custom Content Importer is required that outputs a CustomContent object. Since the output of the Content Importer is a custom class, a custom Content Processor also is needed, and the ContentManager.Load method must be extended to support the custom data object. See Also Adding New Content Types What Is Content? What is the Content Pipeline?"
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/whatis/content_pipeline/CP_DOM.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/whatis/content_pipeline/CP_DOM.html",
    "title": "What is the Content Pipeline Document Object Model? | hallowed",
    "summary": "The MonoGame Content Document Object Model (DOM) represents the set of built-in classes that can be consumed by standard content processors. Currently, the DOM provides support for meshes, materials, textures, sprite-fonts, and animations. Outside of these, a custom importer can return a ContentItem with custom information in its opaque data, or a custom type you have developed. The following diagram lists the complete Content DOM. See Also What Is Content? What is the Content Pipeline? Extending a Standard Content Processor Adding New Content Types"
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/whatis/content_pipeline/CP_Overview.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/whatis/content_pipeline/CP_Overview.html",
    "title": "What Is Content? | hallowed",
    "summary": "The MonoGame Content Pipeline is a set of processes applied to a game's art and data assets when the game is built. The process starts with an art asset in its original form as a file, and it continues to its transformation as data that can be retrieved and used within a MonoGame game through the MonoGame Framework Class Library. Content is all the parts of your game that are not executing managed code. It includes all art assets, such as textures, sprites, meshes, effects, and fonts; and includes sound assets, such as music or brief sound effects. It also can include data assets, such as tables of levels or character attributes. Most content will be created using a digital content creation (DCC) tool, such as a paint program or a 3D model editor. The content your game uses is stored in a variety of file formats. Most will be standard file formats, such as JPEG for textures or Autodesk FBX format for 3D models. However, they might also be in a custom format or house custom data in XML format. Benefits of the Content Pipeline The chief reason MonoGame uses a Content Pipeline is to help your game run fast. Without the content pipeline, your game would have to be built with its art assets in their original file format. When the game needs to load its art to draw it on the screen, it would have to determine its format and convert the data into a form it can use more directly. This would have to be performed at run time, for each asset, making the player wait to have fun. The Content Pipeline remedies this by shifting this time-consuming work to when the game is built. At build time, each asset is imported from its original file format and processed into a managed code object. Those objects are then serialized to a file that is included in the game’s executable. At run time, the game can then read the serialized data from the file directly into a managed code object for immediate use. This architecture also provides several other benefits. Game artists can use the DCC tools of their choice. Game developers can use the files game artists produce directly in their MonoGame projects. If all game assets are in file formats supported by the Standard Importers and Processors provided by MonoGame, the game developer never needs to be concerned with the specifics of that file format, nor possess a detailed knowledge of how the Content Pipeline works. If required, the Content Pipeline can easily be customized or extended to import a new file format or to produce custom output. Using the Content Pipeline For MonoGame games that use the most common types of art assets and formats, a detailed knowledge of how the Content Pipeline works is unnecessary. MonoGame supplies standard importers and processors for many popular DCC file formats. The only procedure necessary is to add these assets to the game's content project. For a list of formats MonoGame inherently supports, see Standard Content Importers and Content Processors. To use a DirectX Effect (.fx) file in your game, for example, just add the file to the MonoGame game content project (.mgcb). The MonoGame Pipeline tool recognizes the .fx file type as one it supports, and it assigns the correct components to it that are used to process it when the game is built. The game then can access the effect through the standard ContentManager.Load method of the MonoGame Framework. The game programmer does not need to be concerned about all the steps taken by the Content Pipeline to ready it for this straightforward use. There are other circumstances, however, when it helps to understand how the Content Pipeline works. A third party may provide custom MonoGame Content Pipeline components that support additional art assets and formats. You may need to write your own custom MonoGame Content Pipeline components to support a new type of art asset or format from a DCC. You may wish to write your own custom MonoGame Content Pipeline components to derive special-purpose content from another piece of content at the time the game is built. Content Pipeline Components The processes that comprise the MonoGame Content Pipeline fall into two types, depending on when they execute: build-time components and run-time components. Build-Time Components The build-time components of the Content Pipeline that process your art assets execute within Visual Studio when you build your MonoGame game and produce an executable file. These processes perform the initial transformation of an asset from a DCC format to a managed code object that your game can use when it executes. These build-time components make use of the Content Pipeline Class Library, which can be used and extended to create custom Content Pipeline build-time components. Component Description Importer An importer converts art assets from a particular DCC file format to objects in the MonoGame Content Document Object Model that standard content processors can consume, or to some other custom form that a particular custom processor can consume. Content processor A processor takes one specific type of imported art asset, such as a set of meshes, and compiles it into a managed code object that can be loaded and used by MonoGame games at runtime. When you include an art asset file in your MonoGame solution's content project (.mgcb), its Properties page in the Pipeline tool specifies the appropriate importer and processor. Thereafter, when you build your game (by pressing F5), the assigned importer and processor for each asset is invoked automatically. The asset is built into your game in a form that can be loaded at run time by your game by using ContentManager.Load. Run-time Components The run-time components of the MonoGame Content Pipeline support the loading and use of the transformed art asset by your MonoGame. These run-time components make use of the MonoGame Framework Class Library, which can be extended to create custom Content Pipeline run-time components. See Also Concepts Adding Content to a Game Adding New Content Types"
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/whatis/content_pipeline/CP_SpriteFontSchema.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/whatis/content_pipeline/CP_SpriteFontSchema.html",
    "title": "What is Sprite Font XML Schema Reference? | hallowed",
    "summary": "Sprite Font XML Schema Reference Tag name Content type Content description <FontName> string The name of the font to be imported. This is not the name of a font file, but rather the friendly name that identifies the font once it is installed on your computer. You can use the Fonts folder in Control Panel to see the names of fonts installed on your system, and to install new ones as well. The Content Pipeline supports the same fonts as the System.Drawing.Font class, including TrueType fonts, but not bitmap (.fon) fonts. <Size> float The point size of the font to be imported. <Spacing> float The number of pixels to add between each character when the string is rendered. <UseKerning> Boolean Specifies whether to use kerning information when rendering the font. Default value is true. <Style> Regular, Bold, Italic, or Bold Italic The style of the font to be imported. <DefaultCharacter> char The Unicode character to substitute any time an attempt is made to render characters that are not in the font. Specifying this element is optional. <CharacterRegions> One or more <CharacterRegion> tags One or more numerical ranges indicating which subset of Unicode characters to import. <CharacterRegion> One <Start> and one <End> tag The beginning and ending of a region of Unicode characters. <Start> char The first Unicode character to include in a <CharacterRegion>. <End> char The last Unicode character to include in a <CharacterRegion>. Example Here is a sample .spritefont file: <?xml version=\"1.0\" encoding=\"utf-8\"?> <XnaContent xmlns:Graphics=\"Microsoft.Xna.Framework.Content.Pipeline.Graphics\"> <Asset Type=\"Graphics:FontDescription\"> <FontName>Courier New</FontName> <Size>18</Size> <Spacing>0</Spacing> <UseKerning>true</UseKerning> <Style>Regular</Style> <CharacterRegions> <CharacterRegion> <Start>32</Start> <End>127</End> </CharacterRegion> </CharacterRegions> </Asset> </XnaContent> Here is a sample localized .spritefont file: <?xml version=\"1.0\" encoding=\"utf-8\"?> <XnaContent xmlns:Graphics=\"Microsoft.Xna.Framework.Content.Pipeline.Graphics\"> <Asset Type=\"Graphics:LocalizedFontDescription\"> <FontName>Courier New</FontName> <Size>18</Size> <Spacing>0</Spacing> <UseKerning>true</UseKerning> <Style>Regular</Style> <CharacterRegions> <CharacterRegion> <Start>32</Start> <End>127</End> </CharacterRegion> </CharacterRegions> <ResourceFiles> <Resx>Strings.resx</Resx> <Resx>Strings-fr.resx</Resx> </ResourceFiles> </Asset> </XnaContent> See Also Adding Content to a Game Reference SpriteFont"
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/whatis/content_pipeline/CP_StdImpsProcs.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/whatis/content_pipeline/CP_StdImpsProcs.html",
    "title": "What are the Standard Content Importers and Content Processors? | hallowed",
    "summary": "Describes the standard Content Pipeline Content Importers and Content Processors of MonoGame that support various common art asset file formats. Content Importers and Content Processors are implemented as assemblies. In addition to the standard ones provided by MonoGame and listed below, you can also use custom Content Importers and Content Processors developed by you or third parties. Use the Properties window to assign an appropriate Content Importer and Content Processor to each game asset added to your game project. Standard Content Importers The following is a description of the standard Content Importers shipped with MonoGame and the type of game asset each supports. All standard Content Importers are declared as part of the Microsoft.Xna.Framework.Content.Pipeline namespace. Name Type name Output type Description Autodesk FBX FbxImporter NodeContent Imports game assets specified with the Autodesk FBX file format (.fbx). This Content Importer is designed to work with assets exported with the 2013 version of the FBX exporter. Effect EffectImporter EffectContent Imports a game asset specified with the DirectX Effect file format (.fx). Sprite Font Description FontDescriptionImporter FontDescription Imports a font description specified in a .spritefont file. Texture TextureImporter TextureContent Imports a texture. These file types are supported: .bmp, .dds, .dib, .hdr, .jpg, .pfm, .png, .ppm, and .tga. X File XImporter NodeContent Imports game assets specified with the DirectX X file format (.x). This Content Importer expects the coordinate system to be left-sided. XML Content XmlImporter object Imports XML content used for editing the values of a custom object at run time. For instance, you could pass XML code to this Content Importer that looks for the specified property of a custom type and changes it to the specified value. You could then process the custom object with a Content Processor or pass it to your game untouched using the No Processing Required Content Processor.This Content Importer is designed for scenarios like importing an XML file that describes game data at run time (similar to the Sprite Font Description Content Importer) or importing terrain data in an XML file that then is passed to a Content Processor that generates a random terrain grid using that data. Other 3D Content OpenAssetImporter NodeContent Imports game assets specified with one of the formats supported by assimp. A sample of supported files types are: .dae, .3ds, .blend, .obj, .fbx (v2013). More are available see Assimp Supported File Formats for more details. Note some formats might not behave correctly with the standard ModelProcessor. Standard Content Processors MonoGame ships with a variety of Content Processors that support several common game asset types. Many of the standard Content Processors, such as the TextureProcessor, support parameters for modifying the default behavior of the Content Processor. For more information, see Parameterized Content Processors. The following describes the standard Content Processors and the type of game asset each supports. Name Type name Input type Output type Description Model ModelProcessor NodeContent Class ModelContent Class A parameterized Content Processor that outputs models as a ModelContent Class object. Available parameters: * Color Key Color–Any valid Color. Magenta is the default value. * Color Key Enabled–A Boolean value indicating if color keying is enabled. The default value is true. * Generate Mipmaps–A Boolean value indicating if mipmaps are generated. The default value is false. * Generate Tangent Frames–A Boolean value indicating if tangent frames are generated. The default value is false. * Resize Textures to Power of Two–A Boolean value indicating if a texture is resized to the next largest power of 2. The default value is false. * Scale–Any valid float value. The default value is 1.0. * Swap Winding Order–A Boolean value indicating if the winding order is swapped. This is useful for models that appear to be drawn inside out. The default value is false. * Texture Format–Any valid SurfaceFormat value. Textures are either unchanged, converted to the Color format, or DXT Compressed. For more information, see TextureProcessorOutputFormat. * X Axis Rotation–Number, in degrees of rotation. The default value is 0. * Y Axis Rotation–Number, in degrees of rotation. The default value is 0. * Z Axis Rotation–Number, in degrees of rotation. The default value is 0. No Processing Required PassThroughProcessor Object Object Performs no processing on the file. Select this Content Processor if your content is already in a game-ready format (for example, an externally prepared DDS file) or a specialized XML format (.xml) designed for use with XNA Game Studio. Sprite Font Description FontDescriptionProcessor FontDescription SpriteFontContent Converts a .spritefont file specifying a font description into a font. Sprite Font Texture FontTextureProcessor TextureContent SpriteFontContent A parameterized Content Processor that outputs a sprite font texture as a SpriteFontContent object. Available parameters: * First Character–Any valid character. The space character is the default value. Sprite Font Texture FontTextureProcessor Texture2DContent SpriteFontContent Converts a specially marked 2D bitmap file (.bmp) into a font. Pixels of Color.Magenta are converted to Color.Transparent. Texture TextureProcessor TextureContent Class TextureContent Class A parameterized Content Processor that outputs textures as a TextureContent Class object. Available parameters: * Color Key Color–Any valid Color. Magenta is the default value. * Color Key Enabled–A Boolean value indicating if color keying is enabled. The default value is true. * Generate Mipmaps–A Boolean value indicating if mipmaps are generated. The default value is false. * Resize to Power of Two–A Boolean value indicating if a texture is resized to the next largest power of 2. The default value is false. * Texture Format–Any valid SurfaceFormat value. Textures are either unchanged, converted to the Color format, or DXT Compressed. For more information, see TextureProcessorOutputFormat. Localized Sprite Font Texture LocalizedFontProcessor FontDescription SpriteFontContent Converts a .spritefont file specifying a font description into a font. See Also Adding Content to a Game What Is Content? Adding a Custom Importer"
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/whatis/content_pipeline/CP_StdParamProcs.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/whatis/content_pipeline/CP_StdParamProcs.html",
    "title": "What are the Parameterized Content Processors? | hallowed",
    "summary": "Describes how parameterized Content Processors work in MonoGame. Many of the standard Content Pipeline Content Processors shipped with XNA Game Studio support parameter usage. Parameterization makes any standard or custom Content Processor more flexible and better able to meet the needs of your XNA Framework application. In addition to specifying values for standard parameters, you can easily implement parameter support for a new or an existing custom Content Processor. For more information, see Developing with Parameterized Processors. When you select a game asset, the Properties window displays the parameters for the related Content Processor. Use the Properties window at any time to modify these parameter values. Tip If you change the Content Processor for a game asset to a different Content Processor, all parameter values are reset to their default values. This means that if you modify the Generate Mipmaps parameter value for the TextureProcessor and then switch to a different Content Processor (for example, FontTextureProcessor Class), the parameters switch to the default values for that Content Processor. If you then switch back again, the modified values are reset to the default values of the original Content Processor. The values do not revert to the modified values you set originally. Standard Parameterized Content Processors The following describes only standard Content Processors that accept parameters, the parameter types, and their default value. For more information about all standard Content Processors, see Standard Content Importers and Content Processors. Friendly name Type name Input type Output type Description Model ModelProcessor NodeContent Class ModelContent Class A parameterized Content Processor that outputs models as a ModelContent Class object. Available parameters: Color Key Color–Any valid Color. Magenta is the default value. Color Key Enabled–A Boolean value indicating if color keying is enabled. The default value is true. Generate Mipmaps–A Boolean value indicating if mipmaps are generated. The default value is false. Generate Tangent Frames–A Boolean value indicating if tangent frames are generated. The default value is false. Resize Textures to Power of Two–A Boolean value indicating if a texture is resized to the next largest power of 2. The default value is false. Scale–Any valid float value. The default value is 1.0. Swap Winding Order–A Boolean value indicating if the winding order is swapped. This is useful for models that appear to be drawn inside out. The default value is false. Texture Format–Any valid value from TextureProcessorOutputFormat. Textures are either unchanged, converted to the Color format, or Compressed using the specified Compression algorithm. X Axis Rotation–Number, in degrees of rotation. The default value is 0. Y Axis Rotation–Number, in degrees of rotation. The default value is 0. * Z Axis Rotation–Number, in degrees of rotation. The default value is 0. Sprite Font Texture FontTextureProcessor TextureContent Class SpriteFontContent A parameterized Content Processor that outputs a sprite font texture as a SpriteFontContent object. Available parameters: * First Character–Any valid character. The space character is the default value. Texture TextureProcessor TextureContent Class TextureContent Class A parameterized Content Processor that outputs textures as a TextureContent Class object. Available parameters: Color Key Color–Any valid Color. Magenta is the default value. Color Key Enabled–A Boolean value indicating if color keying is enabled. The default value is true. Generate Mipmaps–A Boolean value indicating if mipmaps are generated. The default value is false. Resize to Power of Two–A Boolean value indicating if a texture is resized to the next largest power of 2. The default value is false. * Texture Format–Any valid value from TextureProcessorOutputFormat. Textures are unchanged, converted to the Color format, or Compressed using the specified Compression algorithm. See Also Adding Content to a Game"
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/whatis/content_pipeline/CP_Tips_For_Developing.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/whatis/content_pipeline/CP_Tips_For_Developing.html",
    "title": "What are Tips for Developing Custom Importers and Processors? | hallowed",
    "summary": "Importing Basic Graphics Objects The following information should help you import basic graphics objects. Make your coordinate system right-handed. From the standpoint of the observer, the positive x-axis points to the right, the positive y-axis points up, and the positive z-axis points toward you (out from the screen). Create triangles that have a clockwise winding order. The default culling mode removes triangles that have a counterclockwise winding order. Call MeshHelper.SwapWindingOrder to change the winding order of a triangle. Set the scale for graphical objects to 1 unit = 1 meter. Call MeshHelper.TransformScene to change the scale of an object. Taking Advantage of Content Pipeline Mesh Classes There are several properties and classes that are particularly useful when using NodeContent objects to represent a 3D scene or mesh. The NodeContent.Children property represents hierarchical information. The NodeContent.Transform property contains the local transform of the 3D object. The Pipeline.Graphics.MeshContent class (a subclass of Pipeline.Graphics.NodeContent) is used to represent meshes. The Content Pipeline provides two classes that make it easier to create and work with Pipeline.Graphics.MeshContent objects. The Pipeline.Graphics.MeshBuilder class creates new Pipeline.Graphics.MeshContent objects, when necessary. The Pipeline.Graphics.MeshHelper class implements useful operations on existing Pipeline.Graphics.MeshContent objects. Debugging Custom Importers and Processors In a manner similar to projects that create a DLL, Content Pipeline extension projects cannot be directly run or debugged. After completing a few simple steps, however, you can debug any custom importer and processor used by your game. The following procedure details these steps. Tip The Start External program control (located on the Debug page of a project's property pages) is unavailable in the Microsoft Visual Studio development environment. To debug a custom importer or processor Load an existing MonoGame Content Pipeline extension project (later referred to as ProjCP) containing the custom importers or processors to be debugged. Create a separate test game project (later referred to as ProjG). In the References node of ProjG's nested content project, add a project-to-project reference to ProjCP. Add one or two appropriate items of test content to ProjG, and ensure they are set to use the importer or processor (in ProjCP) you wish to debug. Open the property pages for ProjCP. Click the Debug tab, and then select Start external program. Enter the path to the local version of MSBuild.exe. For example, C:\\WINDOWS\\Microsoft.NET\\Framework\\v3.5\\msbuild.exe on Windows. For the Command line arguments control, enter the path to ProjG's nested content project. If this path contains spaces, quote the entire path. Set any required breakpoints in the importer or processor code in ProjCP. Build and debug ProjCP. Debugging ProjCP causes MSBuild to compile your test content while running under the debugger. This enables you to hit your breakpoints in ProjCP and to step through your code. See Also What Is Content? What is the Content Pipeline? Extending a Standard Content Processor Adding New Content Types"
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/whatis/content_pipeline/CP_XML_Elements.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/whatis/content_pipeline/CP_XML_Elements.html",
    "title": "What are the XML Elements for XMLImporter? | hallowed",
    "summary": "XML Elements The following base elements are recognized by XmlImporter Class: Element Parent Children Description <XnaContent> — <Asset> Top-level tag for XNA Content. <Asset> <XnaContent> <Item> Marks the asset. The Type attribute specifies the corresponding namespace and class of the matching data type. <Item> <Asset> — When the asset contains multiple objects (as in an array), marks a single object within the group. The child elements correspond to the properties of the data type's class definition. Examples Example 1: Single Object This example demonstrates an XML file that defines an asset that consists of a single item (not an array). Assume that the XML file is to define a single object of data for the class that is defined as: namespace XMLTest { class MyTest { public int elf; public string hello; } } The XML file that specifies the data that the Content Loader will read into the object would appear as: <?xml version=\"1.0\" encoding=\"utf-8\"?> <XnaContent> <Asset Type=\"XMLTest.MyTest\"> <elf>23</elf> <hello>Hello World</hello> </Asset> </XnaContent> Example 2: Multiple Objects This example demonstrates an XML file that defines an asset that is an array of objects. Assume that the XML file is to define an array of data for the class that is defined as: namespace MyDataTypes { public class CatData { public string Name; public float Weight; public int Lives; } } The XML file that specifies the data that the Content Loader will read into the object array would appear as: <?xml version=\"1.0\" encoding=\"utf-8\"?> <XnaContent> <Asset Type=\"MyDataTypes.CatData[]\"> <Item> <Name>Rhys</Name> <Weight>17</Weight> <Lives>9</Lives> </Item> <Item> <Name>Boo</Name> <Weight>11</Weight> <Lives>5</Lives> </Item> </Asset> </XnaContent> See Also Using an XML File to Specify Content Adding Content to a Game"
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/whatis/content_pipeline/index.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/whatis/content_pipeline/index.html",
    "title": "What is the Content pipeline? | hallowed",
    "summary": "In This Section What Is Content? Describes the purpose of the MonoGame Content Pipeline and how it helps you add art and data assets to your game. Loading Content Demonstrates how to load content such as models, textures, sounds, and effects. What is the Content Pipeline Architecture? The Content Pipeline is designed to be extensible, so that it can easily support new input file formats and new types of conversion. Standard Content Importers and Content Processors Describes the standard Content Pipeline Content Importers and Content Processors of MonoGame that support various common art asset file formats. What is a Custom Importer MonoGame provides standard importers and processors for a number of common file formats used to store such basic game assets as models, materials effects, sprites, textures, and so on. For a list of file formats supported by these standard importers and processors. Parameterized Content Processors Describes how parameterized Content Processors work in MonoGame. Many of the standard Content Pipeline Content Processors shipped with MonoGame support parameter usage. What are Tips for Developing Custom Importers and Processors? The information provided here should help when you develop Content Pipeline extensions. References What is MonoGame Content Pipeline Class Library? An overview of the MonoGame Content Pipeline Class Library reference, containing all the API calls available to the MonoGame Framework Content Framework. What is the Content Pipeline Document Object Model? The MonoGame Content Document Object Model (DOM) represents the set of built-in classes that can be consumed by standard content processors. What is Sprite Font XML Schema Reference? Describes the valid tags and values for Sprite-Font (.spritefont) XML files used by the Content Pipeline to create SpriteFont textures. What are the XML Elements for XMLImporter? The base elements that are recognized by XmlImporter Class."
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/whatis/game_loop/index.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/whatis/game_loop/index.html",
    "title": "What is the Game Loop | hallowed",
    "summary": "The MonoGame Framework Game class implements a game loop, which provides not only the window which displays your game, but also provides overloadable methods that your game implements to facilitate communication between your game and the operating system. This topic provides an overview of the basic functionality provided by the game loop. Making a New Game Game Loop Timing Game Components Game Services Game Components Consuming Game Services Making a New Game The first step in creating a new game is to make a class that derives from Game. The new class needs to override the following methods: Initialize - which is the method is responsible for game setup before the first frame of the game. Update - which is the method is responsible for handling game logic. Draw - which is the method responsible for drawing content to the screen. Game Loop Timing A Game is either fixed step or variable step, defaulting to fixed step. The type of step determines how often Update will be called and affects how you need to represent time-based procedures such as movement and animation. Fixed-Step Game Loops A fixed-step Game tries to call its Update method on the fixed interval specified in TargetElapsedTime. Setting Game.IsFixedTimeStep to true causes a Game to use a fixed-step game loop. A new MonoGame project uses a fixed-step game loop with a default TargetElapsedTime of 1/60th of a second. In a fixed-step game loop, Game calls Update once the TargetElapsedTime has elapsed. After Update is called, if it is not time to call Update again, the Game calls Draw. After Draw is called, if it is not time to call Update again, Game idles until it is time to call UpdateS. If Update takes too long to process, Game sets IsRunningSlowly to true and calls Update again, without calling Draw in between. When an update runs longer than the TargetElapsedTime, Game responds by calling Update extra times and dropping the frames associated with those updates to catch up. This ensures that Update will have been called the expected number of times when the game loop catches up from a slowdown. You can check the value of IsRunningSlowly in your Update if you want to detect dropped frames and shorten your Update processing to compensate. You can reset the elapsed times by calling ResetElapsedTime. When your game pauses in the debugger, Game will not make extra calls to Update when the game resumes. Variable-Step Game Loops A variable-step game calls its Update and Draw methods in a continuous loop without regard to the TargetElapsedTime. Setting Game.IsFixedTimeStep to false causes a Game to use a variable-step game loop. Animation and Timing For operations that require precise timing, such as animation, the type of game loop your game uses (fixed-step or variable-step) is important. Using a fixed step allows game logic to use the TargetElapsedTime as its basic unit of time and assume that Update will be called at that interval. Using a variable step requires the game logic and animation code to be based on ElapsedGameTime to ensure smooth gameplay. Because the Update method is called immediately after the previous frame is drawn, the time between calls to Update can vary. Without taking the time between calls into account, the game would seem to speed up and slow down. The time elapsed between calls to the Update method is available in the Update method's gameTime parameter. You can reset the elapsed times by calling ResetElapsedTime. When using a variable-step game loop, you should express rates—such as the distance a sprite moves—in game units per millisecond (ms). The amount a sprite moves in any given update can then be calculated as the rate of the sprite times the elapsed time. Using this approach to calculate the distance the sprite moved ensures that the sprite will move consistently if the speed of the game or computer varies. Game Components Game components provide a modular way of adding functionality to a game. You create a game component by deriving the new component either from the GameComponent class, or DrawableGameComponent class if the component loads and draws graphics content. You then add game logic and rendering code to the game component by overriding the following methods: GameComponent.Update GameComponent.Initialize Additionally, if you derive from the DrawableGameComponent class, you will additionally be able to override: DrawableGameComponent.Draw A game component is registered with a game by passing the component to Game.Components.Add. A registered component will have its initialize, update, and draw methods called from the Game.Initialize, Game.Update, and Game.Draw methods, respectively. Game Services Game services are a mechanism for maintaining loose coupling between objects that need to interact with each other. Services work through a mediator—in this case, Game.Services. Service providers register with Game.Services, and service consumers request services from Game.Services. This arrangement allows an object that requires a service to request the service without knowing the name of the service provider. Game services are defined by a unique interface. A class specifies the services it provides by implementing interfaces and registering the services with Game.Services. A service is registered by calling Game.Services.AddService specifying the type of service being implemented and a reference to the object providing the service. For example, to register an object that provides a service represented by the interface IMyService, you would use the following code. Services.AddService( typeof( IMyService ), myobject ); Once a service is registered, the object providing the service can be retrieved by Game.Services.GetService and specifying the desired service. For example, to retrieve IGraphicsDeviceService, you would use the following code. IGraphicsDeviceService graphicsservice = (IGraphicsDeviceService)Services.GetService( typeof(IGraphicsDeviceService) ); Game Components Consuming Game Services The GameComponent class provides the Game property so a GameComponent can determine what Game it is attached to. With the Game property, a GameComponent can call Game.Services.GetService to find a provider of a particular service. For example, a GameComponent would find the IGraphicsDeviceService provider by using the following code. IGraphicsDeviceService graphicsservice = (IGraphicsDeviceService)Game.Services.GetService( typeof( IGraphicsDeviceService ) ); Related articles Important How to articles to follow."
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/whatis/graphics/WhatIs_3DRendering.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/whatis/graphics/WhatIs_3DRendering.html",
    "title": "What is 3D Rendering? | hallowed",
    "summary": "The 3D graphics pipeline uses a graphics device (the current display device rendering to the screen) to load resources and render a 3D scene using an Effect. In general, the 3D pipeline requires the following state information for initialization: World, view, and projection matrices to transform 3D vertices into a 2D space. A vertex buffer which contains the geometry to render. An effect that sets the render state necessary for drawing the geometry. Note For a more detailed explanation of World, View and Projection matrices , check out this GameFromScratch - beginning 3D article. As you become comfortable with these ideas, you may want to learn more about the following: Manipulating vertices Creating your own effects Applying textures Improving performance by using index buffers. The MonoGame Framework uses a shader-driven programmable pipeline and requires a graphics card capable of at least Shader Model 2.0. A class called BasicEffect encapsulates most of these common operations. ![IMPORTANT] Shader requirements depend on the platform being targeted, the majority of MonoGame titles these days require Shader Model 3.0 as a minimum. You can use this guide as a reference. MonoGame automatically converts all shaders to their appropriate platform based on the \"shader level\" defined. The Graphics Device When you create a game with MonoGame, the framework initializes a graphics device for you. The GraphicsDeviceManager initializes the GraphicsDevice. Before Initialize is called, there are three ways to change the GraphicsDevice settings: Set the appropriate properties such as the PreferredBackBufferHeight and PreferredBackBufferWidth on the GraphicsDeviceManager in your game's constructor. _graphics.PreferredBackBufferHeight = 768; _graphics.PreferredBackBufferWidth = 1024; _graphics.ApplyChanges(); Handle the PreparingDeviceSettings event on the GraphicsDeviceManager, and change the PreparingDeviceSettingsEventArgs.GraphicsDeviceInformation.PresentationParameters member properties. _graphics.PreparingDeviceSettings += OnPreparingDeviceSettings; private void OnPreparingDeviceSettings(object sender, PreparingDeviceSettingsEventArgs e) { e.GraphicsDeviceInformation.PresentationParameters.BackBufferWidth = 1024; e.GraphicsDeviceInformation.PresentationParameters.BackBufferHeight = 768; } Warning Any changes made to the PreparingDeviceSettingsEventArgs will override the GraphicsDeviceManager preferred settings. Handle the DeviceCreated event on the GraphicsDeviceManager, and change the PresentationParameters of the GraphicsDevice directly. IGraphicsDeviceService graphicsDeviceService = (IGraphicsDeviceService) Game.Services.GetService(typeof(IGraphicsDeviceService)); if (graphicsDeviceService != null) { graphicsDeviceService.DeviceCreated += OnDeviceCreated; } private void OnDeviceCreated(object sender, EventArgs e) { // Handle updating Graphics Device Presentation Parameters } When you call Game.Initialize the GraphicsDeviceManager creates and configures GraphicsDevice. You can then safely access GraphicsDevice settings such as the backbuffer, depth/stencil buffer, viewport, and render states in the Initialize method. Important After you call Game.Initialize, changes to the PresentationParameters of the GraphicsDevice will not take effect until you call GraphicsDeviceManager.ApplyChanges. Other changes, such as render states, will take effect immediately. Resources A graphics resource is a collection of data stored in memory that can be accessed by either the CPU or GPU. The types of resources that an application might use include: Render targets Vertex buffers Index buffers Textures ![NOTE] FOr a more detailed understanding in the use of these terms, check out Riemers 3D series on the XNAGameStudio Archive. Based on the resource management mode that was used when a resource is created, it should be reloaded when the device is reset. For more information, see Loading Resources. Vertex and Index Buffers A vertex buffer contains a list of 3D vertices to be streamed to the graphics device. Each vertex in a vertex buffer may contain data about not only the 3D coordinate of the vertex but also other information describing the vertex, such as the vertex normal, color, or texture coordinate. Which you should use will depend on your usage and the needs of the vertex information you are drawing with, for example The MonoGame Framework contains several classes to describe common vertex declaration types, such as: VertexPositionColor Vertex Declaration containing Position and Color of a vertex. VertexPositionColorTexture Vertex Declaration containing Position, Color and Texture of a vertex. VertexPositionNormalTexture Vertex Declaration containing Position, Normal and Texture of a vertex. VertexPositionTexture. Vertex Declaration containing Position and Texture of a vertex. Note Use the VertexElement class to compose custom vertex types. Vertex buffers can contain indexed or non-indexed vertex data. Note If a Vertex Buffer is not indexed, all of the vertices are placed in the vertex buffer in the order they are to be rendered. Because 3D line lists or triangle lists often reference the same vertices multiple times, this can result in a large amount of redundant data. Index buffers allow you to list each vertex only once in the vertex buffer. An index buffer is a list of indices into the vertex buffer, given in the order that you want the vertices to render. Render a non-indexed vertex buffer To render a non-indexed vertex buffer, call the GraphicsDevice.DrawPrimitives or GraphicsDevice.DrawUserPrimitives Methods. Render an indexed vertex buffer To render an indexed buffer, call the GraphicsDevice.DrawIndexedPrimitives or GraphicsDevice.DrawUserIndexedPrimitives Methods. Textures A texture resource is a structured collection of texture data. The data in a texture resource is made up of one or more sub-resources that are organized into arrays and mipmap chains. Textures are filtered by a texture sampler as they are read. The type of texture influences how the texture is filtered. You can apply textures by using the Texture property of the BasicEffect class, or choose to write your own effect methods to apply textures."
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/whatis/graphics/WhatIs_Antialiasing.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/whatis/graphics/WhatIs_Antialiasing.html",
    "title": "What is Antialiasing? | hallowed",
    "summary": "Antialiasing is a technique for softening or blurring sharp edges so they appear less jagged when rendered. Antialiasing is accomplished by multi-sampling each pixel at multiple pixel locations and combining the samples to generate a final pixel color. Increasing the number of samples per pixel increases the amount of antialiasing which generates a smoother edge: 4x multisampling requires four samples per pixel. 2x multisampling requires two sampler per pixel. And so on. Use the MultiSampleCount property of the PresentationParameters class to set the number of samples for the back buffer. Set the PreferMultiSampling property on the GraphicsDeviceManager class to true to enable multi-sampling for the back buffer. Important This will be ignored if the hardware does not support multi-sampling. See Also Enabling Anti-aliasing (Multi-sampling)"
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/whatis/graphics/WhatIs_BackBuffer.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/whatis/graphics/WhatIs_BackBuffer.html",
    "title": "What Is a Back Buffer? | hallowed",
    "summary": "A back buffer is a render target whose contents will be sent to the device when GraphicsDevice.Present is called. The graphics pipeline renders to a render target, the particular render target that the device presents to the display is called the back buffer. Use the BackBufferWidth and BackBufferHeight properties to get the back buffer dimensions. Render directly to the back buffer or to a render target by configuring the device using GraphicsDevice.SetRenderTarget and GraphicsDevice.SetRenderTargets. For Windows, the back buffer is created to match the dimensions of the ClientBounds by default. For Consoles, the back buffer is created with the dimensions that have been specified by the user. When going into full-screen mode on Windows. On Mobile, it is recommended to set the BackBuffer dimensions to the expected resolution based on the desired orientation of the device (Portrait or Landscape). It is often desirable to set the back buffer dimensions to match the DisplayMode dimensions so that the game (\"display\") resolution does not change when it goes into the full-screen mode. The back buffer created for consoles is not necessarily the same size as the final resolution on a television connected for display. Consoles automatically scale output to the television resolution selected by the user in the System. If the aspect ratio of the back buffer is different from the aspect ratio of the television display mode, the console will automatically add black bars (also called letter-boxing) if the user's display is not widescreen. In addition, if you request a back-buffer resolution that is not supported by the output device, the MonoGame framework automatically selects the highest resolution supported by the output device. For example, if you create a back-buffer with a resolution of 1920x1080 (for example, 1080p or 1080i) and display it on a device with 480i resolution, the back-buffer is resized to 480i automatically. See Also Viewport"
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/whatis/graphics/WhatIs_BlendState.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/whatis/graphics/WhatIs_BlendState.html",
    "title": "What Is Blend State? | hallowed",
    "summary": "The Blend state controls how color and alpha values are blended when combining rendered data with existing render target data. The blend state class, BlendState, contains state that controls how colors are blended. Each time you render, the pixel data you generate (call it source data) is stored in a render target. The render target might be empty or it might already contain data (call it destination data). Blending occurs each time you combine source and destination data. You have a lot of control over how you blend the source and the destination data. For example: You can choose to overwrite the destination with the source data by setting BlendState.Opaque Combine the data by adding them together using BlendState.Additive. You can blend only the color data or the alpha data, or both, by setting up the blending functions ColorBlendFunction and AlphaBlendFunction. You can even limit your blending operation to one or more colors (or channels) using ColorWriteChannels. Note For an example that creates and uses a state object, see Creating a State Object."
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/whatis/graphics/WhatIs_Camera.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/whatis/graphics/WhatIs_Camera.html",
    "title": "What is A Camera? | hallowed",
    "summary": "In order to render anything to the screen the Graphics device needs to understand what it needs to render and where, in basic terms, it needs a projection in 3D space with objects in view that need to be rendered. An easier way to break it down is to compare it to the movies (or movie making), what you need in actuality is a Camera. Where the camera points in the movie scene, what actors are in view and the scenery behind them, that is what makes it into the movie and shows on the screen. In Game Development the principle is the same. The View Frustrum The way we describe a camera in 3D terms is to define a View Frustrum, which tells the graphics device: Where is it looking in 3D space. What is the closest point at which is should be looking from. (Near Plane) What is the furthest point objects can be rendered. (Far Plane) And what is the angle of projection. The following diagram shows how this looks. Everything within the \"cone of view\" is recognized by the graphics pipeline and is rendered into a Texture for displaying on the screen. Everything outside these bounds is ignored (culled) and left on the cutting room floor. Caution Be aware, that in 3D rendering EVERYTHING is evaluated to determine if it is in \"View\", EVERYTHING you send to the graphics card that you want to be rendered. So if you send a massive scene and ALL your Models, ALL your textures, etc, then everything is evaluated. Sure, Graphics Processing has evolved considerably over the years and the processes running on Graphics Cards keep getting quicker, but you still want to make that as efficient as possible. What defines a camera Beyond the View Frustrum above, a Camera exists in graphical terms as: A position - Where in 3D space is the camera positioned? A direction - Which direction is the camera pointing? The Target of the camera - What is it looking at? The central point. The View Frustrum of the camera - What is in the field of view? The World Matrix, where in the world is the camera in relation to the center and other objects? You will see this defined in many samples as the World, View and Projection Matrices, as shown below: // A centered world with no transformation Matrix worldMatrix = Matrix.Identity; // A view pointing at the center of the world from a position 50 units backwards. Matrix viewMatrix = Matrix.CreateLookAt( // View Position, where it is viewed FROM new Vector3(0, 0, 50), // The world space coordinates it is looking at (0,0,0) Vector3.Zero, // The rotation of the view, the direction of the upper edge of the camera. Vector3.Up); // The frustrum of the camera Matrix projectionMatrix = Matrix.CreatePerspectiveFieldOfView( // The width of the camera view. MathHelper.PiOver4, // The height of the camera view. GraphicsDevice.Viewport.AspectRatio, // The near plane, when to start rendering objects from. 1.0f, // The far plane, when to stop rendering objects from. 300.0f); 2D drawing Now to break one illusion, 2D drawing (without all the camera setup) is still 3D drawing but from a fixed point of view with all content drawn at the same physical depth. The SpriteBatch class does a very clever job of setting up this fixed view behind the scenes and also provides some basic ordering/laying of content as it is drawn into view. Each batch is sent to the graphics card collectively and then processed in order from first to last, each subsequent draw being on top of the last. Note Texture / Font drawing is effectively like placing pieces of paper on a table, one on top of another until you are done. What can be seen once all the paper has been placed is the final view. An example 2D drawing method: void DrawTexture(SpriteBatch spriteBatch, Texture2D spriteTexture, Vector2 spritePosition, Color spriteColor) { spriteBatch.Begin(); spriteBatch.Draw(spriteTexture, spritePosition, spriteColor); spriteBatch.End(); } Note For more on 2D / Sprite rendering, check the How To series for 2D rendering. The functionality does provide some techniques to sort what is drawn, provide some additional depth and layers, as well as blending options to effectively merge what is drawn. 3D Drawing When drawing 3D content in a scene, the Camera's current View and Projection are what are fed in to an Effect that draws the 3D content, together with a Transformational Matrix (World position and rotation of the model) multiplied by the same World matrix used by the camera (as they are both part of the same world). The MonoGame Model class has a built in Draw Method which performs the basic functions needed in order to render a 3D model into the view, requiring only the World, View, and Projection matrices required to draw it, as follows: Model myModel; protected override void LoadContent() { myModel = Content.Load<Model>(\"<model file name>\"); } protected override void Draw(GameTime gameTime) { GraphicsDevice.Clear(Color.CornflowerBlue); // Ground drawn from the center of the scene myModel.Draw(Matrix.Identity, currentCameraView, currentCameraProjection); } [!INFO] For information purposes only Behind the scenes, the model.Draw() method is using a BasicEffect and performing the necessary matrix calculations to position and render the model, as follows: /// <summary> /// Draw the model, a model can have multiple meshes, so loop. /// </summary> /// <param name=\"aModel\">The Model to draw.</param> /// <param name=\"aWorld\">The World matrix from the camera or shared world matrix.</param> /// <param name=\"aView\">The camera view in the world.</param> /// <param name=\"aProjection\">The camera projection in the world.</param> void DrawModel(Model aModel, Matrix aWorld, Matrix aView, Matrix aProjection) { //Copy any parent transforms Matrix[] transforms = new Matrix[ aModel.Bones.Count ]; aModel.CopyAbsoluteBoneTransformsTo( transforms ); //Draw the model, a model can have multiple meshes, so loop foreach (ModelMesh mesh in aModel.Meshes) { //This is where the mesh orientation is set, as well as our camera and projection foreach (BasicEffect effect in mesh.Effects) { effect.EnableDefaultLighting(); effect.PreferPerPixelLighting = true; effect.World = transforms[ mesh.ParentBone.Index ] * aWorld; effect.View = aView; effect.Projection = aProjection; } //Draw the mesh, will use the effects set above. mesh.Draw( ); } } Types of Camera Cameras have many roles in games, in certain cases you may even use multiple cameras to render a scene, or render scenes from different angles to a texture to use as a HUD or mini-map. Camera types include: Camera Type Description Fixed A camera that is locked in place and is not intended to move (e.g. a Security Camera) First Person A camera that represents a players perspective of the world, moving and looking around. Third Person A camera that is locked behind a player avatar or model, moving with them as they move, can also rotate around the player for alternate views. Top Down A fixed view that looks from up on high and down in to the game world, sometimes fixed, sometimes tracking the movement of the main player or avatar. Side View A side scrolling view, or platformer, again, sometimes fixed, sometimes following the player or avatar These are just the most common examples as everyone has seen in the many games that have come before. Some games use a combination of these modes to achieve the games look and feel. Multiple cameras can be used simultaneously for either a split screen multi-player effect or by showing an alternate view in a window. Views of Cameras The projection of the camera can also be made to look different, MonoGame supports the two main modes of projection: Perspective - A realistic 3D view. Orthographic - Provides a flat 2D view. Each perspective simply alters the way in which content is rendered into view. Camera Example To demonstrate a camera setup, the following class acts as a base camera definition that can then be extended to meet your needs for rendering: using Microsoft.Xna.Framework; using Microsoft.Xna.Framework.Input; public class Camera { private Vector3 position; private float yaw; private float pitch; private int viewportWidth; private int viewportHeight; private float nearClip = 10.0f; private float farClip = 100000.0f; public Vector3 Position => position; public float Yaw => yaw; public float Pitch => pitch; public Matrix ViewMatrix { get { Vector3 cameraDirection = Vector3.Transform(Vector3.Forward, Matrix.CreateFromYawPitchRoll(yaw, pitch, 0)); Vector3 cameraTarget = position + cameraDirection; return Matrix.CreateLookAt(position, cameraTarget, Vector3.Up); } } public Matrix ProjectionMatrix { get; private set; } public Camera(Vector3 startPosition, float startYaw, float startPitch, int viewportWidth, int viewportHeight) { position = startPosition; yaw = startYaw; this.viewportWidth = viewportWidth; this.viewportHeight = viewportHeight; this.nearClip = nearClip; this.farClip = farClip; ProjectionMatrix = Matrix.CreatePerspectiveFieldOfView( MathHelper.ToRadians(45), viewportWidth / (float)viewportHeight, nearClip, farClip ); } } Using this camera is then as simple as: using Microsoft.Xna.Framework; using Microsoft.Xna.Framework.Graphics; using Microsoft.Xna.Framework.Input; public class MonoGameCameraSample : Game { private GraphicsDeviceManager _graphics; private SpriteBatch _spriteBatch; private Camera camera; private Model myModel; public MonoGameCameraSample() { _graphics = new GraphicsDeviceManager(this); Content.RootDirectory = \"Content\"; } protected override void Initialize() { // Create a new camera with the following parameters: // 1. Position 50 units Up and 100 units back from the center // 2. Camera is looking straight forward, no turn. // 3. Angle the camera down 25 degrees // 4. Pass in the width and height of the Graphics Device camera = new Camera( new Vector3(0, 50, 100), 0f, -MathHelper.ToRadians(25f), GraphicsDevice.Viewport.Width, GraphicsDevice.Viewport.Height ); base.Initialize(); } protected override void LoadContent() { _spriteBatch = new SpriteBatch(GraphicsDevice); myModel = Content.Load<Model>(\"Models/p1_wedge\"); } protected override void Draw(GameTime gameTime) { GraphicsDevice.Clear(Color.CornflowerBlue); GraphicsDevice.BlendState = BlendState.Opaque; GraphicsDevice.RasterizerState = RasterizerState.CullNone; GraphicsDevice.SamplerStates[0] = SamplerState.LinearWrap; GraphicsDevice.DepthStencilState = DepthStencilState.Default; // Draw a model using the camera's current View and Projection Matrix DrawModel(myModel, Matrix.Identity, camera.ViewMatrix, camera.ProjectionMatrix); base.Draw(gameTime); } void DrawModel(Model aModel, Matrix aWorld, Matrix aView, Matrix aProjection) { //Copy any parent transforms Matrix[] transforms = new Matrix[aModel.Bones.Count]; aModel.CopyAbsoluteBoneTransformsTo(transforms); //Draw the model, a model can have multiple meshes, so loop foreach (ModelMesh mesh in aModel.Meshes) { //This is where the mesh orientation is set, as well as our camera and projection foreach (BasicEffect effect in mesh.Effects) { effect.EnableDefaultLighting(); effect.PreferPerPixelLighting = true; effect.World = transforms[mesh.ParentBone.Index] * aWorld; effect.View = aView; effect.Projection = aProjection; } //Draw the mesh, will use the effects set above. mesh.Draw(); } } } This is a fixed camera with no movement and only looking in a single direction all the time, it has no movement, input logic or capability to move around the scene. See Also How to display Multiple Screens with Viewports Concepts What Is 3D Rendering? What Is a Viewport? What Is a View Frustum? What Is a Render Target? Reference GraphicsDevice.Viewport Matrix SpriteBatch"
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/whatis/graphics/WhatIs_ColorBlending.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/whatis/graphics/WhatIs_ColorBlending.html",
    "title": "What Is Color Blending? | hallowed",
    "summary": "Color blending mixes two colors together to produce a third color. The first color is called the source color which is the new color being added. The second color is called the destination color which is the color that already exists (in a render target, for example). Each color has a separate blend factor that determines how much of each color is combined into the final product. Once the source and destination colors have been multiplied by their blend factors, the results are combined according to the specified blend function. The normal blend function is simple addition. The blend formula looks like this: (source * sourceBlendFactor) blendFunction (destination*destinationBlendFactor) The source blend factor is specified by the ColorSourceBlend property The destination blend factor is specified by the ColorDestinationBlend property. The ColorBlendFunction property specifies the blend function to use, normally BlendFunction.Add. In which case the formula reduces to this: (source * sourceBlendFactor) + (destination * destinationBlendFactor) Note When no blending is done, a source pixel overwrites a destination pixel. When blending, you can create a lot of special effects using the blending properties: Blend type. Blend settings. Alpha Blending (_source_ × [Blend.SourceAlpha](/api/Microsoft.Xna.Framework.Graphics.Blend.html)) \\+ (_destination_ × [Blend.InvSourceAlpha](/api/Microsoft.Xna.Framework.Graphics.Blend.html)) Additive Blending (_source_ × [Blend.One](/api/Microsoft.Xna.Framework.Graphics.Blend.html)) \\+ (_destination_ × [Blend.One](/api/Microsoft.Xna.Framework.Graphics.Blend.html)) Multiplicative Blending (_source_ × [Blend.Zero](/api/Microsoft.Xna.Framework.Graphics.Blend.html)) \\+ (_destination_ × [Blend.SourceColor](/api/Microsoft.Xna.Framework.Graphics.Blend.html)) 2X Multiplicative Blending (_source_ × [Blend.DestinationColor](/api/Microsoft.Xna.Framework.Graphics.Blend.html)) \\+ (_destination_ × [Blend.SourceColor](/api/Microsoft.Xna.Framework.Graphics.Blend.html)) Figure 1. This picture illustrates four common blend modes. From left to right: Alpha blending, Additive blending, Multiplicative blending, and 2X Multiplicative blending. The top image in each column is the source image and below, it's effect when added to the destination. Alpha blending uses the alpha channel of the source color to create a transparency effect so that the destination color appears through the source color. For example: If you clear your backbuffer to Color.Gray, it will be colored (0.5,0.5,0.5,1). If you then take a white color with a partial alpha value (1,1,1,0.4), the result will be 60 percent of the destination color and 40 percent of the source: (0.5 x 0.6) + (1 x 0.4). The resulting color will be (0.7,0.7,0.7, 1). The alpha values are multiplied as well - (.6 x 1) + .4 gives us an alpha value of 1. Note When drawing a sprite using the SpriteBatch class, choose BlendState.AlphaBlend to configure alpha blending. By default, the alpha channel is blended along with the red, green, and blue channels using the ColorSourceBlend and ColorDestinationBlend properties. You can choose to customize the blending for just the alpha channel by using the AlphaSourceBlend and AlphaDestinationBlend properties. See Also Concepts What Is a Sprite? 3D Pipeline Basics"
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/whatis/graphics/WhatIs_ConfigurableEffect.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/whatis/graphics/WhatIs_ConfigurableEffect.html",
    "title": "What Is a Configurable Effect? | hallowed",
    "summary": "A configurable effect is an optimized rendering effect designed for use with MonoGame. A configurable effect is created using a built-in object with options for user configuration. An effect initializes the graphics pipeline for performing transforms, lighting, applying textures, and adding per-pixel visual effects such as a glow or a lens flare. Under the covers, an effect implements at least one shader for processing vertices and at least one shader for processing pixels. During rendering, the graphics pipeline transforms 3D geometry to a 2D surface, giving you the option of adding lighting, texturing and many other per-vertex or per-pixel visual effects. An effect initializes the pipeline to render 3D geometry using vertex and pixel shaders, although you can also render a 2D sprite with an effect. Although more advanced programmable effects are available on Windows and other platforms. There are several built-in configurable effects which have been designed to run efficiently on mobile GPU hardware, and which are appropriate to the Reach profile used for mobile games. Use one of the following configurable effects to implement these rendering effects: Basic Lighting and Fog Character Animation More Sophisticated Lighting with a Light Map Billboards and Imposters Lighting Highlights Using an Environment Map Basic Lighting and Fog Use the BasicEffect configurable effect to implement general purpose functionality, including the following: Transformations. Lighting with three directional lights Material colors using ambient, diffuse, and specular properties. A single texture. Fog. Note To improve speed, fog calculations are based on depth instead of distance from the camera. When you choose a basic effect, you can improve the performance of your game if you do not use any fog or if you only use one of the three available directional lights. For an example, see Creating a Basic Effect. Character Animation Use the SkinnedEffect configurable effect to animate a character. This effect uses bones and weights to transform a mesh (an object is made up of several meshes). To use this effect, set up a set of bones for a model when you create content and then transform the bones during the render loop. You can also use this class for hardware instancing by setting WeightsPerVertex to one, and replicating the geometry data with an additional bone index channel. This is similar to the way the shader instancing technique works in the instancing sample. More Sophisticated Lighting with a Light Map Use the DualTextureEffect configurable effect with a pre-baked radiosity lightmap to add more sophisticated lighting to a scene. This effect uses two textures, the base texture with the texture detail and an overlay texture with the pre-baked lighting. The two textures are combined using a fixed modulate2X blend formula as shown here: result.rgb = x.rgb * y.rgb * 2; result.a = x.a * y.a; Billboards and Imposters Use the AlphaTestEffect configurable effect to use alpha data to test whether to draw a pixel. The effect uses a CompareFunction to compare the alpha value for a pixel against the ReferenceAlpha value to determine whether to draw the pixel. This functionality is used for drawing a billboard (a 2D sprite that faces the camera) and an imposter (a 2D sprite that is integrated into a larger scene). Lighting Highlights Using an Environment Map Use the EnvironmentMapEffect configurable effect to generate fast, specular highlights that add shininess to an object. The effect uses two textures, a base texture with the texture detail and a cubemap whose six sides reflect the environment onto the object. Use EnvironmentMapAmount to control the amount of the environment map to add to the object. Also, use FresnelFactor to control how much the edge of an object reflects specular lighting. Pseudo code for the lighting calculations looks similar to this: viewAngle = dot(eyeToVertexVector, vertexNormal); fresnel = saturate(pow(1 – abs(viewAngle), FresnelFactor); amount = fresnel * EnvironmentMapAmount; result.rgb = lerp(diffuseTexture.rgb, cubeTexture.rgb, amount); result.rgb += cubeTexture.a * EnvironmentMapSpecular"
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/whatis/graphics/WhatIs_DepthBuffer.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/whatis/graphics/WhatIs_DepthBuffer.html",
    "title": "What Is a Depth Buffer? | hallowed",
    "summary": "A depth buffer contains per-pixel floating-point data for the z depth of each pixel rendered. A depth buffer may also contain stencil data which can be used to do more complex rendering such as simple shadows or outlines. When a pixel is rendered, color data as well as depth data can be stored. If a pixel is rendered a second time - such as when two objects overlap - depth testing determines which pixel is closer to the camera. The depth function determines what to do with the test result. For example, if CompareFunction.LessEqual is the current depth function, if the current pixel depth is less than or equal to the previous pixel depth, the current pixel depth is written to the depth buffer. Values that fail the depth test are discarded. The depth of a pixel, which ranges between 0.0 and 1.0, is determined based on the view and projection matrices. A pixel that touches the near plane has depth 0, a pixel that touches the far plane has depth 1. As each object in the scene is rendered, normally the pixels that are closest to the camera are kept, as those objects block the view of the objects behind them. A depth buffer may also contain stencil bits - for this reason it's often called a depth-stencil buffer. The depth format describes the data format of the depth buffer. The depth buffer is always 32 bits, but those bits can be arranged in different ways, similar to how texture formats can vary. A common depth format is DepthFormat.Depth24Stencil8, where 24 bits are used for the depth data and 8 bits are used for the stencil data. DepthFormat.Depth24Stencil8Single is a more unusual format where the 24 bits for the depth buffer are arranged as a floating point value. Use DepthFormat.None if you don't want to create a depth buffer. Use DepthStencilState.DepthBufferEnable to enable or disable depth buffering. Use the DepthStencilState.DepthBufferFunction to change the comparison function used for the depth test. Clear the depth buffer by passing ClearOptions.DepthBuffer to GraphicsDevice.Clear. In MonoGame there is no DepthStencilBuffer type. The runtime automatically creates a depth buffer when a render target is created, and you specify the format for the depth buffer in a render target's constructor along with the surface format. This prevents a render target from being created without a matching depth buffer."
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/whatis/graphics/WhatIs_DepthStencilState.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/whatis/graphics/WhatIs_DepthStencilState.html",
    "title": "What Is Depth Stencil State? | hallowed",
    "summary": "A Depth stencil state controls how the depth buffer and the stencil buffer are used. The depth buffer stores floating-point depth or z data for each pixel while the stencil buffer stores integer data for each pixel. The depth-stencil state class, DepthStencilState, contains state that controls how depth and stencil data impacts rendering. During rendering, the z position (or depth) of each pixel is stored in the depth buffer. When rendering pixels more than once -- such as when objects overlap -- depth data is compared between the current pixel and the previous pixel to determine which pixel is closer to the camera. When a pixel passes the depth test, the pixel color is written to a render target and the pixel depth is written to the depth buffer. For more information about a depth buffer, see What Is a Depth Buffer?. A depth buffer may also contain stencil data, which is why a depth buffer is often called a depth-stencil buffer. Use a stencil function to compare a reference stencil value -- a global value you set -- to the per-pixel value in the stencil buffer to mask which pixels get saved and which are discarded. Note For more information about a stencil buffer, see What Is a Stencil Buffer?"
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/whatis/graphics/WhatIs_GraphicsProfile.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/whatis/graphics/WhatIs_GraphicsProfile.html",
    "title": "What Is a Profile? | hallowed",
    "summary": "A graphics profile is a feature set that is implemented in hardware. The Reach profile implements High Level Shader Language (HLSL) Shader Model 2.0 and the HiDef profile implements HLSL Shader Model 3.0 or above. Important The information regarding Graphics Profiles is recorded here for information only, supporting the history of XNA. With current technology, the HiDef profile is more than sufficient for modern hardware and there should be no limits within the MonoGame architecture for using modern techiques for making the most out of todays technology. To simplify multi-platform development, MonoGame creates a profile. A profile is platform independent so you do not need to query for capability bits. The APIs for accessing the features implemented in hardware are consistent across platforms so that game code written for one platform will compile and run on another platform with little or no changes. A game will not run if a hardware device does not meet the profile requirements. You can set the profile at design time by using the MonoGame property page in Microsoft Visual Studio or you can set a profile at runtime by using the GraphicsProfile property. For more information. Note See Selecting Reach vs. HiDef. There are two profiles, HiDef and Reach: the former for fully featured, high-powered hardware, and the latter for less featured, available-everywhere hardware. Reach is designed to broadly cover all platforms and has a limited set of graphic features and capabilities implemented in hardware. This profile is designed to support the widest variety of devices, more specifically Windows-based computers, mobiles and consoles. Reach dramatically speeds up writing multi-platform games because you can design and debug game code on one platform knowing that it will run on other platforms. Performance is dependent on the hardware available for each platform. The HiDef profile is designed for the highest performance and largest available set of graphic features. Use the HiDef profile to target hardware with more enhanced graphic capabilities such as an consoles and Windows-based computers with at least a DirectX 10 GPU. More specifically, the HiDef profile requires a GPU with console-level capabilities such as multiple render targets (MRT), floating-point surface formats, and per-vertex texture fetching. These are optional capabilities in DirectX 9 hardware, but all are required to support HiDef. Since DirectX 9 graphic cards are not required to support these features, it is easier to say that the HiDef profile requires at least a DirectX 10-capable GPU. A HiDef game will run on a DirectX 9 card if it implements the named DirectX 10 features. [IMPORTANT] If you try to run a HiDef game on a device such as a mobile device that does not support HiDef, an exception is thrown at runtime. Additionally, if you try to access HiDef features from a game built for a Reach profile, the runtime throws an exception. To find out which profile your target hardware supports, call GraphicsAdapter.IsProfileSupported Method. Reach vs. HiDef Comparison Differences between the Reach and HiDef profiles are presented next. For more detail, see the sections following the table. Profiles Reach HiDef Platforms Mobile, Consoles, and any computer running Windows with a DirectX 9 GPU that supports at least Shader Model 2.0. Consoles, and any Windows-based PC with at least a DirectX 10 (or equivalent) GPU. See the paragraph above for more detail. Shader Model 2.0 3.0 Maximum texture size 2,048 4,096 Maximum cube map size 512 4,096 Maximum volume texture size Volume textures are not supported. 256 Nonpower of two textures Yes with limitations: no wrap addressing mode, no mipmaps, no DXT compression on nonpower of two textures. Yes Nonpower of two cube maps No Yes Nonpower of two volume textures Volume textures are not supported. Yes Maximum number of primitives per draw call 65,535 1,048,575 Maximum number of vertex streams 16 16 Maximum vertex stream stride 25 255 Index buffer formats 16 bit 16 and 32 bit Vertex element formats Color, Byte4, Single, Vector2, Vector3, Vector4, Short2, Short4, NormalizedShort2, NormalizedShort4 All of the Reach vertex element formats, as well as HalfVector2 and HalfVector4. Texture formats Color, Bgr565, Bgra5551, Bgra4444, NormalizedByte2, NormalizedByte4, Dxt1, Dxt3, Dxt5 All of the Reach texture formats, as well as Alpha8, Rg32, Rgba64, Rgba1010102, Single, Vector2, Vector4, HalfSingle, HalfVector2, HalfVector4. Floating point texture formats do not support filtering. Vertex texture formats Vertex texturing is not supported. Single, Vector2, Vector4, HalfSingle, HalfVector2, HalfVector4 Render target formats Call QueryRenderTargetFormat to find out what is supported. Call QueryRenderTargetFormat to find out what is supported. Multiple render targets No Up to four. All must have the same bit depth. Alpha blending and independent write masks per render target are supported. Occlusion queries No Yes Separate alpha blend No Yes S Shader Model The Reach profile supports HLSL Shader Model 2.0 and the configurable effects for all platforms. Some mobile platforms do not support custom shaders. The HiDef profile supports HLSL Shader Model 3.0 and above. Consoles and desktop also support custom shader extensions such as vertex fetching (vfetch). Textures Texture size limitations are listed in the table comparing the two profiles. These numbers are the maximum width or height of a texture that can be consumed by the profile. HiDef supports larger textures and volume textures. HiDef supports the following features without limitations; Reach supports the following features only for power-of-two textures: The wrap texture addressing mode Mipmaps DXT compression Formats There are a wide variety of render target formats. Call GraphicsAdapter.QueryRenderTargetFormat Method to find out what is supported for your hardware. The runtime also has a built-in fallback mechanism if the format you request is unavailable. The format parameters used when creating render targets and back buffers are now named \"preferredFormat\" instead of \"format.\" The runtime will try to create a resource with the exact format passed in, and will fallback to the closest possible match (based on similar bit depth, number of channels, and so on) if that format is unavailable. For example, if you run a Reach game on a mobile device using a 16-bit render target format and then run the game on some consoles that do not support 16-bit render targets, the runtime will switch the render-target format to a Color format. Conclusion XNA introduced the Reach profile for Consoles, Windows, and mobile, and the HiDef profile for Consoles and Windows devices. The HiDef profile includes a strict superset of the functionality in the Reach profile, which means that HiDef implements all Reach functionality and more. If you run a Reach game on a HiDef platform, the framework will enforce Reach rules. Use this to your advantage when you develop a multi-platform game. You can design and debug on the most powerful hardware with the knowledge that the game will compile and run on the other less powerful platforms when you are ready to test your game. The runtime will throw an exception if you try to set the profile to HiDef on hardware that does not support HiDef, or if you are running a Reach profile game that tries to access HiDef features. Cited Works \"Selecting Reach vs. HiDef.\" Shawn Hargreaves Blog. July 2010. http://web.archive.org/web/20120102231201/http://blogs.msdn.com/b/shawnhar/archive/2010/07/19/selecting-reach-vs-hidef.aspx (Last accessed August 2, 2010)"
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/whatis/graphics/WhatIs_ModelBone.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/whatis/graphics/WhatIs_ModelBone.html",
    "title": "What Is a Model Bone? | hallowed",
    "summary": "A model bone is a matrix that represents the position of a mesh as it relates to other meshes in a 3D model. A complex computer-generated object, often called a model, is made up of many vertices and materials organized into a set of meshes. In the MonoGame Framework, a model is represented by the Model class. A model contains one or more meshes, each of which is represented by a ModelMesh class. Each mesh is associated with one bone represented by the ModelBone class. The bone structure is set up to be hierarchical to make controlling each mesh (and therefore the entire model) easier. At the top of the hierarchy, the model has a Root bone to specify the overall position and orientation of the model. Each ModelMesh object contains a ParentBone and one or more ModelBone. You can transform the entire model using the parent bone as well as transform each individual mesh with its bone. To animate one or more bones, update the bone transforms during the render loop by calling Model.CopyAbsoluteBoneTransformsTo Method, which iterates the individual bone transforms to make them relative to the parent bone. To draw an entire model, loop through a mesh drawing each sub mesh."
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/whatis/graphics/WhatIs_Rasterizer.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/whatis/graphics/WhatIs_Rasterizer.html",
    "title": "What Is Rasterizer State? | hallowed",
    "summary": "A Rasterizer state determines how to render 3D data such as position, color, and texture onto a 2D surface. Rasterization takes a 3D scene containing polygons (which are represented by triangles and vertices) and renders the scene onto a 2D surface. This requires mapping or transforming the 3D vertices into 2D vertices using the world, view, and projection transforms to calculate the final vertex positions in the viewing frustum. To reduce the amount of geometry that needs to be rasterized, the rasterizer clips geometry so that only the parts of a polygon that are visible get processed. The resulting list of transformed vertices is then scan-converted to determine how to fill pixel positions between vertices. Scissor testing takes a list of user-supplied rectangles to further limit the areas you may want rasterized. Create a rasterizer state object using the RasterizerState class. Set the rasterizer state to the graphics device using the RasterizerState property. This is the default state for rasterization: Render triangles with clockwise winding order. Fill primitives so they are solid. Turn off scissor testing. Enable multisampling. Avoid using either depth bias or sloped scaled depth bias. These are the corresponding API states: Set CullMode to CullMode.CullCounterClockwiseFace. Set FillMode to FillMode.Solid. Set ScissorTestEnable to false. Set MultiSampleAntiAlias to true. Set DepthBias and SlopeScaleDepthBias to 0. Built-in state objects make it easy to create objects with the most common rasterizer state settings. CullNone, CullClockwise, and CullCounterClockwise are the most common settings. Note For an example of creating a state object, see Creating a State Object."
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/whatis/graphics/WhatIs_Render_Target.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/whatis/graphics/WhatIs_Render_Target.html",
    "title": "What Is a Render Target? | hallowed",
    "summary": "A render target is a memory buffer for rendering pixels. One common use for a render target is offscreen rendering. The graphics pipeline has a default render target called the back buffer, which is a portion of video memory that contains the next frame to be drawn. If your program does not create a render target, and you render to the screen, you are using the back buffer by default. Use the RenderTarget2D class to create additional render targets. A common scenario is to render to one or more offscreen render targets and assemble them in the back buffer to produce the final frame. Note The RenderTarget2D class derives from the Texture2D class because a render target contains a 2D texture. To draw a render target like you would draw a texture, use the render target object directly. That is, pass a RenderTarget2D object to any method that takes a Texture2D object. To read render target data back from the CPU, call the Texture2D.GetData Method. Note For more information about using a render target, see Creating a Render Target. To use a render target, create a RenderTarget2D object with the width, height, and other options you prefer. Call GraphicsDevice.SetRenderTarget to make your render target the current render target. Any subsequent Draw calls you make will draw into your render target rather than the back buffer. When you are finished rendering, call GraphicsDevice.SetRenderTarget and pass it null to set the device to render to the back buffer again. There are other considerations for choosing width and height when you create a render target. For example, you should choose the width and height of the back buffer to match the size of your game window (althoughmost mobiles scale the final result to match the user's screen). This prevents any resizing when the back buffer is copied to the screen. However, an offscreen render target does not need to have the same width and height as the back buffer. The final image can be rendered in several small render targets and then reassembled in a larger render target. A render target has a surface format, which describes how many bits are allocated to each pixel, and how they are divided between red, green, blue, and alpha. For example, SurfaceFormat.Bgr565 allocates 16 bits per pixel; 5 bits for blue and red and 6 bits for green. A render target works in cooperation with a depth-stencil buffer. When creating a render target, the depth format for the depth-stencil buffer is specified as one of the parameters to the render target constructor. Anytime you set a new render target to the device, the matching depth buffer is also set to the device."
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/whatis/graphics/WhatIs_Sampler.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/whatis/graphics/WhatIs_Sampler.html",
    "title": "What Is Sampler State? | hallowed",
    "summary": "A Sampler state determines how texture data is sampled using texture addressing modes, filtering, and level of detail. A texture contains an array of texels, or texture pixels, sampling is done each time a texture pixel, or texel, is read from a texture. The position of each texel is denoted by (u,v), where: u is the width v is the height These are mapped between 0 and 1 based on the texture width and height. The resulting texture coordinates are used to address a texel when sampling a texture. When texture coordinates are below 0 or above 1, the texture address mode defines how the texture coordinate addresses a texel location. For example, when using TextureAddressMode.Clamp, any coordinate outside the 0-1 range is clamped to a maximum value of 1, and minimum value of 0 before sampling. If the texture is too large or too small for the polygon, the texture is filtered to fit the space. A magnification filter enlarges a texture, a minification filter reduces the texture to fit into a smaller area. Texture magnification repeats the sample texel for one or more addresses which yields a blurrier image. Texture minification is more complicated because it requires combining more than one texel value into a single value. This can cause aliasing or jagged edges depending on the texture data. The most popular approach for minification is to use a mipmap. A mipmap is a multi-level texture. The size of each level is a power-of-two smaller than the previous level down to a 1x1 texture. When minification is used, a game chooses the mipmap level closest to the size that is needed at render time. Use the SamplerState class to create a sampler state object. Set the sampler state to the graphics device using the GraphicsDevice.SamplerStates Property property. This is the default state for sampling: Uses linear filtering. Wraps texture addresses on boundaries. Sets the maximum anisotropy value to 4. Does not use mip maps or LOD bias. These are the corresponding API states: Set Filter to TextureFilter.Linear. Set AddressU, AddressV, and AddressW to TextureAddressMode.Wrap. Set MaxAnisotropy to 4. Set MaxMipLevel and MipMapLevelOfDetailBias to 0. Built-in state objects make it easy to create objects with the most common sampler state settings. The most common settings are LinearClamp, LinearWrap, PointClamp, PointWrap, AnisotropicClamp, and AnisotropicWrap. For an example of creating a state object, see Creating a State Object."
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/whatis/graphics/WhatIs_Sprite.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/whatis/graphics/WhatIs_Sprite.html",
    "title": "What Is a Sprite? | hallowed",
    "summary": "Sprites are 2D bitmaps that are drawn directly to a render target without using the pipeline for transformations, lighting or effects. Sprites are commonly used to display information such as health bars, number of lives, or text such as scores. Some games, especially older games, are composed entirely of sprites. Overview Sprite Origin Sprite Depth Sampling Textures Sprite Scaling Sprite Transformation Matrices Sprite Fonts Sprite Batching Overview Sprites are positioned on the screen by coordinates. The width and height of the screen is the same as the back buffer. The x-axis represents the screen width and the y-axis represents the screen height. The y-axis is measured from the top of the screen and increases as you move down the screen, and the x-axis is measured from left to right. For example, when the graphics back buffer is 800×600, the top left corner is at (0,0) and the bottom-right pixel is at (799,599). To draw a sprite, create a SpriteBatch object, initialize it by calling Begin, and then call Draw for each sprite. The bitmap data for a sprite is taken from a Texture2D object. The texture may contain alpha channel information to make part of the texture transparent or semi-transparent. You can tint, rotate, or scale sprites by using Draw. This method also gives you the option of drawing only part of the texture on the screen. After you draw a sprite, call End before calling Present. Sprite Origin When you draw a sprite, the sprite origin is an important concept. The origin is a specific point on the sprite, which is by default the upper-left corner of the sprite, or (0,0). Draw draws the origin of the sprite at the screen location you specify. For example, if you draw a 50×50 pixel sprite at location (400,200) without specifying an origin, the upper left of the sprite will be on pixel (400,200). If you use the center of the 50×50 sprite as the origin (25,25), to draw the sprite in the same position you must add the origin coordinates to the position. In this case, the position is (425,225) and the origin is (25,25). When rotating a sprite, the method uses the origin as the center of the rotation. In these cases, it is common to use the center of the sprite as the origin when calculating where to draw the sprite on the screen. Note Meaning that by default, a sprite will rotate around the \"top-left\" hand corner of the image when you rotate it. See HowTo Rotate a Sprite for details on how to compensate for this and rotate by an images center. Sprite Depth Sprites also have a concept of depth which is a floating-point number between 0 and 1. Sprites drawn at a depth of 0 are drawn in front of sprites which have a depth of greater than 0; sprites drawn at a depth of 1 are covered by sprites drawn at a depth less than 1. Sampling Textures A sprite is based on a Texture2D object—in other words, a bitmap. Use Draw to draw the entire texture or a portion of the texture. To draw a portion of the texture, use the sourceRectangle parameter to specify which `texels_, or texture pixel, to draw. A 32×32 texture has 1024 texels, specified as x and y values similar to how screen coordinates are specified. Specifying a sourceRectangle of (0, 0, 16, 16) would select the upper-left quadrant of a 32×32 texture. Sprite Scaling Draw provides three options for scaling a sprite: using a uniform scaling parameter, a nonuniform scaling parameter, or a source and destination rectangle. The uniform scaling parameter is a floating-point number that multiplies the sprite size through both the x- and y-axes. This will shrink or expand the sprite along each axis equally, maintaining the original ratio between the sprite width and height. To scale the x- and y-axes independently, Draw accepts a Vector2 value as a scalar. This Vector2 specifies nonuniform scaling: x- and y-axes are scaled independently according to the X and Y fields of the Vector2. Draw also accepts a source and destination rectangle. The destination rectangle is specified in screen coordinates, while the source rectangle is specified in texels. Draw takes the pixels on the texture specified in sourceRectangle and scales them independently along the x- and y-axes until they fit the screen coordinates specified by destinationRectangle. Sprite Transformation Matrices You can also specify a transformation matrix that the batch can apply to each sprite before drawing. The transformation matrix can be any combination of translation, rotation, or scaling matrices multiplied together into a single matrix. This matrix is combined with the sprite position, rotation, scaling, and depth parameters supplied to Draw. Because the matrix also applies to depth, any z-coordinate transformation that makes the sprite depth greater than 1.0 or less than 0.0 will cause the sprite to disappear. See Rotating a Group of Sprites for an example of matrix rotation and Scaling Sprites Based On Screen Size for an example of matrix scaling. Sprite Fonts Use a SpriteBatch to draw text. The DrawString method will draw text on screen with position, color, rotation, origin, and scaling. DrawString also requires a special type of texture encapsulated by the SpriteFont class. A SpriteFont is created by the content pipeline when you add a Sprite Font file to your project. The sprite font file has information such as the name and point size of the font, and which Unicode characters to include in the SpriteFont texture. At run time, a SpriteFont is loaded with ContentManager.Load just like a Texture2D object. See Sprite Font XML Schema Reference for a list of Sprite Font tags. You can use the content pipeline to determine your character regions automatically. For more information, see How to: Extend the Font Description Processor to Support Additional Characters. The following redistributable fonts are installed by XNA Game Studio. For information about redistribution rights, see the text in the end user license agreement. Andyb.ttf JingJing.ttf Kooten.ttf Linds.ttf Miramo.ttf Miramob.ttf Moire-Bold.ttf Moire-ExtraBold.ttf Moire-Light.ttf Moire-Regular.ttf MotorwerkOblique.ttf NGO_____.ttf NGOB____.ttf OcraExt.ttf Peric.ttf Pericl.ttf Pesca.ttf Pescab.ttf QuartMS.ttf SegoeKeycaps.ttf Segoepr.ttf Segoeprb.ttf SegoeUIMono-Bold.ttf SegoeUIMono-Regular.ttf Wscsnbd.ttf Wscsnbdit.ttf Wscsnit.ttf Wscsnrg.ttf Sprite Batching In normal drawing, the SpriteBatch object does not change any render states or draw any sprites until you call End. This is known as Deferred mode. In Deferred mode, SpriteBatch saves the information from each Draw call until you call End. If you call Begin, specifying SpriteSortMode.Immediate, it triggers Immediate mode. In Immediate mode, the SpriteBatch immediately changes the graphics device render states to begin drawing sprites. Thereafter, each call to Draw immediately draws the sprite using the current device settings. In Immediate mode, once you call Begin on one SpriteBatch instance, do not call it on any other SpriteBatch instance until you call End for the first SpriteBatch. Deferred mode is slower than Immediate mode, but it allows multiple instances of SpriteBatch to accept Begin and Draw calls without interfering with each other."
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/whatis/graphics/WhatIs_StencilBuffer.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/whatis/graphics/WhatIs_StencilBuffer.html",
    "title": "What Is a Stencil Buffer? | hallowed",
    "summary": "A stencil buffer contains per-pixel integer data which is used to add more control over which pixels are rendered. A stencil buffer can also be used in combination with a depth buffer to do more complex rendering such as simple shadows or outlines. A stencil buffer operates similarly to a depth buffer. So similarly, that stencil data is stored in a depth buffer. While depth data determines which pixel is closest to the camera, stencil data can be used as a more general purpose per-pixel mask for saving or discarding pixels. To create the mask, use a stencil function to compare a reference stencil value -- a global value -- to the value in the stencil buffer each time a pixel is rendered. For example, to remove an object from a scene: Fill a stencil buffer with a cut out pattern (using zeros) for each pixel where the object is visible. This is done by setting the reference stencil value to 0, clearing the stencil buffer, and rendering the object. Then set the reference stencil value to 1, set the compare function to CompareFunction.LessEqual, and render again. The stencil data masks those pixels whose value is non zero but less than 1, resulting in drawing over (or removing) the object. A stencil buffer can be used in more sophisticated ways such as specifying StencilOperations that go beyond replace or discard and increment or decrement the stencil buffer during a stencil test. You can also combine this with a StencilMask to mask the portion of the stencil buffer that is updated. To use a stencil buffer, the DepthFormat of the depth buffer must reserve some bits for the stencil data; the DepthFormat.Depth24Stencil8 format uses 8 bits for a stencil buffer as an example. Combining stencil data with an 8 bit DepthStencilState.StencilMask Property provide up to eight different stencil buffers."
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/whatis/graphics/WhatIs_ViewFrustum.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/whatis/graphics/WhatIs_ViewFrustum.html",
    "title": "What Is a View Frustum? | hallowed",
    "summary": "A view frustum is a 3D volume that defines how models are projected from camera space to projection space. Objects must be positioned within the 3D volume to be visible. The MonoGame Framework uses a projection matrix to calculate a vertex position in the view frustum. The matrix reverses the y-coordinate (so it is top down) to reflect a screen origin at the top-left corner. After the matrix is applied, the homogenous vertices (that is, the vertices contain (x,y,z,w) coordinates) are converted to non-homogeneous coordinates so they can be rasterized. The most common type of projection is called a perspective projection, which makes objects near the camera appear bigger than objects in the distance. For a perspective projection, the view frustum can be visualized as a clipped pyramid whose top and bottom are defined by the near and far clipping planes as shown in the figure. A view frustum is defined by a field of view (fov), and by the distances of the front and back clipping planes, which are specified in z-coordinates. Set up a perspective fov using the CreatePerspectiveFieldOfView method. See Also What Is a Viewport?"
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/whatis/graphics/WhatIs_Viewport.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/whatis/graphics/WhatIs_Viewport.html",
    "title": "What Is a Viewport? | hallowed",
    "summary": "A viewport is a 2D rectangle that defines the size of the rendering surface onto which a 3D scene is projected. A viewport is represented by the Viewport class. The Width and Height properties of the rectangle are used by methods for a variety of calculations such as creating a projection matrix using CreatePerspectiveFieldOfView. Viewport dimensions default to the dimensions of the back buffer, but they can be a different size. For example, to create a split screen game, you might render multiple viewports to a single render target. The viewport dimensions do not correspond to the display dimensions, which are determined by the DisplayMode property, or to the game window, which is determined by the ClientBounds property. Use the Clear method to reset a render-target surface. Overloaded versions accept various parameters such as a set of rectangles that define more specific areas rather than the entire surface. Specify in the ClearOptions enumeration which buffer or render target to reset. You can also use the Clear method to clear stencil bits within a depth buffer. Set the options parameter to determine which render-target components are cleared. The color argument sets the color value of the render target after it has been cleared. The depth parameter clears the depth buffer to the specified depth: 0.0 is the closest distance, and 1.0 is the farthest. Finally, the stencil parameter resets the stencil bits to the specified value. Use integers ranging from 0 to 2n−1, where n is the stencil buffer bit depth. Desktop Area Versus Display Area The size of the desktop area in Windows is shown by the DisplayMode Width and Height properties. The display area is different from the game window, which can be obtained from the ClientBounds dimensions. On Windows, set the display mode width and height to match the back buffer width and height. This prevents the need to resize the back buffer when switching between windowed and full screen mode. On Xbox 360, you need to display the text and menu items within the inner 80 percent of the display area. This prevents text or menus from getting cut off at the edge of a television screen. This inner area is called the title safe area. The game window size is shown by the ClientBounds Width and Height properties. The game window size matches the display size when a game is running in full-screen mode. The game window size may be smaller for a game running in windowed mode. Use ClientBounds.X and ClientBounds.Y for the upper-left coordinates of the game window relative to the display area. On Xbox 360, the ClientBounds Width and Height properties are always equal to the DisplayModeWidth and Height, and ClientBounds.X and ClientBounds.Y are always (0, 0). Figure 1. DisplayMode and ClientBounds areas on Windows and Xbox 360. See Also What Is a Back Buffer?"
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/whatis/graphics/index.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/whatis/graphics/index.html",
    "title": "What are Graphics? | hallowed",
    "summary": "Graphical basics 101 The topics in this section describe the graphical conventions used by MonoGame in rendering and managing content on a screen. 2D Concepts What Is Sprite? Sprites are 2D bitmaps that are drawn directly to a render target without using the pipeline for transformations, lighting or effects. Sprites are commonly used to display information such as health bars, number of lives, or text such as scores. Some games, especially older games, are composed entirely of sprites. 3D concepts What Is 3D Rendering? The 3D graphics pipeline uses a graphics device to load resources and render a 3D scene using an effect. What Is a Configurable Effect? MonoGame ships with a number of built in effects. These effects have properties so you can use to change behaviour or switch features on or off. What Is a Depth Buffer? A depth buffer contains per-pixel floating-point data for the z depth of each pixel rendered. A depth buffer may also contain stencil data which can be used to do more complex rendering such as simple shadows or outlines. What Is Blend State? Blend state controls how color and alpha values are blended when combining rendered data with existing render target data. What Is Depth Stencil State? Depth stencil state controls how the depth buffer and the stencil buffer are used. What Is Rasterizer State? Rasterizer state determines how to render 3D data such as position, color, and texture onto a 2D surface. What Is Sampler State? Sampler state determines how texture data is sampled using texture addressing modes, filtering, and level of detail. What Is Color Blending? Color blending mixes two colors together to produce a third color. What Is a Stencil Buffer? A stencil buffer contains per-pixel integer data which is used to add more control over which pixels are rendered. A stencil buffer can also be used in combination with a depth buffer to do more complex rendering such as simple shadows or outlines. What Is a Model Bone? A model bone is a matrix that represents the position of a mesh as it relates to other meshes in a 3D model. Other Graphical concepts What Is a Graphics Profile? Provides conceptual information about the MonoGame Framework concept of graphics profiles, including explanations of the Reach and HiDef profiles. What Is a Back Buffer? A back buffer is a render target whose contents will be sent to the device when GraphicsDevice.Present is called. What Is a Render Target? A render target is a memory buffer for rendering pixels. One common use for a render target is offscreen rendering. What Is a View Frustum? A view frustum is a 3D volume that defines how models are projected from camera space to projection space. Objects must be positioned within the 3D volume to be visible. What Is a Viewport? A viewport is a 2D rectangle that defines the size of the rendering surface onto which a 3D scene is projected. What Is Antialiasing? Antialiasing is a technique for softening or blurring sharp edges so they appear less jagged when rendered."
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/whatis/index.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/whatis/index.html",
    "title": "What Is Articles for MonoGame | hallowed",
    "summary": "In This Section Ever wondered why a specific feature exists and what it is supposed to do? The following articles go into detail as to what each of the major components of the MonoGame Framework do and how best to make use of them. Where applicable, these articles also cross-reference with the \"How-To\" articles for the use of these features. Note These guides are not meant to be a replacement for \"full on\" tutorials, they are intended as short cuts to relevant information only. This section is broken down into 3 distinct categories: Detailed sections Game Operations References Detailed sections Due the complexity of the Content and Graphics pipelines, the information is broken up into smaller pieces for easier understanding: What Is the Content Pipeline? An overview of how the MonoGame Framework provides content management and loading for games. What Is the Graphics Pipeline? An overview of how the MonoGame Framework provides graphical support for games. Game Operations This section details some general aspects of the operation of a MonoGame Framework game. What Is Audio? An overview of how the MonoGame Framework provides audio playback through several core audio classes. What Is Input? An overview of how the MonoGame Framework provides input management for games. What Is the GameLoop? A viewport is a 2D rectangle that defines the size of the rendering surface onto which a 3D scene is projected. What are Vectors, Matrices, and Quaternions? Presents an overview of the math-related functionality provided by the MonoGame Framework. See Also References What Is MonoGame Class Library An overview of the MonoGame Class Library reference, containing all the API calls available to the MonoGame Framework."
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/whatis/input/index.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/whatis/input/index.html",
    "title": "Overview of User Input and Input Devices | hallowed",
    "summary": "Input is a general term referring to the process of receiving actions from the user. In MonoGame, the Microsoft.Xna.Framework.Input namespace provides support for most input devices. Methods related to input devices unavailable on the platform your game is running on are always available to your code. For example, you can access all GamePad methods on Mobile, but they will not return valid information (unless a GamePad is connected). Although using these methods will not cause exceptions or build errors in your code, they will silently fail when run. Physical keyboards may or may not be present on mobile devices; you should not rely on the presence of a physical keyboard. For text input, you should use a software input panel (SIP), which will work on all devices, including those with physical keyboards. If the mobile device does have access to a physical keyboard, the same methods used for keyboards on desktop can be used, given a few caveats. For multi-touch devices, you can use the raw touch data provided by the TouchPanel class, but you can also use MonoGame's support for predefined gestures if your input fits one of the supported gesture types. For information about working with raw multi-touch input, see Working with Touch Input. For information about gesture support, see Detecting Gestures on a Multi-touch Screen. The microphone on mobile can be used to capture audio that can be used in your game. For more information, see Recording Sounds with Microphones. See Also How To input articles"
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/whatis/monogame_class_library/index.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/whatis/monogame_class_library/index.html",
    "title": "MonoGame Framework Class Library | hallowed",
    "summary": "The MonoGame Framework class library is a library of classes, interfaces, and value types that are included in MonoGame Game Studio. This library provides access to MonoGame Framework functionality and is designed to be the foundation on which MonoGame Game Studio applications, components, and controls are built. Namespaces Microsoft.Xna.Framework Provides commonly needed game classes such as timers and game loops. Microsoft.Xna.Framework.Audio Contains low-level application programming interface (API) methods that can load and manipulate content files to play audio. Microsoft.Xna.Framework.Content Contains the run-time components of the Content Pipeline. Microsoft.Xna.Framework.Design Provides a unified way of converting types of values to other types. Microsoft.Xna.Framework.Graphics Contains low-level application programming interface (API) methods that take advantage of hardware acceleration capabilities to display 3D objects. Microsoft.Xna.Framework.Graphics.PackedVector Represents data types with components that are not multiples of 8 bits. Microsoft.Xna.Framework.Input Contains classes to receive input from keyboard, mouse, and GamePad devices. Microsoft.Xna.Framework.Input.Touch Contains classes that enable access to touch-based input on devices that support it. Microsoft.Xna.Framework.Media Contains classes to enumerate, play, and view songs, albums, playlists, and pictures. Microsoft.Xna.Framework.Utilities Contains classes that provide additional support for working with MonoGame. Microsoft.Xna.Framework.Utilities.Deflate Contains classes that provide additional support for compression with MonoGame."
  },
  "templates/docs.monogame.github.io/articles/getting_to_know/whatis/vector_matrix_quat/index.html": {
    "href": "templates/docs.monogame.github.io/articles/getting_to_know/whatis/vector_matrix_quat/index.html",
    "title": "What are Vectors, Matrices, and Quaternions? | hallowed",
    "summary": "The MonoGame Framework Math Libraries are in the Microsoft.Xna.Framework namespace alongside a number of additional types that deal with The MonoGame Framework Application model. Coordinate system Mathematical Constants and Scalar Manipulation Basic Geometric Types Precision and Performance Coordinate system The MonoGame Framework uses a right-handed coordinate system, with the positive z-axis pointing toward the observer when the positive x-axis is pointing to the right, and the positive y-axis is pointing up. Mathematical Constants and Scalar Manipulation The MonoGame Framework provides the MathHelper Members class for manipulating scalar values and retrieving some common mathematical constants. This includes methods such as the ToDegrees and ToRadians utility methods for converting between degrees and radians. Basic Geometric Types The MonoGame Framework Math library has multiple basic geometric types for manipulating objects in 2D or 3D space. Each geometric type has a number of mathematical operations that are supported for the type. Vectors The MonoGame Framework provides the Vector2, Vector3, and Vector4 classes for representing and manipulating vectors. A vector typically is used to represent a direction and magnitude. In The MonoGame Framework, however, it also could be used to store a coordinate or other data type with the same storage requirements. Each vector class has methods for performing standard vector operations such as: Dot product Cross product Normalization Transformation Linear, Cubic, Catmull-Rom, or Hermite spline interpolation. Matrices The MonoGame Framework provides the Matrix class for transformation of geometry. The Matrix class uses row major order to address matrices, which means that the row is specified before the column when describing an element of a two-dimensional matrix. The Matrix class provides methods for performing standard matrix operations such as calculating the determinate or inverse of a matrix. There also are helper methods for creating scale, rotation, and translation matrices. Quaternions The MonoGame Framework provides the Quaternion structure to calculate the efficient rotation of a vector by a specified angle. Curves The Curve class represents a Hermite curve for interpolating varying positions at different times without having to explicitly define each position. The curve is defined by a collection of CurveKey points representing each varying position at different times. This class can be used not only for spatial motion, but also to represent any response that changes over time. Bounding Volumes The MonoGame Framework provides the BoundingBox, BoundingFrustum, BoundingSphere, Plane, and Ray classes for representing simplified versions of geometry for the purpose of efficient collision and hit testing. These classes have methods for checking for intersection and containment with each other. Precision and Performance The MonoGame Framework Math libraries are single-precision. This means that the primitives and operations contained in this library use 32-bit floating-point numbers to achieve a balance between precision and efficiency when performing large numbers of calculations. A 32-bit floating-point number ranges from –3.402823e38 to +3.402823e38. The 32 bits store the sign, mantissa, and exponent of the number that yields seven digits of floating-point precision. [!NOTE] Some numbers—for example π, 1/3, or the square root of two—can be approximated only with seven digits of precision, so be aware of rounding errors when using a binary representation of a floating-point number. For more information about single-precision numbers, see the documentation for the Single data type."
  },
  "templates/docs.monogame.github.io/articles/help_and_support.html": {
    "href": "templates/docs.monogame.github.io/articles/help_and_support.html",
    "title": "Help and Support | hallowed",
    "summary": "There is a wealth of community-created content, blogs and tutorials available. You can also chat with other MonoGame users via Discord. If you want to find an answer to a more specific problem, you can ask it on our GitHub Discussions page. Bugs and feature requests If you find a bug or have a feature request, please open a new issue. Before opening an issue, please check for existing ones. Please note that the issue tracker is not for requesting help."
  },
  "templates/docs.monogame.github.io/articles/index.html": {
    "href": "templates/docs.monogame.github.io/articles/index.html",
    "title": "Documentation | hallowed",
    "summary": "Welcome to the MonoGame documentation hub! MonoGame is a simple and powerful .NET framework for creating games for desktop PCs, video game consoles, and mobile devices using the C# programming language. It has been successfully used to create games such as Streets of Rage 4, Carrion, Celeste, Stardew Valley, and many others. It is a re-implementation of the discontinued Microsoft's XNA Framework, and it provides the following features: Game framework 2D and 3D rendering Sound effect and music playback Keyboard, mouse, touch, and controller inputs Content building and optimization Math library optimized for games This documentation helps you to get started by providing overviews of key features and tools, and a complete API reference. Please use the links at the top and left to navigate the documentation sections. This documentation assumes that the reader has a basic knowledge of the C# programming language. What is MonoGame exactly? MonoGame is a \"bring your own tools\" kind of framework, which means that it provides the building blocks to build your own engine and tools, but it isn't quite an engine itself. If you are expecting a scene editor (like Unity or Unreal), MonoGame is not that. If you love coding and understanding how things work under the hood, MonoGame might be what you are looking for. And fear not, getting a game running with MonoGame only takes a few minutes. Let's get started! We Need Your Help! MonoGame is an open-source project maintained by its community. Great open source projects require high-quality documentation. This is a call for volunteers to continue to help us make the MonoGame documentation truly great. If you can create tutorials, feature guides, code snippets, reference docs, video walkthroughs, or make any improvement to the current documentation, we could use your help! Check out the README on GitHub or talk with us on Discord to learn how to help!"
  },
  "templates/docs.monogame.github.io/articles/migration/migrate_37.html": {
    "href": "templates/docs.monogame.github.io/articles/migration/migrate_37.html",
    "title": "Migrating from 3.7 | hallowed",
    "summary": "Previously MonoGame installed on your machine through an installer, but from 3.8 onwards everything is installed through NuGet packages and Visual Studio Extensions. Note MonoGame 3.8 project templates are not compatible with earlier versions of MonoGame. If you wish to work on or build older MonoGame projects, then you will still need to install MonoGame 3.7.1 or earlier to open them. WindowsDX and DesktopGL WindowsDX and DesktopGL templates now use SDK-style projects. To migrate old projects we recommend creating a new project with the 3.8+ templates and copying the csproj to your project folder. Make sure you back up your old project. For more information about SDK-style projects see the documentation. Other Platforms To migrate open up your project file in a text editor. The reference to the MonoGame assembly looks like this: </ItemGroup> <Reference Include=\"MonoGame.Framework\"> <HintPath>$(MonoGameInstallDirectory)\\MonoGame\\v3.0\\Assemblies\\{Platform}\\MonoGame.Framework.dll</HintPath> </Reference> </ItemGroup> The task to build your content is imported at the end of the project file like this: <Import Project=\"$(MSBuildExtensionsPath)\\MonoGame\\v3.0\\MonoGame.Content.Builder.targets\" /> You can remove these references and add a reference to the MonoGame NuGet packages instead. <ItemGroup> <PackageReference Include=\"MonoGame.Framework.{Platform}\" Version=\"3.8.1\" /> <PackageReference Include=\"MonoGame.Content.Builder.Task\" Version=\"3.8.1\" /> </ItemGroup> Tooling MonoGame tools (MGCB, 2MGFX, and the Pipeline Tool) are now distributed as .NET Tools automatically when using any of the MonoGame 3.8.1 templates. The templates also build your .mgcb files automatically thanks to the MonoGame.Content.Builder.Task NuGet package. The Pipeline Tool has been renamed MonoGame Content Builder Editor (MGCB Editor) and does not require an installation anymore (providing that you are using the MonoGame 3.8.1 templates). The Visual Studio 2022 extensions make .mgcb files within your solution clickable and will open the MGCB Editor on them."
  },
  "templates/docs.monogame.github.io/articles/migration/migrate_38.html": {
    "href": "templates/docs.monogame.github.io/articles/migration/migrate_38.html",
    "title": "Upgrading MonoGame from 3.8.x to latest | hallowed",
    "summary": "Upgrading existing projects from earlier 3.8 releases should be straightforward for most platforms. Note If you are migrating/upgrading from XNA or MonoGame 3.7 or earlier then check the dedicated guides for those actions before returning here. The critical difference from pre 3.8.2 builds, is that the MGCB Editor is no longer a global .NET tool and the MGCB editor is now included as part of the specific project through the use of the dotnet tooling configuration dotnet-tools.json file located in the .config folder in your solution/project. The major difference from 3.8.4 onwards is that we recommend using .NET 9 in your client project, but it is not mandatory, we are also simplifying the csproj configuration to reduce management for developers from 3.8.4.1. For iOS/Android however, DotNet 9 at a minimum is Mandatory, see details here. You can follow the environment setup tutorial to make sure that you are not missing any components. Note If you are using Visual Studio 2022, we recommend that you use the MonoGame extension which helps with accessing the MGCB editor without the need of CLI commands. The process of updating your project should be fairly quick and painless without having to change your code or your content project. Contents Updating DotNet Target Framework Update MonoGame references Add/Update dotnet-tools.json Configuration Remove RestoreDotNetTools section from csproj iOS/iPadOS, and Android Considerations Updating the DotNet Target Framework Modern MonoGame projects now use the DotNet framework (older projects used to rely on the NetCore/NetFramework libraries). As MonoGame has used DotNet project templates since 3.8.x, you only need to update the TargetFramework element of any csproj files referencing MonoGame libraries, namely: Replace any <TargetFramework> entries with the following: <TargetFramework>net9.0</TargetFramework> Note Using DotNet 9 is only a recommendation, you can use any version of DotNet (from 8.0 and above) so long as it supports the MonoGame DotNet 8 dependency. This includes the upcoming DotNet 10 LTS. Make sure to update any and all projects in your solution, especially you have a multi-project solution similar to those in the MonoGame.Samples Update MonoGame references Make sure you update the MonoGame references to the latest version, this can be achieved by either: Editing the csproj files that reference MonoGame to the latest version. Note The MonoGame templates set the Version number as Version=\"3.8.*\", this means that it will use the LATEST public version of MonoGame (not including preview releases) that is available. However, this does mean your tools configuration can become out of sync with your project and potentially cause issue. Use the Updating NuGet package dependencies documentation as part of the \"Preview Release installation instructions\", which states you should run the following commands (the example is for DesktopGL, use other platforms accordingly): dotnet add package MonoGame.Framework.DesktopGL -v 3.8.4.1 dotnet add package MonoGame.Content.Builder.Task -v 3.8.4.1 Note The MonoGame.Content.Builder.Task is only needed for client projects and not libraries. This will ensure your project is using the intended version of MonoGame. Important Always ensure your dotnet-tools.json version matches any updates to the version of MonoGame you are using, as detailed in the next section. Add/Update dotnet-tools.json Configuration MonoGame DotNet projects currently Require DotNet tools configuration to be able to locate and run the MGCB editor which is installed locally per project (preventing issues when working with multiple projects using different versions of MonoGame). Important The MGCB Editor is no longer a .NET global tool, and does not need to be installed or registered separately. When migrating from 3.8.0, it is recommended that you uninstall the global versions of the tools. You can accomplish that with these commands: dotnet tool uninstall dotnet-mgcb -g dotnet tool uninstall dotnet-2mgfx -g dotnet tool uninstall dotnet-mgcb-editor -g You can either copy the config folder with the configuration from a new project template (e.g. dotnet new mgdesktopgl -o <project name>), or alternatively you can do the following: Create a new folder in the root of your project named .config. Add a new file called dotnet-tools.json and replace its contents with the following: { \"version\": 1, \"isRoot\": true, \"tools\": { \"dotnet-mgcb\": { \"version\": \"3.8.4.1\", \"commands\": [ \"mgcb\" ] }, \"dotnet-mgcb-editor\": { \"version\": \"3.8.4.1\", \"commands\": [ \"mgcb-editor\" ] }, \"dotnet-mgcb-editor-linux\": { \"version\": \"3.8.4.1\", \"commands\": [ \"mgcb-editor-linux\" ] }, \"dotnet-mgcb-editor-windows\": { \"version\": \"3.8.4.1\", \"commands\": [ \"mgcb-editor-windows\" ] }, \"dotnet-mgcb-editor-mac\": { \"version\": \"3.8.4.1\", \"commands\": [ \"mgcb-editor-mac\" ] } } } Note Please note that you cannot use the 3.8.* wildcard in the dotnet-tools.json file (tool versions have to be fully qualified). We strongly recommend that the versions match the MonoGame version referenced in your .csproj (if you are using the * wildcard, make sure that they do not end up mismatching if the NuGet packages are updated without you noticing). The file is the same regardless of which platform / target you are intending to use. If you have a multi-project solution, you only need a SINGLE configuration at the root of the project for all client projects. Remove RestoreDotNetTools section from csproj From 3.8.4.1 and above, the RestoreDotNetTools section is no longer required in client project csproj files, as the processing is now handled within the MonoGame deliverables. Note Earlier versions of MonoGame, e.g. 3.8.0 do not have this configuration in the project template, if your csproj does not have a RestoreDotNetTools element, you can safely ignore this section. <Target Name=\"RestoreDotNetTools\" BeforeTargets=\"Restore\"> <Message Text=\"Restoring dotnet tools\" Importance=\"High\" /> <Exec Command=\"dotnet tool restore\" /> </Target> Tip The XML has changed over versions with various messages and layout, but the section to remove is always titled Name=\"RestoreDotNetTools\" Simply remove this section safely from any and all csproj files located in your solution that are dependent on MonoGame. iOS/iPadOS, and Android Considerations DotNet 9 is MANDATORY for iOS and Android due to platform requirements, as well as the following configurations: MonoGame 3.8.4.1 is REQUIRED to comply with the Google Policies on 16kb pages and other affordances. The Android targetSdkVersion in the AndroidManifest.xml MUST be a minimum \"35\" to comply with the latest Google policies. The templates set the minimum to 21 which is safe, only the TARGET SDK is critical. iOS MUST use a minimum SupportedOSPlatformVersion of 12.2 in both the csproj and in the info.plist configuration for the project."
  },
  "templates/docs.monogame.github.io/articles/migration/migrate_xna.html": {
    "href": "templates/docs.monogame.github.io/articles/migration/migrate_xna.html",
    "title": "Migrating from XNA | hallowed",
    "summary": "MonoGame is API compatible with XNA 4.0 even down to the namespaces. That means you do not have to change much of your game code to port from XNA to MonoGame. There are however some exceptions and some things to keep in mind. If your game targets XNA 3.1, you might want to use this archived migration cheatsheet to upgrade to 4.0: http://www.nelxon.com/blog/xna-3-1-to-xna-4-0-cheatsheet/ Missing/removed API The Storage namespace was removed due to portability issues (short discussion here). GamerServices was removed. This part of MonoGame was badly maintained due to low usage and difficulties in providing the GamerServices API for different platforms. The Net namespace was removed due to its cost of maintenance. Effects MonoGame does not use the legacy fxc compiler for effects that XNA used. Instead, MonoGame uses the DX11 compiler. The way MonoGame handles shaders imposes some restrictions and causes some caveats in what is and is not supported. This is all documented in the custom effects documentation page. Half pixel offset XNA uses the DirectX 9 graphics API. MonoGame uses the newer Direct X 11 API for DirectX platforms. DirectX 9 interprets UV coordinates differently from other graphics API's. This is typically referred to as the half-pixel offset. MonoGame supports replicating XNA's behavior (currently only on OpenGL platforms) by setting the PreferHalfPixelOffset flag in <xref:Microsoft.Xna.Framework.GraphicsDeviceManager> to true. This flag is set to false by default to encourage users to use the modern style of pixel addressing. DirectX platforms will ignore setting the PreferHalfPixelOffset flag and will always render with a half pixel offset compared to XNA. This is usually not noticeable. This value is passed to UseHalfPixelOffset in <xref:Microsoft.Xna.Framework.Graphics.GraphicsDevice>. If UseHalfPixelOffset is true, you have to add half-pixel offset to a Projection matrix. <xref:Microsoft.Xna.Framework.Graphics.SpriteBatch> rendering is not affected by the flag. Regardless of what value the flag has, SpriteBatch will render things exactly the same as in XNA. If you migrated your game from XNA and some things seem blurred out or very slightly offset, you may want to try to enable the PreferHalfPixelOffset flag."
  },
  "templates/docs.monogame.github.io/articles/migration/updating_versions.html": {
    "href": "templates/docs.monogame.github.io/articles/migration/updating_versions.html",
    "title": "Updating Versions | hallowed",
    "summary": "Update Existing Projects Update Target Framework Update NuGet References Visual Studio 2022 Manually Editing .csproj File (VSCode/Rider) Update MGCB Editor Updating Environment for New Projects Update dotnet Templates Visual Studio 2022 dotnet CLI (VSCode/Rider) When a new release of MonoGame is pushed, developers will need to manually update their development environment and/or existing project to make use of the new version. This guide is intended to walk you through the steps of performing these updates. Update Existing Projects Developers wishing to update their current project to use a new release version only need to update the target framework, NuGet package versions, and dotnet tools version. Doing this depends on if you are using Visual Studio 2022 or another development environment. Update Target Framework Developers will need to ensure the project is updated to target the .NET version used by MonoGame at minimum (currently net8.0). To do this, open your project's .csproj file and find the <TargetFramework> element and change the net-X.Y version to net-8.0, then save the file. Note Only change the .NET version number. some project types have platform specifiers such as net6.0-windows. The only thing that should change here is the version number. Update NuGet References The following sections cover updating your NuGet packages for existing projects based on your development environment. Visual Studio 2022 Open your existing project in Visual Studio 2022 and perform the following: Right-click on the project in the Solution Explorer panel and select *Manage NuGet Packages...\". In the NuGet Packages Manager window, click the Updates tab. Select the MonoGame Framework packages in the list on the left, then click the Update button for each one on the right. Manually Editing .csproj File (VSCode/Rider) Alternatively, regardless of the development environment, developers can manually edit the .csproj file for their project to update to the newest MonoGame release. To do this: Open your project's .csproj file Locate the <PacakgeReference> elements for any MonoGame referenced packages. Change the Version= attribute for each one to the current version of MonoGame (currently this is 3.8.2.1105) Save the .csproj file. Once these changes are made, open a command prompt or terminal at the root of the project directory and enter the following commands dotnet clean dotnet restore Update MGCB Editor Regardless of the development environment, users will need to update the dotnet tools manifest file manually to use the newest version of the MonoGame Content Builder. To do this: Open the .config/dotnet-tools.json manifest file located in the project root directory Update the version specified for each tool to the current version of MonoGame (currently this is 3.8.4). Save the changes Once these changes are made, open a command prompt or terminal at the root of the project directory and enter the following commands dotnet tool restore Updating Environment for New Projects The following sections will cover updating your development environment for new projects. Update dotnet Templates Developers will need to update the MonoGame C# Templates used to create new projects. Doing this depends on if you are using Visual Studio 2022 or through the dotnet cli. Note Updating the templates will not affect existing projects. if developers wish to update existing project, see the info in the Update Existing Projects section. Visual Studio 2022 templates Developers using Visual Studio 2022 should be using the MonoGame C# Project Templates extension. This provides not only the templates but also the functionality to open the MonoGame Content Builder Editor (MGCB Editor) within Visual Studio. You can update the extension by performing the following Open Visual Studio 2022 In the launch window, choose the Continue without code option at the bottom on the right. From the top menu choose, Extensions > Manage Extensions to open the Extension Manager panel. Click the Updates tab and choose MonoGame Framework C# project templates and update it to the latest version. If prompted to close Visual Studio to finish the update, do so now to continue installing the update. dotnet CLI (VSCode/Rider) templates Developers using the dotnet CLI with environments such as Visual Studio Code, JetBrains Rider, or other editors, can execute the following command in a command prompt/terminal to update the templates dotnet new install MonoGame.Templates.CSharp Tip If you receive a an error or warning stating there are naming conflicts in the templates, you may need to uninstall the templates first with the following command and then install them: dotnet new uninstall MonoGame.Templates.CSharp Alternatively, you can perform dotnet new update which will update all templates installed to their most current version available. However, this may affect other templates you have installed that you may not wish to update, it's an all or nothing command."
  },
  "templates/docs.monogame.github.io/articles/samples.html": {
    "href": "templates/docs.monogame.github.io/articles/samples.html",
    "title": "Samples & Demos | hallowed",
    "summary": "Official MonoGame Samples These are the official samples: 2D Samples AutoPong Sample 2D This project shows you how to make the classic game of pong, with basic soundfx, in 300 lines of code. The sample has no content and no content manager use, just code! Check out the AutoPong sample Platformer Sample 2D The Platformer Starter Kit is a near-complete, self-contained game solution that includes both game code and game assets. The game is a standard 2D platformer with levels, enemies, and collectable gems. \\nThis sample is also available as a full cross-platform project template `mg2dstartkit`. Check out the Platformer sample NeonShooter Sample 2D This project shows you how to make a Geometry Wars-inspired twin-stick shooter, with neon graphics, crazy particle effects, and awesome music. Check out the NeonShooter sample 3D Samples FuelCell Sample 3D FuelCell is designed around a central concept providing basic gameplay mechanisms that are easily extensible. The FUelCell sample also includes a complete developer diary documenting its construction. Click to view 3D FuelCell sample ShipGame Sample 3D Ship Game is a 3D spaceship combat game set inside a complex tunnel system featuring advanced lighting and textures, a full GPU particle system, and physics. Click to view 3D ShipGame sample Coming Soon More 3D sample projects coming soon. See what is coming Community delivered full sample projects GreedyKid The repository for \"Boo! Greedy Kid\" on all platforms (Windows, macOS, and Linux) and its level editor (Windows-only). Click to browse the GreedyKid Source Old School Adventure The repository for \"Old School Adventure\" which was originally published using XNA on Xbox (XBLIG) and Windows Phone. Click to browse the Old School Adventure Source Coming Soon More full sample projects coming soon. See what is coming Official MonoGame tutorial source Building 2D Games XNA Game Studio Archive The XNA Game Studio archive contains all of the original XNA sample content. This contains a vast array of samples demonstrating almost every feature of XNA, which is easily translatable to MonoGame. There are pre-converted samples available on the repository as well. MonoGame.Extended Samples MonoGame.Extended is an extension for MonoGame that makes it easier to make games. They have demos and games that can be tried out. CartBlanche's Samples This is a large library of MonoGame Samples covering a wide range of topics, including: 27 2D samples 8 3D samples Physics Networking (Not fully functional yet) Miscellaneous Shaders It also includes games such as: Card Game Starter Kit Flood Control Role Playing Game Starter Kit Pacman Tetris With more on the way."
  },
  "templates/docs.monogame.github.io/articles/tutorials/building_2d_games/01_what_is_monogame/index.html": {
    "href": "templates/docs.monogame.github.io/articles/tutorials/building_2d_games/01_what_is_monogame/index.html",
    "title": "Chapter 01: What is MonoGame | hallowed",
    "summary": "A Brief History In 2006, Microsoft released a game development framework named XNA Game Studio to facilitate game development for Windows PC and the Xbox 360 console. It revolutionized game development for indie creators by bringing a simplified approach to building games and offering a set of tools that lowered the entry barrier for aspiring game developers. Out of XNA Game Studio came critically acclaimed titles such as Bastion and Terraria. In 2008, XNA was expanded to support development for both the Zune and Windows Phone. Note Fun fact, provided by community member stromkos, The release of XNA 3.0 in 2008, which added the support for Windows Phone, is also the release that specified the default window resolution of 800x480 for new projects as this was the preferred resolution on Windows Phone. It is still the default resolution used in MonoGame projects today. As XNA became more popular, the need for cross-platform development started to grow. In 2009, José Antonio Leal de Farias introduced XNA Touch, an open-source project that aimed to make games with XNA playable on iOS devices. This marked the beginning of what would later become MonoGame. Dominique Louis came on board in 2009 and soon took over as full-time project lead, driving its initial development and expansion. The project attracted other developers, such as Tom Spilman, who were interested in expanding the scope of the project as well as its reach. The official first release of MonoGame occurred in 2011, as an open-source version of XNA. While it still had the same familiar API as XNA, the cross-platform support was expanded to include Windows, macOS, Linux, iOS, Android, Xbox, and PlayStation. Despite Microsoft discontinuing XNA in 2013, MonoGame continued to grow and develop. Maintenance of the project was given to Steve Williams and Tom Spilman in 2014. In order to direct its future development and undertaking, the MonoGame Foundation was formed on September 29th, 2023. Today, MonoGame is a mature cross-platform framework, that is built with the spirit of preserving XNA while adopting modern game development practices. Some popular titles created using MonoGame include Celeste, Stardew Valley, and Streets of Rage 4. Figure 1-1 Celeste. Figure 1-2: Stardew Valley Figure 1-3: Streets of Rage 4 Figure 1-4: Bastion Note For more details about MonoGame's history, check the About on the official MonoGame website. Features MonoGame, following in the footsteps of XNA, is a \"bring your own tools\" framework. It provides developers the basic blocks to design the game, engines, and/or tools. As a code-first approach to game development, MonoGame does not include any pre-built editors or interfaces; instead, it gives developers the freedom to create their own working environment. API At its core, MonoGame offers a set of libraries and APIs to handle common game development tasks. These include: Graphics Rendering: 2D and 3D rendering are supported through the graphics API offered by MonoGame. This API provides sprite batching for 2D graphics, a flexible 3D pipeline, and shaders for custom visuals and effects. Input Handling: Input from keyboard, mouse, gamepads, and touchscreens is supported, allowing for development of games for any platform and different styles of play. Audio: A comprehensive audio system that can be used to create sound effects as well as play music with included support for many audio formats. Content Pipeline: An out-of-the-box workflow for importing and processing game assets such as textures, models, and audio, and compiling them to a format that is optimal for the game's target platform. Math Library: A math library specifically optimized for game development, providing essential mathematical functions and operations. Cross Platform One of the main advantages of MonoGame is its cross-platform support. Games built with MonoGame are compatible with a variety of platforms, including: Desktop: Windows, macOS, and Linux. Mobile: iOS and Android. Consoles (with appropriate license): Xbox, PlayStation, and Nintendo Switch. By providing cross-platform support, developers can target multiple platforms from a single code base, significantly reducing development time and resources needed for porting. Programming Language Support MonoGame is designed and built in C#. It is the official programming language supported in documentation, samples, and community discussion. However, MonoGame is not exclusively tied to C#. As a .NET library, MonoGame can be used with any .NET-compatible language, including Visual Basic and F#. Caution While the alternative .NET languages can be used, community support may be limited outside the scope of C#. Regardless of which .NET language is used, developers should have a foundational understanding of the language and programming concepts such as: Object-oriented programming. Data types and structures. Control flow and loops. Error handling and debugging. See Also About MonoGame | MonoGame Test Your Knowledge Name one of the advantages of using the MonoGame framework to develop games. :::question-answer Any of the following are advantages of using the MonoGame framework. It provides cross-platform support, allowing developers to target multiple platforms from a single code base. It offers a set of libraries and APIs common for game development tasks, such as graphics rendering, input handling, audio, and content management. It is a \"bring your own tools\" framework, giving developers flexibility in their working environment. ::: What programming languages can be used when creating a game with MonoGame? :::question-answer The primary language used is C#, which is the same language that the MonoGame framework is developed in. However, any .NET language can be used, such as F# or Visual Basic. :::"
  },
  "templates/docs.monogame.github.io/articles/tutorials/building_2d_games/02_getting_started/index.html": {
    "href": "templates/docs.monogame.github.io/articles/tutorials/building_2d_games/02_getting_started/index.html",
    "title": "Chapter 02: Getting Started | hallowed",
    "summary": "Unlike game engines (such as Unity, Unreal or Godot), MonoGame is a framework. This means it does not come as a standalone program that you download and install, and does not include a graphical user interface used to create games. Instead, MonoGame integrates into the standard .NET development workflow, offering a code-first approach to game development. This approach offers several advantages: Flexibility: Developers are not locked into using a specific editor or interface, allowing them to use their preferred development tools. Integration: As a .NET library itself, MonoGame can easily integrate with other .NET libraries and tools. Cross-platform Development: Since C# is cross-platform, and MonoGame is cross-platform, developers can develop MonoGame projects on Windows, macOS, or Linux, with only slight differences in the setup process for each operating system. Version Control Friendly: The code-first approach makes it easier to use version control systems like Git for your game projects. While the environment setup process is similar to the standard setup process for C# development, there are some MonoGame specific steps. These can vary slightly depending on your operating system and the Integrated Development Environment (IDE). Installing the .NET SDK The first thing we need to do is install the .NET Software Development Kit (SDK). To install it, follow the instructions based on your operating system below: Important As of MonoGame 3.8.2, the minimum supported version of the .NET SDK is .NET 8. Windows macOS Linux Open a web browser and navigate to https://dotnet.microsoft.com/en-us/download. Choose the version of the .NET SDK to install and click the Download .NET SDK x64 button to start the download. Note The minimum supported version is .NET 8 Once the download finishes, run the installer. Open a web browser and navigate to https://dotnet.microsoft.com/en-us/download. Choose the version of the .NET SDK to install and click the Download .NET SDK x64 (Intel) button start the download of the .NET SDK Installer. Note The minimum supported version is .NET 8 Once the download finishes, run the installer. Note For the time being, MonoGame requires that you install the Intel version even if you are using an Apple Silicon (M1/M2) Mac. For Apple Silicon Macs, it also requires that Rosetta be enabled. Open a new Terminal window Enter the following command to install the .NET SDK sudo apt-get update && sudo apt-get install -y dotnet-sdk-8.0 Note The minimum supported version is .NET 8 Install Additional Workloads (Optional) After installing the .NET SDK, if you intend to target mobile devices such as Android or iOS, you will also need to install the corresponding mobile workloads. To do this, open a Command Prompt or Terminal window and enter the following commands. dotnet workload install ios dotnet workload install android Install MonoGame Project Templates MonoGame provides project templates that can be installed to create new projects that are pre-configured to target the current version of MonoGame as a base to begin creating games. To install the MonoGame templates, open a Command Prompt or Terminal window and enter the following command dotnet new install MonoGame.Templates.CSharp Installing Visual Studio Code Visual Studio Code (VSCode) is a free, lightweight editor. Depending on the programming language you are using, it is just a matter of installing the appropriate extension to support that particular language. VSCode is also cross-platform, meaning you can use it for development on Windows, macOS, and Linux. To ensure that all readers can follow this tutorial regardless of the operating system used, we will be using VSCode as our IDE. To install VSCode, follow the instructions for your operating system below: Windows macOS Linux Open a browser and navigate to https://code.visualstudio.com/. Click the Download for Windows button to start the download of the installer. Once the download finishes, run the installer. Open a web browser and navigate to https://code.visualstudio.com/. Click the Download for macOS button to start the download of the .zip archive. Once the download finishes, double click the .zip archive to extract the Visual Studio Code.app application package Drag-and-drop the Visual Studio Code.app application package into your Application folder to make it available in the macOS LaunchPad. Open a web browser and navigate to https://code.visualstudio.com/. Click the .deb download button to download the package for Debian based Linux distributions, or the .rpm download button for Red Hat based Linux distributions. Once the download finishes, open the package downloaded to install. Install the C# Dev Kit Extension For C# development using VSCode, it is recommended to use the official C# Dev Kit extension provided by Microsoft. Installing this extension will add additional features to VSCode such as a project system and Solution Explorer for C# projects. It also provides code editing features such as syntax highlighting, code completion, code navigation, refactoring, NuGet package management, and debugging tools. Note The Solution Explorer panel is a hierarchical view provided by the C# Dev Kit extension that displays your solution structure similar to Visual Studio's Solution Explorer. When you open a workspace in Visual Studio Code containing a .NET solution file (.sln), the Solution Explorer panel automatically appears and loads your solution. From this panel, you can perform common operations like: Adding new files. Managing project references. Viewing dependencies. Executing build commands. For more information about the Solution Explorer panel in Visual Studio Code offered through the C# Dev Kit extension, you can view the official documentation in the Project Management documentation. To install the C# Dev Kit extension, perform the following: Launch the Visual Studio Code application. Open the Extensions Panel by clicking the icon in the Activity Bar on the left or choosing View > Extensions from the top menu. Enter C# in the Search Box Click install for the C# Dev Kit extension. Figure 2-1: The C# Dev Kit Extension listed in Visual Studio Code Note When you search C# in the Extension Panel you may notice there is the C# Dev Kit extension and a base standard C# extension. When installing the C# Dev Kit extension, the base extension will also be installed as a requirement. Installing the \"MonoGame for VSCode\" Extension Throughout this tutorial, we will be using the MonoGame Content Builder (MGCB) Editor to add content to the game. MonoGame offers an official extension for Visual Studio 2022 that allows you to double-click the Content.mgcb file to automatically open it in the MGCB Editor. While there is no official tool for VSCode, there is a an extension developed by community member r88 to provide similar functionality and is regularly used by the MonoGame developers themselves. We will be using that extension throughout this tutorial. To install it, with VSCode open: Open the Extensions Panel by clicking the icon in the Activity Bar on the left or choosing View > Extensions from the top menu. Enter MonoGame for VSCode in the Search Box Click install on the MonoGame for VSCode extension by r88. (Optional) Install the \".NET MAUI\" extension to help with mobile development This extension is provided by Microsoft and is built on top of the C# and C# Dev Kit extensions. They will be installed as dependencies if they were not already installed. While primarily designed for MAUI development, it provides essential mobile debugging capabilities that MonoGame mobile projects can utilize. The .NET MAUI extension adds features for building mobile apps, including: F5 debugging support - Debug your MonoGame mobile apps on emulators, simulators, and physical devices Easy target switching - Change debug/deploy targets between different mobile platforms Enhanced C# Dev Kit integration - Leverages Solution Explorer, Test Explorer, and advanced language features Figure 2-2: The .NET MAUI Extension listed in Visual Studio Code Note This extension is recommended if you wish to do iOS or Android development. It is required for debugging support when working on mobile games. Setup WINE for Effect Compilation (macOS and Linux Only) Effect (shader) compilation requires access to DirectX. This means it will not work natively on macOS and Linux systems, but it can be used through WINE. MonoGame provides a setup script that can be executed to setup the WINE environment. Below you can find the steps based on your operating system. To do this, follow the instructions for your operating system below: Windows macOS Linux Note Setting up WINE for effect compilation is not required for Windows Open a new Terminal window and execute the following commands: brew install p7zip brew install --cask wine-stable xattr -dr com.apple.quarantine \"/Applications/Wine Stable.app\" wget -qO- https://monogame.net/downloads/net8_mgfxc_wine_setup.sh | bash Note After performing these steps, a new folder called .winemonogame will be created in your home folder. If you ever wish to undo the setup performed by this script, you can simply delete this folder. Open a new Terminal window and execute the following commands: sudo apt-get update && sudo apt-get install -y curl p7zip-full wine64 wget -qO- https://monogame.net/downloads/net8_mgfxc_wine_setup.sh | bash Note After performing these steps, a new folder called .winemonogame will be created in your home folder. If you ever wish to undo the setup performed by this script, you can simply delete this folder. Creating Your First MonoGame Application With your development environment setup, it is time to create your first MonoGame application. Launch the VSCode application Open the Command Palette by clicking View > Command Palette or by using the keyboard shortcut CTRL+SHIFT+P (CMD+SHIFT+P on Mac). Type .NET New Project in the Command Palette and choose the .NET New Project command Next, you will be presented with a list of the available .NET project templates. Enter MonoGame into the prompt to filter the project templates to only show the MonoGame ones, then choose the MonoGame Cross-Platform Desktop Application project template. Note If the MonoGame templates are not showing up, then you skipped the step to install the templates, exit the project creation and click Terminal -> New Terminal in VSCode and run the following command: dotnet new install MonoGame.Templates.CSharp After choosing the template, a dialog window will appear asking you to choose a location to save the project, this is a folder where your projects will be created by default. Next, you will be prompted to enter a name for the project. Enter the name DungeonSlime, which will create your project in a new folder with the same name. If this is your first time creating your project, you will be asked to choose a solution format, simply select the default .sln option and click Next to continue. (This does not occur with subsequent projects) Finally, select the Create Project prompt. After selecting Create Project, a new C# project will be generated based on the chosen MonoGame template and opened automatically in VSCode. Figure 2-3: A new MonoGame project after being created in Visual Studio Code Now that we have the project created, press the F5 key on your keyboard, or choose Run > Start Debugging from the top menu. If prompted for a configuration, choose C#. The project will compile and run, displaying a screen similar to the following: Figure 2-4: The default MonoGame cornflower blue game window Be amazed, the default MonoGame Cornflower Blue game window. You have just created your very first MonoGame application. While there is not much happening here visually, there is a lot going on behind the scenes that the MonoGame framework is handling for you. When you ran the application, the following occurred: The application started The game window was created and graphics were initialized A loop is entered which performs the following over and over, until the game is told to exit: The game is updated The game is rendered to the window You can exit the game at any time by pressing the Esc key on your keyboard. Note Above, I mentioned that a loop is entered. This is commonly referred to as the game loop, which we will discuss in more detail in the next chapter. The reason the application enters this loop is because game applications work differently than traditional desktop applications, such as your web browser. Desktop applications are event based, meaning once loaded, they do not do much at all while waiting for input from the user. They respond to user interactions and redraw the window only when necessary. In games, things are always happening, such as objects moving around like the player or particle effects. To handle this, games implement a loop structure that runs continuously, first calling a method to update the game logic, and then a draw method to render the current frame, until it is told to exit. Conclusion In this chapter, you accomplished the following: You setup your operating system to develop .NET applications by installing the .NET SDK You installed the MonoGame project templates. You installed VSCode and the necessary extension to develop C# applications with VSCode You created and ran your first MonoGame project. Now that your development environment is setup and ready to go, you can dive in and start building your first game. In the next chapter, we will cover the contents of the Game1.cs file that was included in the MonoGame project you just created. Test Your Knowledge What are two advantages of MonoGame being a framework rather than an engine? :::question-answer Any two of the following: Flexibility: Developers can use their preferred development tools Integration: MonoGame easily integrates with other .NET libraries Cross-platform Development: Projects can be developed on Windows, macOS, or Linux Version Control Friendly: The code-first approach works well with systems like Git ::: What is the primary reason that game applications implement a game loop structure instead of using an event-based approach like traditional desktop applications? :::question-answer Game applications implement a game loop structure because games need to continuously update and render, event when there is no user input. In games, objects might be moving, animations playing, and physics calculating regardless of user interaction, requiring constant updating and rendering until the game is told to exit. ::: What is the color of the game window when you run a MonoGame project for the first time? :::question-answer Cornflower Blue :::"
  },
  "templates/docs.monogame.github.io/articles/tutorials/building_2d_games/03_the_game1_file/index.html": {
    "href": "templates/docs.monogame.github.io/articles/tutorials/building_2d_games/03_the_game1_file/index.html",
    "title": "Chapter 03: The Game1 File | hallowed",
    "summary": "After you created a new MonoGame project using the MonoGame Cross-Platform Desktop Application template in Chapter 02, you will notice the generated files and project structure that serve as a starting point for your game application. While MonoGame offers different templates based on target platform, all projects will contain the Game1.cs file. Exploring the Game1 Class At the core of a MonoGame project is the Game class. This class handles the initialization of graphics services, initialization of the game, loading content, updating, and rendering the game. When you create a new MonoGame project, this Game class is implemented as the Game1 class that you can customize as needed for your specific game. Tip While the default template names the class Game1, you are free to rename it to something more appropriate for your project. However, for consistency, the documentation will continue to refer to it as Game1. Locate the Game1.cs file that was generated when you created the MonoGame project and open it. The default content will be: using Microsoft.Xna.Framework; using Microsoft.Xna.Framework.Graphics; using Microsoft.Xna.Framework.Input; namespace DungeonSlime; public class Game1 : Game { private GraphicsDeviceManager _graphics; private SpriteBatch _spriteBatch; public Game1() { _graphics = new GraphicsDeviceManager(this); Content.RootDirectory = \"Content\"; IsMouseVisible = true; } protected override void Initialize() { base.Initialize(); } protected override void LoadContent() { _spriteBatch = new SpriteBatch(GraphicsDevice); } protected override void Update(GameTime gameTime) { if (GamePad.GetState(PlayerIndex.One).Buttons.Back == ButtonState.Pressed || Keyboard.GetState().IsKeyDown(Keys.Escape)) Exit(); base.Update(gameTime); } protected override void Draw(GameTime gameTime) { GraphicsDevice.Clear(Color.CornflowerBlue); base.Draw(gameTime); } } This class provides the following structure: Graphics and Rendering: The class declares two core graphics components; the GraphicsDeviceManager for interacting with the Graphics Processing Unit (GPU) and the SpriteBatch for 2D rendering. Initialization: The constructor and Initialize method handle the game's setup sequence. Content Loading: The LoadContent method manages game asset loading during startup. Game Loop: The game loop consists of the Update method for game logic and the Draw method for rendering, running continuously until the game is told to exit. Figure 3-1 below shows the lifecycle of a MonoGame game including the Update and Draw methods that make up the game loop. Figure 3-1: Lifecycle of a MonoGame game Graphics and Rendering The graphics pipeline in MonoGame starts with two components: the GraphicsDeviceManager and SpriteBatch. private GraphicsDeviceManager _graphics; private SpriteBatch _spriteBatch; The GraphicsDeviceManager initializes and manages the connection to the graphics hardware. It handles tasks such as setting the screen resolution, toggling between fullscreen and windowed mode, and managing the GraphicsDevice, which is the interface between your game and the Graphics Processing Unit (GPU) the game is running on. The SpriteBatch optimizes 2D rendering by batching similar draw calls together, improving draw performance when rendering multiple sprites. Initialization MonoGame's initialization process for your game follows a specific sequence. The constructor runs first, which handles basic setup like creating the GraphicsDeviceManager, setting the content directory, and the visibility of the mouse. public Game1() { _graphics = new GraphicsDeviceManager(this); Content.RootDirectory = \"Content\"; IsMouseVisible = true; } After that, the Initialize method executes, providing a dedicated place for additional configuration and initializations. protected override void Initialize() { base.Initialize(); } This separation allows you to perform setup tasks in a logical order; core systems in the constructor and game-specific initializations in the Initialize method. The call to base.Initialize() should never be removed, as this is where the graphics device is initialized for the target platform. Tip You may be wondering why there is an Initialize method instead of performing all initializations in the constructor. The Initialize method is a virtual method that is overridden, and it is advised to not call overridable methods from within a constructor, as this can lead to unexpected states in the object constructor when called. Additionally, when the constructor is called, the base constructor will instantiate properties and services based on the target platform that may be needed first before performing initializations for the game itself. Content Loading The LoadContent method serves as the place for asset management. Here you can load textures, sound effects, music, and other game assets. We will cover loading assets in the coming chapters as we discuss each asset type that can be loaded. In a new project, the only task it performs is initializing a new instance of the SpriteBatch. protected override void LoadContent() { _spriteBatch = new SpriteBatch(GraphicsDevice); } This method is only called once during the startup of the game, but when it is called can be a little confusing at first. In the Initialize method shown above, when the base.Initialize call is executed, the final task it performs is calling the LoadContent method. This means any initializations you need to perform that have a dependency on assets being loaded should be done after the base.Initialize call and not before it. The Game Loop MonoGame implements a game loop by calling Update and Draw over and over until the game is told to exit. Recall at the end of Chapter 02 when you ran the project for the first time, I mentioned that there is a lot going on behind the scenes? This game loop is what I was referring to. MonoGame is executing the Update method and then the Draw method 60 times per second. protected override void Update(GameTime gameTime) { if (GamePad.GetState(PlayerIndex.One).Buttons.Back == ButtonState.Pressed || Keyboard.GetState().IsKeyDown(Keys.Escape)) Exit(); base.Update(gameTime); } protected override void Draw(GameTime gameTime) { GraphicsDevice.Clear(Color.CornflowerBlue); base.Draw(gameTime); } The Update method at the moment is not doing much, only checking for input from a controller or keyboard to determine if the game should exit. However, the Draw method is doing more than what it appears to at first glance. The first line is executing the Clear method of the GraphicsDevice property using the color CornflowerBlue. Recall that the GraphicsDevice object is your direct interface between the game and what is rendered to the screen. Every time the Draw method is called, this line of code is erasing the contents of the game window and refilling it with the color specified. Without clearing the contents of the screen first, every draw call would draw the new frame render on top of the previous render, and you'd end up with something like the old solitaire win screen. Figure 3-2: Windows XP Solitaire Win Screen While this can make for a neat effect, it is not something you want all the time. So, the screen is cleared and refilled with a solid color. Note You can test this yourself by modifying the code to use a different color, such as Color.MonoGameOrange. (yes, there is a MonoGame Orange color). protected override void Draw(GameTime gameTime) { GraphicsDevice.Clear(Color.MonoGameOrange); base.Draw(gameTime); } After making this change and running the game, the screen is cleared to the MonoGame Orange color. Figure 3-3: The game window clearing the screen using the MonoGame Orange color Each time the game loop completes and the game is drawn to the screen, we call this a frame. So, if MonoGame is running the game loop at 60 frames per second, that means it is performing an update and a render of a frame in 16ms. Notice that both the Update and the Draw methods both receive a parameter of the type GameTime. The GameTime parameter provides a snapshot of the timing values for the game, including the amount of time that it took for the previous frame to execute. This is commonly referred to as the delta time. Delta time allows you to track time accurately for things such as animations and events based on game time and not the speed of the processor (CPU) on the machine running the game. While in ideal circumstances, the delta time will always be 16ms, there are any number of things that could cause a temporary slow down or hiccup in a frame, and using the delta time ensures that time-based events are always correct. Conclusion In this chapter, you accomplished the following: You read through the default code provided in the Game1.cs file created by a MonoGame template. You learned about the lifecycle of a MonoGame game project. You learned what a game loop is and how it is implemented in MonoGame. In the next chapter, you will start working with sprites and learn how to load and render them. Test Your Knowledge Can the Game1 class be renamed or is it required to be called Game1 :::question-answer It is not a requirement that it be called Game1. This is just the default name given to it by the templates when creating a new MonoGame game project. However, you cannot change the name of the BASE class Game, as this is a MonoGame construct. ::: What is the SpriteBatch used for? :::question-answer The SpriteBatch provides an optimized method of rendering 2D graphics, like sprites, onto the screen. ::: When is the LoadContent method executed and why is it important to know this? :::question-answer LoadContent is executed during the base.Initialize() method call within the Initialize method. It is important to know this because anything being initialized that is dependent on content loaded should be done after the base.Initialize() call and not before. ::: How does MonoGame provide a delta time value? :::question-answer Through the GameTime parameter that is given to both the Update and the Draw methods. :::"
  },
  "templates/docs.monogame.github.io/articles/tutorials/building_2d_games/04_creating_a_class_library/index.html": {
    "href": "templates/docs.monogame.github.io/articles/tutorials/building_2d_games/04_creating_a_class_library/index.html",
    "title": "04: Creating a Class Library | hallowed",
    "summary": "One of the goals of this tutorial is to create reusable modules that you can use to jump start your next game project after this. Rather than starting from scratch each time, we will build a collection of game components you can take with you from project to project. In this chapter you will: Learn about class libraries and their benefits for game development. Create a MonoGame class library project using templates. Add library references to your game project. Structure your library for reusability. Set up the foundation for creating shared game components. What Is a Class Library Think of a class library like a toolbox for your game development. Just as a mechanic keeps their most-used tools in a toolbox they bring to every job, a class library stores code components you will want to use in multiple game projects. Instead of recreating these tools for each new game (or copying and pasting code), you organize them in one place where they are easy to find, use, and improve over time. The following diagrams show how this works: Figure 4-1: This diagram displays the block for Game 1 on the left and Game 2 on the right. In this example, when not using a class library, code for input, physics and audio systems is duplicated in both game projects. If a bug is fixed in one system, the effort has to be replicated in the same system in the other game projects. Figure 4-2: This diagram displays a block for a class library containing common modules at the top, which are then shared between the two game projects below. If a bug is found in a module, fixing the bug will fix it across all game projects that use the class library. Note A class library is a project type that compiles into a Dynamic Link Library (DLL) instead of an executable. It contains reusable code that can be referenced by other projects, making it perfect for sharing common functionality across multiple games. Why Create a Class Library? Creating a class library offers several important advantages, especially as your games grow in complexity: Reusability: Instead of rewriting the same code for each new game project, you build it once in your library and reuse it everywhere. This is like creating a multi-tool that works across all your projects. Organization: Your game code stays focused on the unique aspects of each game, while common functionality lives in the library. This keeps your project folder neat and makes code easier to find. Maintainability: When you improve or fix a bug in your library code, all games using that library benefit automatically. This means you only fix a bug once, rather than in several places. Testing: You can test your library code independently from any specific game. This helps ensure your core systems are solid before you build a game on top of them. As your library grows, you will accumulate a personal collection of well-tested modules that make starting new projects much faster. The modules we will create in this library will handle common game tasks like input, audio, sprites, and animations. Adding the Class Library MonoGame offers the MonoGame Game Library project template to add a new class library project that is configured with the correct MonoGame framework references. Using this template saves time and ensures compatibility with MonoGame projects. To use the template to add the class library, perform the following based on which development environment you are using: Visual Studio Code Visual Studio 2022 dotnet CLI To add the class library using the MonoGame Game Library project template in Visual Studio Code, perform the following: In the Solution Explorer panel, right-click the DungeonSlime solution. Choose New Project from the context menu. Enter \"MonoGame Game Library\" and select it as the template to use. Name the project \"MonoGameLibrary\". When prompted for a location, use the default option, which will put the new project in a folder next to your game project. Select \"Create Project\". To add the class library using the MonoGame Game Library project template in Visual Studio 2022, perform the following: Right-click the DungeonSlime solution in the Solution Explorer panel. Choose Add > New Project from the context menu. Enter \"MonoGame Game Library\" in the search box, select that template, then click Next. Name the project \"MonoGameLibrary\". The default location will place the new project in a folder next to your game project; you do not need to adjust this setting. Click \"Create\". To add the class library using the MonoGame Game Library project template with the dotnet CLI, perform the following: Open a new Command Prompt or Terminal window in the same folder as the DungeonSlime.sln solution file. Enter the command dotnet new mglib -n MonoGameLibrary to create the project, placing it in a folder next to your game project. Enter the command dotnet sln DungeonSlime.sln add ./MonoGameLibrary/MonoGameLibrary.csproj to add the newly created class library project to the DungeonSlime.sln solution file. Adding a Reference To The Class Library Now that the game library project has been created, a reference to it needs to be added in our game project. Without adding a reference, our game project will be unaware of anything we add to the class library. To do this, perform the following based on which development environment you are using: Visual Studio Code Visual Studio 2022 dotnet CLI To add the game library project as a reference to the game project in Visual Studio Code: In the Solution Explorer panel, right-click the DungeonSlime project. Choose \"Add Project Reference\" from the context menu. Choose MonoGameLibrary from the available options. Tip The Solution Explorer panel in VSCode is provided by the C# Dev Kit extension that was installed in Chapter 02. If you do not see this panel, you can open it by Opening the Command Palette (View > Command Palette). Enter \"Explorer: Focus on Solution Explorer View\" and select the command. To add the game library project as a reference to the game project in Visual Studio 2022: In the Solution Explorer panel, right-click the DungeonSlime project. Select Add > Project Reference from the context menu. Check the box for the MonoGameLibrary project. Click Ok. To add the game library project as a reference to the game project with the dotnet CLI: Open a new Command Prompt or Terminal window in the same folder as the DungeonSlime.csproj C# project file. Enter the command dotnet add ./DungeonSlime.csproj reference ../MonoGameLibrary/MonoGameLibrary.csproj. This will add the MonoGameLibrary reference to the DungeonSlime game project. Clean Up When using the MonoGame Game Library project template, the generated project contains file similar to a standard MonoGame game project, including a dotnet-tools.json manifest file, a Content.mgcb file, and a Game1.cs file. For the purposes of this tutorial, we will not need these. To clean these up, locate the following in the MonoGameLibrary project folder and delete them: The .config/ folder. The Content/ folder The Game1.cs file. Tip These files are needed in more advanced scenarios, such as creating a central code base for game logic that is referenced by other projects, each targeting different platforms such as desktop, mobile, and console. Creating a project structure of this type is out of scope for this tutorial. If you would like more information on this, Simon Jackson has written the article Going cross-platform with MonoGame which covers this in more detail. Also the 2D StartKit and 2D Blank StartKit templates provide you with a richer startup project targeting all platforms, using a common Class Library to reuse code across them all. Although we recommend completing this tutorial first before tackling that beast. Creating Our First Library Module We will create a class for our library called Core. This class will extend the MonoGame Game class and provide a starting point for game development with a few common built-in functionalities. Creating this will also allow us to confirm that our class library reference setup is correct. Create a new file called Core.cs in the MonoGameLibrary project and add the following code: using System; using Microsoft.Xna.Framework; using Microsoft.Xna.Framework.Content; using Microsoft.Xna.Framework.Graphics; namespace MonoGameLibrary; public class Core : Game { internal static Core s_instance; /// <summary> /// Gets a reference to the Core instance. /// </summary> public static Core Instance => s_instance; /// <summary> /// Gets the graphics device manager to control the presentation of graphics. /// </summary> public static GraphicsDeviceManager Graphics { get; private set; } /// <summary> /// Gets the graphics device used to create graphical resources and perform primitive rendering. /// </summary> public static new GraphicsDevice GraphicsDevice { get; private set; } /// <summary> /// Gets the sprite batch used for all 2D rendering. /// </summary> public static SpriteBatch SpriteBatch { get; private set; } /// <summary> /// Gets the content manager used to load global assets. /// </summary> public static new ContentManager Content { get; private set; } /// <summary> /// Creates a new Core instance. /// </summary> /// <param name=\"title\">The title to display in the title bar of the game window.</param> /// <param name=\"width\">The initial width, in pixels, of the game window.</param> /// <param name=\"height\">The initial height, in pixels, of the game window.</param> /// <param name=\"fullScreen\">Indicates if the game should start in fullscreen mode.</param> public Core(string title, int width, int height, bool fullScreen) { // Ensure that multiple cores are not created. if (s_instance != null) { throw new InvalidOperationException($\"Only a single Core instance can be created\"); } // Store reference to engine for global member access. s_instance = this; // Create a new graphics device manager. Graphics = new GraphicsDeviceManager(this); // Set the graphics defaults. Graphics.PreferredBackBufferWidth = width; Graphics.PreferredBackBufferHeight = height; Graphics.IsFullScreen = fullScreen; // Apply the graphic presentation changes. Graphics.ApplyChanges(); // Set the window title. Window.Title = title; // Set the core's content manager to a reference of the base Game's // content manager. Content = base.Content; // Set the root directory for content. Content.RootDirectory = \"Content\"; // Mouse is visible by default. IsMouseVisible = true; } protected override void Initialize() { base.Initialize(); // Set the core's graphics device to a reference of the base Game's // graphics device. GraphicsDevice = base.GraphicsDevice; // Create the sprite batch instance. SpriteBatch = new SpriteBatch(GraphicsDevice); } } The Core class provides the following features: It extends the MonoGame Game class, so it inherits all of the base functionality. It implements a singleton pattern through the Instance property, ensuring that only one core exists. It provides static access to the graphics device manager, the graphics device, the sprite batch, and the content manager. It simplifies the game window setup with a constructor that handles common initializations. Note The new keyword in the property declaration public static new GraphicsDevice GraphicsDevice and public static new ContentManager Content is used to intentionally hide (or \"shadow\") the inherited GraphicsDevice and Content properties from the base Game class. This creates new properties with the same name but different accessibility (static vs. instance) in the derived class. When you access Core.GraphicsDevice or Core.Content you will be using these static properties, while base.GraphicsDevice or base.Content within instance methods of the Core class will access the original property. This pattern allows us to provide convenient static access to the graphics device and content manager throughout our game without having to reference the Core instance every time. This approach provides a consistent foundation for all our games, handling common setup tasks and providing convenient access to core functionality. Note As this tutorial progresses, we will be coming back to this Core class to add more to it. Updating Our Game to Use the Core Class Now that we have our Core class, we can modify our game project to use it. Doing this will also help ensure that the project references were setup correctly. Open the Game1.cs file and make the following changes: using Microsoft.Xna.Framework; using Microsoft.Xna.Framework.Graphics; using Microsoft.Xna.Framework.Input; using MonoGameLibrary; namespace DungeonSlime; public class Game1 : Core { public Game1() : base(\"Dungeon Slime\", 1280, 720, false) { } protected override void Initialize() { // TODO: Add your initialization logic here base.Initialize(); } protected override void LoadContent() { // TODO: use this.Content to load your game content here base.LoadContent(); } protected override void Update(GameTime gameTime) { if (GamePad.GetState(PlayerIndex.One).Buttons.Back == ButtonState.Pressed || Keyboard.GetState().IsKeyDown(Keys.Escape)) Exit(); // TODO: Add your update logic here base.Update(gameTime); } protected override void Draw(GameTime gameTime) { GraphicsDevice.Clear(Color.CornflowerBlue); // TODO: Add your drawing code here base.Draw(gameTime); } } The key changes made here are: Added using MonoGameLibrary; directive to reference our library. Removed the GraphicsDeviceManager and SpriteBatch fields; these are now supplied through the Core class. Changed Game1 class to inherit from Core instead of Game. Updated the constructor to call the Core base constructor with our game configuration. Running the game now will show the same window as before, only now it is at a 1280x720 resolution as per the configuration and it is using the Core class from our library. This may not seem like a big change visually, but it demonstrates how our library can simplify and standardize game initializations. Note If you get any additional prompts when starting the project, simply accept the defaults. Adding the Game Library gives the compiler more projects to choose from when starting the project, however, we can only \"run\" the Game Project, libraries are not executables. Figure 4-3: The game window at 1280x720 with the title Dungeon Slime Important If you receive an error stating the following: The type or namespace name 'Core' could not be found (are you missing a using directive or an assembly reference?) This means either you forgot to add the using MonoGameLibrary; using directive to the top of the Game1.cs class file, or you did not add the project reference correctly. Ensure that the project reference was added correctly by revisiting the Add a Reference to the Class Library section above and that you added the using directive. Conclusion In this chapter, you accomplished the following: Learned about class libraries and their advantages for game development: Code reusability across projects Better organization and separation of concerns Improved maintainability Easier testing Created a MonoGame class library project Added the library as a reference to your game project Created your first reusable component, added a reference to it, and used it in the game project. In the next chapter, we will learn about the Content Pipeline and how to load game assets. Test Your Knowledge What are the main benefits of using a class library for game development? :::question-answer The main benefits are: Reusability: Code can be easily shared between different game projects Organization: Separates reusable code from game-specific code Maintainability: Changes to shared code benefit all games using the library Testing: Library code can be tested independently of specific games ::: Why should you use the MonoGame Game Library template instead of a standard class library template? :::question-answer The MonoGame Game Library template automatically configures the correct MonoGame framework references and ensures compatibility with MonoGame projects, saving time and preventing potential setup issues. ::: What happens if you do not add a reference to your class library in your game project? :::question-answer Without adding a reference, your game project will be unaware of any code in the class library. You will not be able to use any of the classes or components from the library in your game. :::"
  },
  "templates/docs.monogame.github.io/articles/tutorials/building_2d_games/05_content_pipeline/index.html": {
    "href": "templates/docs.monogame.github.io/articles/tutorials/building_2d_games/05_content_pipeline/index.html",
    "title": "Chapter 05: Content Pipeline | hallowed",
    "summary": "Every game has assets: images to represent the visual graphics to players, audio to provide sound effects and background music, fonts to render text with, and much more. These assets start out as raw files (e.g. .png image files or .mp3 audio files), which you will need to load into the game to use. Loading Assets Loading assets can be done during runtime directly from file, or it can be loaded through the Content Pipeline. Both of these methods are two sides of the same coin, and there are trade offs to each approach. For instance, to load an image file directly at runtime, you would need to: Add the image file to your project. Configure the project to copy the image file on build to the build output folder. Load the image file as a texture at runtime using the Texture2D.FromFile method. Important One major drawback of loading an image file as a texture directly at runtime is that the data is in a compressed format, such as .png or .jpg. These compression formats are not understood by a Graphics Processing Unit (GPU). In order to be used by your game, this data will need to be decompressed into raw bytes, a format that the GPU understands. This operation can potentially leave a larger memory footprint for your assets. You will also need to handle how different compression formats work on the platform you are targeting, such as desktops, mobile and consoles. On the other side of the coin, MonoGame offers the Content Pipeline; a workflow for managing assets. The workflow is made up of a set of tools and utilities that are automatically added by default when you create a new MonoGame project using the MonoGame project templates. To use this workflow, you need to: Add the asset file to your content project (Content.mgcb file) using the MonoGame Content Builder Editor (MGCB Editor). Perform a project build. This will cause the MonoGame.Content.Builder.Tasks NuGet reference to compile the assets defined in the content project, optimized for the target platform, and automatically copy them to the game project build folder. Load the compiled asset at runtime using the ContentManager. For the same amount of steps, you also get the benefit of the assets being pre-processed and compiled to an optimized format for the target platform. For instance, image files can be compiled using DXT compression, which is a format that is understood by GPUs without needing to be decompressed first, reducing the memory footprint. Note For more information on the benefits of compiling assets and what optimizations it can offer, see the Content Pipeline documentation. For this tutorial series, we are going to focus on using the content pipeline workflow to load assets. Doing this will allow you, as the developer, to get accustomed to using the content pipeline tools, and also give the benefits of having assets pre-compiled to optimized formats. The MGCB Editor As mentioned previously, the content pipeline workflow in MonoGame is made up of a set of tools that come with every new MonoGame project. At the center of this workflow is the MGCB Editor; a graphical tool for managing your game's content. Opening the MGCB Editor can be done in different ways depending on which IDE and development environment you have. Choose the one you are using below to open the MGCB Editor so we can explore its interface: Visual Studio Code Visual Studio 2022 dotnet CLI To open the Content.mgcb content project file in the MGCB Editor from Visual Studio Code, you can use the MonoGame for VSCode extension. You should already have installed this extension in Chapter 02. With this extension installed, anytime you have a code file open, you will see the MonoGame logo in the top-right of the code window like below: Figure 5-1: MonoGame for VSCode extension icon Clicking the MonoGame logo here will open the Content.mgcb content project file from the current project in the MGCB Editor. To open the Content.mgcb content project file in the MGCB Editor from Visual Studio 2022, you can use the MonoGame Framework C# project templates extension. Despite the name, this extension does more than just install the MonoGame project templates. With this extension installed, simply double-click the Content.mgcb content project file in the Solution Explorer panel to open it in the MGCB Editor. To open the Content.mgcb content project file in the MGCB Editor using the dotnet CLI commands, perform the following: Open a new Command Prompt or Terminal window in the same folder as the DungeonSlime.csproj project file (your main game project). Enter the following dotnet CLI command dotnet mgcb-editor ./Content/Content.mgcb Tip If for any reason the MGCB editor fails to load or you are hit with MGCB errors when you build your project, it is likely the MGCB references from the dotnet-tools.json configuration located in your projects .config folder have not been loaded/initialized. To correct this, simply run the following from a terminal/command prompt in your projects directory (there the .config folder is located) dotnet tool restore This should restore the tool with the version that is configured. If at any time you update your dotnet-tools.json configuration, e.g. when upgrading to a newer version of MonoGame, you will need to run this command again Figure 5-2: MonoGame Content Builder Editor (MGCB Editor) Window In Figure 5-2 above, you can see the user interface for the MGCB Editor: Toolbar: Contains icon buttons for common actions such as creating new items, opening files, saving changes, and building content. Project Panel: Located on the left side of the MGCB Editor, it displays a hierarchical tree view of all content items added to the content project. The root node Content represents the root of the content project. Properties Panel: Located in the lower left corner of the MGCB Editor, it lists the properties of the currently selected item in the project panel. The available properties are based on the selected element type. Build Output Panel: The large area to the right side outputs build messages, warnings, and errors when content is processed. Creating Folders to Organize Content Organizing your game assets into folders helps keep your content project manageable as it grows. For now, we will add a new folder that will hold the image assets we will add to the game throughout this tutorial series. In the MGCB Editor: In the Project Panel, select the root Content node. Right-click it and choose Add > New Folder... from the context menu. Type images for the folder name and click the Ok button. Figure 5-3: New folder pop-up You have now created a folder that will help organize the game's image assets. As we continue through this tutorial series, we will be adding additional folders for organization of content such as audio, fonts, and effects. Note If you try to add a new folder that already exists in the file system but is not showing in the MGCB editor, you will get an error. Either remove the folder or use Add Existing Folder instead. Adding Your First Asset Now that we have a folder structure, we can add our first image asset to the project. For this example, we will use the MonoGame logo. Perform the following: First, download the MonoGame logo by right-clicking the following image and saving it as logo.png somewhere on your computer: Figure 5-4: MonoGame Horizontal Logo In the MGCB Editor, select the images folder you created earlier. Right-click it and choose Add > Existing Item... from the context menu. Navigate to the location of the logo.png file you just downloaded and select it. Click the Open button When prompted in the add existing file popup, choose Copy the file to the directory. Figure 5-5: Add existing file pop-up Save the changes to the content project by selecting File > Save from the top menu or pressing CTRL+S. Figure 5-6: The logo image added to the content project in the MGCB Editor Important After changes have been made in the MGCB Editor, ensure that you save the changes. They are not automatically saved, though you will be warned if you close the editor and have not saved changes. You can tell that changes have not been saved by looking at the title bar of the MGCB editor window. If it has an '*' at the end of the window title, this means changes have not been saved. Understanding the Content Pipeline Workflow Now that we have added our first asset, we can take a moment to understand what happens to this asset in the Content Pipeline workflow: You create source files for your game assets such as images, audio, fonts, effects, and 3D models. Using the MGCB Editor, add these assets your content project (the Content.mgcb file). When you perform a build of your project, the MonoGame.Content.Builder.Task NuGet reference will: Compile the assets defined in the content project using the MonoGame Content Builder (MGCB) tool into .xnb files. Copy the compiled .xnb files from the content project's build folder to your game project's build folder. At runtime, you load the compiled assets using the ContentManager. The following diagram demonstrates this workflow: Figure 5-7: MonoGame Content Pipeline Workflow diagram showing the process flow from source files (Images, Audio, Fonts, Effects, Models) through the MGCB Editor to generate the Content.mgcb file, which is then processed by MonoGame.Content.Builder.Tasks to create compiled .xnb assets (Xnb formats for each type), which are finally loaded by the ContentManager at runtime The Content Pipeline offers significant advantages: Assets are pre-processed and optimized for your target platform. Image files can be compiled using formats like DXT compression, which GPU's understand natively. Asset loading is simplified and consistent across platforms. The ContentManager Class To load assets in your game code, MonoGame provides the ContentManager class. The Game already has a Content property which is a ready-to-use instance of the ContentManager ContentManager Methods The key methods for asset loading are: Method Returns Description Load<T>(string) T Loads the asset of type T that has been processed by the content pipeline. Unload void Unloads all assets that have been loaded by that content manager instance. Tip When an asset is loaded for the first time, the ContentManager internally caches it. Loading the same asset again will return the cached version, avoiding extra disk reads. Understanding Content Paths When loading content, you need to specify the path to the asset, minus the extension. This path is relative to the ContentManager's RootDirectory property, which is set to \"Content\" by default in the Game1 constructor. For example, with our newly added logo in the \"images\" folder,the path would be \"images/logo\" (without the file extension). The reason for this relates to the build process. When you build your project, the MonoGame.Content.Builder.Tasks NuGet reference compiles your assets and copies them to the game's output folder. This creates a folder structure in your output directory similar to: DungeonSlime/ └── bin/ └── Debug/ └── net8.0/ ├── DungeonSlime.exe └── Content/ └── images/ └── logo.xnb Note Notice that the compiled asset has an .xnb extension, but when loading the asset in code, you refer to it without any extension. Loading and Displaying Your First Asset Now that we have the MonoGame logo added as an asset in the content project, we can modify the game to display the logo. In the DungeonSlime project, open the Game1.cs file and perform the following: Add a field to store the logo texture by inserting this line after the class declaration: // The MonoGame logo texture private Texture2D _logo; In the LoadContent method, add this line to load the logo texture: _logo = Content.Load<Texture2D>(\"images/logo\"); Finally, in the Draw method, add these lines before the base.Draw(gameTime); call: // Begin the sprite batch to prepare for rendering. SpriteBatch.Begin(); // Draw the logo texture SpriteBatch.Draw(_logo, Vector2.Zero, Color.White); // Always end the sprite batch when finished. SpriteBatch.End(); Note We will go into more details about the SpriteBatch in the next chapter. The complete updated Game1.cs file should now look like this: using Microsoft.Xna.Framework; using Microsoft.Xna.Framework.Graphics; using Microsoft.Xna.Framework.Input; using MonoGameLibrary; namespace DungeonSlime; public class Game1 : Core { // The MonoGame logo texture private Texture2D _logo; public Game1() : base(\"Dungeon Slime\", 1280, 720, false) { } protected override void Initialize() { // TODO: Add your initialization logic here base.Initialize(); } protected override void LoadContent() { _logo = Content.Load<Texture2D>(\"images/logo\"); } protected override void Update(GameTime gameTime) { if (GamePad.GetState(PlayerIndex.One).Buttons.Back == ButtonState.Pressed || Keyboard.GetState().IsKeyDown(Keys.Escape)) Exit(); // TODO: Add your update logic here base.Update(gameTime); } protected override void Draw(GameTime gameTime) { GraphicsDevice.Clear(Color.CornflowerBlue); // Begin the sprite batch to prepare for rendering. SpriteBatch.Begin(); // Draw the logo texture SpriteBatch.Draw(_logo, Vector2.Zero, Color.White); // Always end the sprite batch when finished. SpriteBatch.End(); base.Draw(gameTime); } } Running the game now will show the MonoGame logo displayed in the upper-left corner of the game window. Figure 5-8: The MonoGame logo drawn to the game window Adding Built-In Asset Types The MGCB Editor can also create certain built-in asset types. In this section we will explore these types and this functionality. If not already open, open the MGCB Editor and perform the following: Select the Content node. Right-click it and choose Add > New Item... from the context menu. In the dialog that appears, you will see the available built-in types. Figure 5-9: New file pop-up The available built-in types include: Effect (.fx): A shader file that creates custom visual effects by controlling how graphics are rendered on the GPU. SpriteFont Description (.spritefont): A configuration file that defines how text will be displayed in your game, including character set and font properties. Sprite Effect (.fx): A shader specifically designed for use with 2D sprites to create special visual effects. Xml Content (.xml): A structured data file for storing game information like levels, dialogues, or configuration settings. LocalizedSpriteFont Description (.spritefont): A configuration file for creating fonts with support for multiple languages. Note Each built-in asset type comes with a template that includes the minimum required structure and settings. For now, click the Cancel button on the new file dialog. We will explore these built-in types further in later chapters when we need them. Conclusion In this chapter, you accomplished the following: You learned about the advantages of loading assets using the Content Pipeline. You opened the MGCB Editor and explored its interface. You created a folder structure to organize your game assets. You added an image file asset to the content project. You understood the Content Pipeline workflow and how MonoGame automates the process. You loaded and displayed your first asset using the ContentManager. In the next chapter, we will explore working with textures in more detail and learn about different rendering options. Test Your Knowledge What are the two main ways of loading a texture, and what are the pros and cons of each approach? :::question-answer The two main ways to load a texture in MonoGame are: Directly from file using Texture2D.FromFile. This method requires manually setting up file copying, offers no pre-processing benefits, and can have a higher memory footprint. Using the content pipeline with Content.Load<Texture2D>. Using the content pipeline optimizes textures into formats for the target platform(s), automatically handles compiling and copying assets during build, and reduces memory footprint, but requires additional setup using the MGCB Editor. ::: During the MonoGame content pipeline workflow, assets are compiled and then copied to the project output folder. What is responsible for performing this task? :::question-answer The MonoGame.Content.Builder.Tasks NuGet reference. :::"
  },
  "templates/docs.monogame.github.io/articles/tutorials/building_2d_games/06_working_with_textures/index.html": {
    "href": "templates/docs.monogame.github.io/articles/tutorials/building_2d_games/06_working_with_textures/index.html",
    "title": "Chapter 06: Working with Textures | hallowed",
    "summary": "Textures are images that are used in your game to represent the visual graphics to the player, commonly referred to as Sprites. In Chapter 05, you learned how to use the Content Pipeline to load the MonoGame logo.png texture and render it to the screen. In this chapter, you will: Learn how to render a texture with the SpriteBatch. Explore how to manipulate the way the texture is rendered using the parameters of the SpriteBatch.Draw method. Drawing a Texture When rendering in MonoGame, render states, properties of the GraphicsDevice that affect how rendering is performed, need to be set. When rendering 2D sprites, the SpriteBatch class simplifies rendering by managing these render states for you. Important Although the SpriteBatch makes it easier to manage the render states for the GraphicsDevice, it can also change states that you may have set manually, such as when you are performing 3D rendering. Keep this in mind when mixing 2D and 3D rendering. Three methods are used when rendering with the SpriteBatch: SpriteBatch.Begin prepares the Graphics Device for rendering, including the render states. SpriteBatch.Draw tells the SpriteBatch what to render. This is usually called multiple times before SpriteBatch.End and batches the draw calls for efficiency. SpriteBatch.End submits the draw calls that were batched to the graphics device to be rendered. Note The order of method calls when rendering using the SpriteBatch is important. SpriteBatch.Begin must be called before any SpriteBatch.Draw calls are made. When finished, SpriteBatch.End must be called before another SpriteBatch.Begin can be called. If these methods are called out of order, an exception will be thrown. As mentioned in Chapter 03, all rendering should be done inside the Draw method. The Draw method's responsibility is to render the game state that was calculated in Update; it should not contain any game logic or complex calculations. At the end of Chapter 05, you added the following code to the Draw method inside the Game1.cs file: protected override void Draw(GameTime gameTime) { // Clear the back buffer. GraphicsDevice.Clear(Color.CornflowerBlue); // Begin the sprite batch to prepare for rendering. SpriteBatch.Begin(); // Draw the texture. SpriteBatch.Draw(_logo, Vector2.Zero, Color.White); // Always end the sprite batch when finished. SpriteBatch.End(); base.Draw(gameTime); } These lines initialize the SpriteBatch, draw the logo at Vector2.Zero (0, 0), and submit the batch. When you ran the game, the logo appeared in the upper-left corner of the window: Figure 6-1: The MonoGame logo drawn to the game window The SpriteBatch.Draw method we just used can be given the following parameters: Parameter Type Description texture Texture2D The Texture2D to draw. position Vector2 The X and Y coordinates at which the texture will be rendered, with the texture's origin being the upper-left corner of the image. color Color The color mask (tint) to apply to the image drawn. Specifying Color.White will render the texture with no tint. Tip Try adjusting the position and color parameters and see how they affect the image being drawn. MonoGame uses a coordinate system where (0, 0) is at the screen's upper-left corner. X values increase moving right, and Y values increase moving down. Understanding this, we will try to center the logo on the game window. To center content on the screen, we need to find the window's center point. We can access this using the Window.ClientBounds property from the Game class, which represents the rectangular bounds of the game window. Window.ClientBounds exposes both Width and Height properties for the window's dimensions in pixels. By dividing these dimensions in half, we can calculate the window's center coordinates. We can update our Draw method to use this: protected override void Draw(GameTime gameTime) { // Clear the back buffer. GraphicsDevice.Clear(Color.CornflowerBlue); // Begin the sprite batch to prepare for rendering. SpriteBatch.Begin(); // Draw the logo texture. SpriteBatch.Draw( _logo, // texture new Vector2( // position Window.ClientBounds.Width, Window.ClientBounds.Height) * 0.5f, Color.White // color ); // Always end the sprite batch when finished. SpriteBatch.End(); base.Draw(gameTime); } Tip In the example above, we multiply the Vector2 created by 0.5f to halve the values instead of dividing it by 2.0f. If you are not used to seeing this, it might seem strange at first, but it is actually an optimization technique. CPUs are able to perform multiplication operations much faster than division operations and reading * 0.5f is easily understood to be the same thing as / 2.0f. We have now set the position to half the window's dimensions, which should center the logo. Run the game to see the result. Figure 6-2: Attempting to draw the MonoGame logo centered on the game window The logo is not centered as we expected it to be. Even though we set the position parameter to the center of the game window, the texture starts drawing from its origin, which is the upper-left corner in this example. So when we set the position to the screen's center, we are actually placing the logo's upper-left corner at that point, not the center of the texture. One way to solve this is to subtract half the width and height of the texture from the center position of the game window, as shown below: protected override void Draw(GameTime gameTime) { // Clear the back buffer. GraphicsDevice.Clear(Color.CornflowerBlue); // Begin the sprite batch to prepare for rendering. SpriteBatch.Begin(); // Draw the logo texture. SpriteBatch.Draw( _logo, // texture new Vector2( // position (Window.ClientBounds.Width * 0.5f) - (_logo.Width * 0.5f), (Window.ClientBounds.Height * 0.5f) - (_logo.Height * 0.5f)), Color.White // color ); // Always end the sprite batch when finished. SpriteBatch.End(); base.Draw(gameTime); } This offsets the position so that it correctly centers the image inside the game window. Figure 6-3: The MonoGame logo drawn centered on the game window While this works, there is a better approach. There is a different overload of the SpriteBatch.Draw method that provides additional parameters for complete control over the draw operation, which we will use in the upcoming sections. Update your code to: protected override void Draw(GameTime gameTime) { // Clear the back buffer. GraphicsDevice.Clear(Color.CornflowerBlue); // Begin the sprite batch to prepare for rendering. SpriteBatch.Begin(); // Draw the texture. SpriteBatch.Draw( _logo, // texture new Vector2( // position (Window.ClientBounds.Width * 0.5f) - (_logo.Width * 0.5f), (Window.ClientBounds.Height * 0.5f) - (_logo.Height * 0.5f)), null, // sourceRectangle Color.White, // color 0.0f, // rotation Vector2.Zero, // origin 1.0f, // scale SpriteEffects.None, // effects 0.0f // layerDepth ); // Always end the sprite batch when finished. SpriteBatch.End(); base.Draw(gameTime); } This overload produces the same centered result but exposes all parameters that control rendering for a draw operation. Unlike engines that abstract much of these details away, MonoGame provides explicit control for a flexible custom rendering pipeline. Here is what each parameter does: Parameter Type Description texture Texture2D The Texture2D to draw. position Vector2 The X and Y position at which the texture will be rendered, relative to the origin parameter. sourceRectangle Rectangle An optional region within the texture to be rendered in order to draw only a portion of the texture. Specifying null will render the entire texture. color Color The color mask (tint) to apply to the image drawn. Specifying Color.White will render the texture with no tint. rotation float The amount of rotation, in radians, to apply to the texture when rendering. Specifying 0.0f will render the image with no rotation. origin Vector2 The X and Y coordinates defining the position of the texture origin. This affects the texture's offset during rendering and serves as a reference point around which the texture is rotated and scaled. scale float The scale factor applied to the image across the x- and y-axes. Specifying 1.0f will render the image at its original size with no scaling. effects SpriteEffects A SpriteEffects enum value that specifies if the texture should be rendered flipped across the horizontal axis, the vertical axis, or both axes. layerDepth float Specifies the depth at which the texture is rendered. Textures with a higher layer depth value are drawn on top of those with a lower layer depth value. Note: This value will only apply when using SpriteSortMode.FrontToBack or SpriteSortMode.BackToFront. We will cover this in a moment. Rotation First we will explore the rotation parameter. This value is the amount of rotation to apply to the sprite when rendering it. We will rotate the texture 90° to make it vertical. Since rotation is measured in radians, not degrees, we can use the built-in math library in MonoGame to make the conversion for us by calling MathHelper.ToRadians. Update the code to: protected override void Draw(GameTime gameTime) { // Clear the back buffer. GraphicsDevice.Clear(Color.CornflowerBlue); // Begin the sprite batch to prepare for rendering. SpriteBatch.Begin(); // Draw the texture. SpriteBatch.Draw( _logo, // texture new Vector2( // position (Window.ClientBounds.Width * 0.5f) - (_logo.Width * 0.5f), (Window.ClientBounds.Height * 0.5f) - (_logo.Height * 0.5f)), null, // sourceRectangle Color.White, // color MathHelper.ToRadians(90), // rotation Vector2.Zero, // origin 1.0f, // scale SpriteEffects.None, // effects 0.0f // layerDepth ); // Always end the sprite batch when finished. SpriteBatch.End(); base.Draw(gameTime); } Running the code now shows the rotated image, but not in the expected position: Figure 6-4: Attempting to draw the MonoGame logo rotated 90° and centered on the game window The reason the sprite did not rotate as expected is because of the origin parameter. Origin The origin parameter determines the reference point from which the sprite is rendered, rotated, and scaled. By default, if no origin is set, it will be Vector2.Zero, the upper-left corner of the sprite. To visualize this, see Figure 6-5 below. The red square represents where the origin is for the sprite, and we can see how it is rotated around this origin point. Figure 6-5: Demonstration of how a sprite is rotated around its origin To resolve this rotation issue, we need to need to change two things: Set the origin parameter to the center of the sprite instead of defaulting to the upper-left corner. Change the position parameter back to the center of the screen. Update the code to: protected override void Draw(GameTime gameTime) { // Clear the back buffer. GraphicsDevice.Clear(Color.CornflowerBlue); // Begin the sprite batch to prepare for rendering. SpriteBatch.Begin(); // Draw the texture. SpriteBatch.Draw( _logo, // texture new Vector2( // position Window.ClientBounds.Width, Window.ClientBounds.Height) * 0.5f, null, // sourceRectangle Color.White, // color MathHelper.ToRadians(90), // rotation new Vector2( // origin _logo.Width, _logo.Height) * 0.5f, 1.0f, // scale SpriteEffects.None, // effects 0.0f // layerDepth ); // Always end the sprite batch when finished. SpriteBatch.End(); base.Draw(gameTime); } Moving the sprite's origin to its center not only solves the rotation problem, but also allows us to use the screen's center position directly, without the need for additional offset calculations. Running the game now shows the logo properly centered and rotated by 90°. Note The origin parameter is based on the sprite's width and height, so the center will be half the width and half the height of the sprite. Figure 6-6: The MonoGame logo drawn rotated 90° and centered on the game window Scale The scale parameter specifies the amount of scaling to apply to the sprite when it is rendered. The default value is 1.0f, which can be read as \"rendering the sprite at 1x the size\". Increasing this will scale up the size of the sprite and decreasing it will scale down the sprite. For this example, we will first reset the rotation back to 0.0f (removing the 90° rotation we applied above) so we can clearly see the scaling effect. Then we will set the scale of the logo sprite to 1.5f protected override void Draw(GameTime gameTime) { // Clear the back buffer. GraphicsDevice.Clear(Color.CornflowerBlue); // Begin the sprite batch to prepare for rendering. SpriteBatch.Begin(); // Draw the texture. SpriteBatch.Draw( _logo, // texture new Vector2( // position Window.ClientBounds.Width, Window.ClientBounds.Height) * 0.5f, null, // sourceRectangle Color.White, // color 0.0f, // rotation new Vector2( // origin _logo.Width, _logo.Height) * 0.5f, 1.5f, // scale SpriteEffects.None, // effects 0.0f // layerDepth ); // Always end the sprite batch when finished. SpriteBatch.End(); base.Draw(gameTime); } Figure 6-7: The MonoGame logo drawn scaled at 1.5x the size Note that the sprite is scaled up from the center. This is because the origin parameter is still set to the center of the sprite. If we adjust the code so that the origin parameter is back in the upper-left corner, as in the listing below: protected override void Draw(GameTime gameTime) { // Clear the back buffer. GraphicsDevice.Clear(Color.CornflowerBlue); // Begin the sprite batch to prepare for rendering. SpriteBatch.Begin(); // Draw the texture. SpriteBatch.Draw( _logo, // texture new Vector2( // position Window.ClientBounds.Width, Window.ClientBounds.Height) * 0.5f, null, // sourceRectangle Color.White, // color 0.0f, // rotation Vector2.Zero, // origin 1.5f, // scale SpriteEffects.None, // effects 0.0f //layerDepth ); // Always end the sprite batch when finished. SpriteBatch.End(); base.Draw(gameTime); } Then the scaling is applied from the origin in the upper-left corner, producing the following result: Figure 6-8: The MonoGame logo drawn with a scale factor of 1.5x and the origin set in the upper-left corner Scaling can also be applied to the x- and y-axes independently by providing a Vector2 value instead of a float value. For instance, we can scale the x-axis of the sprite by 1.5x and reduce the scale of the y-axis to 0.5x: protected override void Draw(GameTime gameTime) { // Clear the back buffer. GraphicsDevice.Clear(Color.CornflowerBlue); // Begin the sprite batch to prepare for rendering. SpriteBatch.Begin(); // Draw the texture. SpriteBatch.Draw( _logo, // texture new Vector2( // position Window.ClientBounds.Width, Window.ClientBounds.Height) * 0.5f, null, // sourceRectangle Color.White, // color 0.0f, // rotation new Vector2( // origin _logo.Width, _logo.Height) * 0.5f, new Vector2(1.5f, 0.5f), // scale SpriteEffects.None, // effects 0.0f // layerDepth ); // Always end the sprite batch when finished. SpriteBatch.End(); base.Draw(gameTime); } Which will produce the following result: Figure 6-9: The MonoGame logo drawn scaled at 1.5x the size on the x-axis and 0.5x on the y-axis SpriteEffects The effects parameter is used to flip the sprite when rendered on either the horizontal axis, vertical axis, or both. The value for this parameter will be one of the SpriteEffects enum values. SpriteEffect Description SpriteEffects.None No effect is applied and the sprite is rendered normally. SpriteEffects.FlipHorizontally The sprite is rendered flipped along the horizontal axis. SpriteEffects.FlipVertically The sprite is rendered flipped along the vertical axis. For this example, we will reset the scale back to 1.0f and apply the SpriteEffects.FlipHorizontally value to the sprite: protected override void Draw(GameTime gameTime) { // Clear the back buffer. GraphicsDevice.Clear(Color.CornflowerBlue); // Begin the sprite batch to prepare for rendering. SpriteBatch.Begin(); // Draw the texture. SpriteBatch.Draw( _logo, // texture new Vector2( // position Window.ClientBounds.Width, Window.ClientBounds.Height) * 0.5f, null, // sourceRectangle Color.White, // color 0.0f, // rotation new Vector2( // origin _logo.Width, _logo.Height) * 0.5f, 1.0f, // scale SpriteEffects.FlipHorizontally, // effects 0.0f // layerDepth ); // Always end the sprite batch when finished. SpriteBatch.End(); base.Draw(gameTime); } Which will produce the following result: Figure 6-10: The MonoGame logo flipped horizontally The SpriteEffects enum value also uses the [Flag] attribute, which means we can combine both horizontal and vertical flipping together. To do this, we use the bitwise OR operator |. Update the effect parameter value to the following: protected override void Draw(GameTime gameTime) { // Clear the back buffer. GraphicsDevice.Clear(Color.CornflowerBlue); // Begin the sprite batch to prepare for rendering. SpriteBatch.Begin(); // Draw the texture. SpriteBatch.Draw( _logo, // texture new Vector2( // position Window.ClientBounds.Width, Window.ClientBounds.Height) * 0.5f, null, // sourceRectangle Color.White, // color 0.0f, // rotation new Vector2( // origin _logo.Width, _logo.Height) * 0.5f, 1.0f, // scale SpriteEffects.FlipHorizontally | // effects SpriteEffects.FlipVertically, 0.0f // layerDepth ); // Always end the sprite batch when finished. SpriteBatch.End(); base.Draw(gameTime); } Now the sprite is flipped both horizontally and vertically Figure 6-11: The MonoGame logo flipped horizontally and vertically Color and Opacity The color parameter applies a color mask to the sprite when it is rendered. Note that this is not setting the actual color of the image, just a mask that is applied on top of the image. The default value is Color.White. So if we are setting it to Color.White, why does this not affect the tinting of the sprite drawn? When the color parameter is applied, each color channel (Red, Green, Blue) of the sprite is multiplied by the corresponding channel in the color parameter, where each channel is represented as a value between 0.0f and 1.0f. For Color.White, all color channels are set to 1.0f (255 in byte form), so the multiplication looks like this: Final Red = Sprite Red * 1.0f Final Green = Sprite Green * 1.0f Final Blue = Sprite Blue * 1.0f; Since multiplying by 1.0f does not change the value, Color.White essentially preserves the original colors of the sprite. For this example, we will reset the effects parameter back to SpriteEffects.None and update the color parameter to use Color.Green: protected override void Draw(GameTime gameTime) { // Clear the back buffer. GraphicsDevice.Clear(Color.CornflowerBlue); // Begin the sprite batch to prepare for rendering. SpriteBatch.Begin(); // Draw the texture. SpriteBatch.Draw( _logo, // texture new Vector2( // position Window.ClientBounds.Width, Window.ClientBounds.Height) * 0.5f, null, // sourceRectangle Color.Green, // color 0.0f, // rotation new Vector2( // origin _logo.Width, _logo.Height) * 0.5f, 1.0f, // scale SpriteEffects.None, // effects 0.0f ); // Always end the sprite batch when finished. SpriteBatch.End(); base.Draw(gameTime); } This produces the following result: Figure 6-12: The MonoGame logo with a green color tint applied Note The icon and the word \"GAME\" in the logo look black after using Color.Green because the Red, Blue and Green components of that color are (0.0f, 0.5f, 0.0f). The Orange color used in the logo is Color.MonoGameOrange, which has the component values of (0.9f, 0.23f, 0.0f). When multiplying the component values, the result is (0.0f, 0.125f, 0.0f) which would be Red 0, Green 31, Blue 0 in byte values. So it is not quite fully black, but it is very close. This is why it is important to understand how the color parameter values are applied to the sprite when it is rendered. To adjust the opacity of a sprite, we can multiply the color parameter value by a value between 0.0f (fully transparent) and 1.0f (fully opaque). For instance, if we wanted to render the logo with 50% transparency we can multiply the color parameter by 0.5f like this: protected override void Draw(GameTime gameTime) { // Clear the back buffer. GraphicsDevice.Clear(Color.CornflowerBlue); // Begin the sprite batch to prepare for rendering. SpriteBatch.Begin(); // Draw the texture. SpriteBatch.Draw( _logo, // texture new Vector2( // position Window.ClientBounds.Width, Window.ClientBounds.Height) * 0.5f, null, // sourceRectangle Color.White * 0.5f, // color 0.0f, // rotation new Vector2( // origin _logo.Width, _logo.Height) * 0.5f, 1.0f, // scale SpriteEffects.None, // effects 0.0f ); // Always end the sprite batch when finished. SpriteBatch.End(); base.Draw(gameTime); } Which will produce the following result: Figure 6-13: The MonoGame logo with half transparency Source Rectangle The sourceRectangle parameter specifies a region within the texture that should be rendered. So far, we have just set this parameter to null, which specifies that the full texture should be rendered. If we only wanted to render a portion of the texture as the sprite, we can set this parameter value. For instance, take the logo image we have been using. We can break it down into two distinct regions; the MonoGame icon and the MonoGame wordmark. Figure 6-14: The MonoGame logo broken down into the icon and wordmark regions We can see from Figure 6-14 above that the actual icon starts at position (0, 0) and is 128px wide and 128px tall. Likewise, the wordmark starts at position (150, 34) and is 458px wide and 58px tall. Knowing the starting position and the width and height of the region gives us a defined rectangle that we can use as the sourceRectangle. We can see this in action by drawing the icon and the wordmark separately from the same texture. Update the code to the following: protected override void Draw(GameTime gameTime) { // Clear the back buffer. GraphicsDevice.Clear(Color.CornflowerBlue); // The bounds of the icon within the texture. Rectangle iconSourceRect = new Rectangle(0, 0, 128, 128); // The bounds of the word mark within the texture. Rectangle wordmarkSourceRect = new Rectangle(150, 34, 458, 58); // Begin the sprite batch to prepare for rendering. SpriteBatch.Begin(); // Draw only the icon portion of the texture. SpriteBatch.Draw( _logo, // texture new Vector2( // position Window.ClientBounds.Width, Window.ClientBounds.Height) * 0.5f, iconSourceRect, // sourceRectangle Color.White, // color 0.0f, // rotation new Vector2( // origin iconSourceRect.Width, iconSourceRect.Height) * 0.5f, 1.0f, // scale SpriteEffects.None, // effects 0.0f // layerDepth ); // Draw only the word mark portion of the texture. SpriteBatch.Draw( _logo, // texture new Vector2( // position Window.ClientBounds.Width, Window.ClientBounds.Height) * 0.5f, wordmarkSourceRect, // sourceRectangle Color.White, // color 0.0f, // rotation new Vector2( // origin wordmarkSourceRect.Width, wordmarkSourceRect.Height) * 0.5f, 1.0f, // scale SpriteEffects.None, // effects 0.0f // layerDepth ); // Always end the sprite batch when finished. SpriteBatch.End(); base.Draw(gameTime); } The following changes were made: Two new Rectangle values called iconSourceRect and wordmarkSourceRect that represent the boundaries of the MonoGame icon and wordmark regions within the logo texture were added. The sourceRectangle parameter of the _spriteBatch.Draw call was updated to use the new iconSourceRect value. Notice that we are still telling it to draw the _logo for the texture, we have just supplied it with a source rectangle this time. The origin parameter was updated to use the width and height of the iconSourceRect. Since the overall dimensions of what we will be rendering has changed due to supplying a source rectangle, the origin needs to be adjusted to those dimensions as well. Finally, a second _spriteBatch.Draw call is made, this time using the wordmarkSourceRect as the source rectangle so that the wordmark is drawn. If you run the game now, you should see the following: Figure 6-15: The MonoGame icon and wordmark, from the logo texture, centered in the game window Note Making use of the sourceRectangle parameter to draw different sprites from the same texture is an optimization technique that we will explore further in the next chapter. Layer Depth The final parameter to discuss is the layerDepth parameter. Notice that in Figure 6-15 above, the word mark is rendered on top of the icon. This is because of the order the draw calls were made; first the icon was rendered, then the word mark was rendered. The SpriteBatch.Begin method contains several optional parameters, one of which is the sortMode parameter. By default, this value is SpriteSortMode.Deferred, which means what is drawn is done so in the order of the SpriteBatch.Draw calls. Each subsequent call will be drawn visually on top of the previous call. When SpriteSortMode.Deferred is used, then the layerDepth parameter in the SpriteBatch.Draw call is essentially ignored. For instance, in the first _spriteBatch.Draw method call, update the layerDepth parameter to 1.0f. protected override void Draw(GameTime gameTime) { // Clear the back buffer. GraphicsDevice.Clear(Color.CornflowerBlue); // The bounds of the icon within the texture. Rectangle iconSourceRect = new Rectangle(0, 0, 128, 128); // The bounds of the word mark within the texture. Rectangle wordmarkSourceRect = new Rectangle(150, 34, 458, 58); // Begin the sprite batch to prepare for rendering. SpriteBatch.Begin(); // Draw only the icon portion of the texture. SpriteBatch.Draw( _logo, // texture new Vector2( // position Window.ClientBounds.Width, Window.ClientBounds.Height) * 0.5f, iconSourceRect, // sourceRectangle Color.White, // color 0.0f, // rotation new Vector2( // origin iconSourceRect.Width, iconSourceRect.Height) * 0.5f, 1.0f, // scale SpriteEffects.None, // effects 1.0f // layerDepth ); // Draw only the word mark portion of the texture. SpriteBatch.Draw( _logo, // texture new Vector2( // position Window.ClientBounds.Width, Window.ClientBounds.Height) * 0.5f, wordmarkSourceRect, // sourceRectangle Color.White, // color 0.0f, // rotation new Vector2( // origin wordmarkSourceRect.Width, wordmarkSourceRect.Height) * 0.5f, 1.0f, // scale SpriteEffects.None, // effects 0.0f // layerDepth ); // Always end the sprite batch when finished. SpriteBatch.End(); base.Draw(gameTime); } Doing this should tell it to render on a layer above the wordmark since the icon is at 1.0f and the wordmark is at 0.0f for the layerDepth. However, if you run the game now, you will see that no change actually happens; the wordmark is still drawn on top of the icon. To make use of the layerDepth parameter, you need to set the sortMode to either SpriteSortMode.BackToFront or SpriteSortMode.FrontToBack. Sort Mode Description SpriteSortMode.BackToFront Sprites are sorted by depth in back-to-front order prior to drawing. SpriteSortMode.FrontToBack Sprites are sorted by depth in front-to-back order prior to drawing. Now we can see this in action. We have already set the layerDepth parameter of the icon to 1.0f. Find the _spriteBatch.Begin() method call and update it to the following: protected override void Draw(GameTime gameTime) { // Clear the back buffer. GraphicsDevice.Clear(Color.CornflowerBlue); // The bounds of the icon within the texture. Rectangle iconSourceRect = new Rectangle(0, 0, 128, 128); // The bounds of the word mark within the texture. Rectangle wordmarkSourceRect = new Rectangle(150, 34, 458, 58); // Begin the sprite batch to prepare for rendering. SpriteBatch.Begin(sortMode: SpriteSortMode.FrontToBack); // Draw only the icon portion of the texture. SpriteBatch.Draw( _logo, // texture new Vector2( // position Window.ClientBounds.Width, Window.ClientBounds.Height) * 0.5f, iconSourceRect, // sourceRectangle Color.White, // color 0.0f, // rotation new Vector2( // origin iconSourceRect.Width, iconSourceRect.Height) * 0.5f, 1.0f, // scale SpriteEffects.None, // effects 1.0f // layerDepth ); // Draw only the word mark portion of the texture. SpriteBatch.Draw( _logo, // texture new Vector2( // position Window.ClientBounds.Width, Window.ClientBounds.Height) * 0.5f, wordmarkSourceRect, // sourceRectangle Color.White, // color 0.0f, // rotation new Vector2( // origin wordmarkSourceRect.Width, wordmarkSourceRect.Height) * 0.5f, 1.0f, // scale SpriteEffects.None, // effects 0.0f // layerDepth ); // Always end the sprite batch when finished. SpriteBatch.End(); base.Draw(gameTime); } Now we are telling it to use the SpriteSortMode.FrontToBack sort mode, which will sort the draw calls so that those with a higher layerDepth will be drawn on top of those with a lower one. Even though we did not change the order of the _spriteBatch.Draw calls, if you run the game now, you will see the following: Figure 6-16: The MonoGame icon drawn on top of the wordmark There are also two additional SpriteSortMode values that can be used. These, however, are situational and can have draw backs when using them, so understanding what they are for is important. The first is SpriteSortMode.Texture. This works similar to SpriteSortMode.Deferred in that draw calls happen in the order they are made. However, before the draw calls are made, they are sorted by texture. This can be helpful when using multiple textures to reduce texture swapping, however it can have unintended results with layering if you are not careful. The second is SpriteSortMode.Immediate. When using this sort mode, when a draw call is made, it is immediately flushed to the GPU and rendered to the screen, ignoring the layer depth, instead of batched and drawn when SpriteBatch.End is called. Using this can cause performance issues and should only be used when necessary. We will discuss an example of using this in a later chapter when we discuss shaders, since with SpriteSortMode.Immediate you can adjust shader parameters for each individual draw call. Conclusion In this chapter, you accomplished the following: You learned about the different parameters of the SpriteBatch.Draw method and how they affect sprite rendering. You learned how the rotation parameter works and how to convert between degrees and radians using MathHelper.ToRadians. You learned how the origin parameter affects sprite positioning, rotation, and scaling. You learned how to use the scale parameter to resize sprites uniformly or along individual axes. You explored the SpriteEffects enum to flip sprites horizontally and vertically. You learned how the color parameter can be used to tint sprites and adjust their opacity. You used the sourceRectangle parameter to draw specific regions from a texture. You explored sprite layering using the layerDepth parameter and different SpriteSortMode options. In the next chapter, we will take what we have learned about working with textures and learn techniques to optimize rendering to reduce texture swapping. Test Your Knowledge What is the purpose of the origin parameter in SpriteBatch.Draw, and how does it affect position, rotation and scaling? :::question-answer The origin parameter determines the reference point for the sprite's position, rotation, and scaling. When set to Vector2.Zero, the sprite rotates and scales from its upper-left corner. When set to the center of the sprite, the sprite rotates and scales from its center. The origin point also affects where the sprite is positioned relative to the position parameter. ::: How can you adjust a sprite's opacity using SpriteBatch.Draw? :::question-answer A sprite's opacity can be adjusted by multiplying the color parameter by a value between 0.0f (fully transparent) and 1.0f (fully opaque). For example, Color.White * 0.5f will render the sprite at 50% opacity. ::: How can you flip a sprite horizontally and vertically at the same time using SpriteEffects? :::question-answer To flip a sprite both horizontally and vertically, you can combine the SpriteEffects values using the bitwise OR operator (|): SpriteEffects.FlipHorizontally | SpriteEffects.FlipVertically ::: When using the sourceRectangle parameter, what information do you need to specify, and what is its purpose? :::question-answer The sourceRectangle parameter requires a Rectangle value where the x- and y-coordinates specify the upper-left corner of the region within the texture and the width and height, in pixels, of the region. Its purpose is to specify a specific region within a texture to draw, allowing multiple sprites to be drawn from different parts of the same texture. :::"
  },
  "templates/docs.monogame.github.io/articles/tutorials/building_2d_games/07_optimizing_texture_rendering/index.html": {
    "href": "templates/docs.monogame.github.io/articles/tutorials/building_2d_games/07_optimizing_texture_rendering/index.html",
    "title": "Chapter 07: Optimizing Texture Rendering | hallowed",
    "summary": "In Chapter 06, you learned how to load and render textures using SpriteBatch. While rendering individual textures works well for simple games, it can lead to performance issues as your game grows more complex. In this chapter, we will explore how to optimize texture rendering by reducing texture swaps and creating reusable components for better organization. In this chapter, you will: Learn about texture swapping and its impact on performance. Explore texture atlases as a solution for optimizing texture rendering. Create reusable classes to optimize and simplify texture management and rendering. By the end of this chapter, you will understand how to organize your game's textures for optimal performance and have a flexible texture atlas management system for your future game projects. Texture Swapping Every time the SpriteBatch.Draw method is executed with a different texture parameter than the previous SpriteBatch.Draw method call, a texture swap occurs, unbinding the current texture on the GPU and binding the new texture. Note A texture swap occurs when the GPU needs to switch between different textures during rendering. While each individual swap may seem trivial, the cumulative effect in a complex game can significantly impact performance. For example, here are the simplified draw calls for an example Pong game: // Using the paddle texture to render the left player paddle. // The paddle texture is bound to the GPU. _spriteBatch.Draw(paddleTexture, leftPaddlePosition, Color.White); // Using the ball texture to render the ball // A texture swap occurs, unbinding the paddle texture to bind the ball texture. _spriteBatch.Draw(ballTexture, ballPosition, Color.White); // Reusing the paddle texture to draw the right player paddle. // A texture swap occurs again, unbinding the ball texture to bind the paddle texture. _spriteBatch.Draw(paddleTexture, rightPaddlePosition, Color.White); In the above example: The paddle texture is bound to the GPU so the left player paddle can be drawn. The paddle texture is unbound from the GPU and the ball texture is bound so that the ball can be drawn (Texture Swap #1). The ball texture is unbound from the GPU and the paddle texture is bound again so the right player paddle can be drawn (Texture Swap #2). These texture swaps, while negligible in this example, can become a performance issue in a full game where you might be drawing hundreds or thousands of sprites per frame. Attempting to Optimize Draw Order One approach to get around this could be to optimize the order of the draw calls to minimize texture swaps. For example, if we reorder the draw calls from the previous example so that both paddles are drawn first and then the ball, the number of texture swaps is reduced from two to one: // Render the left and right paddles first. // This reduces the number of texture swaps needed from two to one. _spriteBatch.Draw(paddleTexture, _leftPaddlePosition, Color.White); _spriteBatch.Draw(paddleTexture, _rightPaddlePosition, Color.White); _spriteBatch.Draw(ballTexture, _ballPosition, Color.White); However this is not a scalable solution. In a real game with dozens of different textures and complex draw orders for layered sprites, UI elements, particles, etc., managing draw order by texture becomes impractical and will conflict with desired visual layering. What is a Texture Atlas A texture atlas (also known as a sprite sheet) is a large image file that contains multiple smaller images packed together. Instead of loading separate textures for each sprite, you load the single texture file with all the images combined like a scrapbook where all your photos are arranged on the same page. Note Using a texture atlas not only eliminates texture swaps but also reduces memory usage and simplifies asset management since you are loading and tracking a single texture instead of many individual ones. In the Pong example, imagine taking the paddle and ball image and combining them into a single image file like in Figure 7-1 below: Figure 7-1: Pong Texture Atlas Example Now when we draw these images, we would be using the same texture and just specify the source rectangles for the paddle or ball when needed, completely eliminating texture swaps. private Texture2D _textureAtlas; private Rectangle _paddleSourceRect; private Rectangle _ballSourceRect; protected override void LoadContent() { _textureAtlas = Content.Load<Texture2D>(\"pong-atlas\"); _paddleSourceRect = new Rectangle(0, 0, 32, 32); _ballSourceRect = new Rectangle(32, 0, 32, 32); } protected override void Draw(GameTime gameTime) { GraphicsDevice.Clear(Color.CornflowerBlue); _spriteBatch.Begin(); // All draw calls use the same texture, so there is no texture swapping! _spriteBatch.Draw(_textureAtlas, _leftPaddlePosition, _paddleSourceRect, Color.White); _spriteBatch.Draw(_textureAtlas, _rightPaddlePosition, _paddleSourceRect, Color.White); _spriteBatch.Draw(_textureAtlas, _ballPosition, _ballSourceRect, Color.White); _spriteBatch.End(); } While using the single texture with source rectangles solves the potential performance issues, managing multiple source rectangles in variables can become complex as your game grows. In the Pong example above, we are already tracking the source rectangles for both the paddle and ball sprites. Imagine scaling this up to a game with dozens of different images, each potentially needing their own position, rotation, scale, and other rendering properties. To better organize this complexity, we can apply object-oriented design principles to create classes that encapsulates the information needed. The TextureRegion Class In Chapter 06, we learned about using the sourceRectangle parameter to reuse the same texture when rendering sprites but specifying different regions within the texture to render. For our next step, we will build on this and create a class called TextureRegion. We are going to add this class to the class library we created in Chapter 04. Perform the following: Add new folder in the MonoGameLibrary project named Graphics Create a new file named TextureRegion.cs inside the Graphics folder you just created. Add the following code for the foundation of the TextureRegion class to the file: using Microsoft.Xna.Framework; using Microsoft.Xna.Framework.Graphics; namespace MonoGameLibrary.Graphics; /// <summary> /// Represents a rectangular region within a texture. /// </summary> public class TextureRegion { } Note The TextureRegion.cs class file is placed in the MonoGame/Graphics folder and the class uses the MonoGameLibrary.Graphics namespace to keep graphics-related classes organized together. As we add more functionality to the library, we will continue to use directories and namespaces to maintain a clean structure. We will add several components to this class in sequence. Each section below should be added to the TextureRegion class in the order presented between the brackets { } of the class definition. As we go through each part, the class will gradually take shape to handle all the texture handling behavior we need. TextureRegion Members The TextureRegion class will utilize four properties to define and manage a region within a texture. Add the following properties: /// <summary> /// Gets or Sets the source texture this texture region is part of. /// </summary> public Texture2D Texture { get; set; } /// <summary> /// Gets or Sets the source rectangle boundary of this texture region within the source texture. /// </summary> public Rectangle SourceRectangle { get; set; } /// <summary> /// Gets the width, in pixels, of this texture region. /// </summary> public int Width => SourceRectangle.Width; /// <summary> /// Gets the height, in pixels, of this texture region. /// </summary> public int Height => SourceRectangle.Height; The Texture and SourceRectangle properties work together to define where the region is located: Texture specifies which texture contains the region, while SourceRectangle defines its exact location and size within that texture. The Width and Height properties provide convenient access to the region's dimensions without having to access the SourceRectangle property directly. TextureRegion Constructor The TextureRegion class provides two ways to create a new texture region. Add the following constructors: /// <summary> /// Creates a new texture region. /// </summary> public TextureRegion() { } /// <summary> /// Creates a new texture region using the specified source texture. /// </summary> /// <param name=\"texture\">The texture to use as the source texture for this texture region.</param> /// <param name=\"x\">The x-coordinate position of the upper-left corner of this texture region relative to the upper-left corner of the source texture.</param> /// <param name=\"y\">The y-coordinate position of the upper-left corner of this texture region relative to the upper-left corner of the source texture.</param> /// <param name=\"width\">The width, in pixels, of this texture region.</param> /// <param name=\"height\">The height, in pixels, of this texture region.</param> public TextureRegion(Texture2D texture, int x, int y, int width, int height) { Texture = texture; SourceRectangle = new Rectangle(x, y, width, height); } The default constructor creates an empty texture region that can be configured later. The parameterized constructor allows you to define the region's source texture and boundary in a single step. The second constructor provides a convenient way to create texture regions when you know the exact location and dimensions within the source texture upfront. TextureRegion Methods Finally, the TextureRegion class will provide three overloaded Draw methods to render the texture region. Add the following methods: /// <summary> /// Submit this texture region for drawing in the current batch. /// </summary> /// <param name=\"spriteBatch\">The spritebatch instance used for batching draw calls.</param> /// <param name=\"position\">The xy-coordinate location to draw this texture region on the screen.</param> /// <param name=\"color\">The color mask to apply when drawing this texture region on screen.</param> public void Draw(SpriteBatch spriteBatch, Vector2 position, Color color) { Draw(spriteBatch, position, color, 0.0f, Vector2.Zero, Vector2.One, SpriteEffects.None, 0.0f); } /// <summary> /// Submit this texture region for drawing in the current batch. /// </summary> /// <param name=\"spriteBatch\">The spritebatch instance used for batching draw calls.</param> /// <param name=\"position\">The xy-coordinate location to draw this texture region on the screen.</param> /// <param name=\"color\">The color mask to apply when drawing this texture region on screen.</param> /// <param name=\"rotation\">The amount of rotation, in radians, to apply when drawing this texture region on screen.</param> /// <param name=\"origin\">The center of rotation, scaling, and position when drawing this texture region on screen.</param> /// <param name=\"scale\">The scale factor to apply when drawing this texture region on screen.</param> /// <param name=\"effects\">Specifies if this texture region should be flipped horizontally, vertically, or both when drawing on screen.</param> /// <param name=\"layerDepth\">The depth of the layer to use when drawing this texture region on screen.</param> public void Draw(SpriteBatch spriteBatch, Vector2 position, Color color, float rotation, Vector2 origin, float scale, SpriteEffects effects, float layerDepth) { Draw( spriteBatch, position, color, rotation, origin, new Vector2(scale, scale), effects, layerDepth ); } /// <summary> /// Submit this texture region for drawing in the current batch. /// </summary> /// <param name=\"spriteBatch\">The spritebatch instance used for batching draw calls.</param> /// <param name=\"position\">The xy-coordinate location to draw this texture region on the screen.</param> /// <param name=\"color\">The color mask to apply when drawing this texture region on screen.</param> /// <param name=\"rotation\">The amount of rotation, in radians, to apply when drawing this texture region on screen.</param> /// <param name=\"origin\">The center of rotation, scaling, and position when drawing this texture region on screen.</param> /// <param name=\"scale\">The amount of scaling to apply to the x- and y-axes when drawing this texture region on screen.</param> /// <param name=\"effects\">Specifies if this texture region should be flipped horizontally, vertically, or both when drawing on screen.</param> /// <param name=\"layerDepth\">The depth of the layer to use when drawing this texture region on screen.</param> public void Draw(SpriteBatch spriteBatch, Vector2 position, Color color, float rotation, Vector2 origin, Vector2 scale, SpriteEffects effects, float layerDepth) { spriteBatch.Draw( Texture, position, SourceRectangle, color, rotation, origin, scale, effects, layerDepth ); } These methods provide flexible options for rendering the texture region, similar to what the SpriteBatch.Draw method does: The simplest overload requires only position and color. A second overload exposes all rendering parameters while allowing for a single float value to be applied to both axes for scaling. The third overload is the most flexible, offering all rendering parameters and independent x- and y-axis scaling. Only the last Draw method actually uses the Texture specified in the class, as the other two methods both depend on this final implementation, simplifying the code needed to actually do the drawing. The TextureAtlas Class In the What is a Texture Atlas section above, a texture atlas was described as a scrap book that holds all of the individual sprites for the game. These individual sprites can now be represented by the TextureRegion class we just created. Now, we will create the TextureAtlas class to represent the collection of the regions that make up all of our sprites. Just like the TextureRegion class, we are going to add this to the class library. In the Graphics folder within the MonoGameLibrary project, add a new file named TextureAtlas.cs, then add the following code for the foundation of the TextureAtlas class: using System.Collections.Generic; using System.IO; using System.Xml; using System.Xml.Linq; using Microsoft.Xna.Framework; using Microsoft.Xna.Framework.Content; using Microsoft.Xna.Framework.Graphics; namespace MonoGameLibrary.Graphics; public class TextureAtlas { } As before, each section below adds more functionality to this class, one after the other within the TextureAtlas class. TextureAtlas Members The TextureAtlas class needs two key members to manage texture regions. Add the following: private Dictionary<string, TextureRegion> _regions; /// <summary> /// Gets or Sets the source texture represented by this texture atlas. /// </summary> public Texture2D Texture { get; set; } The private _regions dictionary stores named texture regions, allowing us to retrieve specific regions by name, while the Texture property holds the source texture that contains all the regions. Together, these members enable the atlas to manage multiple texture regions from a single source texture. TextureAtlas Constructors The TextureAtlas class provides two ways to create a new atlas. Add the following constructors: /// <summary> /// Creates a new texture atlas. /// </summary> public TextureAtlas() { _regions = new Dictionary<string, TextureRegion>(); } /// <summary> /// Creates a new texture atlas instance using the given texture. /// </summary> /// <param name=\"texture\">The source texture represented by the texture atlas.</param> public TextureAtlas(Texture2D texture) { Texture = texture; _regions = new Dictionary<string, TextureRegion>(); } The default constructor creates an empty atlas that can be configured later. The parameterized constructor allows you to specify the source texture immediately. Both constructors initialize the _regions dictionary so that it is ready to be used either way. TextureAtlas Methods Finally, The TextureAtlas class will provide methods for managing texture regions and creating atlases from configuration files. Add the following methods: /// <summary> /// Creates a new region and adds it to this texture atlas. /// </summary> /// <param name=\"name\">The name to give the texture region.</param> /// <param name=\"x\">The top-left x-coordinate position of the region boundary relative to the top-left corner of the source texture boundary.</param> /// <param name=\"y\">The top-left y-coordinate position of the region boundary relative to the top-left corner of the source texture boundary.</param> /// <param name=\"width\">The width, in pixels, of the region.</param> /// <param name=\"height\">The height, in pixels, of the region.</param> public void AddRegion(string name, int x, int y, int width, int height) { TextureRegion region = new TextureRegion(Texture, x, y, width, height); _regions.Add(name, region); } /// <summary> /// Gets the region from this texture atlas with the specified name. /// </summary> /// <param name=\"name\">The name of the region to retrieve.</param> /// <returns>The TextureRegion with the specified name.</returns> public TextureRegion GetRegion(string name) { return _regions[name]; } /// <summary> /// Removes the region from this texture atlas with the specified name. /// </summary> /// <param name=\"name\">The name of the region to remove.</param> /// <returns></returns> public bool RemoveRegion(string name) { return _regions.Remove(name); } /// <summary> /// Removes all regions from this texture atlas. /// </summary> public void Clear() { _regions.Clear(); } /// <summary> /// Creates a new texture atlas based on a texture atlas xml configuration file. /// </summary> /// <param name=\"content\">The content manager used to load the texture for the atlas.</param> /// <param name=\"fileName\">The path to the xml file, relative to the content root directory.</param> /// <returns>The texture atlas created by this method.</returns> public static TextureAtlas FromFile(ContentManager content, string fileName) { TextureAtlas atlas = new TextureAtlas(); string filePath = Path.Combine(content.RootDirectory, fileName); using (Stream stream = TitleContainer.OpenStream(filePath)) { using (XmlReader reader = XmlReader.Create(stream)) { XDocument doc = XDocument.Load(reader); XElement root = doc.Root; // The <Texture> element contains the content path for the Texture2D to load. // So we will retrieve that value then use the content manager to load the texture. string texturePath = root.Element(\"Texture\").Value; atlas.Texture = content.Load<Texture2D>(texturePath); // The <Regions> element contains individual <Region> elements, each one describing // a different texture region within the atlas. // // Example: // <Regions> // <Region name=\"spriteOne\" x=\"0\" y=\"0\" width=\"32\" height=\"32\" /> // <Region name=\"spriteTwo\" x=\"32\" y=\"0\" width=\"32\" height=\"32\" /> // </Regions> // // So we retrieve all of the <Region> elements then loop through each one // and generate a new TextureRegion instance from it and add it to this atlas. var regions = root.Element(\"Regions\")?.Elements(\"Region\"); if (regions != null) { foreach (var region in regions) { string name = region.Attribute(\"name\")?.Value; int x = int.Parse(region.Attribute(\"x\")?.Value ?? \"0\"); int y = int.Parse(region.Attribute(\"y\")?.Value ?? \"0\"); int width = int.Parse(region.Attribute(\"width\")?.Value ?? \"0\"); int height = int.Parse(region.Attribute(\"height\")?.Value ?? \"0\"); if (!string.IsNullOrEmpty(name)) { atlas.AddRegion(name, x, y, width, height); } } } return atlas; } } } These methods serve different purposes in managing the texture atlas: Region Management AddRegion: Creates a new TextureRegion at the specified location in the atlas. GetRegion: Retrieves a previously added region by its name. RemoveRegion: Removes a specific region by its name. Clear: Removes all regions from the atlas. Atlas Creation FromFile: creates a new TextureAtlas from an XML configuration file. This method will load the source texture then create and add the regions based on the XML configuration. We will look more into using the XML configuration in a moment. Using the TextureAtlas Class Now we can put our new TextureAtlas class to use by exploring two approaches; creating an atlas manually and using XML configuration. So far, we have been practicing using textures with the MonoGame logo. Now we will use a new texture atlas that contains various sprites we will need for our game. Download the texture atlas by right-clicking the following image and saving it as atlas.png: Figure 7-2: The texture atlas for our game Tip You may notice that our texture atlas image has some empty areas, which seems like a waste. Its dimensions are 256x256 pixels when it could have just been 240x160 pixels. This is intentional. Game graphics often use texture dimensions that are powers of 2 (128, 256, 512, 1024, etc.) for technical reasons. While modern graphics hardware can handle any texture size, power-of-2 dimensions provide better memory efficiency and more precise rendering. When pixel coordinates are converted to texture coordinates during rendering, powers of 2 can be represented more precisely in floating-point calculations, helping prevent visual artifacts like texture seams. This is not critical for simple 2D games, but adopting this practice early will serve you well as your games become more complex. Add this texture atlas to your content project using the MGCB Editor: Open the Content.mgcb file in the MGCB Editor In the editor, right-click the images folder and choose Add > Existing item.... Navigate to and choose the atlas.png file you downloaded to add it. Save the changes and close the MGCB Editor. Tip If you need a refresher on adding content using the MGCB Editor, you can revisit the Chapter 05: The Content Pipeline. First, we will explore creating the texture atlas and defining the texture regions directly in code. Replace the contents of Game1.cs with the following: using Microsoft.Xna.Framework; using Microsoft.Xna.Framework.Graphics; using Microsoft.Xna.Framework.Input; using MonoGameLibrary; using MonoGameLibrary.Graphics; namespace DungeonSlime; public class Game1 : Core { // texture region that defines the slime sprite in the atlas. private TextureRegion _slime; // texture region that defines the bat sprite in the atlas. private TextureRegion _bat; public Game1() : base(\"Dungeon Slime\", 1280, 720, false) { } protected override void Initialize() { // TODO: Add your initialization logic here base.Initialize(); } protected override void LoadContent() { // Load the atlas texture using the content manager Texture2D atlasTexture = Content.Load<Texture2D>(\"images/atlas\"); // Create a TextureAtlas instance from the atlas TextureAtlas atlas = new TextureAtlas(atlasTexture); // add the slime region to the atlas. atlas.AddRegion(\"slime\", 0, 0, 20, 20); // add the bat region to the atlas. atlas.AddRegion(\"bat\", 20, 0, 20, 20); // retrieve the slime region from the atlas. _slime = atlas.GetRegion(\"slime\"); // retrieve the bat region from the atlas. _bat = atlas.GetRegion(\"bat\"); } protected override void Update(GameTime gameTime) { if (GamePad.GetState(PlayerIndex.One).Buttons.Back == ButtonState.Pressed || Keyboard.GetState().IsKeyDown(Keys.Escape)) Exit(); // TODO: Add your update logic here base.Update(gameTime); } protected override void Draw(GameTime gameTime) { // Clear the back buffer. GraphicsDevice.Clear(Color.CornflowerBlue); // Begin the sprite batch to prepare for rendering. SpriteBatch.Begin(samplerState: SamplerState.PointClamp); // Draw the slime texture region at a scale of 4.0 _slime.Draw(SpriteBatch, Vector2.Zero, Color.White, 0.0f, Vector2.One, 4.0f, SpriteEffects.None, 0.0f); // Draw the bat texture region 10px to the right of the slime at a scale of 4.0 _bat.Draw(SpriteBatch, new Vector2(_slime.Width * 4.0f + 10, 0), Color.White, 0.0f, Vector2.One, 4.0f, SpriteEffects.None, 1.0f); // Always end the sprite batch when finished. SpriteBatch.End(); base.Draw(gameTime); } } The key changes in this implementation are: The _logo field was removed. Added TextureRegion members for the slime and bat sprites. In LoadContent: Removed loading the logo texture. Created a TextureAtlas with the atlas texture. Added regions for both the slime and the bat. Retrieved the regions using their names. Updated Draw to: Draw the slime at a scale factor of 4. Draw the bat 10 pixels to the right of the slime based on the slime's Width property, at a scale of 4. Running the game now shows both sprites in the upper-left corner: Figure 7-3: The slime and bat texture regions being rendered in the upper-left corner of the game window While manual creation works for a few sprites, managing many regions becomes cumbersome. Now we will explore the TextureAtlas.FromFile method to load our atlas configuration from XML instead. Perform the following: Open the Content.mgcb file in the MGCB Editor Create a new file named atlas-definition in the Content/images folder using \"Add -> New Item -> XML Content\". In the properties panel at the bottom for the atlas-definition.xml file, change the Build Action property from Build to Copy. Save the changes and close the MGCB Editor Open the new atlas-definition.xml file in your code editor (The MGCB editor cannot edit files, only manage the what content it builds) Replace the contents of the XML file with the following: <?xml version=\"1.0\" encoding=\"utf-8\"?> <TextureAtlas> <Texture>images/atlas</Texture> <Regions> <Region name=\"slime\" x=\"0\" y=\"0\" width=\"20\" height=\"20\" /> <Region name=\"bat\" x=\"20\" y=\"0\" width=\"20\" height=\"20\" /> </Regions> </TextureAtlas> Figure 7-4: The atlas-definition.xml file added to the content project with the Build Action property set to Copy Tip Using the content pipeline to copy files ensures they are placed in the correct location alongside other game content. While there are other methods (like editing the .csproj), this approach keeps asset management centralized Update the contents of Game1.cs with the following code: using Microsoft.Xna.Framework; using Microsoft.Xna.Framework.Graphics; using Microsoft.Xna.Framework.Input; using MonoGameLibrary; using MonoGameLibrary.Graphics; namespace DungeonSlime; public class Game1 : Core { // texture region that defines the slime sprite in the atlas. private TextureRegion _slime; // texture region that defines the bat sprite in the atlas. private TextureRegion _bat; public Game1() : base(\"Dungeon Slime\", 1280, 720, false) { } protected override void Initialize() { // TODO: Add your initialization logic here base.Initialize(); } protected override void LoadContent() { // Create the texture atlas from the XML configuration file TextureAtlas atlas = TextureAtlas.FromFile(Content, \"images/atlas-definition.xml\"); // retrieve the slime region from the atlas. _slime = atlas.GetRegion(\"slime\"); // retrieve the bat region from the atlas. _bat = atlas.GetRegion(\"bat\"); } protected override void Update(GameTime gameTime) { if (GamePad.GetState(PlayerIndex.One).Buttons.Back == ButtonState.Pressed || Keyboard.GetState().IsKeyDown(Keys.Escape)) Exit(); // TODO: Add your update logic here base.Update(gameTime); } protected override void Draw(GameTime gameTime) { // Clear the back buffer. GraphicsDevice.Clear(Color.CornflowerBlue); // Begin the sprite batch to prepare for rendering. SpriteBatch.Begin(samplerState: SamplerState.PointClamp); // Draw the slime texture region at a scale of 4.0 _slime.Draw(SpriteBatch, Vector2.Zero, Color.White, 0.0f, Vector2.One, 4.0f, SpriteEffects.None, 0.0f); // Draw the bat texture region 10px to the right of the slime at a scale of 4.0 _bat.Draw(SpriteBatch, new Vector2(_slime.Width * 4.0f + 10, 0), Color.White, 0.0f, Vector2.One, 4.0f, SpriteEffects.None, 1.0f); // Always end the sprite batch when finished. SpriteBatch.End(); base.Draw(gameTime); } } The key improvements here is in LoadContent, where we now: Create an atlas from the XML configuration file. Let the TextureAtlas.FromFile method handle texture loading and region creation. Removed the manual creation of regions in code. This configuration based approached is advantageous because we can now add new and modify existing regions within the atlas without having to change code and/or recompile. This also keeps the sprite definitions separate from the game logic. Running the game now will show the same results as Figure 7-4 above, with the slime and bat texture regions rendered in the upper-left corner of the game window. Conclusion In this chapter, you accomplished the following: Learned about texture swapping and its impact on performance Explored texture atlases as a solution for optimizing texture rendering Learned what a class library is and the benefits of using one. Created reusable TextureRegion and TextureAtlas classes to optimize and simplify texture management. Learned how to include assets in the content pipeline that should only be copied and not processed. In the next chapter, we will build on the concepts of the TextureAtlas and explore creating the Sprite and AnimatedSprite classes to further simplify managing and rendering sprites. Test Your Knowledge What is a texture swap and why can it impact performance? :::question-answer A texture swap occurs when the GPU needs to unbind one texture and bind another between draw calls. While individual swaps may seem trivial, they can significantly impact performance in games with many sprites as each swap is an expensive GPU operation. ::: Name a benefit of using a texture atlas. :::question-answer Any of the following are benefits of using a texture atlas: Eliminates texture swaps by using a single texture Reduces memory usage Simplifies asset management Improves rendering performance :::"
  },
  "templates/docs.monogame.github.io/articles/tutorials/building_2d_games/08_the_sprite_class/index.html": {
    "href": "templates/docs.monogame.github.io/articles/tutorials/building_2d_games/08_the_sprite_class/index.html",
    "title": "Chapter 08: The Sprite Class | hallowed",
    "summary": "In Chapter 07, you learned how to use texture atlases to optimize rendering performance. While this solved the issue of texture swapping, managing individual sprites and their properties becomes increasingly complex as your game grows. Even in our simple example with just a slime and a bat, we would eventually need to track various properties for each sprite: Color mask for tinting. Origin for rotation and scale. Scale for size adjustments. Rotation for orientation. Sprite effects to flip horizontally and/or vertically. Layer depth for draw order layering. Imagine scaling this up to dozens of sprites, each with multiple instances on screen. Tracking all these properties through individual variables quickly becomes unmanageable. In this chapter, we will solve this by creating a class that encapsulates sprite information and handles rendering. The Sprite Class A sprite in our game represents a visual object created from a texture region, along with its rendering properties. While multiple sprites might use the same texture region (like multiple enemies of the same type), each sprite can have unique properties that control how it appears on screen; its position, rotation, scale, and other visual characteristics. By creating a Sprite class, we can encapsulate both the texture region and its rendering parameters into a single, reusable component. This not only makes our code more organized but also makes it easier to manage multiple instances of the same type of sprite. In the Graphics folder within the MonoGameLibrary project, add a new file named Sprite.cs and add the following code for the foundation of the Sprite class to the file: using Microsoft.Xna.Framework; using Microsoft.Xna.Framework.Graphics; namespace MonoGameLibrary.Graphics; public class Sprite { } Properties The Sprite class will utilize properties that mirror the parameters used in SpriteBatch.Draw so the rendering parameter for each sprite is self contained. Add the following properties: /// <summary> /// Gets or Sets the source texture region represented by this sprite. /// </summary> public TextureRegion Region { get; set; } /// <summary> /// Gets or Sets the color mask to apply when rendering this sprite. /// </summary> /// <remarks> /// Default value is Color.White /// </remarks> public Color Color { get; set; } = Color.White; /// <summary> /// Gets or Sets the amount of rotation, in radians, to apply when rendering this sprite. /// </summary> /// <remarks> /// Default value is 0.0f /// </remarks> public float Rotation { get; set; } = 0.0f; /// <summary> /// Gets or Sets the scale factor to apply to the x- and y-axes when rendering this sprite. /// </summary> /// <remarks> /// Default value is Vector2.One /// </remarks> public Vector2 Scale { get; set; } = Vector2.One; /// <summary> /// Gets or Sets the xy-coordinate origin point, relative to the top-left corner, of this sprite. /// </summary> /// <remarks> /// Default value is Vector2.Zero /// </remarks> public Vector2 Origin { get; set; } = Vector2.Zero; /// <summary> /// Gets or Sets the sprite effects to apply when rendering this sprite. /// </summary> /// <remarks> /// Default value is SpriteEffects.None /// </remarks> public SpriteEffects Effects { get; set; } = SpriteEffects.None; /// <summary> /// Gets or Sets the layer depth to apply when rendering this sprite. /// </summary> /// <remarks> /// Default value is 0.0f /// </remarks> public float LayerDepth { get; set; } = 0.0f; /// <summary> /// Gets the width, in pixels, of this sprite. /// </summary> /// <remarks> /// Width is calculated by multiplying the width of the source texture region by the x-axis scale factor. /// </remarks> public float Width => Region.Width * Scale.X; /// <summary> /// Gets the height, in pixels, of this sprite. /// </summary> /// <remarks> /// Height is calculated by multiplying the height of the source texture region by the y-axis scale factor. /// </remarks> public float Height => Region.Height * Scale.Y; The TextureRegion property works to provide the texture and source rectangle when rendering the sprite. Other properties directly correspond to SpriteBatch.Draw parameters with the same default values, making it easy to understand how each property affects the sprite's appearance. Tip The calculated Width and Height properties make it easier to position sprites relative to each other without manually applying scale factors. Constructors The Sprite class provides two ways to create a new sprite. Add the following constructors: /// <summary> /// Creates a new sprite. /// </summary> public Sprite() { } /// <summary> /// Creates a new sprite using the specified source texture region. /// </summary> /// <param name=\"region\">The texture region to use as the source texture region for this sprite.</param> public Sprite(TextureRegion region) { Region = region; } The default constructor creates an empty sprite that can be configured later. The parameterized constructor allows you to specify the source texture region for the sprite. Methods Finally, add the following two method to the Sprite class: /// <summary> /// Sets the origin of this sprite to the center. /// </summary> public void CenterOrigin() { Origin = new Vector2(Region.Width, Region.Height) * 0.5f; } /// <summary> /// Submit this sprite for drawing to the current batch. /// </summary> /// <param name=\"spriteBatch\">The SpriteBatch instance used for batching draw calls.</param> /// <param name=\"position\">The xy-coordinate position to render this sprite at.</param> public void Draw(SpriteBatch spriteBatch, Vector2 position) { Region.Draw(spriteBatch, position, Color, Rotation, Origin, Scale, Effects, LayerDepth); } CenterOrigin: Sets the origin point of the sprite to its center. Note The origin needs to be set based on the width and height of the source texture region itself, regardless of the scale the sprite is rendered at. Draw: Uses the TextureRegion property to submit the sprite for rendering using the properties of the sprite itself. Create Sprites With The TextureAtlas Class While the GetRegion method of the TextureAtlas class we created in Chapter 07 works well for retrieving regions, creating sprites requires multiple steps: Get the region by name. Store it in a variable. Create a new sprite with that region. We can simplify this process by adding a sprite creation method to the TextureAtlas class. Open the TextureAtlas.cs and add the following method: /// <summary> /// Creates a new sprite using the region from this texture atlas with the specified name. /// </summary> /// <param name=\"regionName\">The name of the region to create the sprite with.</param> /// <returns>A new Sprite using the texture region with the specified name.</returns> public Sprite CreateSprite(string regionName) { TextureRegion region = GetRegion(regionName); return new Sprite(region); } Using the Sprite Class Now we can adjust our game to use the Sprite class instead of just the texture regions. Update the contents of Game1.cs with the following: using Microsoft.Xna.Framework; using Microsoft.Xna.Framework.Graphics; using Microsoft.Xna.Framework.Input; using MonoGameLibrary; using MonoGameLibrary.Graphics; namespace DungeonSlime; public class Game1 : Core { // Defines the slime sprite. private Sprite _slime; // Defines the bat sprite. private Sprite _bat; public Game1() : base(\"Dungeon Slime\", 1280, 720, false) { } protected override void Initialize() { // TODO: Add your initialization logic here base.Initialize(); } protected override void LoadContent() { // Create the texture atlas from the XML configuration file. TextureAtlas atlas = TextureAtlas.FromFile(Content, \"images/atlas-definition.xml\"); // Create the slime sprite from the atlas. _slime = atlas.CreateSprite(\"slime\"); _slime.Scale = new Vector2(4.0f, 4.0f); // Create the bat sprite from the atlas. _bat = atlas.CreateSprite(\"bat\"); _bat.Scale = new Vector2(4.0f, 4.0f); } protected override void Update(GameTime gameTime) { if (GamePad.GetState(PlayerIndex.One).Buttons.Back == ButtonState.Pressed || Keyboard.GetState().IsKeyDown(Keys.Escape)) Exit(); // TODO: Add your update logic here base.Update(gameTime); } protected override void Draw(GameTime gameTime) { // Clear the back buffer. GraphicsDevice.Clear(Color.CornflowerBlue); // Begin the sprite batch to prepare for rendering. SpriteBatch.Begin(samplerState: SamplerState.PointClamp); // Draw the slime sprite. _slime.Draw(SpriteBatch, Vector2.One); // Draw the bat sprite 10px to the right of the slime. _bat.Draw(SpriteBatch, new Vector2(_slime.Width + 10, 0)); // Always end the sprite batch when finished. SpriteBatch.End(); base.Draw(gameTime); } } The key changes in this implementation are: The _slime and _bat members were changed from TextureRegion to Sprite. In LoadContent The _slime and _bat sprites are now created using the new TextureAtlas.CreateSprite method. Both the _slime and _bat sprites are given a scale of 4.0f. In Draw, the draw calls were updated to use the Sprite.Draw method. Running the game now will produce the same result as in the previous chapter. Figure 8-1: The slime and bat sprites being rendered in the upper-left corner of the game window Note Notice how even though we increased the scale of both sprites, the bat sprite is still only 10px to the right of the slime. This is because the Width property we created for the Sprite class takes into account the scale factor of the sprite as well. Try adjusting the various properties available for the slime and the bat sprites to see how they affect the rendering. Conclusion In this chapter, we created a reusable Sprite class that encapsulates the properties for each sprite that we would render. The TextureAtlas class was updated to simplify sprite creation based on the Sprite class we created. In the next chapter, we will build upon the Sprite class to create an AnimatedSprite class that will allow us to bring our sprites to life through animation. Test Your Knowledge What is the benefit of using a Sprite class instead of managing texture regions directly? :::question-answer The Sprite class encapsulates all rendering properties (position, rotation, scale, etc.) into a single, reusable component. This makes it easier to manage multiple instances of the same type of sprite without having to track properties through individual variables. ::: Why do the Width and Height properties of a Sprite take the Scale property into account? :::question-answer The Width and Height properties account for scaling to make it easier to position sprites relative to each other without having to manually calculate the scaled dimensions. This is particularly useful when sprites are rendered at different scales. ::: When using the CenterOrigin method, why is the origin calculated using the region's dimensions rather than the sprite's scaled dimensions? :::question-answer The origin needs to be set based on the texture region's actual dimensions because it represents the point around which scaling and rotation are applied. Using the scaled dimensions would result in incorrect positioning since the origin would change based on the current scale factor. ::: What advantage does the TextureAtlas.CreateSprite method provide over using GetRegion? :::question-answer The CreateSprite method simplifies sprite creation by combining multiple steps (getting the region, storing it, creating a sprite) into a single method call. This reduces code repetition and makes sprite creation more straightforward. :::"
  },
  "templates/docs.monogame.github.io/articles/tutorials/building_2d_games/09_the_animatedsprite_class/index.html": {
    "href": "templates/docs.monogame.github.io/articles/tutorials/building_2d_games/09_the_animatedsprite_class/index.html",
    "title": "Chapter 09: The AnimatedSprite Class | hallowed",
    "summary": "While packing images into a texture atlas and managing them through our Sprite class improves performance and organization, games need animation to bring their visuals to life. 2D animation in games works much like a flip book; a sequence of individual images (frames) displayed in rapid succession creates the illusion of movement. Each frame represents a specific point in the sprite's animation, and when these frames are cycled through quickly, our eyes perceive fluid motion. Note The term \"frame\" in animation refers to a single image in an animation sequence. This is different from a game frame, which represents one complete render cycle of your game. In MonoGame, we can create these animations by cycling through different regions of our texture atlas, with each region representing a single frame of the animation. For example, Figure 9-1 below shows three frames that make up a bat's wing-flapping animation: Figure 9-1: Animation example of a bat flapping its wings By drawing each frame sequentially over time, we create the illusion that the bat is flapping its wings. The speed at which we switch between frames determines how smooth or rapid the animation appears. In this chapter, we will build off of the Sprite class we created in Chapter 08 to create an AnimatedSprite class we can use to bring animations to life. The Animation Class Before we can create animated sprites, we need a way to manage animation data. We will create an Animation class to encapsulate this information. In the Graphics folder within the MonoGameLibrary project, add a new file named Animation.cs with this initial structure: using System; using System.Collections.Generic; namespace MonoGameLibrary.Graphics; public class Animation { } Animation Properties An animation requires two key pieces of information: the sequence of frames to display and the timing between them. Add these properties to the Animation class: /// <summary> /// The texture regions that make up the frames of this animation. The order of the regions within the collection /// are the order that the frames should be displayed in. /// </summary> public List<TextureRegion> Frames { get; set; } /// <summary> /// The amount of time to delay between each frame before moving to the next frame for this animation. /// </summary> public TimeSpan Delay { get; set; } The Frames property stores the collection of texture regions that make up the animation sequence. The order of regions in this collection is important; they will be displayed in the same sequence they are added, creating the animation's movement. For example, in our bat animation, the frames would be ordered to show the wings moving up, then fully extended, then down. The Delay property defines how long each frame should be displayed before moving to the next one. This timing control allows us to adjust the speed of our animations; a shorter delay creates faster animations, while a longer delay creates slower ones. Note Using TimeSpan for the delay allows us to specify precise timing intervals, making it easier to synchronize animations with game time. In other scenarios, you could opt to just use float values instead. Animation Constructors The Animation class provides two ways to create an animation. Add the following constructors: /// <summary> /// Creates a new animation. /// </summary> public Animation() { Frames = new List<TextureRegion>(); Delay = TimeSpan.FromMilliseconds(100); } /// <summary> /// Creates a new animation with the specified frames and delay. /// </summary> /// <param name=\"frames\">An ordered collection of the frames for this animation.</param> /// <param name=\"delay\">The amount of time to delay between each frame of this animation.</param> public Animation(List<TextureRegion> frames, TimeSpan delay) { Frames = frames; Delay = delay; } The default constructor creates an animation with an empty collection of frames and a default delay of 100 milliseconds between each frame. The parameterized constructor allows you to specify the frames of animation and the delay for the animation. Tip The default 100 milliseconds delay provides a good starting point for most animations, roughly equivalent to 10 animation frame changes per second. Creating Animations With The TextureAtlas Class The TextureAtlas class we created in Chapter 07 can do more than just manage texture regions and create sprites; it can also store and manage animation data to create animated sprites. The atlas.png image we are currently using contains the frames of animation for both a slime and a bat, as well as sprites for other things. We will first update our atlas-definition.xml file to include all regions in the atlas, as well as add new <Animation> elements to define the animations. Open the atlas-definition.xml file in your code editor and replace the contents with the following: <?xml version=\"1.0\" encoding=\"utf-8\"?> <TextureAtlas> <Texture>images/atlas</Texture> <Regions> <Region name=\"slime-1\" x=\"0\" y=\"0\" width=\"20\" height=\"20\" /> <Region name=\"slime-2\" x=\"0\" y=\"20\" width=\"20\" height=\"20\" /> <Region name=\"bat-1\" x=\"20\" y=\"0\" width=\"20\" height=\"20\" /> <Region name=\"bat-2\" x=\"20\" y=\"20\" width=\"20\" height=\"20\" /> <Region name=\"bat-3\" x=\"40\" y=\"0\" width=\"20\" height=\"20\" /> </Regions> <Animations> <Animation name=\"slime-animation\" delay=\"200\"> <Frame region=\"slime-1\" /> <Frame region=\"slime-2\" /> </Animation> <Animation name=\"bat-animation\" delay=\"200\"> <Frame region=\"bat-1\" /> <Frame region=\"bat-2\" /> <Frame region=\"bat-1\" /> <Frame region=\"bat-3\" /> </Animation> </Animations> </TextureAtlas> The key changes here are: Regions have been added for all regions within the atlas. The slime and bat regions have been renamed to reflect the frame number of the animation. A new <Animations> element has been added that defines <Animation> elements. Note In the bat animation, we reuse frame \"bat-1\" in the sequence (bat-1, bat-2, bat-1, bat-3). This creates a smoother wing-flapping animation by returning to the neutral position between up and down wing positions. Now that we have a fully configured XML configuration for the atlas, we need to update the TextureAtlas class to manage animation data. Open the TextureAtlas.cs file and make the following changes: Add the following using statement so we can reference the TimeSpan struct: using System; using System.Collections.Generic; using System.IO; using System.Xml; using System.Xml.Linq; using Microsoft.Xna.Framework; using Microsoft.Xna.Framework.Content; using Microsoft.Xna.Framework.Graphics; Add storage for animations after the Texture property: // Stores animations added to this atlas. private Dictionary<string, Animation> _animations; Update the constructors so that the animations dictionary is initialized: /// <summary> /// Creates a new texture atlas. /// </summary> public TextureAtlas() { _regions = new Dictionary<string, TextureRegion>(); _animations = new Dictionary<string, Animation>(); } /// <summary> /// Creates a new texture atlas instance using the given texture. /// </summary> /// <param name=\"texture\">The source texture represented by the texture atlas.</param> public TextureAtlas(Texture2D texture) { Texture = texture; _regions = new Dictionary<string, TextureRegion>(); _animations = new Dictionary<string, Animation>(); } Add methods to manage animations, similar to those that we use to manage regions: /// <summary> /// Adds the given animation to this texture atlas with the specified name. /// </summary> /// <param name=\"animationName\">The name of the animation to add.</param> /// <param name=\"animation\">The animation to add.</param> public void AddAnimation(string animationName, Animation animation) { _animations.Add(animationName, animation); } /// <summary> /// Gets the animation from this texture atlas with the specified name. /// </summary> /// <param name=\"animationName\">The name of the animation to retrieve.</param> /// <returns>The animation with the specified name.</returns> public Animation GetAnimation(string animationName) { return _animations[animationName]; } /// <summary> /// Removes the animation with the specified name from this texture atlas. /// </summary> /// <param name=\"animationName\">The name of the animation to remove.</param> /// <returns>true if the animation is removed successfully; otherwise, false.</returns> public bool RemoveAnimation(string animationName) { return _animations.Remove(animationName); } Update the FromFile method to parse the new <Animation> animation definitions from the XML configuration file /// <summary> /// Creates a new texture atlas based a texture atlas xml configuration file. /// </summary> /// <param name=\"content\">The content manager used to load the texture for the atlas.</param> /// <param name=\"fileName\">The path to the xml file, relative to the content root directory..</param> /// <returns>The texture atlas created by this method.</returns> public static TextureAtlas FromFile(ContentManager content, string fileName) { TextureAtlas atlas = new TextureAtlas(); string filePath = Path.Combine(content.RootDirectory, fileName); using (Stream stream = TitleContainer.OpenStream(filePath)) { using (XmlReader reader = XmlReader.Create(stream)) { XDocument doc = XDocument.Load(reader); XElement root = doc.Root; // The <Texture> element contains the content path for the Texture2D to load. // So we will retrieve that value then use the content manager to load the texture. string texturePath = root.Element(\"Texture\").Value; atlas.Texture = content.Load<Texture2D>(texturePath); // The <Regions> element contains individual <Region> elements, each one describing // a different texture region within the atlas. // // Example: // <Regions> // <Region name=\"spriteOne\" x=\"0\" y=\"0\" width=\"32\" height=\"32\" /> // <Region name=\"spriteTwo\" x=\"32\" y=\"0\" width=\"32\" height=\"32\" /> // </Regions> // // So we retrieve all of the <Region> elements then loop through each one // and generate a new TextureRegion instance from it and add it to this atlas. var regions = root.Element(\"Regions\")?.Elements(\"Region\"); if (regions != null) { foreach (var region in regions) { string name = region.Attribute(\"name\")?.Value; int x = int.Parse(region.Attribute(\"x\")?.Value ?? \"0\"); int y = int.Parse(region.Attribute(\"y\")?.Value ?? \"0\"); int width = int.Parse(region.Attribute(\"width\")?.Value ?? \"0\"); int height = int.Parse(region.Attribute(\"height\")?.Value ?? \"0\"); if (!string.IsNullOrEmpty(name)) { atlas.AddRegion(name, x, y, width, height); } } } // The <Animations> element contains individual <Animation> elements, each one describing // a different animation within the atlas. // // Example: // <Animations> // <Animation name=\"animation\" delay=\"100\"> // <Frame region=\"spriteOne\" /> // <Frame region=\"spriteTwo\" /> // </Animation> // </Animations> // // So we retrieve all of the <Animation> elements then loop through each one // and generate a new Animation instance from it and add it to this atlas. var animationElements = root.Element(\"Animations\").Elements(\"Animation\"); if (animationElements != null) { foreach (var animationElement in animationElements) { string name = animationElement.Attribute(\"name\")?.Value; float delayInMilliseconds = float.Parse(animationElement.Attribute(\"delay\")?.Value ?? \"0\"); TimeSpan delay = TimeSpan.FromMilliseconds(delayInMilliseconds); List<TextureRegion> frames = new List<TextureRegion>(); var frameElements = animationElement.Elements(\"Frame\"); if (frameElements != null) { foreach (var frameElement in frameElements) { string regionName = frameElement.Attribute(\"region\").Value; TextureRegion region = atlas.GetRegion(regionName); frames.Add(region); } } Animation animation = new Animation(frames, delay); atlas.AddAnimation(name, animation); } } return atlas; } } } The updated FromFile method now handles both region and animation definitions from the XML configuration. For animations, it: Reads the <Animations> section from the XML. For each animation: Gets the name and frame delay. Collects the referenced texture regions. Creates and stores a new Animation instance. The AnimatedSprite Class With our Animation class handling animation data, and the TextureAtlas updated to store the animation data, we can now create a class that represents an animated sprites. Since an animated sprite is essentially a sprite that changes its texture region over time, we can build upon our existing Sprite class through inheritance. Note By inheriting from Sprite, our AnimatedSprite class automatically gets all the rendering properties (position, rotation, scale, etc.) while adding new animation-specific functionality. The key to this design is the Sprite.Region property. Our Sprite class already knows how to render whatever region is currently set, so our AnimatedSprite class just needs to update this region property to the correct animation frame at the right time. We will now create the initial structure for our AnimatedSprite class. In the Graphics folder within the MonoGameLibrary project, add a new file named AnimatedSprite.cs: using System; using Microsoft.Xna.Framework; namespace MonoGameLibrary.Graphics; public class AnimatedSprite : Sprite { } AnimatedSprite Members An animated sprite needs to track both its current animation state and timing information. Add the following members to the AnimatedSprite class: private int _currentFrame; private TimeSpan _elapsed; private Animation _animation; /// <summary> /// Gets or Sets the animation for this animated sprite. /// </summary> public Animation Animation { get => _animation; set { _animation = value; Region = _animation.Frames[0]; } } The class uses three private fields to manage its animation state: _currentFrame: Tracks which frame of the animation is currently being displayed. _elapsed: Keeps track of how much time has passed since the last frame change. _animation: Stores the current animation being played. The Animation property provides access to the current animation and ensures the sprite always starts with the first frame when a new animation is set. When you assign a new animation, the property's setter automatically updates the sprite's region to display the first frame of that animation. Note Starting with the first frame when setting a new animation ensures consistent behavior when switching between different animations. AnimatedSprite Constructors The AnimatedSprite class provides two ways to create an animated sprite. Add the following constructors: /// <summary> /// Creates a new animated sprite. /// </summary> public AnimatedSprite() { } /// <summary> /// Creates a new animated sprite with the specified frames and delay. /// </summary> /// <param name=\"animation\">The animation for this animated sprite.</param> public AnimatedSprite(Animation animation) { Animation = animation; } The default constructor creates an empty animated sprite that can be configured later. The parameterized constructor creates an animated sprite with a specified animation, which automatically sets the sprite's initial region to the first frame of that animation through the Animation property. Note Both constructors inherit from the base Sprite class, so an AnimatedSprite will have all the same rendering properties (position, rotation, scale, etc.) as a regular sprite. AnimatedSprite Methods The AnimatedSprite class needs a way to update its animation state over time. This is handled by adding an Update method: /// <summary> /// Updates this animated sprite. /// </summary> /// <param name=\"gameTime\">A snapshot of the game timing values provided by the framework.</param> public void Update(GameTime gameTime) { _elapsed += gameTime.ElapsedGameTime; if (_elapsed >= _animation.Delay) { _elapsed -= _animation.Delay; _currentFrame++; if (_currentFrame >= _animation.Frames.Count) { _currentFrame = 0; } Region = _animation.Frames[_currentFrame]; } } The Update method manages the animation timing and frame progression: Accumulates the time passed since the last update in _elapsed. When enough time has passed (defined by the animation's delay): Resets the elapsed time counter Advances to the next frame Loops back to the first frame if we have reached the end Updates the sprite's region to display the current frame Note Unlike the Sprite class which only needs a Draw method, the AnimatedSprite requires this additional Update method to handle frame changes over time. This follows MonoGame's update/draw pattern we first saw in Chapter 03 The Draw method inherited from the base Sprite class remains unchanged, as it will automatically use whatever frame is currently set as the sprite's region. Creating AnimatedSprites With The TextureAtlas Class Similar to the update we did to the TextureAtlas class in Chapter 08, creating an AnimatedSprite from the atlas would require Get the animation by name. Store it in a variable. Create a new animated sprite with that animation. We can simplify this process by adding an animated sprite creation method to the TextureAtlas class. Open TextureAtlas.cs and add the following method: /// <summary> /// Creates a new animated sprite using the animation from this texture atlas with the specified name. /// </summary> /// <param name=\"animationName\">The name of the animation to use.</param> /// <returns>A new AnimatedSprite using the animation with the specified name.</returns> public AnimatedSprite CreateAnimatedSprite(string animationName) { Animation animation = GetAnimation(animationName); return new AnimatedSprite(animation); } Using the AnimatedSprite Class We can now adjust our game to use the AnimatedSprite class to see our sprites come to life. Update the contents of Game1.cs with the following: using Microsoft.Xna.Framework; using Microsoft.Xna.Framework.Graphics; using Microsoft.Xna.Framework.Input; using MonoGameLibrary; using MonoGameLibrary.Graphics; namespace DungeonSlime; public class Game1 : Core { // Defines the slime animated sprite. private AnimatedSprite _slime; // Defines the bat animated sprite. private AnimatedSprite _bat; public Game1() : base(\"Dungeon Slime\", 1280, 720, false) { } protected override void Initialize() { // TODO: Add your initialization logic here base.Initialize(); } protected override void LoadContent() { // Create the texture atlas from the XML configuration file. TextureAtlas atlas = TextureAtlas.FromFile(Content, \"images/atlas-definition.xml\"); // Create the slime animated sprite from the atlas. _slime = atlas.CreateAnimatedSprite(\"slime-animation\"); _slime.Scale = new Vector2(4.0f, 4.0f); // Create the bat animated sprite from the atlas. _bat = atlas.CreateAnimatedSprite(\"bat-animation\"); _bat.Scale = new Vector2(4.0f, 4.0f); } protected override void Update(GameTime gameTime) { if (GamePad.GetState(PlayerIndex.One).Buttons.Back == ButtonState.Pressed || Keyboard.GetState().IsKeyDown(Keys.Escape)) Exit(); // Update the slime animated sprite. _slime.Update(gameTime); // Update the bat animated sprite. _bat.Update(gameTime); base.Update(gameTime); } protected override void Draw(GameTime gameTime) { // Clear the back buffer. GraphicsDevice.Clear(Color.CornflowerBlue); // Begin the sprite batch to prepare for rendering. SpriteBatch.Begin(samplerState: SamplerState.PointClamp); // Draw the slime sprite. _slime.Draw(SpriteBatch, Vector2.One); // Draw the bat sprite 10px to the right of the slime. _bat.Draw(SpriteBatch, new Vector2(_slime.Width + 10, 0)); // Always end the sprite batch when finished. SpriteBatch.End(); base.Draw(gameTime); } } Here are the key changes in this implementation: The _slime and _bat members were changed from Sprite to AnimatedSprite. In LoadContent the _slime and _bat sprites are now created using the new TextureAtlas.CreateAnimatedSprite method. In Update, the animations are updated based on the game time using the AnimatedSprite.Update method. Running the game now shows both sprites animating automatically: The slime bounces between two frames The bat's wings flap in a continuous cycle Figure 9-2: The slime and bat sprite animating Conclusion In this chapter, you accomplished the following: Created an Animation class to manage frame sequences and timing. Extended the TextureAtlas class to support animation definitions. Built an AnimatedSprite class that inherits from Sprite. Applied inheritance to add animation capabilities while maintaining existing sprite functionality. Used XML configuration to define animations separately from code. Now that we can efficiently manage and render sprites and animations, in the next chapter we will start taking a look at user input. Test Your Knowledge Why did we create a separate Animation class instead of putting animation properties directly in AnimatedSprite? :::question-answer Separating animation data into its own class allows multiple AnimatedSprite instances to share the same animation definition. This is more efficient than each sprite having its own copy of the frame sequence and timing information. ::: What is the benefit of using TimeSpan for animation delays instead of float values? :::question-answer TimeSpan provides precise timing control and makes it easier to synchronize animations with game time. It also makes the delay values more explicit (milliseconds vs arbitrary numbers) and helps prevent timing errors. ::: Why does the AnimatedSprite class need an Update method while the base Sprite class does not? :::question-answer The AnimatedSprite needs to track elapsed time and change frames based on the animation's timing. This requires updating its state over time, while a regular sprite's appearance remains static until explicitly changed. ::: In the TextureAtlas XML configuration, why might you want to reuse a frame in an animation sequence, like we did with the bat animation? :::question-answer Reusing frames in an animation sequence can create smoother animations by providing transition states. In the bat animation, reusing the neutral position (bat-1) between wing movements creates a more natural flapping motion without requiring additional sprite frames. :::"
  },
  "templates/docs.monogame.github.io/articles/tutorials/building_2d_games/10_handling_input/index.html": {
    "href": "templates/docs.monogame.github.io/articles/tutorials/building_2d_games/10_handling_input/index.html",
    "title": "Chapter 10: Handling Input | hallowed",
    "summary": "When you play a game, you need ways to control what is happening; using a keyboard or gamepad to control a character or clicking the mouse to navigate a menu, MonoGame helps us handle all these different types of controls through dedicated input classes: Keyboard: Detects which keys are being pressed. Mouse: Tracks mouse movement, button clicks, and scroll wheel use. GamePad: Manages controller input like button presses and thumbstick movement. TouchPanel: Manages touch input on devices with a touch panel such as mobile phones and tablets. Each of these input types has a GetState method that, when called, checks what is happening with that device at that moment. Think of it like taking a snapshot; when you call GetState, MonoGame looks at that exact moment to see which buttons are pressed, where the mouse is, or how the controller is being used. In this chapter, you will learn how to use each of these dedicated input classes to handle player input. Keyboard Input The keyboard is often the primary input device for PC games, used for everything from character movement to menu navigation. MonoGame provides the Keyboard class to handle keyboard input, making it easy to detect which keys are being pressed at any time. Calling Keyboard.GetState will retrieve the current state of the keyboard as a KeyboardState struct. KeyboardState Struct The KeyboardState struct contains methods that can be used to determine if a keyboard key is currently down or up: Method Description IsKeyDown(Keys) Returns true if the specified key is down; otherwise, returns false. IsKeyUp(Keys) Returns true if the specified key is up; otherwise, returns false. For example, if we wanted to see if the Space key is down, you could use the following: // Get the current state of keyboard input. KeyboardState keyboardState = Keyboard.GetState(); // Check if the space key is down. if(keyboardState.IsKeyDown(Keys.Space)) { // The space key is down, so do something. } Tip Notice we store the keyboard state in a variable instead of calling Keyboard.GetState multiple times. This is more efficient and ensures consistent input checking within a single frame. Mouse Input The mouse is often the secondary input device for PC games, used for various actions from camera movement to interacting with menus and objects. MonoGame provides the Mouse class to handle mouse input, making it easy to detect which buttons are pressed, the position of the mouse cursor, and the value of the scroll wheel. Calling Mouse.GetState will retrieve the current state of the mouse as a MouseState struct. MouseState Struct The MouseState struct contains properties that can be used to determine the state of the mouse buttons, the mouse position, and the scroll wheel value: Property Type Description LeftButton ButtonState Returns the state of the left mouse button. MiddleButton ButtonState Returns the state of the middle mouse button. This is often the button activated by pressing the scroll wheel down. Position Point Returns the position of the mouse cursor relative to the bounds of the game window. RightButton ButtonState Returns the state of the right mouse button. ScrollWheelValue int Returns the cumulative scroll wheel value since the start of the game XButton1 ButtonState Returns the state of the first extended button on the mouse. XButton2 ButtonState Returns the state of the second extended button on the mouse. Note ScrollWheelValue returns the cumulative value of the scroll wheel since the start of the game, not how much it moved since the last update. To determine how much it moved between one update and the next, you would need to compare it with the previous frame's value. We will discuss comparing previous and current frame values for inputs in the next chapter. Unlike keyboard input which uses IsKeyDown(Keys)/IsKeyUp(Keys) methods mouse buttons return a ButtonState: ButtonState.Pressed: The button is being held down. ButtonState.Released: The button is not being pressed. For example, if we wanted to see if the left mouse button is down, you could use the following // Get the current state of mouse input. MouseState mouseState = Mouse.GetState(); // Check if the left mouse button is pressed down. if(mouseState.LeftButton == ButtonState.Pressed) { // The left button is down, so do something. } Gamepad Input Gamepads are often used as a primary input for a game or an alternative for keyboard and mouse controls. MonoGame provides the GamePad class to handle gamepad input, making it easy to detect which buttons are pressed and the value of the thumbsticks. Calling GamePad.GetState will retrieve the state of the gamepad as a GamePadState struct. Since multiple gamepads can be connected, you will need to supply a PlayerIndex value to specify which gamepad state to retrieve. GamePadState Struct The GamePadState struct and properties that can be used to get the state of the buttons, dpad, triggers, and thumbsticks: Property Type Description Buttons GamePadButtons Returns a struct that identifies which buttons on the controller are pressed. DPad GamePadDPad Returns a struct that identifies which directions on the DPad are pressed. IsConnected bool Returns a value that indicates whether the controller is connected. ThumbSticks GamePadThumbSticks Returns a struct that contains the direction of each thumbstick. Each thumbstick (left and right) are represented as a Vector2 value between -1.0f and 1.0 for the x- and y-axes. Triggers GamePadTriggers Returns a struct that contains the value of each trigger. Each trigger (left and right) are represented as a float value between 0.0f, meaning not pressed, and 1.0f, meaning fully pressed. Buttons The GamePadState.Buttons property returns a GamePadButtons struct that can be used to identify which buttons on the controller are pressed. This struct contains the following properties: Property Type Description A ButtonState Returns the state of the A button B ButtonState Returns the state of the B button Back ButtonState Returns the state of the Back button BigButton ButtonState Returns the state of the BigButton button LeftShoulder ButtonState Returns the state of the LeftShoulder button LeftStick ButtonState Returns the state of the LeftStick button RightShoulder ButtonState Returns the state of the RightShoulder button RightStick ButtonState Returns the state of the RightStick button Start ButtonState Returns the state of the Start button X ButtonState Returns the state of the X button Y ButtonState Returns the state of the Y button Note Recall from Chapter 01 that MonoGame is a implementation the XNA API. Since XNA was originally created for making games on Windows PC and Xbox 360, the names of the gamepad buttons match those of an Xbox 360 controller. The BigButton refers to the large, centrally located button on special Xbox 360 controllers created for games like \"Scene It?\" - this button is not present on standard controllers and is not mapped to any button on modern controllers. It remains in the API for backward compatibility with XNA. Front Back Xbox Playstation Like with the mouse input, each of these buttons are represented by a ButtonState enum value. For instance, if you wanted to check if the A button is being pressed you could do the following: // Get the current state of player one's gamepad. GamePadState gamePadState = GamePad.GetState(PlayerIndex.One); // Check if the A button is pressed down. if(gamePadState.Buttons.A == ButtonState.Pressed) { // Button A is pressed, do something. } Note You may notice however, that the GamePadState also requires a controller index, as more than one can be connected at the same time. The latest Xbox console for instance can support up to 8 controllers at a time, for this reason you need to specify which controller you are listening for. Additionally, if you want ANY controller to start your game, you will need to loop through all possible controllers each frame until the first one \"picks up\". DPad The DPad property returns a GamePadDPad struct that can be used to identify which DPad buttons on the controller are pressed. This struct contains the following properties: Property Type Description Down ButtonState Returns the state of the DPad Down button. Left ButtonState Returns the state of the DPad Left button. Right ButtonState Returns the state of the DPad Right button. Up ButtonState Returns the state of the DPad Up Button. Like with the Buttons, these also return a ButtonState enum value to represent the state of the DPad button. For instance, if you wanted to check if the DPad up button is being pressed, you could do the following: // Get the current state of player one's gamepad. GamePadState gamePadState = GamePad.GetState(PlayerIndex.One); // Check if the down on the DPad is pressed. if(gamePadState.DPad.Down == ButtonState.Pressed) { // DPad down is pressed, do something. } Thumbsticks The ThumbSticks property returns a GamePadThumbSticks struct that can be used to retrieve the values of the left and right thumbsticks. This struct contains the following properties: Property Type Description Left Vector2 The direction the left thumbstick is pressed. Right Vector2 The direction the right thumbstick is pressed. The thumbstick values are represented as a Vector2 value: X-axis: A value between -1.0f (pushed fully to the left) and 1.0f (pushed fully to the right). Y-axis: A value between -1.0f (pushed fully downward) and 1.0f (pushed fully upward). For example, if you wanted to move a sprite using the left thumbstick, you could do the following: // Get the current state of player one's gamepad. GamePadState gamePadState = GamePad.GetState(PlayerIndex.One); // Get the value of the left thumbstick. Vector2 leftStick = gamePadState.Thumbsticks.Left; // Invert the y-axis value. leftStick.Y *= -1.0f; // Apply the value to the position of the sprite. sprite.Position += leftStick; Important Notice that we inverted the y-axis value of the thumbstick by multiplying it by -1.0f. This is necessary because the thumbstick y-axis values range from -1.0f (down) to 1.0f (up). The y-axis of the screen coordinates in MonoGame increases downward, as we saw in Chapter 06. This inversion aligns the thumbstick's y-axis value with the screen movement. Triggers The Triggers property returns a GamePadTriggers struct that can be used to retrieve the values of the left and right triggers. This struct contains the following properties: Property Type Description Left float The value of the left trigger. Right float The value of the left trigger. The trigger values are represented as a float value between 0.0f (not pressed) to 1.0f (fully pressed). The triggers on a gamepad, however, can be either analog or digital depending on the gamepad manufacturer. For gamepads with digital triggers, the value will always be either 0.0f or 1.0f, as a digital trigger does not register values in between based on the amount of pressure applied to the trigger. For example, if we were creating a racing game, the right trigger could be used for acceleration like the following: // Get the current state of player one's gamepad. GamePadState gamePadState = GamePad.GetState(PlayerIndex.One); // Get the acceleration based on how far the right trigger is pushed down. float acceleration = gamePadState.Triggers.Right; GamePadState Methods The GamePadState struct also contains two methods that can be used to get information about the device's inputs as either being up or down: Method Description IsButtonDown(Buttons) Returns a value that indicates whether the specified button is down. Multiple Buttons values can be given using the bitwise OR | operator. When multiple buttons are given, the return value indicates if all buttons specified are down, not just one of them. IsButtonUp(Buttons) Returns a value that indicates whether the specified button is up. Multiple Buttons values can be given using the bitwise OR | operator. When multiple buttons are given, the return value indicates if all buttons specified are up, not just one of them. You can use the IsButtonDown(Buttons) and IsButtonUp(Buttons) methods to get the state of all buttons, including the DPad. The following is a complete list of all of the Buttons enum values: Buttons.A Buttons.B Buttons.Back Buttons.BigButton Buttons.DPadDown Buttons.DPadLeft Buttons.DPadRight Buttons.DPadUp Buttons.LeftShoulder Buttons.LeftStick Buttons.LeftThumbstickDown Buttons.LeftThumbstickLeft Buttons.LeftThumbstickRight Buttons.LeftThumbstickUp Buttons.LeftTrigger Buttons.None Buttons.RightShoulder Buttons.RightStick Buttons.RightStickDown Buttons.RightStickLeft Buttons.RightStickRight Buttons.RightStickUp Buttons.RightTrigger Buttons.Start Buttons.X Buttons.Y Caution While you can use these methods to get the state of any of these button inputs, the state will only tell you if it is being pressed or released. For the actual thumbstick values and trigger values, you would need to use the properties instead. For example, if we wanted to check if the A button on the first gamepad is pressed, you could use the following: // Get the current state of player one's gamepad. GamePadState gamePadState = GamePad.GetState(PlayerIndex.One); // Check if the A button is down. if(gamePadState.IsButtonDown(Buttons.A)) { // The A button is pressed, do something. } GamePad Vibration Another capability of gamepads is haptic feedback through vibration motors. MonoGame allows you to control this feature using the GamePad.SetVibration method. This method takes three parameters: The PlayerIndex of the gamepad to vibrate. The intensity of the left motor (from 0.0f for no vibration to 1.0f for maximum vibration). The intensity of the right motor (using the same scale). Most modern gamepads have two vibration motors, a larger one (usually the left motor) for low-frequency rumble and a smaller one (usually the right motor) for high-frequency feedback. By controlling these independently, you can create various haptic effects: // Make the gamepad vibrate at full intensity. GamePad.SetVibration(PlayerIndex.One, 1.0f, 1.0f); // Stop all vibration. GamePad.SetVibration(PlayerIndex.One, 0.0f, 0.0f); // Create a subtle, low-intensity vibration. GamePad.SetVibration(PlayerIndex.One, 0.3f, 0.1f); TouchPanel Input For mobile devices such as Android/iOS phones and tablets, the primary input device is the touch panel screen. Touching a location on the screen is similar to clicking a location on your computer with a mouse. MonoGame provides the TouchPanel class to handle touch input. The TouchPanel class offers two ways of retrieving information about touch input: TouchPanel.GetState retrieves a TouchCollection struct that contains TouchLocation values for each point of touch on the touch panel. TouchPanel.ReadGesture retrieves a GestureSample struct that contains information about recent gestures that have been performed like a vertical or horizontal drag across the screen. TouchCollection When calling TouchPanel.GetState a TouchCollection struct is returned. This collection contains a TouchLocation value for each point of touch. TouchLocation Each TouchLocation value in a touch collection contains the following properties: Property Type Description Id int The id of the touch location. Position Vector2 The position of the touch location. Pressure float The amount of pressure applied at the touch location. (Only available for Android devices.) State TouchLocationState The current state of the touch location. The important properties of the location are the Position and the State The position property will tell us the location of the touch event, and the state can be one of the following values: State Description Invalid This touch location position is invalid. Moved This touch location position was updated or pressed at the same position. Pressed This touch location was pressed. Released This touch location was released. When the state is moved or pressed, then we know that location on the touch panel is being touched. So we can capture it and use it like the following: // Get the current state of touch input. TouchCollection touchCollection = TouchPanel.GetState(); foreach(TouchLocation touchLocation in touchCollection) { if(touchLocation.State == TouchLocationState.Pressed || touchLocation.State == TouchLocationState.Moved) { // The the location at touchLocation.Position is currently being pressed, // so we can act on that information. } } Note Unlike mouse input which only tracks a single point, TouchPanel supports multiple simultaneous touch points. The TouchCollection contains all active touch points, which is why we loop through them in the sample above. The state of a touch location progresses through the states typically in order of: Pressed: Initial contact with the screen. Moved : Touch point moved while maintaining contact. Released: Contact with screen ended. Invalid : Touch data is invalid (used when tracking data is lost). GestureSample When calling TouchPanel.ReadGesture a GestureSample struct containing the information about recent gestures that have been performed is returned. The GestureSample struct contains the following properties: Property Type Description Delta Vector2 Gets the delta information about the first touch-point in the gesture sample. Delta2 Vector2 Gets the delta information about the second touch-point in the gesture sample. GestureType GestureType Gets the type of the gesture. Position Vector2 Gets the position of the first touch-point in the gesture sample. Position2 Vector2 Gets the position of the second touch-point in the gesture sample. Note Gestures have two delta properties and two position properties. This is because some gestures require multiple touch inputs to perform, such as performing a pinch to zoom in or out. You would need the location of both touch points to determine the correct zoom to apply during the gesture. To determine what type of gesture is performed, we can get that from the GestureType property which will be one of the following values: Gesture Type Description DoubleTap The user double tapped the device twice which is always preceded by a Tap gesture. DragComplete States completion of a drag gesture (VerticalDrag, HorizontalDrag, or FreeDrag). Flick States that a touch was combined with a quick swipe. FreeDrag The user touched a point and then performed a free-form drag. Hold The user touched a single point for approximately one second. HorizontalDrag The user touched the screen and performed either a left-to-right or right-to-left drag gesture. None No gesture. Pinch The user converged or diverged two touch-points on the screen which is like a two-finger drag. PinchComplete An in-progress pinch gesture was completed. Tap The user touched a single point. VerticalDrag The user touched the screen and performed either a top-to-bottom or bottom-to-top drag gesture. Important Before gestures can be detected, they have to be enabled using TouchPanel.EnabledGestures. This can be done in Game.Initialize like the following: protected override void Initialize() { base.Initialize(); // Enable gestures we want to handle. TouchPanel.EnabledGestures = GestureType.Tap | GestureType.HorizontalDrag | GestureType.VerticalDrag; } The following is an example of using a gesture to detect horizontal and vertical drags: while(TouchPanel.IsGestureAvailable) { GestureSample gesture = TouchPanel.ReadGesture(); if(gesture.GestureType == GestureType.HorizontalDrag) { // A horizontal drag from left-to-right or right-to-left occurred. // You can use the Delta property to determine how much movement // occurred during the swipe. float xDragAmount = gesture.Delta.X; // Now do something with that information. } if(gesture.GestureType == GestureType.VerticalDrag) { // A vertical drag from top-to-bottom or bottom-to-top occurred. // You can use the Delta property to determine how much movement // occurred during the swipe. float yDragAmount = gesture.Delta.Y; // Now do something with that information. } } Important Notice above that we use a while loop with TouchPanel.IsGestureAvailable as the condition for the loop. The reason we do this is because when a user performs a gesture, such as a horizontal drag across the screen, very quickly, what can often occurs is a series of multiple small drag gestures are registered and queued. Each time TouchPanel.ReadGesture is called, it will dequeue the next gesture. So to ensure that we handle the complete gesture, we loop the gesture queue until there are none left. Implementing Input in Our Game For our game, we are going to implement keyboard and gamepad controls based on the following criteria: Keyboard Input Gamepad Input Description [Keys.W] and [Keys.Up] [Thumbstick.Left.Y] and [Buttons.DPadUp] Moves the slime up the screen. [Keys.S] and [Keys.Down] [Thumbstick.Left.Y] and [Buttons.DPadDown] Moves the slime down the screen [Keys.A] and [Keys.Left] [Thumbstick.Left.X] and [Buttons.DPadLeft] Moves the slime left on the screen. [Keys.D] and [Keys.Right] [Thumbstick.Left.X] and [Buttons.DPadRight] Moves the slime right on the screen. [Keys.Space] [Buttons.A] Increased the speed of the slime. Open Game1.cs in the DungeonSlime project and update it with the following: using Microsoft.Xna.Framework; using Microsoft.Xna.Framework.Graphics; using Microsoft.Xna.Framework.Input; using MonoGameLibrary; using MonoGameLibrary.Graphics; namespace DungeonSlime; public class Game1 : Core { // Defines the slime animated sprite. private AnimatedSprite _slime; // Defines the bat animated sprite. private AnimatedSprite _bat; // Tracks the position of the slime. private Vector2 _slimePosition; // Speed multiplier when moving. private const float MOVEMENT_SPEED = 5.0f; public Game1() : base(\"Dungeon Slime\", 1280, 720, false) { } protected override void Initialize() { // TODO: Add your initialization logic here base.Initialize(); } protected override void LoadContent() { // Create the texture atlas from the XML configuration file. TextureAtlas atlas = TextureAtlas.FromFile(Content, \"images/atlas-definition.xml\"); // Create the slime animated sprite from the atlas. _slime = atlas.CreateAnimatedSprite(\"slime-animation\"); _slime.Scale = new Vector2(4.0f, 4.0f); // Create the bat animated sprite from the atlas. _bat = atlas.CreateAnimatedSprite(\"bat-animation\"); _bat.Scale = new Vector2(4.0f, 4.0f); } protected override void Update(GameTime gameTime) { if (GamePad.GetState(PlayerIndex.One).Buttons.Back == ButtonState.Pressed || Keyboard.GetState().IsKeyDown(Keys.Escape)) Exit(); // Update the slime animated sprite. _slime.Update(gameTime); // Update the bat animated sprite. _bat.Update(gameTime); // Check for keyboard input and handle it. CheckKeyboardInput(); // Check for gamepad input and handle it. CheckGamePadInput(); base.Update(gameTime); } private void CheckKeyboardInput() { // Get the state of keyboard input KeyboardState keyboardState = Keyboard.GetState(); // If the space key is held down, the movement speed increases by 1.5 float speed = MOVEMENT_SPEED; if (keyboardState.IsKeyDown(Keys.Space)) { speed *= 1.5f; } // If the W or Up keys are down, move the slime up on the screen. if (keyboardState.IsKeyDown(Keys.W) || keyboardState.IsKeyDown(Keys.Up)) { _slimePosition.Y -= speed; } // if the S or Down keys are down, move the slime down on the screen. if (keyboardState.IsKeyDown(Keys.S) || keyboardState.IsKeyDown(Keys.Down)) { _slimePosition.Y += speed; } // If the A or Left keys are down, move the slime left on the screen. if (keyboardState.IsKeyDown(Keys.A) || keyboardState.IsKeyDown(Keys.Left)) { _slimePosition.X -= speed; } // If the D or Right keys are down, move the slime right on the screen. if (keyboardState.IsKeyDown(Keys.D) || keyboardState.IsKeyDown(Keys.Right)) { _slimePosition.X += speed; } } private void CheckGamePadInput() { GamePadState gamePadState = GamePad.GetState(PlayerIndex.One); // If the A button is held down, the movement speed increases by 1.5 // and the gamepad vibrates as feedback to the player. float speed = MOVEMENT_SPEED; if (gamePadState.IsButtonDown(Buttons.A)) { speed *= 1.5f; GamePad.SetVibration(PlayerIndex.One, 1.0f, 1.0f); } else { GamePad.SetVibration(PlayerIndex.One, 0.0f, 0.0f); } // Check thumbstick first since it has priority over which gamepad input // is movement. It has priority since the thumbstick values provide a // more granular analog value that can be used for movement. if (gamePadState.ThumbSticks.Left != Vector2.Zero) { _slimePosition.X += gamePadState.ThumbSticks.Left.X * speed; _slimePosition.Y -= gamePadState.ThumbSticks.Left.Y * speed; } else { // If DPadUp is down, move the slime up on the screen. if (gamePadState.IsButtonDown(Buttons.DPadUp)) { _slimePosition.Y -= speed; } // If DPadDown is down, move the slime down on the screen. if (gamePadState.IsButtonDown(Buttons.DPadDown)) { _slimePosition.Y += speed; } // If DPapLeft is down, move the slime left on the screen. if (gamePadState.IsButtonDown(Buttons.DPadLeft)) { _slimePosition.X -= speed; } // If DPadRight is down, move the slime right on the screen. if (gamePadState.IsButtonDown(Buttons.DPadRight)) { _slimePosition.X += speed; } } } protected override void Draw(GameTime gameTime) { // Clear the back buffer. GraphicsDevice.Clear(Color.CornflowerBlue); // Begin the sprite batch to prepare for rendering. SpriteBatch.Begin(samplerState: SamplerState.PointClamp); // Draw the slime sprite. _slime.Draw(SpriteBatch, _slimePosition); // Draw the bat sprite 10px to the right of the slime. _bat.Draw(SpriteBatch, new Vector2(_slime.Width + 10, 0)); // Always end the sprite batch when finished. SpriteBatch.End(); base.Draw(gameTime); } } The key changes made here are: The _slimePosition field was added to track the position of the slime as it moves. The MOVEMENT_SPEED constant was added to use as the base multiplier for the movement speed. The CheckKeyboardInput method was added which checks for input from the keyboard based on the input table above and moves the slime based on the keyboard input detected. The CheckGamePadInput method was added which checks for input from the gamepad based on the input table above and moves the slime based the gamepad input detected. Note The gamepad implementation includes a priority system for directional input. The code prioritizes the analog thumbstick values over the digital DPad buttons. This design choice provides players with more nuanced control, as analog inputs allow for a variable movement speed based on how far the thumbstick is pushed, while DPad buttons only provide on/off input states. The code first checks if either thumbstick axis has a non-zero value, and only falls back to DPad input when the thumbstick is centered. To enhance player experience, the gamepad implementation also includes gamepad vibration when the speed boost is activated. Haptic feedback like this creates a more immersive experience by engaging additional senses for the player beyond just visual and auditory feedback. In Update CheckKeyboardInput and CheckGamePadInput methods are called. In Draw, the slime is now drawn using _slimePosition as the position. Running the game now, you can move the slime around using the keyboard with the arrow keys or WASD keys. If you have a gamepad plugged in you can also use the DPad and left thumbstick. Figure 10-1: The slime moving around based on device input Note You may notice that the slime is capable of moving completely off the screen, this is completely normal as we have not yet implemented any logic to prevent it from doing so, it is only doing what we currently tell it to do. Input Buffering While checking for input every frame works well for continuous actions like movement, many games benefit from more sophisticated input handling techniques. One such technique is input buffering, which can significantly improve how responsive controls feel to players. Understanding Input Buffering Input buffering is a technique where the game temporarily stores player inputs that cannot be immediately processed. Instead of discarding these inputs, they are placed in a queue and processed in order when the game is ready to handle them. Input buffering is particularly valuable in games where: Actions occur at fixed intervals rather than continuously (like turn-based games or grid movement). Precise timing is required for complex input sequences (like fighting games). Multiple rapid inputs need to be remembered in order (like quick directional changes). Without input buffering, players must time their inputs perfectly to align with the game's update cycle. With buffering, the game becomes more forgiving and responsive by: Storing inputs that arrive between action updates. Preserving the order of inputs for more predictable behavior. Creating a sense that the game is actually listening to the player. Implementing a Simple Input Buffer A basic input buffer can be implemented using a queue data structure, which follows a First-In-First-Out (FIFO) pattern: // Use a queue directly for input buffering private Queue<Vector2> _inputBuffer; private const int MAX_BUFFER_SIZE = 2; // In initialization code: _inputBuffer = new Queue<Vector2>(MAX_BUFFER_SIZE); // In the input handling code: KeyboardState keyboard = Keyboard.GetState(); Vector2 newDirection = Vector2.Zero; if(keyboard.IsKeyDown(Keys.Up)) { newDirection = -Vector2.UnitY; } else if(keyboard.IsKeyDown(Keys.Down)) { newDirection = Vector2.UnitY; } else if(keyboard.IsKeyDown(Keys.Left)) { newDirection = -Vector2.UnitX; } else if(keyboard.IsKeyDown(Keys.Right)) { newDirection = Vector2.UnitX; } // Only add if a valid direction and does not exceed the buffer size. if(newDirection != Vector2.Zero && _inputBuffer.Count < MAX_BUFFER_SIZE) { _inputBuffer.Enqueue(newDirection); } // In movement update code. if(_inputBuffer.Count > 0) { Vector2 nextDirection = _inputBuffer.Dequeue(); _position += nextDirection * _speed; } Note The Queue<T> is a First In, First Out (FIFO) collection in C#. When you add items with Enqueue(), they join the end of the line, and when you retrieve items with Dequeue(), you always get the oldest item (the one at the front of the line). Think of it like people waiting in line - the first person to arrive is the first one served. This contrasts with a Stack<T>, which follows Last In, First Out (LIFO) behavior, where the most recently added item is the first one retrieved. The size of an input buffer is an important design decision. If it is too small, players might still feel the game is not responsive enough. If it is too large, the game might feel like it is playing itself by working through a backlog of commands. When to Use Input Buffering Consider implementing input buffering in your game when: Players complain about the game feeling \"unresponsive\". Your game uses fixed-interval updates for certain mechanics. Actions require precise timing that is difficult for players to hit consistently. You want to allow players to \"queue up\" their next few moves. We will see a practical implementation of input buffering in Chapter 23 when we finalize our snake-like game mechanics, where timing and direction changes are critical to gameplay. Conclusion In this chapter, you accomplished the following: Handle keyboard input to detect key presses. Handle mouse input including button clicks and cursor position. Work with gamepad controls including buttons, thumbsticks, and vibration. Understand touch input for mobile devices including touch points and gestures. Implement movement controls using different input methods. Consider controller-specific details like coordinate systems and analog vs digital input. In the next chapter, we will learn how to track previous input states to handle single-press events and implement an input management system to simplify some of the complexity of handling input. Test Your Knowledge Why do we store the result of GetState in a variable instead of calling it multiple times? :::question-answer Storing the state in a variable is more efficient and ensures consistent input checking within a frame. Each GetState call polls the device, which can impact performance if called repeatedly. ::: What is the main difference between how keyboard and mouse/gamepad button states are checked? :::question-answer Keyboard input uses IsKeyUp/IsKeyDown methods, while mouse and gamepad buttons return a ButtonState enum value (Pressed or Released). ::: When using thumbstick values for movement, why do we multiply the Y value by -1? :::question-answer The thumbstick Y-axis values (-1.0f down to 1.0f up) are inverted compared to MonoGame's screen coordinate system (Y increases downward). Multiplying by -1 aligns the thumbstick direction with screen movement. ::: What is the difference between analog and digital trigger input on a gamepad? :::question-answer Analog triggers provide values between 0.0f and 1.0f based on how far they are pressed, while digital triggers only report 0.0f (not pressed) or 1.0f (pressed). This affects how you handle trigger input in your game. ::: What is the key difference between TouchPanel.GetState and TouchPanel.ReadGesture? :::question-answer TouchPanel.GetState returns information about current touch points on the screen, while TouchPanel.ReadGesture provides information about specific gesture patterns like taps, drags, and pinches that have been performed. ::: Why do we use a while loop with TouchPanel.IsGestureAvailable when reading gestures? :::question-answer Quick gestures can generate multiple gesture events that are queued. Using a while loop with TouchPanel.IsGestureAvailable ensures we process all queued gestures, as TouchPanel.ReadGesture only returns one gesture at a time. ::: How does touch input differ from mouse input in terms of handling multiple input points? :::question-answer Touch input can handle multiple simultaneous touch points through the TouchCollection, while mouse input only tracks a single cursor position. This allows touch input to support features like multi-touch gestures that are not possible with a mouse. ::: What are the different states a TouchLocation can have and what do they indicate? :::question-answer A TouchLocation can have four states: Pressed: Initial contact with the screen Moved: Touch point moved while maintaining contact Released: Contact with the screen ended Invalid: Touch data is not valid or tracking was lost :::"
  },
  "templates/docs.monogame.github.io/articles/tutorials/building_2d_games/11_input_management/index.html": {
    "href": "templates/docs.monogame.github.io/articles/tutorials/building_2d_games/11_input_management/index.html",
    "title": "Chapter 11: Input Management | hallowed",
    "summary": "In Chapter 10, you learned how to handle input from various devices like keyboard, mouse, and gamepad. While checking if an input is currently down works well for continuous actions like movement, many game actions should only happen once when an input is first pressed; think firing a weapon or jumping. To handle these scenarios, we need to compare the current input state with the previous frame's state to detect when an input changes from up to down. In this chapter you will: Learn the difference between an input being down versus being pressed Track input states between frames Create a reusable input management system Simplify handling input across multiple devices We will start by understanding the concept of input state changes and how we can detect them. Understanding Input States When handling input in games, there are two key scenarios we need to consider: An input is being held down (like holding a movement key). An input was just pressed for one frame (like pressing a jump button). Now, we will look at the difference using keyboard input as an example. With our current implementation, we can check if a key is down using KeyboardState.IsKeyDown: // Get the current state of keyboard input. KeyboardState keyboardState = Keyboard.GetState(); // Check if the space key is down. if (keyboardState.IsKeyDown(Keys.Space)) { // This runs EVERY frame the space key is held down } However, many game actions should not repeat while a key is held. For instance, if the Space key makes your character jump, you probably do not want them to jump repeatedly just because the player is holding the key down. Instead, you want the jump to happen only on the first frame when Space is pressed. To detect this \"just pressed\" state, we need to compare two states: Is the key down in the current frame? Was the key up in the previous frame? If both conditions are true, we know the key was just pressed. If we were to modify the above code to track the previous keyboard state it would look something like this: // Track the state of keyboard input during the previous frame. private KeyboardState _previousKeyboardState; protected override void Update(GameTime gameTime) { // Get the current state of keyboard input. KeyboardState keyboardState = Keyboard.GetState(); // Compare if the space key is down on the current frame but was up on the previous frame. if (keyboardState.IsKeyDown(Keys.Space) && _previousKeyboardState.IsKeyUp(Keys.Space)) { // This will only run on the first frame Space is pressed and will not // happen again until it has been released and then pressed again. } // At the end of update, store the current state of keyboard input into the // previous state tracker. _previousKeyboardState = keyboardState; base.Update(gameTime); } If you need to know the inverse state, when the key was just released, then it is simply a matter of switching the checking of the states, for example, is the key up this frame and was it down in the previous frame. This same concept applies to mouse buttons and gamepad input as well. Any time you need to detect a \"just pressed\" or \"just released\" state, you will need to compare the current input state with the previous frame's state. So far, we have only been working with our game within the Game1.cs file. This has been fine for the examples given. Over time, as the game grows, we are going to have a more complex system set up with different scenes, and each scene will need a way to track the state of input over time. We could do this by creating a lot of variables in each scene to track this information, or we can use object-oriented design concepts to create a reusable InputManager class to simplify this for us. Before we create the InputManager class, we should first create classes for the keyboard, mouse, and gamepad that encapsulates the information about those inputs, which will then be exposed through the InputManager. To get started, create a new folder called Input in the MonoGameLibrary project. We will put all of our input related classes here. The KeyboardInfo Class We will start our input management system by creating a class to handle keyboard input. The KeyboardInfo class will encapsulate all keyboard-related functionality, making it easier to: Track current and previous keyboard states Detect when keys are pressed or released Check if keys are being held down In the Input folder of the MonoGameLibrary project, add a new file named KeyboardInfo.cs with this initial structure: using Microsoft.Xna.Framework.Input; namespace MonoGameLibrary.Input; public class KeyboardInfo { } KeyboardInfo Properties To detect changes in keyboard input between frames, we need to track both the previous and current keyboard states. Add these properties to the KeyboardInfo class: /// <summary> /// Gets the state of keyboard input during the previous update cycle. /// </summary> public KeyboardState PreviousState { get; private set; } /// <summary> /// Gets the state of keyboard input during the current input cycle. /// </summary> public KeyboardState CurrentState { get; private set; } Note These properties use a public getter but private setter pattern. This allows other parts of the game to read the keyboard states if needed, while ensuring only the KeyboardInfo class can update them. KeyboardInfo Constructor The KeyboardInfo class constructor needs to initialize the keyboard states. Add this constructor: /// <summary> /// Creates a new KeyboardInfo. /// </summary> public KeyboardInfo() { PreviousState = new KeyboardState(); CurrentState = Keyboard.GetState(); } The constructor: Creates an empty state for PreviousState since there is no previous input yet Gets the current keyboard state as our starting point for CurrentState This initialization ensures we have valid states to compare against in the first frame of our game, preventing any potential null reference issues when checking for input changes. KeyboardInfo Methods The KeyboardInfo class needs methods both for updating states and checking key states. First, we will start with our update method: /// <summary> /// Updates the state information about keyboard input. /// </summary> public void Update() { PreviousState = CurrentState; CurrentState = Keyboard.GetState(); } Note Each time Update is called, the current state becomes the previous state, and we get a fresh current state. This creates our frame-to-frame comparison chain. Next, we will add methods to check various key states: /// <summary> /// Returns a value that indicates if the specified key is currently down. /// </summary> /// <param name=\"key\">The key to check.</param> /// <returns>true if the specified key is currently down; otherwise, false.</returns> public bool IsKeyDown(Keys key) { return CurrentState.IsKeyDown(key); } /// <summary> /// Returns a value that indicates whether the specified key is currently up. /// </summary> /// <param name=\"key\">The key to check.</param> /// <returns>true if the specified key is currently up; otherwise, false.</returns> public bool IsKeyUp(Keys key) { return CurrentState.IsKeyUp(key); } /// <summary> /// Returns a value that indicates if the specified key was just pressed on the current frame. /// </summary> /// <param name=\"key\">The key to check.</param> /// <returns>true if the specified key was just pressed on the current frame; otherwise, false.</returns> public bool WasKeyJustPressed(Keys key) { return CurrentState.IsKeyDown(key) && PreviousState.IsKeyUp(key); } /// <summary> /// Returns a value that indicates if the specified key was just released on the current frame. /// </summary> /// <param name=\"key\">The key to check.</param> /// <returns>true if the specified key was just released on the current frame; otherwise, false.</returns> public bool WasKeyJustReleased(Keys key) { return CurrentState.IsKeyUp(key) && PreviousState.IsKeyDown(key); } These methods serve two distinct purposes. For checking continuous states: IsKeyDown: Returns true as long as the specified key is being held down. IsKeyUp: Returns true as long as the specified key is not being pressed. And for detecting state changes: WasKeyJustPressed: Returns true only on the frame when the specified key changes from up-to-down. WasKeyJustReleased: Returns true only on the frame when the specified key changes from down-to-up. Tip Use continuous state checks (IsKeyDown/IsKeyUp) for actions that should repeat while a key is held, like movement. Use single-frame checks (WasKeyJustPressed/WasKeyJustReleased) for actions that should happen once per key press, like jumping or shooting. That's it for the KeyboardInfo class, now we can move on to mouse input next. MouseButton Enum Recall from the Mouse Input section of the previous chapter that the MouseState struct provides button states through properties rather than methods like IsButtonDown/IsButtonUp. To keep our input management API consistent across devices, we will create a MouseButton enum that lets us reference mouse buttons in a similar way to how we use Keys for keyboard input and Buttons for gamepad input. In the Input folder of the MonoGameLibrary project, add a new file named MouseButton.cs with the following code: namespace MonoGameLibrary.Input; public enum MouseButton { Left, Middle, Right, XButton1, XButton2 } Note Each enum value corresponds directly to a button property in MouseState: Left: Maps to MouseState.LeftButton. Middle: Maps to MouseState.MiddleButton. Right: Maps to MouseState.RightButton. XButton1: Maps to MouseState.XButton1. XButton2: Maps to MouseState.XButton2. The MouseInfo Class To manage mouse input effectively, we need to track both current and previous states, as well as provide easy access to mouse position, scroll wheel values, and button states. The MouseInfo class will encapsulate all of this functionality, making it easier to: Track current and previous mouse states. Track the mouse position. Check the change in mouse position between frames and if it was moved. Track scroll wheel changes. Detect when mouse buttons are pressed or released Check if mouse buttons are being held down To get started, in the Input folder of the MonoGameLibrary project, create a new file named MouseInfo.cs with the following initial structure: using Microsoft.Xna.Framework; using Microsoft.Xna.Framework.Input; namespace MonoGameLibrary.Input; public class MouseInfo { } MouseInfo Properties The MouseInfo class needs properties to track both mouse states and provide easy access to common mouse information. Add the following properties to the MouseInfo class: First, we need properties for tracking mouse states: /// <summary> /// The state of mouse input during the previous update cycle. /// </summary> public MouseState PreviousState { get; private set; } /// <summary> /// The state of mouse input during the current update cycle. /// </summary> public MouseState CurrentState { get; private set; } Next, we will add properties for handling cursor position: /// <summary> /// Gets or Sets the current position of the mouse cursor in screen space. /// </summary> public Point Position { get => CurrentState.Position; set => SetPosition(value.X, value.Y); } /// <summary> /// Gets or Sets the current x-coordinate position of the mouse cursor in screen space. /// </summary> public int X { get => CurrentState.X; set => SetPosition(value, CurrentState.Y); } /// <summary> /// Gets or Sets the current y-coordinate position of the mouse cursor in screen space. /// </summary> public int Y { get => CurrentState.Y; set => SetPosition(CurrentState.X, value); } Note The position properties use a SetPosition method that we will implement later. This method will handle the actual cursor positioning on screen. These properties provide different ways to work with the cursor position: Position: Gets/sets the cursor position as a Point. X: Gets/sets just the horizontal position. Y: Gets/sets just the vertical position. Next, we will add properties for determining if the mouse cursor moved between game frames and if so how much: /// <summary> /// Gets the difference in the mouse cursor position between the previous and current frame. /// </summary> public Point PositionDelta => CurrentState.Position - PreviousState.Position; /// <summary> /// Gets the difference in the mouse cursor x-position between the previous and current frame. /// </summary> public int XDelta => CurrentState.X - PreviousState.X; /// <summary> /// Gets the difference in the mouse cursor y-position between the previous and current frame. /// </summary> public int YDelta => CurrentState.Y - PreviousState.Y; /// <summary> /// Gets a value that indicates if the mouse cursor moved between the previous and current frames. /// </summary> public bool WasMoved => PositionDelta != Point.Zero; The properties provide different ways of detecting mouse movement between frames: PositionDelta: Gets how much the cursor moved between frames as a Point. XDelta: Gets how much the cursor moved horizontally between frames. YDelta: Gets how much the cursor moved vertically between frames. WasMoved: Indicates if the cursor moved between frames. Finally, we will add properties for handling the scroll wheel: /// <summary> /// Gets the cumulative value of the mouse scroll wheel since the start of the game. /// </summary> public int ScrollWheel => CurrentState.ScrollWheelValue; /// <summary> /// Gets the value of the scroll wheel between the previous and current frame. /// </summary> public int ScrollWheelDelta => CurrentState.ScrollWheelValue - PreviousState.ScrollWheelValue; The scroll wheel properties serve different purposes: ScrollWheel: Gets the total accumulated scroll value since game start. ScrollWheelDelta: Gets the change in scroll value just in this frame. Tip Use ScrollWheelDelta when you need to respond to how much the user just scrolled, rather than tracking the total scroll amount. MouseInfo Constructor The MouseInfo class constructor needs to initialize the mouse states. Add this constructor: /// <summary> /// Creates a new MouseInfo. /// </summary> public MouseInfo() { PreviousState = new MouseState(); CurrentState = Mouse.GetState(); } The constructor: Creates an empty state for PreviousState since there is no previous input yet. Gets the current mouse state as our starting point for CurrentState. This initialization ensures we have valid states to compare against in the first frame of our game, preventing any potential null reference issues when checking for input changes. MouseInfo Methods The MouseInfo class needs methods for updating states, checking button states, and setting the cursor position. Add the following method to the MouseInfo class: /// <summary> /// Updates the state information about mouse input. /// </summary> public void Update() { PreviousState = CurrentState; CurrentState = Mouse.GetState(); } Next, we will add methods to check various button states: /// <summary> /// Returns a value that indicates whether the specified mouse button is currently down. /// </summary> /// <param name=\"button\">The mouse button to check.</param> /// <returns>true if the specified mouse button is currently down; otherwise, false.</returns> public bool IsButtonDown(MouseButton button) { switch (button) { case MouseButton.Left: return CurrentState.LeftButton == ButtonState.Pressed; case MouseButton.Middle: return CurrentState.MiddleButton == ButtonState.Pressed; case MouseButton.Right: return CurrentState.RightButton == ButtonState.Pressed; case MouseButton.XButton1: return CurrentState.XButton1 == ButtonState.Pressed; case MouseButton.XButton2: return CurrentState.XButton2 == ButtonState.Pressed; default: return false; } } /// <summary> /// Returns a value that indicates whether the specified mouse button is current up. /// </summary> /// <param name=\"button\">The mouse button to check.</param> /// <returns>true if the specified mouse button is currently up; otherwise, false.</returns> public bool IsButtonUp(MouseButton button) { switch (button) { case MouseButton.Left: return CurrentState.LeftButton == ButtonState.Released; case MouseButton.Middle: return CurrentState.MiddleButton == ButtonState.Released; case MouseButton.Right: return CurrentState.RightButton == ButtonState.Released; case MouseButton.XButton1: return CurrentState.XButton1 == ButtonState.Released; case MouseButton.XButton2: return CurrentState.XButton2 == ButtonState.Released; default: return false; } } /// <summary> /// Returns a value that indicates whether the specified mouse button was just pressed on the current frame. /// </summary> /// <param name=\"button\">The mouse button to check.</param> /// <returns>true if the specified mouse button was just pressed on the current frame; otherwise, false.</returns> public bool WasButtonJustPressed(MouseButton button) { switch (button) { case MouseButton.Left: return CurrentState.LeftButton == ButtonState.Pressed && PreviousState.LeftButton == ButtonState.Released; case MouseButton.Middle: return CurrentState.MiddleButton == ButtonState.Pressed && PreviousState.MiddleButton == ButtonState.Released; case MouseButton.Right: return CurrentState.RightButton == ButtonState.Pressed && PreviousState.RightButton == ButtonState.Released; case MouseButton.XButton1: return CurrentState.XButton1 == ButtonState.Pressed && PreviousState.XButton1 == ButtonState.Released; case MouseButton.XButton2: return CurrentState.XButton2 == ButtonState.Pressed && PreviousState.XButton2 == ButtonState.Released; default: return false; } } /// <summary> /// Returns a value that indicates whether the specified mouse button was just released on the current frame. /// </summary> /// <param name=\"button\">The mouse button to check.</param> /// <returns>true if the specified mouse button was just released on the current frame; otherwise, false.</returns> public bool WasButtonJustReleased(MouseButton button) { switch (button) { case MouseButton.Left: return CurrentState.LeftButton == ButtonState.Released && PreviousState.LeftButton == ButtonState.Pressed; case MouseButton.Middle: return CurrentState.MiddleButton == ButtonState.Released && PreviousState.MiddleButton == ButtonState.Pressed; case MouseButton.Right: return CurrentState.RightButton == ButtonState.Released && PreviousState.RightButton == ButtonState.Pressed; case MouseButton.XButton1: return CurrentState.XButton1 == ButtonState.Released && PreviousState.XButton1 == ButtonState.Pressed; case MouseButton.XButton2: return CurrentState.XButton2 == ButtonState.Released && PreviousState.XButton2 == ButtonState.Pressed; default: return false; } } These methods serve two distinct purposes. For checking continuous states: IsButtonDown: Returns true as long as the specified button is being held down. IsButtonUp: Returns true as long as the specified button is not being pressed. And for detecting state changes: WasButtonJustPressed: Returns true only on the frame when the specified button changes from up-to-down. WasButtonJustReleased: Returns true only on the frame when the specified button changes from down-to-up. Note Each method uses a switch statement to check the appropriate button property from the MouseState based on which MouseButton enum value is provided. This provides a consistent API while handling the different button properties internally. Finally, we need a method to handle setting the cursor position: /// <summary> /// Sets the current position of the mouse cursor in screen space and updates the CurrentState with the new position. /// </summary> /// <param name=\"x\">The x-coordinate location of the mouse cursor in screen space.</param> /// <param name=\"y\">The y-coordinate location of the mouse cursor in screen space.</param> public void SetPosition(int x, int y) { Mouse.SetPosition(x, y); CurrentState = new MouseState( x, y, CurrentState.ScrollWheelValue, CurrentState.LeftButton, CurrentState.MiddleButton, CurrentState.RightButton, CurrentState.XButton1, CurrentState.XButton2 ); } Tip Notice that after setting the position, we immediately update the CurrentState. This ensures our state tracking remains accurate even when manually moving the cursor. That's it for the MouseInfo class, next we will move onto gamepad input. The GamePadInfo Class To manage gamepad input effectively, we need to track both current and previous states, is the gamepad still connected, as well as provide easy access to the thumbstick values, trigger values, and button states. The GamePadInfo class will encapsulate all of this functionality, making it easier to: Track current and previous gamepad states. Check if the gamepad is still connected. Track the position of the left and right thumbsticks. Check the values of the left and right triggers. Detect when gamepad buttons are pressed or released. Check if gamepad buttons are being held down. Start and Stop vibration of a gamepad. To get started, in the Input folder of the MonoGameLibrary project, create a new file named GamePadInfo.cs with the following initial structure: using System; using Microsoft.Xna.Framework; using Microsoft.Xna.Framework.Input; namespace MonoGameLibrary.Input; public class GamePadInfo { } GamePadInfo Properties We use vibration in gamepads to provide haptic feedback to the player. The GamePad class provides the SetVibration method to tell the gamepad to vibrate, but it does not provide a timing mechanism for it if we wanted to only vibrate for a certain period of time. Add the following private field to the GamePadInfo class: private TimeSpan _vibrationTimeRemaining = TimeSpan.Zero; If you recall from the previous chapter, a PlayerIndex value needs to be supplied when calling Gamepad.GetState. Doing this returns the state of the gamepad connected at that player index. So we will need a property to track the player index this gamepad info is for. /// <summary> /// Gets the index of the player this gamepad is for. /// </summary> public PlayerIndex PlayerIndex { get; } To detect changes in the gamepad input between frames, we need to track both the previous and current gamepad states. Add these properties to the GamePadInfo class: /// <summary> /// Gets the state of input for this gamepad during the previous update cycle. /// </summary> public GamePadState PreviousState { get; private set; } /// <summary> /// Gets the state of input for this gamepad during the current update cycle. /// </summary> public GamePadState CurrentState { get; private set; } There are times that a gamepad can disconnect for various reasons; being unplugged, bluetooth disconnection, or battery dying are just some examples. To track if the gamepad is connected, add the following property: /// <summary> /// Gets a value that indicates if this gamepad is currently connected. /// </summary> public bool IsConnected => CurrentState.IsConnected; The values of the thumbsticks and triggers can be accessed through the CurrentState. However, instead of having to navigate through multiple property chains to get this information, add the following properties to get direct access to the values: /// <summary> /// Gets the value of the left thumbstick of this gamepad. /// </summary> public Vector2 LeftThumbStick => CurrentState.ThumbSticks.Left; /// <summary> /// Gets the value of the right thumbstick of this gamepad. /// </summary> public Vector2 RightThumbStick => CurrentState.ThumbSticks.Right; /// <summary> /// Gets the value of the left trigger of this gamepad. /// </summary> public float LeftTrigger => CurrentState.Triggers.Left; /// <summary> /// Gets the value of the right trigger of this gamepad. /// </summary> public float RightTrigger => CurrentState.Triggers.Right; GamePadInfo Constructor The GamePadInfo class constructor needs to initialize the gamepad states. Add this constructor: /// <summary> /// Creates a new GamePadInfo for the gamepad connected at the specified player index. /// </summary> /// <param name=\"playerIndex\">The index of the player for this gamepad.</param> public GamePadInfo(PlayerIndex playerIndex) { PlayerIndex = playerIndex; PreviousState = new GamePadState(); CurrentState = GamePad.GetState(playerIndex); } This constructor Requires a PlayerIndex value which is stored and will be used to get the states for the correct gamepad Creates an empty state for PreviousState since there is no previous state yet. Gets the current gamepad state as our starting CurrentState. This initialization ensures we have valid states to compare against in the first frame of our game, preventing any potential null reference issues when checking for input changes. GamePadInfo Methods The GamePadInfo class needs methods for updating states, checking button states, and controlling vibration. Add the following method to the GamePadInfo class: /// <summary> /// Updates the state information for this gamepad input. /// </summary> /// <param name=\"gameTime\"></param> public void Update(GameTime gameTime) { PreviousState = CurrentState; CurrentState = GamePad.GetState(PlayerIndex); if (_vibrationTimeRemaining > TimeSpan.Zero) { _vibrationTimeRemaining -= gameTime.ElapsedGameTime; if (_vibrationTimeRemaining <= TimeSpan.Zero) { StopVibration(); } } } Note Unlike keyboard and mouse input, the gamepad update method takes a GameTime parameter. This allows us to track and manage timed vibration effects. Next, we will add methods to check various button states: /// <summary> /// Returns a value that indicates whether the specified gamepad button is current down. /// </summary> /// <param name=\"button\">The gamepad button to check.</param> /// <returns>true if the specified gamepad button is currently down; otherwise, false.</returns> public bool IsButtonDown(Buttons button) { return CurrentState.IsButtonDown(button); } /// <summary> /// Returns a value that indicates whether the specified gamepad button is currently up. /// </summary> /// <param name=\"button\">The gamepad button to check.</param> /// <returns>true if the specified gamepad button is currently up; otherwise, false.</returns> public bool IsButtonUp(Buttons button) { return CurrentState.IsButtonUp(button); } /// <summary> /// Returns a value that indicates whether the specified gamepad button was just pressed on the current frame. /// </summary> /// <param name=\"button\">The gamepad button to check.</param> /// <returns>true if the specified gamepad button was just pressed on the current frame; otherwise, false.</returns> public bool WasButtonJustPressed(Buttons button) { return CurrentState.IsButtonDown(button) && PreviousState.IsButtonUp(button); } /// <summary> /// Returns a value that indicates whether the specified gamepad button was just released on the current frame. /// </summary> /// <param name=\"button\">The gamepad button to check.</param> /// <returns>true if the specified gamepad button was just released on the current frame; otherwise, false.</returns> public bool WasButtonJustReleased(Buttons button) { return CurrentState.IsButtonUp(button) && PreviousState.IsButtonDown(button); } These methods serve two distinct purposes. For checking continuous states: IsButtonDown: Returns true as long as a button is being held down. IsButtonUp: Returns true as long as a button is not being pressed. And for detecting state changes: WasButtonJustPressed: Returns true only on the frame when a button changes from up-to-down. WasButtonJustReleased: Returns true only on the frame when a button changes from down-to-up. Finally, we will add methods for controlling gamepad vibration: /// <summary> /// Sets the vibration for all motors of this gamepad. /// </summary> /// <param name=\"strength\">The strength of the vibration from 0.0f (none) to 1.0f (full).</param> /// <param name=\"time\">The amount of time the vibration should occur.</param> public void SetVibration(float strength, TimeSpan time) { _vibrationTimeRemaining = time; GamePad.SetVibration(PlayerIndex, strength, strength); } /// <summary> /// Stops the vibration of all motors for this gamepad. /// </summary> public void StopVibration() { GamePad.SetVibration(PlayerIndex, 0.0f, 0.0f); } The vibration methods provide control over the gamepad's haptic feedback: SetVibration: Starts vibration at the specified strength for a set duration. StopVibration: Immediately stops all vibration. Tip When setting vibration, you can specify both the strength (0.0f to 1.0f) and duration. The vibration will automatically stop after the specified time has elapsed, so you do not need to manage stopping it manually. That's it for the GamePadInfo class. Next, we can create the actual input manager. The InputManager Class Now that we have classes to handle keyboard, mouse, and gamepad input individually, we can create a centralized manager class to coordinate all input handling. In the Input folder of the MonoGameLibrary project, add a new file named InputManager.cs with this initial structure: using Microsoft.Xna.Framework; namespace MonoGameLibrary.Input; public class InputManager { } InputManager Properties The InputManager class needs properties to access each type of input device. Add these properties: /// <summary> /// Gets the state information of keyboard input. /// </summary> public KeyboardInfo Keyboard { get; private set; } /// <summary> /// Gets the state information of mouse input. /// </summary> public MouseInfo Mouse { get; private set; } /// <summary> /// Gets the state information of a gamepad. /// </summary> public GamePadInfo[] GamePads { get; private set; } Note The GamePads property is an array because MonoGame supports up to four gamepads simultaneously. Each gamepad is associated with a PlayerIndex (0-3). InputManager Constructor The constructor for the InputManager initializes the keyboard, mouse, and gamepad states. Add the following constructor: /// <summary> /// Creates a new InputManager. /// </summary> public InputManager() { Keyboard = new KeyboardInfo(); Mouse = new MouseInfo(); GamePads = new GamePadInfo[4]; for (int i = 0; i < 4; i++) { GamePads[i] = new GamePadInfo((PlayerIndex)i); } } InputManager Methods The Update method for the InputManager calls update for each device, so that they can update their internal states. /// <summary> /// Updates the state information for the keyboard, mouse, and gamepad inputs. /// </summary> /// <param name=\"gameTime\">A snapshot of the timing values for the current frame.</param> public void Update(GameTime gameTime) { Keyboard.Update(); Mouse.Update(); for (int i = 0; i < 4; i++) { GamePads[i].Update(gameTime); } } Implementing the InputManager Class Now that we have our input management system complete, we will update our game to use it. We will do this in two steps: First, update the Core class to add the InputManager globally. Update the Game1 class to use the global input manager from Core. Updating the Core Class The Core class serves as our base game class, so we will update it to add and expose the InputManager globally. Open the Core.cs file in the MonoGameLibrary project and update it to the following: using System; using Microsoft.Xna.Framework; using Microsoft.Xna.Framework.Content; using Microsoft.Xna.Framework.Graphics; using Microsoft.Xna.Framework.Input; using MonoGameLibrary.Input; namespace MonoGameLibrary; public class Core : Game { internal static Core s_instance; /// <summary> /// Gets a reference to the Core instance. /// </summary> public static Core Instance => s_instance; /// <summary> /// Gets the graphics device manager to control the presentation of graphics. /// </summary> public static GraphicsDeviceManager Graphics { get; private set; } /// <summary> /// Gets the graphics device used to create graphical resources and perform primitive rendering. /// </summary> public static new GraphicsDevice GraphicsDevice { get; private set; } /// <summary> /// Gets the sprite batch used for all 2D rendering. /// </summary> public static SpriteBatch SpriteBatch { get; private set; } /// <summary> /// Gets the content manager used to load global assets. /// </summary> public static new ContentManager Content { get; private set; } /// <summary> /// Gets a reference to the input management system. /// </summary> public static InputManager Input { get; private set; } /// <summary> /// Gets or Sets a value that indicates if the game should exit when the esc key on the keyboard is pressed. /// </summary> public static bool ExitOnEscape { get; set; } /// <summary> /// Creates a new Core instance. /// </summary> /// <param name=\"title\">The title to display in the title bar of the game window.</param> /// <param name=\"width\">The initial width, in pixels, of the game window.</param> /// <param name=\"height\">The initial height, in pixels, of the game window.</param> /// <param name=\"fullScreen\">Indicates if the game should start in fullscreen mode.</param> public Core(string title, int width, int height, bool fullScreen) { // Ensure that multiple cores are not created. if (s_instance != null) { throw new InvalidOperationException($\"Only a single Core instance can be created\"); } // Store reference to engine for global member access. s_instance = this; // Create a new graphics device manager. Graphics = new GraphicsDeviceManager(this); // Set the graphics defaults. Graphics.PreferredBackBufferWidth = width; Graphics.PreferredBackBufferHeight = height; Graphics.IsFullScreen = fullScreen; // Apply the graphic presentation changes. Graphics.ApplyChanges(); // Set the window title. Window.Title = title; // Set the core's content manager to a reference of the base Game's // content manager. Content = base.Content; // Set the root directory for content. Content.RootDirectory = \"Content\"; // Mouse is visible by default. IsMouseVisible = true; // Exit on escape is true by default ExitOnEscape = true; } protected override void Initialize() { base.Initialize(); // Set the core's graphics device to a reference of the base Game's // graphics device. GraphicsDevice = base.GraphicsDevice; // Create the sprite batch instance. SpriteBatch = new SpriteBatch(GraphicsDevice); // Create a new input manager. Input = new InputManager(); } protected override void Update(GameTime gameTime) { // Update the input manager. Input.Update(gameTime); if (ExitOnEscape && Input.Keyboard.IsKeyDown(Keys.Escape)) { Exit(); } base.Update(gameTime); } } The key changes to the Core class are: Added the using MonoGameLibrary.Input; directive to access the InputManager class. Added a static Input property to provide global access to the input manager. Added a static ExitOnEscape property to set whether the game should exit when the Escape key on the keyboard is pressed. In the Core constructor, ExitOnEscape is set to true by default to mirror how the default MonoGame Game1 class template has this functionality by default. In Initialize the input manager is created. Added an override for the Update method where: The input manager is updated A check is made to see if ExitOnEscape is true and if the Escape keyboard key is pressed. Updating the Game1 Class Now we can update our Game1 class to use the new input management system through the Core class. Open Game1.cs in the game project and update it to the following: using System; using Microsoft.Xna.Framework; using Microsoft.Xna.Framework.Graphics; using Microsoft.Xna.Framework.Input; using MonoGameLibrary; using MonoGameLibrary.Graphics; using MonoGameLibrary.Input; namespace DungeonSlime; public class Game1 : Core { // Defines the slime animated sprite. private AnimatedSprite _slime; // Defines the bat animated sprite. private AnimatedSprite _bat; // Tracks the position of the slime. private Vector2 _slimePosition; // Speed multiplier when moving. private const float MOVEMENT_SPEED = 5.0f; public Game1() : base(\"Dungeon Slime\", 1280, 720, false) { } protected override void Initialize() { // TODO: Add your initialization logic here base.Initialize(); } protected override void LoadContent() { // Create the texture atlas from the XML configuration file. TextureAtlas atlas = TextureAtlas.FromFile(Content, \"images/atlas-definition.xml\"); // Create the slime animated sprite from the atlas. _slime = atlas.CreateAnimatedSprite(\"slime-animation\"); _slime.Scale = new Vector2(4.0f, 4.0f); // Create the bat animated sprite from the atlas. _bat = atlas.CreateAnimatedSprite(\"bat-animation\"); _bat.Scale = new Vector2(4.0f, 4.0f); } protected override void Update(GameTime gameTime) { // Update the slime animated sprite. _slime.Update(gameTime); // Update the bat animated sprite. _bat.Update(gameTime); // Check for keyboard input and handle it. CheckKeyboardInput(); // Check for gamepad input and handle it. CheckGamePadInput(); base.Update(gameTime); } private void CheckKeyboardInput() { // If the space key is held down, the movement speed increases by 1.5 float speed = MOVEMENT_SPEED; if (Input.Keyboard.IsKeyDown(Keys.Space)) { speed *= 1.5f; } // If the W or Up keys are down, move the slime up on the screen. if (Input.Keyboard.IsKeyDown(Keys.W) || Input.Keyboard.IsKeyDown(Keys.Up)) { _slimePosition.Y -= speed; } // if the S or Down keys are down, move the slime down on the screen. if (Input.Keyboard.IsKeyDown(Keys.S) || Input.Keyboard.IsKeyDown(Keys.Down)) { _slimePosition.Y += speed; } // If the A or Left keys are down, move the slime left on the screen. if (Input.Keyboard.IsKeyDown(Keys.A) || Input.Keyboard.IsKeyDown(Keys.Left)) { _slimePosition.X -= speed; } // If the D or Right keys are down, move the slime right on the screen. if (Input.Keyboard.IsKeyDown(Keys.D) || Input.Keyboard.IsKeyDown(Keys.Right)) { _slimePosition.X += speed; } } private void CheckGamePadInput() { GamePadInfo gamePadOne = Input.GamePads[(int)PlayerIndex.One]; // If the A button is held down, the movement speed increases by 1.5 // and the gamepad vibrates as feedback to the player. float speed = MOVEMENT_SPEED; if (gamePadOne.IsButtonDown(Buttons.A)) { speed *= 1.5f; gamePadOne.SetVibration(1.0f, TimeSpan.FromSeconds(1)); } else { gamePadOne.StopVibration(); } // Check thumbstick first since it has priority over which gamepad input // is movement. It has priority since the thumbstick values provide a // more granular analog value that can be used for movement. if (gamePadOne.LeftThumbStick != Vector2.Zero) { _slimePosition.X += gamePadOne.LeftThumbStick.X * speed; _slimePosition.Y -= gamePadOne.LeftThumbStick.Y * speed; } else { // If DPadUp is down, move the slime up on the screen. if (gamePadOne.IsButtonDown(Buttons.DPadUp)) { _slimePosition.Y -= speed; } // If DPadDown is down, move the slime down on the screen. if (gamePadOne.IsButtonDown(Buttons.DPadDown)) { _slimePosition.Y += speed; } // If DPapLeft is down, move the slime left on the screen. if (gamePadOne.IsButtonDown(Buttons.DPadLeft)) { _slimePosition.X -= speed; } // If DPadRight is down, move the slime right on the screen. if (gamePadOne.IsButtonDown(Buttons.DPadRight)) { _slimePosition.X += speed; } } } protected override void Draw(GameTime gameTime) { // Clear the back buffer. GraphicsDevice.Clear(Color.CornflowerBlue); // Begin the sprite batch to prepare for rendering. SpriteBatch.Begin(samplerState: SamplerState.PointClamp); // Draw the slime sprite. _slime.Draw(SpriteBatch, _slimePosition); // Draw the bat sprite 10px to the right of the slime. _bat.Draw(SpriteBatch, new Vector2(_slime.Width + 10, 0)); // Always end the sprite batch when finished. SpriteBatch.End(); base.Draw(gameTime); } } The key changes to the Game1 class are: In Update, the check for the gamepad back button or keyboard escape key being pressed was removed. This is now handled by the ExitOnEscape property and the Update method of the Core class. In CheckKeyboardInput and CheckGamepadInput, instead of getting the keyboard and gamepad states and then using the states, calls to check those devices are now done through the input. Running the game now, you will be able to control it the same as before, only now we are using our new InputManager class instead. Figure 11-1: The slime moving around based on device input Conclusion In this chapter, you accomplished the following: Detect the difference between continuous and single-frame input states. Create classes to manage different input devices. Build a centralized InputManager to coordinate all input handling that is: Reusable across different game projects Easy to maintain and extend Consistent across different input devices Integrate the input system into the Core class for global access. Update the game to use the new input management system. Test Your Knowledge What is the difference between checking if an input is \"down\" versus checking if it was \"just pressed\"? :::question-answer \"Down\" checks if an input is currently being held, returning true every frame while held. \"Just pressed\" only returns true on the first frame when the input changes from up to down, requiring comparison between current and previous states. ::: Why do we track both current and previous input states? :::question-answer Tracking both states allows us to detect when input changes occur by comparing the current frame's state with the previous frame's state. This is essential for implementing \"just pressed\" and \"just released\" checks. ::: What advantage does the InputManager provide over handling input directly? :::question-answer The InputManager centralizes all input handling, automatically tracks states between frames, and provides a consistent API across different input devices. This makes the code more organized, reusable, and easier to maintain. :::"
  },
  "templates/docs.monogame.github.io/articles/tutorials/building_2d_games/12_collision_detection/index.html": {
    "href": "templates/docs.monogame.github.io/articles/tutorials/building_2d_games/12_collision_detection/index.html",
    "title": "Chapter 12: Collision Detection | hallowed",
    "summary": "In Chapter 11, you learned how to manage player input to control game objects. However, for objects in your game to interact with each other, collecting items, hitting obstacles, or triggering events, you need to detect when these objects come into contact. This is accomplished through collision detection. In this chapter you will: Understand different collision shapes and their use cases. Implement rectangle-based collision detection. Create circle-based collision detection. Learn how to handle object overlap and response. Build a reusable collision system for your game. We will first start by understanding the basics of collision detection and the different approaches that can be used. Note There is a lot to understand when it comes to collision detection and the many complex ways that two objects can be considered IN collision or NEAR collision. It is critical to get an understanding of the basics before jumping into code. So buckle up, we have a story to tell before you can get back to the keyboard. Feel free to keep coming back to this chapter and refer to the content when you need to, with a fresh cup of coffee. Understanding Collision Detection Before we start implementing collision detection, we should discuss what collision detection actually is. In 2D games, collision detection involves checking if two objects interact with each other in some way. There are several approaches to detecting collisions, ranging from simple to complex: Proximity Collision Detection The simplest form is checking if objects are within a certain range of each other. This is useful when you only need to know if objects are \"near\" each other like detecting if an enemy is close enough to chase a player or if two objects are close enough to perform a more complex collision check. Simple Shape Based Collision Detection Shaped based collision detection checks if two shapes overlap. The most common and simple shapes used are circles and rectangles: Circle Collision Detection Circle collision detection is computationally a simpler check than rectangles. There are also no special considerations if the circles are rotated, which makes them easier to use. To determine if two circle shapes are overlapping, we only need to check if the square of the sum of the radii between the two circles is less than the squared distance between the two circles with the following formula: To find the distance between two circles, imagine drawing a line from the center of one circle to the center of the other. The length of this line is the distance, but we could also calculate it by first walking up or down and then walking left or right from the center of one circle to another, forming a right triangle. Figure 12-1: Showing the distance between the center of two circles forms a right triangle In Figure 12-1 above \\(a\\) is the horizontal distance between the centers of the two circles (x-axis). \\(b\\) is the vertical distance between the centers of the two circles (y-axis). \\(c\\) is the total distance between the centers of the two circles. Since this forms a right triangle, we can use Pythagorean's Theorem to calculate \\(c^2\\) given \\(a^2\\) and \\(b^2\\): \\(c^2 = a^2 + b^2\\) To check for overlap of two circles, we compare whether the squared sum of the radii of the two circles is greater than the squared distance: \\((radius_{circle1} + radius_{circle2})^2 > a^2 + b^2\\) It is easy to confuse the direction of the inequality sign. As a quick mental test, think of how the math works when the origin of two circles are at the same position, i.e., when the squared distance is zero. To calculate the squared distance between two points, MonoGame provides the Vector2.DistanceSquared method: Vector2 circle1Position = new Vector2(8, 10); Vector2 circle2Position = new Vector2(5, 6); float circle1Radius = 5; float circle2Radius = 5; // c^2 = a^2 + b^2 // c^2 = (8 - 5)^2 + (10 - 6)^2 // c^2 = 3^2 + 4^2 // c^2 = 9 + 16 // c^2 = 25 float distanceSquared = Vector2.DistanceSquared(circle1Position, circle2Position); // r^2 = (5 + 5)^2 // r^2 = (10)^2 // r^2 = 100 int radiiSquared = (circle1Radius + circle2Radius) * (circle1Radius + circle2Radius); // The circles overlap because 100 is greater than 25. if(radiiSquared > distanceSquared) { } Tip MonoGame also provides a distance calculation method with Vector2.Distance which returns the distance by providing the square root of the distance squared. So why not use this instead? Square root operations are more computationally complex for a CPU. So instead of getting the normal distance, which would require the square root operation, it is more efficient for the cpu to multiply the sum of the radii by itself to get the squared sum and use that for comparison instead. Rectangle Collision Detection Rectangles, often called bounding boxes, typically uses what is called Axis-Aligned Bounding Box (AABB) collision detection to determine if two rectangle shapes overlap. Unlike circles, to perform AABB collision detection, the x- and y-axes of both rectangles must be aligned with the x- and y-axes of the screen. This is just another way of saying that the rectangles cannot be rotated. Figure 12-2: The rectangle on the left is axis-aligned since both the axes are aligned with the screen axes. The rectangle on the right is non axis-aligned since it is rotated and the axes do not align with the screen axes MonoGame provides the Rectangle struct which represents a rectangle by its position (X,Y) and size (Width,Height). The following table shows some of the properties of the Rectangle struct: Property Type Description Bottom int Returns the y-coordinate location of the bottom edge of the rectangle. This is equal to Rectangle.Y plus the height of the rectangle. Left int Returns the x-coordinate location of the left edge of the rectangle. This is equal to Rectangle.X. Right int Returns the x-coordinate location of the right edge of the rectangle. This is equal to Rectangle.X plus the width of the rectangle. Top int Returns the y-coordinate location of the top edge of the rectangle. This is equal to Rectangle.Y. To determine if two rectangles overlap using AABB collision detection, there are four conditions that need to be checked, and all four conditions must be true. Given two rectangles \\(A\\) and \\(B\\), these conditions are: \\(A_{Left}\\) must be less than \\(B_{Right}\\). \\(A_{Right}\\) must be greater than \\(B_{Left}\\). \\(A_{Top}\\) must be less than \\(B_{Bottom}\\). \\(A_{Bottom}\\) must be greater than \\(B_{Top}\\). If even a single one of these conditions is false, then the rectangles are not overlapping and thus not colliding. MonoGame provides the Rectangle.Intersects method which will perform an AABB collision check for us: // Rectangle 1 // Top: 0 // ---------------- // | | // | | // Left: 0 | | Right: 32 // | | // | | // ---------------- // Bottom: 32 Rectangle rect1 = new Rectangle(0, 0, 32, 32); // Rectangle 2 // Top: 16 // ---------------- // | | // | | // Left: 16 | | Right: 48 // | | // | | // ---------------- // Bottom: 48 Rectangle rect2 = new Rectangle (16, 16, 32, 32); // rect1.Left (0) < rect2.Right (48) = true // rect1.Right (32) > rect3.Left (16) = true // rect1.Top (0) < rect2.Bottom (48) = true // rect1.Bottom (32) > rect2.Top (16) = true bool isColliding = rect1.Intersects(rect2); // returns true Figure 12-3: The rectangle on the left is overlapping the rectangle on the right based on the conditions required for the Axis-Aligned Bounding Box collision check Complex Polygon Collision Detection Complex polygon collision detection uses a method called Separating Axis Theorem (SAT) to determine if two polygon shapes overlap. SAT uses more complex calculations that can determine if any polygon shape overlaps with another polygon shape, including if they are rotated. There are performance considerations to consider when using SAT. Implementing SAT is out-of-scope for this tutorial. If you are interested in further reading about this, please see the following articles as a good starting point: Separating Axis Theorem (SAT) Explanation. Collision Detection Using the Separating Axis Theorem by Kah Shiu Chong. N Tutorial A - Collision Detection and Response. Choosing a Collision Detection Method When determining which collision detection method to use, you should start with the simplest one that meets the needs of your game. If distance checks work for your game mechanic, there's no need to implement more complex shape based detections. Similarly, if a circle can represent the bounding area of a game object, start with that before moving on to rectangles. Some other points to consider are Circles: Better for round objects like balls and coins. More accurate for rotating objects. A simpler check for overlap than rectangles. Rectangles: Great for walls, platforms, and most game objects. Easy to visualize and debug. Works well with tile-based games. Collision Detection vs Collision Response Often times when talking about collision detection, the term is used to mean both the detection of overlapping shapes and what to do once a positive check has occurred. What you do after a positive collision check has occurred is called the collision response. Some of the common responses are: Blocking Collision Response A blocking collision response is the most basic response which just prevents the two objects from overlapping. This is commonly used for walls, platforms and other solid objects. To perform a blocking collision response: Store the object’s current location and calculate the new position it should move to. Check if it is overlapping an object at the new location: If it is overlapping, then set the position to the position before it was moved. If it is not overlapping, set the position to the new calculated position. For example: // Store the current location. Vector2 previousLocation = _spriteLocation; // Calculate a new location. Vector2 newLocation = _spriteLocation + new Vector2(10, 0); // Create a bounding box for the sprite object. Rectangle spriteBounds = new Rectangle( (int)newLocation.X, (int)newLocation.Y, (int)_sprite.Width, (int)_sprite.Height ); // Create a bounding box for the blocking object. Rectangle blockingBounds = new Rectangle( (int)_blockingLocation_.X, (int)_blockingLocation_.Y, (int)_blockingSprite_.Width, (int)_blockingSprite_.Height ); // Detect if they are colliding if(spriteBounds.Intersects(blockingBounds)) { // Respond by not allowing the sprite to move by setting // the location back to the previous location. newLocation = previousLocation; } _spriteLocation = newLocation; Sometimes, instead of preventing an object from moving onto another object, we want to ensure an object remains contained within a certain bounding area. MonoGame also provides the Rectangle.Contains method that we can use to determine this. Rectangle.Contains can check if any of the following are completely contained within the bounds of the rectangle; Point Rectangle Vector2 For example, if we wanted to perform a blocking collision response that ensure a sprite remained contained within the bounds of the game screen: // Store the current location Vector2 previousLocation = _spriteLocation; // Calculate a new location Vector2 newLocation = _spriteLocation + new Vector2(10, 0); // Create a bounding box for the sprite object Rectangle spriteBounds = new Rectangle( (int)newLocation.X, (int)newLocation.Y, (int)_sprite.Width, (int)_sprite.Height ); // Get the bounds of the screen as a rectangle Rectangle screenBounds = new Rectangle( 0, 0, GraphicsDevice.PresentationParameters.BackBufferWidth, GraphicsDevice.PresentationParameters.BackBufferHeight ); // Detect if the sprite is contained within the bounds of the screen if(!screenBounds.Contains(spriteBounds)) { // Respond by not allowing the sprite to move outside the screen // bounds by setting the location back to the previous location. newLocation = previousLocation; } _spriteLocation = newLocation; Tip Use GraphicsDevice.PresentationParameters to get the actual screen dimensions instead of GraphicsDeviceManager.PreferredBackBufferWidth and GraphicsDeviceManager.PreferredBackBufferHeight. The preferred values are only hints and may not reflect the actual back buffer size. Trigger Collision Response Sometimes you want to trigger an event, rather than block movement, when a collision occurs. Common examples include: Collecting items. Activating switches. Entering zones or areas. Triggering cutscenes. Performing a trigger collision response is just simply checking if the game object is overlapping with the bounding area of the trigger zone, and if so trigger the event. For example: // Create a bounding box for the sprite object. Rectangle spriteBounds = new Rectangle( (int)_spriteLocation.X, (int)_spriteLocation.Y, (int)_sprite.Width, (int)_sprite.Height ); // Detect if the sprite object is within the trigger zone. if(_spriteBounds.Intersects(_triggerBounds)) { // Perform some event. CollectItem(); } Bounce Collision Response For games that need objects to bounce off each other (like the ball in a Pong game), we need to calculate how their velocity should change after the collision. MonoGame provides the Vector2.Reflect method to handle this calculation for us. The method needs two pieces of information: The incoming vector (the direction the object is moving in before the collision). The normal vector (the direction perpendicular to the surface). Figure 12-4: A diagram showing how an incoming vector reflects off of a surface base around the normal vector of the surface As shown in the diagram above, when an incoming vector hits a surface, it reflects at the same angle (\\(\\theta\\)) relative to the normal vector. Tip Think of the normal vector like the line you'd draw perpendicular to a mirror's surface. The angle between your incoming path and this line will be the same as the angle between your reflection and this line. For example, if we had a ball moving around the screen and wanted it to bounce off the edges of the screen: // Calculate the new position of the ball based on the velocity. Vector2 newPosition = _ballPosition + _ballVelocity; // Get the bounds of the ball as a rectangle. Rectangle ballBounds = new Rectangle( (int)_ballPosition.X, (int)_ballPosition.Y, (int)_ball.Width, (int)_ball.Height ); // Get the bounds of the screen as a rectangle. Rectangle screenBounds = new Rectangle( 0, 0, GraphicsDevice.PresentationParameters.BackBufferWidth, GraphicsDevice.PresentationParameters.BackBufferHeight ); // Detect if the ball object is within the screen bounds. if(!screenBounds.Contains(ballBounds)) { // Ball would move outside the screen // First find the distance from the edge of the ball to each edge of the screen. float distanceLeft = Math.Abs(screenBounds.Left - ballBounds.Left); float distanceRight = Math.Abs(screenBounds.Right - ballBounds.Right); float distanceTop = Math.Abs(screenBounds.Top - ballBounds.Top); float distanceBottom = Math.Abs(screenBounds.Bottom - ballBounds.Bottom); // Determine which screen edge is the closest. float minDistance = Math.Min( Math.Min(distanceLeft, distanceRight), Math.Min(distanceTop, distanceBottom) ); // Determine the normal vector based on which screen edge is the closest. Vector2 normal; if (minDistance == distanceLeft) { // Closest to the left edge. normal = Vector2.UnitX; newPosition.X = 0; } else if (minDistance == distanceRight) { // Closest to the right edge. normal = -Vector2.UnitX; newPosition.X = screenBounds.Right - _ball.Width; } else if (minDistance == distanceTop) { // Closest to the top edge. normal = Vector2.UnitY; newPosition.Y = 0; } else { // Closest to the bottom edge. normal = -Vector2.UnitY; newPosition.Y = screenBounds.Bottom - _ball.Height; } // Reflect the velocity about the normal. _ballVelocity = Vector2.Reflect(_ballVelocity, normal); } // Set the new position of the ball. _ballVelocity = newPosition; Tip Vector2.UnitX is \\((1, 0)\\) and Vector2.UnitY is \\((0, 1)\\). We use these to get the screen edge normal since the edges of the screen are not at an angle. For more complex surfaces, you would need to calculate the appropriate normal vector based on the surface angle. Optimizing Collision Performance When checking for collisions between multiple objects, testing every object against every other object (often called brute force checking) becomes inefficient as your game grows. Brute force checking can be calculated as \\((n * (n - 1)) / 2\\) where \\(n\\) is the total number of objects. For example, if you have 100 objects in your game, that's \\((100 * 99) / 2 = 4950\\) collision checks every frame. To improve performance, we can use a two-phase approach: Broad Phase: A quick, simple check to rule out objects that definitely are not colliding. Narrow Phase: A more precise check that is only performed on objects that have passed the broad phase. For our simple game with just two objects, this optimization is not necessary. However, as you develop more complex games, implementing a broad-phase check can significantly improve performance. Note Time to get back to the code! The fun starts again here. The Circle Struct For our game, we are going to implement circle based collision detection. MonoGame does not have a Circle struct to represent a circle like it does with Rectangle. Before we can perform circle collision, we will need to create our own. In the root of the MonoGameLibrary project, add a new file named Circle.cs. Add the following code as the foundation of the Circle struct: using System; using Microsoft.Xna.Framework; namespace MonoGameLibrary; public readonly struct Circle : IEquatable<Circle> { } Note Notice that the struct has declared it will implement the IEquatable<T> interface. When creating value types like this, it is recommended to implement IEquatable<T> because it has better performance for comparing objects and can help avoid boxing. For more information on recommended design guidelines for structs, see Struct Design - Framework Design Guidelines | Microsoft Learn Ignore the red squiggles for now, they will be resolved as we add more code. Circle Fields The Circle struct uses both private and public fields to store its state. First, add the following private static field that stores a reusable empty circle: private static readonly Circle s_empty = new Circle(); Next, add the following public fields that define the circle's position and size: /// <summary> /// The x-coordinate of the center of this circle. /// </summary> public readonly int X; /// <summary> /// The y-coordinate of the center of this circle. /// </summary> public readonly int Y; /// <summary> /// The length, in pixels, from the center of this circle to the edge. /// </summary> public readonly int Radius; These public fields store the fundamental properties of the circle: X and Y define the center point location. Radius defines how far the circle extends from its center. Circle Properties The Circle struct provides properties to access its location, state, and its boundaries. Add the following property to get the location of the circle as a Point value: /// <summary> /// Gets the location of the center of this circle. /// </summary> public readonly Point Location => new Point(X, Y); Add the following properties to track empty circles: /// <summary> /// Gets a circle with X=0, Y=0, and Radius=0. /// </summary> public static Circle Empty => s_empty; /// <summary> /// Gets a value that indicates whether this circle has a radius of 0 and a location of (0, 0). /// </summary> public readonly bool IsEmpty => X == 0 && Y == 0 && Radius == 0; Note The Empty property returns a reusable instance of an empty circle stored in the private static field s_empty. This is more efficient than creating new empty circles each time one is needed, as it reuses the same instance in memory. Add the following properties for getting the circle's boundaries: /// <summary> /// Gets the y-coordinate of the highest point on this circle. /// </summary> public readonly int Top => Y - Radius; /// <summary> /// Gets the y-coordinate of the lowest point on this circle. /// </summary> public readonly int Bottom => Y + Radius; /// <summary> /// Gets the x-coordinate of the leftmost point on this circle. /// </summary> public readonly int Left => X - Radius; /// <summary> /// Gets the x-coordinate of the rightmost point on this circle. /// </summary> public readonly int Right => X + Radius; Tip These boundary properties are particularly useful when you need to know the extent of a circle in screen space, such as determining if a circle is visible on screen or creating a bounding box around the circle. Circle Constructors The Circle struct provides two ways to create a new circle: /// <summary> /// Creates a new circle with the specified position and radius. /// </summary> /// <param name=\"x\">The x-coordinate of the center of the circle.</param> /// <param name=\"y\">The y-coordinate of the center of the circle..</param> /// <param name=\"radius\">The length from the center of the circle to an edge.</param> public Circle(int x, int y, int radius) { X = x; Y = y; Radius = radius; } /// <summary> /// Creates a new circle with the specified position and radius. /// </summary> /// <param name=\"location\">The center of the circle.</param> /// <param name=\"radius\">The length from the center of the circle to an edge.</param> public Circle(Point location, int radius) { X = location.X; Y = location.Y; Radius = radius; } The first constructor accepts individual x and y coordinates for the circle's center. The second accepts a Point struct that combines both coordinates. Both constructors require a radius value that defines the circle's size. Circle Methods The Circle struct implements several methods to support equality comparison between circles. These methods allow us to check if two circles are identical (have the same center position and radius). First, add the following method that will check if two circles are overlapping with each other: /// <summary> /// Returns a value that indicates whether the specified circle intersects with this circle. /// </summary> /// <param name=\"other\">The other circle to check.</param> /// <returns>true if the other circle intersects with this circle; otherwise, false.</returns> public bool Intersects(Circle other) { int radiiSquared = (this.Radius + other.Radius) * (this.Radius + other.Radius); float distanceSquared = Vector2.DistanceSquared(this.Location.ToVector2(), other.Location.ToVector2()); return distanceSquared < radiiSquared; } Next we start implementing the IEquatable<T> Interface, add the following methods for comparing a circle with another object: /// <summary> /// Returns a value that indicates whether this circle and the specified object are equal /// </summary> /// <param name=\"obj\">The object to compare with this circle.</param> /// <returns>true if this circle and the specified object are equal; otherwise, false.</returns> public override readonly bool Equals(object obj) => obj is Circle other && Equals(other); /// <summary> /// Returns a value that indicates whether this circle and the specified circle are equal. /// </summary> /// <param name=\"other\">The circle to compare with this circle.</param> /// <returns>true if this circle and the specified circle are equal; otherwise, false.</returns> public readonly bool Equals(Circle other) => this.X == other.X && this.Y == other.Y && this.Radius == other.Radius; Next, add the following override for GetHashCode to support using circles in hash-based collections: /// <summary> /// Returns the hash code for this circle. /// </summary> /// <returns>The hash code for this circle as a 32-bit signed integer.</returns> public override readonly int GetHashCode() => HashCode.Combine(X, Y, Radius); Finally, add the following operator overloads to support using == and != with circles: /// <summary> /// Returns a value that indicates if the circle on the left hand side of the equality operator is equal to the /// circle on the right hand side of the equality operator. /// </summary> /// <param name=\"lhs\">The circle on the left hand side of the equality operator.</param> /// <param name=\"rhs\">The circle on the right hand side of the equality operator.</param> /// <returns>true if the two circles are equal; otherwise, false.</returns> public static bool operator ==(Circle lhs, Circle rhs) => lhs.Equals(rhs); /// <summary> /// Returns a value that indicates if the circle on the left hand side of the inequality operator is not equal to the /// circle on the right hand side of the inequality operator. /// </summary> /// <param name=\"lhs\">The circle on the left hand side of the inequality operator.</param> /// <param name=\"rhs\">The circle on the right hand side fo the inequality operator.</param> /// <returns>true if the two circle are not equal; otherwise, false.</returns> public static bool operator !=(Circle lhs, Circle rhs) => !lhs.Equals(rhs); IEquatable interface implemented, red squiggles be gone. Tip The operator overloads allow you to compare circles using familiar syntax: Circle circle1 = new Circle(0, 0, 5); Circle circle2 = new Circle(0, 0, 5); bool areEqual = circle1 == circle2; // Returns true Now that we have a struct to represent a circle and check for overlapping, we will update our game to implement collision detection and responses. Adding Collision To Our Game If you run the game right now and move the slime around, you will notice a few issues that can be fixed by adding collision detection and response: You can move the slime outside the bounds of the screen. Nothing occurs when the slime collides with the bat. The bat does not move, providing no challenge in the game. We can now implement these features using collision detection and response in our game. In the DungeonSlime project (your main game project), open the Game1.cs file and make the following changes to the Game1 class: using System; using Microsoft.Xna.Framework; using Microsoft.Xna.Framework.Graphics; using Microsoft.Xna.Framework.Input; using MonoGameLibrary; using MonoGameLibrary.Graphics; using MonoGameLibrary.Input; namespace DungeonSlime; public class Game1 : Core { // Defines the slime animated sprite. private AnimatedSprite _slime; // Defines the bat animated sprite. private AnimatedSprite _bat; // Tracks the position of the slime. private Vector2 _slimePosition; // Speed multiplier when moving. private const float MOVEMENT_SPEED = 5.0f; // Tracks the position of the bat. private Vector2 _batPosition; // Tracks the velocity of the bat. private Vector2 _batVelocity; public Game1() : base(\"Dungeon Slime\", 1280, 720, false) { } protected override void Initialize() { base.Initialize(); // Set the initial position of the bat to be 10px // to the right of the slime. _batPosition = new Vector2(_slime.Width + 10, 0); // Assign the initial random velocity to the bat. AssignRandomBatVelocity(); } protected override void LoadContent() { // Create the texture atlas from the XML configuration file. TextureAtlas atlas = TextureAtlas.FromFile(Content, \"images/atlas-definition.xml\"); // Create the slime animated sprite from the atlas. _slime = atlas.CreateAnimatedSprite(\"slime-animation\"); _slime.Scale = new Vector2(4.0f, 4.0f); // Create the bat animated sprite from the atlas. _bat = atlas.CreateAnimatedSprite(\"bat-animation\"); _bat.Scale = new Vector2(4.0f, 4.0f); } protected override void Update(GameTime gameTime) { // Update the slime animated sprite. _slime.Update(gameTime); // Update the bat animated sprite. _bat.Update(gameTime); // Check for keyboard input and handle it. CheckKeyboardInput(); // Check for gamepad input and handle it. CheckGamePadInput(); // Create a bounding rectangle for the screen. Rectangle screenBounds = new Rectangle( 0, 0, GraphicsDevice.PresentationParameters.BackBufferWidth, GraphicsDevice.PresentationParameters.BackBufferHeight ); // Creating a bounding circle for the slime Circle slimeBounds = new Circle( (int)(_slimePosition.X + (_slime.Width * 0.5f)), (int)(_slimePosition.Y + (_slime.Height * 0.5f)), (int)(_slime.Width * 0.5f) ); // Use distance based checks to determine if the slime is within the // bounds of the game screen, and if it is outside that screen edge, // move it back inside. if (slimeBounds.Left < screenBounds.Left) { _slimePosition.X = screenBounds.Left; } else if (slimeBounds.Right > screenBounds.Right) { _slimePosition.X = screenBounds.Right - _slime.Width; } if (slimeBounds.Top < screenBounds.Top) { _slimePosition.Y = screenBounds.Top; } else if (slimeBounds.Bottom > screenBounds.Bottom) { _slimePosition.Y = screenBounds.Bottom - _slime.Height; } // Calculate the new position of the bat based on the velocity. Vector2 newBatPosition = _batPosition + _batVelocity; // Create a bounding circle for the bat. Circle batBounds = new Circle( (int)(newBatPosition.X + (_bat.Width * 0.5f)), (int)(newBatPosition.Y + (_bat.Height * 0.5f)), (int)(_bat.Width * 0.5f) ); Vector2 normal = Vector2.Zero; // Use distance based checks to determine if the bat is within the // bounds of the game screen, and if it is outside that screen edge, // reflect it about the screen edge normal. if (batBounds.Left < screenBounds.Left) { normal.X = Vector2.UnitX.X; newBatPosition.X = screenBounds.Left; } else if (batBounds.Right > screenBounds.Right) { normal.X = -Vector2.UnitX.X; newBatPosition.X = screenBounds.Right - _bat.Width; } if (batBounds.Top < screenBounds.Top) { normal.Y = Vector2.UnitY.Y; newBatPosition.Y = screenBounds.Top; } else if (batBounds.Bottom > screenBounds.Bottom) { normal.Y = -Vector2.UnitY.Y; newBatPosition.Y = screenBounds.Bottom - _bat.Height; } // If the normal is anything but Vector2.Zero, this means the bat had // moved outside the screen edge so we should reflect it about the // normal. if (normal != Vector2.Zero) { normal.Normalize(); _batVelocity = Vector2.Reflect(_batVelocity, normal); } _batPosition = newBatPosition; if (slimeBounds.Intersects(batBounds)) { // Divide the width and height of the screen into equal columns and // rows based on the width and height of the bat. int totalColumns = GraphicsDevice.PresentationParameters.BackBufferWidth / (int)_bat.Width; int totalRows = GraphicsDevice.PresentationParameters.BackBufferHeight / (int)_bat.Height; // Choose a random row and column based on the total number of each int column = Random.Shared.Next(0, totalColumns); int row = Random.Shared.Next(0, totalRows); // Change the bat position by setting the x and y values equal to // the column and row multiplied by the width and height. _batPosition = new Vector2(column * _bat.Width, row * _bat.Height); // Assign a new random velocity to the bat AssignRandomBatVelocity(); } base.Update(gameTime); } private void AssignRandomBatVelocity() { // Generate a random angle. float angle = (float)(Random.Shared.NextDouble() * Math.PI * 2); // Convert angle to a direction vector. float x = (float)Math.Cos(angle); float y = (float)Math.Sin(angle); Vector2 direction = new Vector2(x, y); // Multiply the direction vector by the movement speed. _batVelocity = direction * MOVEMENT_SPEED; } private void CheckKeyboardInput() { // If the space key is held down, the movement speed increases by 1.5 float speed = MOVEMENT_SPEED; if (Input.Keyboard.IsKeyDown(Keys.Space)) { speed *= 1.5f; } // If the W or Up keys are down, move the slime up on the screen. if (Input.Keyboard.IsKeyDown(Keys.W) || Input.Keyboard.IsKeyDown(Keys.Up)) { _slimePosition.Y -= speed; } // if the S or Down keys are down, move the slime down on the screen. if (Input.Keyboard.IsKeyDown(Keys.S) || Input.Keyboard.IsKeyDown(Keys.Down)) { _slimePosition.Y += speed; } // If the A or Left keys are down, move the slime left on the screen. if (Input.Keyboard.IsKeyDown(Keys.A) || Input.Keyboard.IsKeyDown(Keys.Left)) { _slimePosition.X -= speed; } // If the D or Right keys are down, move the slime right on the screen. if (Input.Keyboard.IsKeyDown(Keys.D) || Input.Keyboard.IsKeyDown(Keys.Right)) { _slimePosition.X += speed; } } private void CheckGamePadInput() { GamePadInfo gamePadOne = Input.GamePads[(int)PlayerIndex.One]; // If the A button is held down, the movement speed increases by 1.5 // and the gamepad vibrates as feedback to the player. float speed = MOVEMENT_SPEED; if (gamePadOne.IsButtonDown(Buttons.A)) { speed *= 1.5f; GamePad.SetVibration(PlayerIndex.One, 1.0f, 1.0f); } else { GamePad.SetVibration(PlayerIndex.One, 0.0f, 0.0f); } // Check thumbstick first since it has priority over which gamepad input // is movement. It has priority since the thumbstick values provide a // more granular analog value that can be used for movement. if (gamePadOne.LeftThumbStick != Vector2.Zero) { _slimePosition.X += gamePadOne.LeftThumbStick.X * speed; _slimePosition.Y -= gamePadOne.LeftThumbStick.Y * speed; } else { // If DPadUp is down, move the slime up on the screen. if (gamePadOne.IsButtonDown(Buttons.DPadUp)) { _slimePosition.Y -= speed; } // If DPadDown is down, move the slime down on the screen. if (gamePadOne.IsButtonDown(Buttons.DPadDown)) { _slimePosition.Y += speed; } // If DPapLeft is down, move the slime left on the screen. if (gamePadOne.IsButtonDown(Buttons.DPadLeft)) { _slimePosition.X -= speed; } // If DPadRight is down, move the slime right on the screen. if (gamePadOne.IsButtonDown(Buttons.DPadRight)) { _slimePosition.X += speed; } } } protected override void Draw(GameTime gameTime) { // Clear the back buffer. GraphicsDevice.Clear(Color.CornflowerBlue); // Begin the sprite batch to prepare for rendering. SpriteBatch.Begin(samplerState: SamplerState.PointClamp); // Draw the slime sprite. _slime.Draw(SpriteBatch, _slimePosition); // Draw the bat sprite. _bat.Draw(SpriteBatch, _batPosition); // Always end the sprite batch when finished. SpriteBatch.End(); base.Draw(gameTime); } } The key changes made here are: The field _batPosition was added to track the position of the bat. The field _batVelocity was added to track the velocity of the bat. The AssignRandomBatVelocity() method was added which calculates a random x and y velocity for the bat to move at when called. In Initialize, the initial position of the bat is set and AssignRandomVelocity is called to assign the initial velocity for the bat. In Update, collision detection and response logic was added to perform the following in order: A Rectangle bound is created to represent the bounds of the screen. A Circle bound is created to represent the bounds of the slime. Distance based checks are performed to ensure that the slime cannot move outside of the screen, the resolution of which is to perform a blocking response. A new position for the bat is calculated based on the current velocity of the bat. A Circle bound is created to represent the bounds of the bat. Distance based checks are performed to ensure the bat cannot move outside of the screen, the resolution of which is to perform a bounce response. A collision check is made to determine if the slime and bat are colliding (bat \"eating\" the slime). If so, the bat is assigned a new random position within the screen and assigned a new random velocity. In Draw, the bat is now drawn using the _batPosition value. Running the game now The bat will start moving with a random velocity and bounce off the edges of the screen You can move the slime around, but cannot leave the bounds of the screen with the slime. If you move the slime to collide (\"eat\") the bat, the bat will respawn at a new location with a new velocity. Figure 12-5: When the slime collides (\"eats\") the bat, the bat respawns in a new location on the screen with a random velocity assigned Conclusion In this chapter, you accomplished the following: Learned about different approaches to collision detection: Distance-based checks for simple proximity detection. Shape-based checks using circles and rectangles. Complex polygon checks using SAT. Understood when to use different collision shapes: Circles for round objects and rotation. Rectangles for walls and platforms. Explored different types of collision responses: Blocking to prevent objects from overlapping. Triggering events when objects collide. Bouncing to reflect objects off surfaces. Created reusable components: Implemented a Circle struct for circle-based collision. Added methods to detect circle intersections. Applied collision concepts to our game: Added screen boundary collision for the slime. Implemented bouncing behavior for the bat. Created a trigger response when the slime \"eats\" the bat. In the next chapter, we will explore using tilesets and tilemaps to create tile based environments for our game. Test Your Knowledge What is the difference between collision detection and collision response? ::: question-answer Collision detection is determining when two objects overlap or intersect, while collision response is what happens after a collision is detected (like blocking movement, triggering events, or bouncing objects off each other). ::: When using Rectangle.Intersects for AABB collision, what four conditions must all be true for a collision to occur? ::: question-answer For two rectangles A and B to collide: A's left edge must be less than B's right edge. A's right edge must be greater than B's left edge. A's top edge must be less than B's bottom edge. A's bottom edge must be greater than B's top edge. ::: When implementing circle collision, why do we compare the distance between centers to the sum of the radii? ::: question-answer Two circles are colliding if the distance between their centers is less than the sum of their radii. If the distance is greater, they are separate. If the distance equals the sum of radii, they are just touching at one point. ::: When implementing bounce collision response, what two pieces of information does Vector2.Reflect need? ::: question-answer Vector2.Reflect needs: The incoming vector (direction the object is moving). The normal vector (direction perpendicular to the surface being hit). ::: Why might you choose to use circle collision over rectangle collision for certain objects? ::: question-answer Circle collision might be chosen because: It is more accurate for round objects. It handles rotating objects better. It is simpler for continuous collision detection. It is natural for radius-based interactions. ::: In the blocking collision response example, why do we store the previous position before handling input? ::: question-answer We store the previous position so that if a collision occurs after movement, we can reset the object back to its last valid position. This prevents objects from moving through each other by undoing any movement that would cause overlap. :::"
  },
  "templates/docs.monogame.github.io/articles/tutorials/building_2d_games/13_working_with_tilemaps/index.html": {
    "href": "templates/docs.monogame.github.io/articles/tutorials/building_2d_games/13_working_with_tilemaps/index.html",
    "title": "Chapter 13: Working with Tilemaps | hallowed",
    "summary": "In the previous chapters, you have learned how to draw individual sprites and animated sprites from a texture atlas and handle collision detection. However, the game so far is lacking an actual world or environment to exist in; it is just sprites on a cornflower blue background. Most 2D games feature game worlds built from many tiles arranged in a grid-like patten. These tilemaps allow you to efficiently create large game environments without managing thousands of individual sprites. In this chapter you will: Learn what tilemaps are and how they are used in game development. Create a Tileset class to manage collections of related tiles. Build a Tilemap class to render tile-based game worlds. Implement an XML-based tilemap loading system. Update our game to use tilemaps for the game environment. Understanding Tilemaps Tilemaps are a common technique used in 2D game development to create game worlds. Instead of positioning individual sprites for each element in the game world, a tilemap divides the world into a grid and places tiles from a tileset at each grid position. What is a Tileset? A tileset is a collection of small images (tiles) that can be combined and arranged to create game environments. Typically these are stored in a single texture atlas, similar to how we have been handing sprites and animations. Common examples of tiles might include: Floor and ground tiles. Walls and obstacle tiles. Decorative elements like plants and furniture. Special tiles like doors, ladders, or water. Each tile in a tileset is assigned an ID number, which the tilemap uses to reference which tile goes where. For example, in Figure 13-1 below, the tileset we will add to our game in a moment is shown on the left and on the right is the same tileset with an overlay showing how each tile is assigned an ID number. Figure 13-1: Left: Original dungeon tileset. Right: The same tileset with an overlay showing how each tile is assigned a numeric ID What is a Tilemap? A tilemap is a grid-based data structure that defines which tiles from a tileset appear at each position in the game world. The tilemap stores an ID for each cell in the grid, where the ID corresponds to a specific tile in the tileset. For example, a simple tilemap may look like this conceptually: 00 01 02 01 03 04 05 06 05 07 08 09 10 09 11 04 09 09 09 07 12 13 14 13 15 If we took the above tilemap data and mapped each cell to the tile in the related tileset, it would look something similar to Figure 13-2 below: Figure 13-2: From tileset to tilemap. Left: Tileset with an overlay showing the tile IDs. Right: The tilemap created using the tiles arranged with the pattern from the code example above This approach offers several advantage: Memory efficiency: Instead of storing complete information about each tile's appearance, you only need to store a reference ID. Performance: Drawing a tilemap can be optimized to reduce texture swapping compared to rendering many individual sprites. Design flexibility: Tilemaps make it easy to create, modify, and load level designs from external files. We will now take this concept and implement it in our game by creating a Tileset class and a Tilemap class. The Tileset Class The Tileset class will manage a collection of tiles from a texture atlas. Each tile will be represented as a TextureRegion, building on the tools in the library we created earlier. In the Graphics folder of the MonoGameLibrary project, create a new file named Tileset.cs with the following code as the initial structure: namespace MonoGameLibrary.Graphics; public class Tileset { } Tileset Properties and Fields The Tileset class needs to store a TextureRegion for each of the individual tiles in the tile set and provide the dimensions (width and height) of the tiles. It should also offers additional properties that provide the total number of rows and columns in the tileset and the total number of tiles. Add the following fields and properties: private readonly TextureRegion[] _tiles; /// <summary> /// Gets the width, in pixels, of each tile in this tileset. /// </summary> public int TileWidth { get; } /// <summary> /// Gets the height, in pixels, of each tile in this tileset. /// </summary> public int TileHeight { get; } /// <summary> /// Gets the total number of columns in this tileset. /// </summary> public int Columns { get; } /// <summary> /// Gets the total number of rows in this tileset. /// </summary> public int Rows { get; } /// <summary> /// Gets the total number of tiles in this tileset. /// </summary> public int Count { get; } Tileset Constructor The Tileset class constructor requires a source TextureRegion that represents the tileset and the width and height of the tiles. Based on these parameters provided, it can automatically divide the source TextureRegion into a grid of smaller texture regions and calculate the total number of rows, columns, and tiles. Add the following constructor: /// <summary> /// Creates a new tileset based on the given texture region with the specified /// tile width and height. /// </summary> /// <param name=\"textureRegion\">The texture region that contains the tiles for the tileset.</param> /// <param name=\"tileWidth\">The width of each tile in the tileset.</param> /// <param name=\"tileHeight\">The height of each tile in the tileset.</param> public Tileset(TextureRegion textureRegion, int tileWidth, int tileHeight) { TileWidth = tileWidth; TileHeight = tileHeight; Columns = textureRegion.Width / tileWidth; Rows = textureRegion.Height / tileHeight; Count = Columns * Rows; // Create the texture regions that make up each individual tile _tiles = new TextureRegion[Count]; for (int i = 0; i < Count; i++) { int x = i % Columns * tileWidth; int y = i / Columns * tileHeight; _tiles[i] = new TextureRegion(textureRegion.Texture, textureRegion.SourceRectangle.X + x, textureRegion.SourceRectangle.Y + y, tileWidth, tileHeight); } } Tileset Methods The Tileset class needs to provide methods to retrieve the TextureRegion of a tile based on the index (tile ID) or by the location (row and column) of the tile in the tileset. Add the following methods: /// <summary> /// Gets the texture region for the tile from this tileset at the given index. /// </summary> /// <param name=\"index\">The index of the texture region in this tile set.</param> /// <returns>The texture region for the tile form this tileset at the given index.</returns> public TextureRegion GetTile(int index) => _tiles[index]; /// <summary> /// Gets the texture region for the tile from this tileset at the given location. /// </summary> /// <param name=\"column\">The column in this tileset of the texture region.</param> /// <param name=\"row\">The row in this tileset of the texture region.</param> /// <returns>The texture region for the tile from this tileset at given location.</returns> public TextureRegion GetTile(int column, int row) { int index = row * Columns + column; return GetTile(index); } The Tilemap Class Now that we have a Tileset class to define our tile collection, we need a Tilemap class to arrange these tiles into a game level. The Tilemap class will store which tile goes where in our game world and provide methods to draw the entire map. In the Graphics folder of the MonoGameLibrary project, create a new file named Tilemap.cs with the following code as the initial structure: using System; using System.IO; using System.Xml; using System.Xml.Linq; using Microsoft.Xna.Framework; using Microsoft.Xna.Framework.Content; using Microsoft.Xna.Framework.Graphics; namespace MonoGameLibrary.Graphics; public class Tilemap { } Tilemap Properties and Fields The Tilemap class needs to store a reference to the tileset being used, along with an array of the tile IDs representing each tile in the map. It should also offer additional properties that provide the total number of rows and columns in the tilemap and the total number of tiles. Add the following fields and properties: private readonly Tileset _tileset; private readonly int[] _tiles; /// <summary> /// Gets the total number of rows in this tilemap. /// </summary> public int Rows { get; } /// <summary> /// Gets the total number of columns in this tilemap. /// </summary> public int Columns { get; } /// <summary> /// Gets the total number of tiles in this tilemap. /// </summary> public int Count { get; } /// <summary> /// Gets or Sets the scale factor to draw each tile at. /// </summary> public Vector2 Scale { get; set; } /// <summary> /// Gets the width, in pixels, each tile is drawn at. /// </summary> public float TileWidth => _tileset.TileWidth * Scale.X; /// <summary> /// Gets the height, in pixels, each tile is drawn at. /// </summary> public float TileHeight => _tileset.TileHeight * Scale.Y; Tilemap Constructor The Tilemap constructor requires the Tilemap to reference for each tile, the total number of columns and rows in the map, and the size (width and height) of each tile. Add the following constructor: /// <summary> /// Creates a new tilemap. /// </summary> /// <param name=\"tileset\">The tileset used by this tilemap.</param> /// <param name=\"columns\">The total number of columns in this tilemap.</param> /// <param name=\"rows\">The total number of rows in this tilemap.</param> public Tilemap(Tileset tileset, int columns, int rows) { _tileset = tileset; Rows = rows; Columns = columns; Count = Columns * Rows; Scale = Vector2.One; _tiles = new int[Count]; } Tilemap Tile Management Methods The Tilemap class should provide methods to set and retrieve tiles, either by index or location (rows and column). Add the following methods: /// <summary> /// Sets the tile at the given index in this tilemap to use the tile from /// the tileset at the specified tileset id. /// </summary> /// <param name=\"index\">The index of the tile in this tilemap.</param> /// <param name=\"tilesetID\">The tileset id of the tile from the tileset to use.</param> public void SetTile(int index, int tilesetID) { _tiles[index] = tilesetID; } /// <summary> /// Sets the tile at the given column and row in this tilemap to use the tile /// from the tileset at the specified tileset id. /// </summary> /// <param name=\"column\">The column of the tile in this tilemap.</param> /// <param name=\"row\">The row of the tile in this tilemap.</param> /// <param name=\"tilesetID\">The tileset id of the tile from the tileset to use.</param> public void SetTile(int column, int row, int tilesetID) { int index = row * Columns + column; SetTile(index, tilesetID); } /// <summary> /// Gets the texture region of the tile from this tilemap at the specified index. /// </summary> /// <param name=\"index\">The index of the tile in this tilemap.</param> /// <returns>The texture region of the tile from this tilemap at the specified index.</returns> public TextureRegion GetTile(int index) { return _tileset.GetTile(_tiles[index]); } /// <summary> /// Gets the texture region of the tile from this tilemap at the specified /// column and row. /// </summary> /// <param name=\"column\">The column of the tile in this tilemap.</param> /// <param name=\"row\">The row of the tile in this tilemap.</param> /// <returns>The texture region of the tile from this tilemap at the specified column and row.</returns> public TextureRegion GetTile(int column, int row) { int index = row * Columns + column; return GetTile(index); } Tilemap Draw Method The Tilemap class needs a method to draw the tilemap by iterating through each of the tiles and drawing the TextureRegion for that tile at its correct position. Add the following method: /// <summary> /// Draws this tilemap using the given sprite batch. /// </summary> /// <param name=\"spriteBatch\">The sprite batch used to draw this tilemap.</param> public void Draw(SpriteBatch spriteBatch) { for (int i = 0; i < Count; i++) { int tilesetIndex = _tiles[i]; TextureRegion tile = _tileset.GetTile(tilesetIndex); int x = i % Columns; int y = i / Columns; Vector2 position = new Vector2(x * TileWidth, y * TileHeight); tile.Draw(spriteBatch, position, Color.White, 0.0f, Vector2.Zero, Scale, SpriteEffects.None, 1.0f); } } Tilemap FromFile Method The Tilemap class also requires a method to load and create an instance of the tilemap from an external configuration file. This allows us to separate level design from code. Add the following method: /// <summary> /// Creates a new tilemap based on a tilemap xml configuration file. /// </summary> /// <param name=\"content\">The content manager used to load the texture for the tileset.</param> /// <param name=\"filename\">The path to the xml file, relative to the content root directory.</param> /// <returns>The tilemap created by this method.</returns> public static Tilemap FromFile(ContentManager content, string filename) { string filePath = Path.Combine(content.RootDirectory, filename); using (Stream stream = TitleContainer.OpenStream(filePath)) { using (XmlReader reader = XmlReader.Create(stream)) { XDocument doc = XDocument.Load(reader); XElement root = doc.Root; // The <Tileset> element contains the information about the tileset // used by the tilemap. // // Example // <Tileset region=\"0 0 100 100\" tileWidth=\"10\" tileHeight=\"10\">contentPath</Tileset> // // The region attribute represents the x, y, width, and height // components of the boundary for the texture region within the // texture at the contentPath specified. // // the tileWidth and tileHeight attributes specify the width and // height of each tile in the tileset. // // the contentPath value is the contentPath to the texture to // load that contains the tileset XElement tilesetElement = root.Element(\"Tileset\"); string regionAttribute = tilesetElement.Attribute(\"region\").Value; string[] split = regionAttribute.Split(\" \", StringSplitOptions.RemoveEmptyEntries); int x = int.Parse(split[0]); int y = int.Parse(split[1]); int width = int.Parse(split[2]); int height = int.Parse(split[3]); int tileWidth = int.Parse(tilesetElement.Attribute(\"tileWidth\").Value); int tileHeight = int.Parse(tilesetElement.Attribute(\"tileHeight\").Value); string contentPath = tilesetElement.Value; // Load the texture 2d at the content path Texture2D texture = content.Load<Texture2D>(contentPath); // Create the texture region from the texture TextureRegion textureRegion = new TextureRegion(texture, x, y, width, height); // Create the tileset using the texture region Tileset tileset = new Tileset(textureRegion, tileWidth, tileHeight); // The <Tiles> element contains lines of strings where each line // represents a row in the tilemap. Each line is a space // separated string where each element represents a column in that // row. The value of the column is the id of the tile in the // tileset to draw for that location. // // Example: // <Tiles> // 00 01 01 02 // 03 04 04 05 // 03 04 04 05 // 06 07 07 08 // </Tiles> XElement tilesElement = root.Element(\"Tiles\"); // Split the value of the tiles data into rows by splitting on // the new line character string[] rows = tilesElement.Value.Trim().Split('\\n', StringSplitOptions.RemoveEmptyEntries); // Split the value of the first row to determine the total number of columns int columnCount = rows[0].Split(\" \", StringSplitOptions.RemoveEmptyEntries).Length; // Create the tilemap Tilemap tilemap = new Tilemap(tileset, columnCount, rows.Length); // Process each row for (int row = 0; row < rows.Length; row++) { // Split the row into individual columns string[] columns = rows[row].Trim().Split(\" \", StringSplitOptions.RemoveEmptyEntries); // Process each column of the current row for (int column = 0; column < columnCount; column++) { // Get the tileset index for this location int tilesetIndex = int.Parse(columns[column]); // Get the texture region of that tile from the tileset TextureRegion region = tileset.GetTile(tilesetIndex); // Add that region to the tilemap at the row and column location tilemap.SetTile(column, row, tilesetIndex); } } return tilemap; } } } Updating the Game Now that we have the Tilemap and Tileset classes defined, we can update our game to use them. We will need to Update the texture atlas to include the tileset. Create a tilemap xml configuration file. Update the game to load the tilemap from the configuration file and draw it. Update the Texture Atlas Currently, the texture atlas we have been using only contains the sprites for the slime and bat animations. We need update it to a new version that contains the tileset as well. Right-click the following image and save it as atlas.png in the Content/images directory of the DungeonSlime project (your main game project), overwriting the existing one. Note You do not need to do this in the MGCB editor as you are simply replacing the file and not altering any of its import properties. Figure 13-3: The texture atlas for our game updated to include the tileset for the tilemap Note Since the slime and bat sprites are in the same position in the new texture atlas, we do not need to update the atlas XML configuration file. Creating a Tilemap XML Configuration Now that we have the texture atlas updated to include the tileset, we need to create a tilemap configuration that our game can load. The configuration will be an XML file that specifies the tileset to use and the arrangement of tiles in the tilemap. We need to add this configuration file to our content project in the Content/images folder with the MGCB Editor, in the same way we did with the \"atlas-definition.xml\": Open the Content.mgcb content project file in the MGCB Editor. Right-click the images folder and choose Add > New Item.... Select the Xml Content (.xml) type and name it tilemap-definition Select the tilemap-definition.xml file you just created. In the Properties panel, change the Build Action property from Build to Copy. Save the changes in the MGCB Editor. Figure 13-4: The Content project in the MGCB Editor with the tilemap-definition.xml file added and the Build Action property set to copy Open the tilemap-definition.xml file in your code editor and replace its contents with the following and save it: <?xml version=\"1.0\" encoding=\"utf-8\"?> <Tilemap> <Tileset region=\"0 40 80 80\" tileWidth=\"20\" tileHeight=\"20\">images/atlas</Tileset> <Tiles> 00 01 02 01 02 01 02 01 02 01 02 01 02 01 02 03 04 05 05 06 05 05 06 05 05 06 05 05 06 05 05 07 08 09 09 09 09 09 09 09 09 09 09 09 09 09 09 11 04 09 09 09 09 09 09 09 10 09 09 09 09 10 09 07 08 09 10 09 09 09 09 09 09 09 09 09 09 09 09 11 04 09 09 09 09 09 09 09 09 09 09 09 09 09 09 07 08 10 09 09 09 09 09 09 09 09 10 09 09 09 09 11 04 09 09 09 09 09 10 09 09 09 09 09 09 09 09 07 12 13 14 13 14 13 14 13 14 13 14 13 14 13 14 15 </Tiles> </Tilemap> This tilemap configuration creates a simple dungeon layout with walls around the perimeter and an open floor in the middle. The tile IDs correspond to specific tiles in the tileset: 00, 03, 12, 15: Corner wall tiles (top-left, top-right, bottom-left, bottom-right). 01, 02, 13, 14: Horizontal wall tiles (top and bottom walls). 04, 07, 08, 11: Vertical wall tiles (left and right walls). 05 and 06: Top floor edge tiles. 09: Standard floor tile. 10: Decorated floor tile with a crack in it. Update the Game1 Class With all of the assets now in place and configured, we can update the Game1 class to load the tilemap and draw it. We will also need to update the collision logic so that the boundary is no longer the edge of the screen, but instead the edges of the wall tiles of the tilemap. Open Game1.cs and make the following updates: using System; using Microsoft.Xna.Framework; using Microsoft.Xna.Framework.Graphics; using Microsoft.Xna.Framework.Input; using MonoGameLibrary; using MonoGameLibrary.Graphics; using MonoGameLibrary.Input; namespace DungeonSlime; public class Game1 : Core { // Defines the slime animated sprite. private AnimatedSprite _slime; // Defines the bat animated sprite. private AnimatedSprite _bat; // Tracks the position of the slime. private Vector2 _slimePosition; // Speed multiplier when moving. private const float MOVEMENT_SPEED = 5.0f; // Tracks the position of the bat. private Vector2 _batPosition; // Tracks the velocity of the bat. private Vector2 _batVelocity; // Defines the tilemap to draw. private Tilemap _tilemap; // Defines the bounds of the room that the slime and bat are contained within. private Rectangle _roomBounds; public Game1() : base(\"Dungeon Slime\", 1280, 720, false) { } protected override void Initialize() { base.Initialize(); Rectangle screenBounds = GraphicsDevice.PresentationParameters.Bounds; _roomBounds = new Rectangle( (int)_tilemap.TileWidth, (int)_tilemap.TileHeight, screenBounds.Width - (int)_tilemap.TileWidth * 2, screenBounds.Height - (int)_tilemap.TileHeight * 2 ); // Initial slime position will be the center tile of the tile map. int centerRow = _tilemap.Rows / 2; int centerColumn = _tilemap.Columns / 2; _slimePosition = new Vector2(centerColumn * _tilemap.TileWidth, centerRow * _tilemap.TileHeight); // Initial bat position will be in the top left corner of the room _batPosition = new Vector2(_roomBounds.Left, _roomBounds.Top); // Assign the initial random velocity to the bat. AssignRandomBatVelocity(); } protected override void LoadContent() { // Create the texture atlas from the XML configuration file TextureAtlas atlas = TextureAtlas.FromFile(Content, \"images/atlas-definition.xml\"); // Create the slime animated sprite from the atlas. _slime = atlas.CreateAnimatedSprite(\"slime-animation\"); _slime.Scale = new Vector2(4.0f, 4.0f); // Create the bat animated sprite from the atlas. _bat = atlas.CreateAnimatedSprite(\"bat-animation\"); _bat.Scale = new Vector2(4.0f, 4.0f); // Create the tilemap from the XML configuration file. _tilemap = Tilemap.FromFile(Content, \"images/tilemap-definition.xml\"); _tilemap.Scale = new Vector2(4.0f, 4.0f); } protected override void Update(GameTime gameTime) { // Update the slime animated sprite. _slime.Update(gameTime); // Update the bat animated sprite. _bat.Update(gameTime); // Check for keyboard input and handle it. CheckKeyboardInput(); // Check for gamepad input and handle it. CheckGamePadInput(); // Creating a bounding circle for the slime Circle slimeBounds = new Circle( (int)(_slimePosition.X + (_slime.Width * 0.5f)), (int)(_slimePosition.Y + (_slime.Height * 0.5f)), (int)(_slime.Width * 0.5f) ); // Use distance based checks to determine if the slime is within the // bounds of the game screen, and if it is outside that screen edge, // move it back inside. if (slimeBounds.Left < _roomBounds.Left) { _slimePosition.X = _roomBounds.Left; } else if (slimeBounds.Right > _roomBounds.Right) { _slimePosition.X = _roomBounds.Right - _slime.Width; } if (slimeBounds.Top < _roomBounds.Top) { _slimePosition.Y = _roomBounds.Top; } else if (slimeBounds.Bottom > _roomBounds.Bottom) { _slimePosition.Y = _roomBounds.Bottom - _slime.Height; } // Calculate the new position of the bat based on the velocity Vector2 newBatPosition = _batPosition + _batVelocity; // Create a bounding circle for the bat Circle batBounds = new Circle( (int)(newBatPosition.X + (_bat.Width * 0.5f)), (int)(newBatPosition.Y + (_bat.Height * 0.5f)), (int)(_bat.Width * 0.5f) ); Vector2 normal = Vector2.Zero; // Use distance based checks to determine if the bat is within the // bounds of the game screen, and if it is outside that screen edge, // reflect it about the screen edge normal if (batBounds.Left < _roomBounds.Left) { normal.X = Vector2.UnitX.X; newBatPosition.X = _roomBounds.Left; } else if (batBounds.Right > _roomBounds.Right) { normal.X = -Vector2.UnitX.X; newBatPosition.X = _roomBounds.Right - _bat.Width; } if (batBounds.Top < _roomBounds.Top) { normal.Y = Vector2.UnitY.Y; newBatPosition.Y = _roomBounds.Top; } else if (batBounds.Bottom > _roomBounds.Bottom) { normal.Y = -Vector2.UnitY.Y; newBatPosition.Y = _roomBounds.Bottom - _bat.Height; } // If the normal is anything but Vector2.Zero, this means the bat had // moved outside the screen edge so we should reflect it about the // normal. if (normal != Vector2.Zero) { normal.Normalize(); _batVelocity = Vector2.Reflect(_batVelocity, normal); } _batPosition = newBatPosition; if (slimeBounds.Intersects(batBounds)) { // Choose a random row and column based on the total number of each int column = Random.Shared.Next(1, _tilemap.Columns - 1); int row = Random.Shared.Next(1, _tilemap.Rows - 1); // Change the bat position by setting the x and y values equal to // the column and row multiplied by the width and height. _batPosition = new Vector2(column * _bat.Width, row * _bat.Height); // Assign a new random velocity to the bat AssignRandomBatVelocity(); } base.Update(gameTime); } private void AssignRandomBatVelocity() { // Generate a random angle float angle = (float)(Random.Shared.NextDouble() * Math.PI * 2); // Convert angle to a direction vector float x = (float)Math.Cos(angle); float y = (float)Math.Sin(angle); Vector2 direction = new Vector2(x, y); // Multiply the direction vector by the movement speed _batVelocity = direction * MOVEMENT_SPEED; } private void CheckKeyboardInput() { // If the space key is held down, the movement speed increases by 1.5 float speed = MOVEMENT_SPEED; if (Input.Keyboard.IsKeyDown(Keys.Space)) { speed *= 1.5f; } // If the W or Up keys are down, move the slime up on the screen. if (Input.Keyboard.IsKeyDown(Keys.W) || Input.Keyboard.IsKeyDown(Keys.Up)) { _slimePosition.Y -= speed; } // if the S or Down keys are down, move the slime down on the screen. if (Input.Keyboard.IsKeyDown(Keys.S) || Input.Keyboard.IsKeyDown(Keys.Down)) { _slimePosition.Y += speed; } // If the A or Left keys are down, move the slime left on the screen. if (Input.Keyboard.IsKeyDown(Keys.A) || Input.Keyboard.IsKeyDown(Keys.Left)) { _slimePosition.X -= speed; } // If the D or Right keys are down, move the slime right on the screen. if (Input.Keyboard.IsKeyDown(Keys.D) || Input.Keyboard.IsKeyDown(Keys.Right)) { _slimePosition.X += speed; } } private void CheckGamePadInput() { GamePadInfo gamePadOne = Input.GamePads[(int)PlayerIndex.One]; // If the A button is held down, the movement speed increases by 1.5 // and the gamepad vibrates as feedback to the player. float speed = MOVEMENT_SPEED; if (gamePadOne.IsButtonDown(Buttons.A)) { speed *= 1.5f; GamePad.SetVibration(PlayerIndex.One, 1.0f, 1.0f); } else { GamePad.SetVibration(PlayerIndex.One, 0.0f, 0.0f); } // Check thumbstick first since it has priority over which gamepad input // is movement. It has priority since the thumbstick values provide a // more granular analog value that can be used for movement. if (gamePadOne.LeftThumbStick != Vector2.Zero) { _slimePosition.X += gamePadOne.LeftThumbStick.X * speed; _slimePosition.Y -= gamePadOne.LeftThumbStick.Y * speed; } else { // If DPadUp is down, move the slime up on the screen. if (gamePadOne.IsButtonDown(Buttons.DPadUp)) { _slimePosition.Y -= speed; } // If DPadDown is down, move the slime down on the screen. if (gamePadOne.IsButtonDown(Buttons.DPadDown)) { _slimePosition.Y += speed; } // If DPapLeft is down, move the slime left on the screen. if (gamePadOne.IsButtonDown(Buttons.DPadLeft)) { _slimePosition.X -= speed; } // If DPadRight is down, move the slime right on the screen. if (gamePadOne.IsButtonDown(Buttons.DPadRight)) { _slimePosition.X += speed; } } } protected override void Draw(GameTime gameTime) { // Clear the back buffer. GraphicsDevice.Clear(Color.CornflowerBlue); // Begin the sprite batch to prepare for rendering. SpriteBatch.Begin(samplerState: SamplerState.PointClamp); // Draw the tilemap. _tilemap.Draw(SpriteBatch); // Draw the slime sprite. _slime.Draw(SpriteBatch, _slimePosition); // Draw the bat sprite. _bat.Draw(SpriteBatch, _batPosition); // Always end the sprite batch when finished. SpriteBatch.End(); base.Draw(gameTime); } } The key changes to the Game1 class include: The _tilemap field was added to hold the loaded tilemap. The _roombounds Rectangle was added to define the playable area within the tilemap to keep the slime and bat inside the walls. In Initialize: The _roomBounds is set based on the tilemap's tile size. The starting position of the slime is now set to be in the center of the room. In LoadContent: The tilemap is loaded from the XML configuration file. The scale of the tilemap is set to a factor of 4.0. In Update, the screenBounds variable was removed and the collision logic has been updated to instead use the _roomBounds instead. In Draw the tilemap is drawn. Running the game now with these changes, our game now visually transforms from a simple screen with sprites to a proper game environment with walls and floors. The slime and bat are now confined within the walls of the dungeon defined by our tilemap. Figure 13-5: Gameplay with the tilemap rendered and the bat and slime contained within the dungeon walls Additional Notes While the method provided in this chapter offers a straightforward approach to loading tilemaps from external configuration files, several dedicated tools exist specifically for creating tilemaps for games. Popular options include Tiled, LDtk, and Ogmo. These specialized tools export map configurations in various formats such as XML (similar to what we implemented) or JSON, and often include additional features like multiple layers, object placement, and custom properties for tiles. Note In order to utilize Tilemaps from other tools, you will need a way to import those maps as MonoGame does not natively support them, one option is to use MonoGame.Extended which provides Tilemap importers for Tiled (and more in the future) as well as a host of other features. Although these tools are more robust than our implementation, the underlying concept remains the same: a tilemap is fundamentally a grid layout where each cell references a tile ID from a tileset. The principles you have learned in this chapter form the foundation for working with any tilemap system, regardless of which tool you might use. Conclusion In this chapter, you accomplished the following: Learned about tilemaps and how they are used in 2D game development. Created a Tileset class to manage collections of tiles from a texture atlas. Implemented a Tilemap class to render grid-based game environments. Created an XML-based tilemap definition system for storing level layouts. Updated our game to use tilemaps for the game environment. In the next chapter, we will start exploring audio to add sound effects when a collision occurs and background music to our game. Test Your Knowledge What is the main advantage of using tilemaps for game environments rather than individual sprites? :::question-answer Tilemaps offer several advantages: memory efficiency (reusing tiles instead of storing complete environments), performance optimization (batched rendering), and design flexibility (easier to create and modify levels). They allow creating large game worlds by reusing a small set of tiles in different arrangements. ::: What is the relationship between a tileset and a tilemap? :::question-answer A tileset is a collection of individual tiles stored in a texture atlas, where each tile has a unique ID. A tilemap is a grid-based structure that references tiles from the tileset by their IDs to create a complete game environment. The tileset provides the visual elements, while the tilemap defines their arrangement. ::: Why might you use an XML definition for a tilemap instead of hardcoding the tile layout? :::question-answer Using XML definitions for tilemaps separates level design from game code, offering several benefits: easier level editing (without changing code), support for multiple levels, ability to create external level editors, and better organization of game content. It also allows non-programmers like game designers to create and modify levels. ::: In our implementation, how does the Tilemap's Draw method work? :::question-answer The Tilemap's Draw method iterates through each position in the grid. For each position, it: Retrieves the tile ID stored at that position. Gets the corresponding texture region from the tileset. Calculates the screen position based on the grid coordinates and tile size. Draws the texture region at that position using the sprite batch. :::"
  },
  "templates/docs.monogame.github.io/articles/tutorials/building_2d_games/14_soundeffects_and_music/index.html": {
    "href": "templates/docs.monogame.github.io/articles/tutorials/building_2d_games/14_soundeffects_and_music/index.html",
    "title": "Chapter 14: SoundEffects and Music | hallowed",
    "summary": "In Chapter 12, we implemented collision detection to enable interactions between game objects; the slime can now \"eat\" the bat, which respawns in a random location, while the bat bounces off walls of the dungeon. While these mechanics work visually, our game lacks an important element of player feedback: audio. Audio plays a crucial role in game development by providing immediate feedback for player actions and creating atmosphere. Sound effects alert players when events occur (like collisions or collecting items), while background music helps establish mood and atmosphere. In this chapter, you will: Learn how MonoGame handles different types of audio content. Learn how to load and play sound effects and music using the content pipeline. Implement sound effects for collision events. Add background music to enhance atmosphere. We will first start by understanding how MonoGame approaches audio content. Understanding Audio in MonoGame Recall from Chapter 01 that MonoGame is an implementation of the XNA API. With XNA, there were two methods for implementing audio in your game: the Microsoft Cross-Platform Audio Creation Tool (XACT) and the simplified sound API. Important XACT is a mini audio engineering studio where you can easily edit the audio for your game like editing volume, pitch, looping, applying effects, and other properties without having to do it in code. At that time, XACT for XNA games was akin to what FMOD Studio is today for game audio. Figure 14-1: Microsoft Cross-Platform Audio Creation Tool While XACT projects are still fully supported in MonoGame, it remains a Windows-only tool that has not been updated since Microsoft discontinued the original XNA, nor has its source code been made open source. Though it is possible to install XACT on modern Windows, the process can be complex. For these reasons, this tutorial will focus on the simplified sound API, which provides all the core functionality needed for most games while remaining cross-platform compatible. The simplified sound API approaches audio management through two distinct paths, each optimized for different use cases in games. When adding audio to your game, you need to consider how different types of sounds should be handled: Sound Effects: Short audio clips that need to play immediately and often simultaneously, like the bounce of a ball or feedback for picking up a collectable. Music: Longer audio pieces that play continuously in the background, like level themes. MonoGame addresses these different needs through two main classes: Sound Effects The SoundEffect class handles short audio clips like: Collision sounds. Player action feedback (jumping, shooting, etc.). UI interactions (button clicks, menu navigation). Environmental effects (footsteps, ambient sounds). The key characteristics of sound effects are: Loaded entirely into memory for quick access Can play multiple instances simultaneously: Mobile platforms can have a maximum of 32 sounds playing simultaneously. Desktop platforms have a maximum of 256 sounds playing simultaneously. Consoles and other platforms have their own constraints, and you would need to refer to the SDK documentation for that platform. Lower latency playback (ideal for immediate feedback) Individual volume control per instance. Music The Song class handles longer audio pieces like background music. The key characteristics of songs are: Streamed from storage rather than loaded into memory. Only one song can be played at a time. Higher latency, but lower memory usage. Throughout this chapter, we will use both classes to add audio feedback to our game; sound effects for the bat bouncing and being eaten by the slime, and background music to create atmosphere. Loading Audio Content Just like textures, audio content in MonoGame can be loaded through the content pipeline, optimizing the format for your target platform. Supported Audio Formats MonoGame supports several audio file formats for both sound effects and music: .wav: Uncompressed audio, ideal for short sound effects .mp3: Compressed audio, better for music and longer sounds .ogg: Open source compressed format, supported on all platforms .wma: Windows Media Audio format (not recommended for cross-platform games) Tip For sound effects, .wav files provide the best loading and playback performance since they do not need to be decompressed. For music, .mp3 or .ogg files are better choices as they reduce file size while maintaining good quality. Adding Audio Files Adding audio files can be done through the content pipeline, just like we did for image files, using the MGCB Editor. When you add an audio file to the content project, the MGCB Editor will automatically select the appropriate importer and processor for the audio file based on the file extension. The processor that are available for audio files file: Sound Effects: Processes the audio file as a SoundEffect. This is automatically selected for .wav files. Song: Processes the audio file as a Song. This is automatically selected for .mp3, .ogg, and .wma files. Figure 14-2: MGCB Editor properties panel showing Sound Effect content processor settings for .wav files Figure 14-3: MGCB Editor properties panel showing Song content processor settings for .mp3 files Note While you typically will not need to change the processor it automatically selects, there may be times where you add files, such as .mp3 files that are meant to be sound effects and not songs. Always double check that the processor selected is for the intended type. Loading Sound Effects To load a sound effect, we use ContentManager.Load with the SoundEffect type: // Loading a SoundEffect using the content pipeline SoundEffect soundEffect = Content.Load<SoundEffect>(\"soundEffect\"); Loading Music Loading music is similar, only we specify the Song type instead. // Loading a Song using the content pipeline Song song = Content.Load<Song>(\"song\"); Playing Sound Effects Sound effects are played using the SoundEffect class. This class provides two ways to play sounds: Direct playback using SoundEffect.Play: // Loading a SoundEffect using the content pipeline SoundEffect soundEffect = Content.Load<SoundEffect>(\"soundEffect\"); // Play the sound effect with default settings soundEffect.Play(); Creating an instance using SoundEffect.CreateInstance: // Loading a SoundEffect using the content pipeline SoundEffect soundEffect = Content.Load<SoundEffect>(\"soundEffect\"); // Create an instance we can control SoundEffectInstance soundEffectInstance = soundEffect.CreateInstance(); // Adjust the properties of the instance as needed soundEffectInstance.IsLooped = true; // Make it loop soundEffectInstance.Volume = 0.5f; // Set half volume. // Play the sound effect using the instance. soundEffectInstance.Play(); Use SoundEffect.Play for simple sound effects that you just want to play once. Use SoundEffect.CreateInstance when you need more control over the sound effect, like adjusting volume, looping, or managing multiple instances of the same sound. SoundEffectInstance contains several properties that can be used to control how the sound effect is played: Property Type Description IsLooped bool Whether the sound should loop when it reaches the end. Pan float Stereo panning between -1.0f (full left) and 1.0f (full right). Pitch float Pitch adjustment between -1.0f (down one octave) and 1.0f (up one octave). State SoundState Current playback state (Playing, Paused, or Stopped). Volume float Volume level between 0.0f (silent) and 1.0f (full volume). Note There is a lot more behind SoundEffectInstances such as the ability to play 3D sounds, as well as the advanced capabilities of the DynamicSoundEffectInstance which can build audio streams. However, these are beyond the scope of this beginners guide. If you wish to know more, then check the MonoGame documentation Playing Music Unlike sound effects, music is played through the MediaPlayer class. This static class manages playback of Song instances and provides global control over music playback: // Loading a Song using the content pipeline Song song = Content.Load<Song>(\"song\"); // Set whether the song should repeat when finished MediaPlayer.IsRepeating = true; // Adjust the volume (0.0f to 1.0f) MediaPlayer.Volume = 0.5f; // Check if the media player is already playing, if so, stop it if(MediaPlayer.State == MediaState.Playing) { MediaPlayer.Stop(); } // Start playing the background music MediaPlayer.Play(song); Important While SoundEffect instances can be played simultaneously, trying to play a new Song while another is playing will stop the current song in the best case, and in the worst case cause a crash on some platforms. In the example above, the state of the media player is checked first before we tell it to play a song. Checking the state first and stopping it manually if it is playing is best practice to prevent potential crashes. Adding Audio To Our Game Before we can add audio to our game, we need some sound files to work with. Download the following audio files: bounce.wav{download} - For when the bat bounces off screen edges collect.wav{download} - For when the slime eats the bat theme.ogg{download} - Background music Note bounce.wav is \"Retro Impact Punch 07\" by Davit Masia (https://kronbits.itch.io/retrosfx). collect.wav is \"Retro Jump Classic 08\" by Davit Masia (https://kronbits.itch.io/retrosfx). theme.mp3 is \"Exploration\" by Luis Zuno (@ansimuz). Add these files to your content project using the MGCB Editor: Open the Content.mgcb file in the MGCB Editor. Create a new folder called audio (right-click Content > Add > New Folder). Right-click the new audio folder and choose Add > Existing Item.... Navigate to and select the audio files you downloaded. For each file that is added, check its properties in the Properties panel: For .wav files, ensure the Processor is set to Sound Effect. For .mp3 files, ensure the Processor is set to Song. Save the changes and close the MGCB Editor. Next, open the Game1.cs file and update it to the following: using System; using Microsoft.Xna.Framework; using Microsoft.Xna.Framework.Audio; using Microsoft.Xna.Framework.Graphics; using Microsoft.Xna.Framework.Input; using Microsoft.Xna.Framework.Media; using MonoGameLibrary; using MonoGameLibrary.Graphics; using MonoGameLibrary.Input; namespace DungeonSlime; public class Game1 : Core { // Defines the slime animated sprite. private AnimatedSprite _slime; // Defines the bat animated sprite. private AnimatedSprite _bat; // Tracks the position of the slime. private Vector2 _slimePosition; // Speed multiplier when moving. private const float MOVEMENT_SPEED = 5.0f; // Tracks the position of the bat. private Vector2 _batPosition; // Tracks the velocity of the bat. private Vector2 _batVelocity; // Defines the tilemap to draw. private Tilemap _tilemap; // Defines the bounds of the room that the slime and bat are contained within. private Rectangle _roomBounds; // The sound effect to play when the bat bounces off the edge of the screen. private SoundEffect _bounceSoundEffect; // The sound effect to play when the slime eats a bat. private SoundEffect _collectSoundEffect; public Game1() : base(\"Dungeon Slime\", 1280, 720, false) { } protected override void Initialize() { base.Initialize(); Rectangle screenBounds = GraphicsDevice.PresentationParameters.Bounds; _roomBounds = new Rectangle( (int)_tilemap.TileWidth, (int)_tilemap.TileHeight, screenBounds.Width - (int)_tilemap.TileWidth * 2, screenBounds.Height - (int)_tilemap.TileHeight * 2 ); // Initial slime position will be the center tile of the tile map. int centerRow = _tilemap.Rows / 2; int centerColumn = _tilemap.Columns / 2; _slimePosition = new Vector2(centerColumn * _tilemap.TileWidth, centerRow * _tilemap.TileHeight); // Initial bat position will the in the top left corner of the room _batPosition = new Vector2(_roomBounds.Left, _roomBounds.Top); // Assign the initial random velocity to the bat. AssignRandomBatVelocity(); } protected override void LoadContent() { // Create the texture atlas from the XML configuration file TextureAtlas atlas = TextureAtlas.FromFile(Content, \"images/atlas-definition.xml\"); // Create the slime animated sprite from the atlas. _slime = atlas.CreateAnimatedSprite(\"slime-animation\"); _slime.Scale = new Vector2(4.0f, 4.0f); // Create the bat animated sprite from the atlas. _bat = atlas.CreateAnimatedSprite(\"bat-animation\"); _bat.Scale = new Vector2(4.0f, 4.0f); // Create the tilemap from the XML configuration file. _tilemap = Tilemap.FromFile(Content, \"images/tilemap-definition.xml\"); _tilemap.Scale = new Vector2(4.0f, 4.0f); // Load the bounce sound effect _bounceSoundEffect = Content.Load<SoundEffect>(\"audio/bounce\"); // Load the collect sound effect _collectSoundEffect = Content.Load<SoundEffect>(\"audio/collect\"); // Load the background theme music Song theme = Content.Load<Song>(\"audio/theme\"); // Ensure media player is not already playing on device, if so, stop it if (MediaPlayer.State == MediaState.Playing) { MediaPlayer.Stop(); } // Play the background theme music. MediaPlayer.Play(theme); // Set the theme music to repeat. MediaPlayer.IsRepeating = true; } protected override void Update(GameTime gameTime) { // Update the slime animated sprite. _slime.Update(gameTime); // Update the bat animated sprite. _bat.Update(gameTime); // Check for keyboard input and handle it. CheckKeyboardInput(); // Check for gamepad input and handle it. CheckGamePadInput(); // Creating a bounding circle for the slime Circle slimeBounds = new Circle( (int)(_slimePosition.X + (_slime.Width * 0.5f)), (int)(_slimePosition.Y + (_slime.Height * 0.5f)), (int)(_slime.Width * 0.5f) ); // Use distance based checks to determine if the slime is within the // bounds of the game screen, and if it is outside that screen edge, // move it back inside. if (slimeBounds.Left < _roomBounds.Left) { _slimePosition.X = _roomBounds.Left; } else if (slimeBounds.Right > _roomBounds.Right) { _slimePosition.X = _roomBounds.Right - _slime.Width; } if (slimeBounds.Top < _roomBounds.Top) { _slimePosition.Y = _roomBounds.Top; } else if (slimeBounds.Bottom > _roomBounds.Bottom) { _slimePosition.Y = _roomBounds.Bottom - _slime.Height; } // Calculate the new position of the bat based on the velocity Vector2 newBatPosition = _batPosition + _batVelocity; // Create a bounding circle for the bat Circle batBounds = new Circle( (int)(newBatPosition.X + (_bat.Width * 0.5f)), (int)(newBatPosition.Y + (_bat.Height * 0.5f)), (int)(_bat.Width * 0.5f) ); Vector2 normal = Vector2.Zero; // Use distance based checks to determine if the bat is within the // bounds of the game screen, and if it is outside that screen edge, // reflect it about the screen edge normal if (batBounds.Left < _roomBounds.Left) { normal.X = Vector2.UnitX.X; newBatPosition.X = _roomBounds.Left; } else if (batBounds.Right > _roomBounds.Right) { normal.X = -Vector2.UnitX.X; newBatPosition.X = _roomBounds.Right - _bat.Width; } if (batBounds.Top < _roomBounds.Top) { normal.Y = Vector2.UnitY.Y; newBatPosition.Y = _roomBounds.Top; } else if (batBounds.Bottom > _roomBounds.Bottom) { normal.Y = -Vector2.UnitY.Y; newBatPosition.Y = _roomBounds.Bottom - _bat.Height; } // If the normal is anything but Vector2.Zero, this means the bat had // moved outside the screen edge so we should reflect it about the // normal. if (normal != Vector2.Zero) { normal.Normalize(); _batVelocity = Vector2.Reflect(_batVelocity, normal); // Play the bounce sound effect _bounceSoundEffect.Play(); } _batPosition = newBatPosition; if (slimeBounds.Intersects(batBounds)) { // Choose a random row and column based on the total number of each int column = Random.Shared.Next(1, _tilemap.Columns - 1); int row = Random.Shared.Next(1, _tilemap.Rows - 1); // Change the bat position by setting the x and y values equal to // the column and row multiplied by the width and height. _batPosition = new Vector2(column * _bat.Width, row * _bat.Height); // Assign a new random velocity to the bat AssignRandomBatVelocity(); // Play the collect sound effect _collectSoundEffect.Play(); } base.Update(gameTime); } private void AssignRandomBatVelocity() { // Generate a random angle float angle = (float)(Random.Shared.NextDouble() * Math.PI * 2); // Convert angle to a direction vector float x = (float)Math.Cos(angle); float y = (float)Math.Sin(angle); Vector2 direction = new Vector2(x, y); // Multiply the direction vector by the movement speed _batVelocity = direction * MOVEMENT_SPEED; } private void CheckKeyboardInput() { // If the space key is held down, the movement speed increases by 1.5 float speed = MOVEMENT_SPEED; if (Input.Keyboard.IsKeyDown(Keys.Space)) { speed *= 1.5f; } // If the W or Up keys are down, move the slime up on the screen. if (Input.Keyboard.IsKeyDown(Keys.W) || Input.Keyboard.IsKeyDown(Keys.Up)) { _slimePosition.Y -= speed; } // if the S or Down keys are down, move the slime down on the screen. if (Input.Keyboard.IsKeyDown(Keys.S) || Input.Keyboard.IsKeyDown(Keys.Down)) { _slimePosition.Y += speed; } // If the A or Left keys are down, move the slime left on the screen. if (Input.Keyboard.IsKeyDown(Keys.A) || Input.Keyboard.IsKeyDown(Keys.Left)) { _slimePosition.X -= speed; } // If the D or Right keys are down, move the slime right on the screen. if (Input.Keyboard.IsKeyDown(Keys.D) || Input.Keyboard.IsKeyDown(Keys.Right)) { _slimePosition.X += speed; } } private void CheckGamePadInput() { GamePadInfo gamePadOne = Input.GamePads[(int)PlayerIndex.One]; // If the A button is held down, the movement speed increases by 1.5 // and the gamepad vibrates as feedback to the player. float speed = MOVEMENT_SPEED; if (gamePadOne.IsButtonDown(Buttons.A)) { speed *= 1.5f; GamePad.SetVibration(PlayerIndex.One, 1.0f, 1.0f); } else { GamePad.SetVibration(PlayerIndex.One, 0.0f, 0.0f); } // Check thumbstick first since it has priority over which gamepad input // is movement. It has priority since the thumbstick values provide a // more granular analog value that can be used for movement. if (gamePadOne.LeftThumbStick != Vector2.Zero) { _slimePosition.X += gamePadOne.LeftThumbStick.X * speed; _slimePosition.Y -= gamePadOne.LeftThumbStick.Y * speed; } else { // If DPadUp is down, move the slime up on the screen. if (gamePadOne.IsButtonDown(Buttons.DPadUp)) { _slimePosition.Y -= speed; } // If DPadDown is down, move the slime down on the screen. if (gamePadOne.IsButtonDown(Buttons.DPadDown)) { _slimePosition.Y += speed; } // If DPapLeft is down, move the slime left on the screen. if (gamePadOne.IsButtonDown(Buttons.DPadLeft)) { _slimePosition.X -= speed; } // If DPadRight is down, move the slime right on the screen. if (gamePadOne.IsButtonDown(Buttons.DPadRight)) { _slimePosition.X += speed; } } } protected override void Draw(GameTime gameTime) { // Clear the back buffer. GraphicsDevice.Clear(Color.CornflowerBlue); // Begin the sprite batch to prepare for rendering. SpriteBatch.Begin(samplerState: SamplerState.PointClamp); // Draw the tilemap _tilemap.Draw(SpriteBatch); // Draw the slime sprite. _slime.Draw(SpriteBatch, _slimePosition); // Draw the bat sprite. _bat.Draw(SpriteBatch, _batPosition); // Always end the sprite batch when finished. SpriteBatch.End(); base.Draw(gameTime); } } The key changes here are: Added the using Microsoft.Xna.Framework.Audio; and using Microsoft.Xna.Framework.Media; directories to access the Song and SoundEffect classes. Added the _boundSoundEffect and _collectSoundEffect fields to store those sound effects when loaded and use them for playback. In LoadContent The bounce and collect sound effects are loaded using the content manager. The background theme music is loaded using the content manager. The background music is played using the media player, checking its state first. The MediaPlayer.IsRepeating is set to true so the background music loops. In Update: The bounce sound effect is played when the bat bounces off the edge of the screen. The collect sound effect is played when the slime eats the bat. Running the game now, the theme music plays in the background, you can hear the bat bounce off the edge of the screen, and if you move the slime to eat the bat, you hear that as well. Figure 14-4: Gameplay with audio. Conclusion In this chapter, you accomplished the following: Learned about MonoGame's audio system including sound effects and music. Explored the key differences between: Sound effects (short, multiple simultaneous playback). Music (longer, streamed, single playback). Added audio content to your game project through the content pipeline. Loaded audio files using the ContentManager. Implemented audio feedback in your game: Background music to set atmosphere. Sound effects for bat bouncing and collection events. Learned best practices for handling audio playback across different platforms. In the next chapter, we will explore additional ways to manage audio by creating an audio controller module that will help with common tasks such as volume control, muting, and state management. Test Your Knowledge What are the two main classes MonoGame provides for audio playback and how do they differ? :::question-answer MonoGame provides: SoundEffect for short audio clips (loaded entirely into memory, multiple can play at once) and Song for longer audio like music (streamed from storage, only one can play at a time). ::: Why is it important to check if MediaPlayer is already playing before starting a new song? :::question-answer Checking if MediaPlayer is already playing and stopping it if necessary helps prevent crashes on some platforms. Since only one song can play at a time, properly stopping the current song before starting a new one ensures reliable behavior across different platforms. ::: What file formats are best suited for sound effects and music, respectively, and why? :::question-answer For sound effects, .wav files are generally best because they are uncompressed and load quickly into memory for immediate playback. For music, compressed formats like .mp3 or .ogg are better suited because they greatly reduce file size while maintaining good audio quality, which is important for longer audio that's streamed rather than fully loaded. ::: What is the difference between using SoundEffect.Play directly and creating a SoundEffectInstance? :::question-answer SoundEffect.Play is simpler but provides limited control - it plays the sound once with basic volume/pitch/pan settings. Creating a SoundEffectInstance gives more control including the ability to pause, resume, loop, and change properties during playback, as well as track the sound's state. ::: How many sound effects can play simultaneously on different platforms? :::question-answer The number of simultaneous sound effects varies by platform: Mobile platforms: maximum of 32 sounds. Desktop platforms: maximum of 256 sounds. Consoles and other platforms have their own constraints specified in their respective SDK documentation. :::"
  },
  "templates/docs.monogame.github.io/articles/tutorials/building_2d_games/15_audio_controller/index.html": {
    "href": "templates/docs.monogame.github.io/articles/tutorials/building_2d_games/15_audio_controller/index.html",
    "title": "Chapter 15: Audio Controller | hallowed",
    "summary": "While playing sounds and music using the simplified sound API is straightforward, a game needs to handle various audio states and resource cleanup including: Track and manage sound effect instances that are created. Dispose of sound effect instances when they are finished. Handle volume control for songs and sound effects. Manage audio states (pause/resume, mute/unmute). In this chapter you will: Learn how to create a central audio management system. Implement proper resource tracking and cleanup for sound effects. Build methods to control audio state (play/pause, mute/unmute). Add global volume control for different audio types. Integrate the audio controller with your game's core systems. Implement keyboard shortcuts for audio control. By the end of this chapter, you will have an audio control system that can be easily reused in future game projects. The AudioController Class To get started, in the MonoGameLibrary project: Create a new folder named Audio. Add a new class file named AudioController.cs to the Audio folder you just created. Add the following code as the initial structure for the class using System; using System.Collections.Generic; using Microsoft.Xna.Framework.Audio; using Microsoft.Xna.Framework.Media; namespace MonoGameLibrary.Audio; public class AudioController : IDisposable { } Note The AudioController class will implement the IDisposable interface, This interface is part of .NET and provides a standardized implementation for an object to release resources. Implementing IDisposable allows other code to properly clean up the resources held by our audio controller when it is no longer needed. For more information on IDisposable, you can read the Implement a Dispose Method article on Microsoft Learn. AudioController Properties and Fields The AudioController will need to track sound effect instances created for cleanup and track the state and volume levels of songs and sound effects when toggling between mute states. Add the following fields and properties: // Tracks sound effect instances created so they can be paused, unpaused, and/or disposed. private readonly List<SoundEffectInstance> _activeSoundEffectInstances; // Tracks the volume for song playback when muting and unmuting. private float _previousSongVolume; // Tracks the volume for sound effect playback when muting and unmuting. private float _previousSoundEffectVolume; /// <summary> /// Gets a value that indicates if audio is muted. /// </summary> public bool IsMuted { get; private set; } /// <summary> /// Gets or Sets the global volume of songs. /// </summary> /// <remarks> /// If IsMuted is true, the getter will always return back 0.0f and the /// setter will ignore setting the volume. /// </remarks> public float SongVolume { get { if(IsMuted) { return 0.0f; } return MediaPlayer.Volume; } set { if(IsMuted) { return; } MediaPlayer.Volume = Math.Clamp(value, 0.0f, 1.0f); } } /// <summary> /// Gets or Sets the global volume of sound effects. /// </summary> /// <remarks> /// If IsMuted is true, the getter will always return back 0.0f and the /// setter will ignore setting the volume. /// </remarks> public float SoundEffectVolume { get { if(IsMuted) { return 0.0f; } return SoundEffect.MasterVolume; } set { if(IsMuted) { return; } SoundEffect.MasterVolume = Math.Clamp(value, 0.0f, 1.0f); } } /// <summary> /// Gets a value that indicates if this audio controller has been disposed. /// </summary> public bool IsDisposed { get; private set; } AudioController Constructor The constructor just initializes the collection used to track the sound effect instances. Add the following constructor and finalizer: /// <summary> /// Creates a new audio controller instance. /// </summary> public AudioController() { _activeSoundEffectInstances = new List<SoundEffectInstance>(); } // Finalizer called when object is collected by the garbage collector. ~AudioController() => Dispose(false); Note The AudioController class implements a finalizer method ~AudioManager(). This method is called when an instance of the class is collected by the garbage collector and is here as part of the IDisposable implementation. AudioController Methods The AudioController needs methods to: Update it to check for resources to clean up. Playing sound effects and songs State management (play/pause, mute/unmute) Volume control Implement the IDisposable interface. So lets add them below. AudioController Update The Update method will check for existing sound effect instances that have expired and properly dispose of them. Add the following method: /// <summary> /// Updates this audio controller. /// </summary> public void Update() { for (int i = _activeSoundEffectInstances.Count - 1; i >= 0; i--) { SoundEffectInstance instance = _activeSoundEffectInstances[i]; if (instance.State == SoundState.Stopped) { if (!instance.IsDisposed) { instance.Dispose(); } _activeSoundEffectInstances.RemoveAt(i); } } } AudioController Playback While the MonoGame simplified audio API allows sound effects to be played in a fire and forget manner, doing it this way does not work if you need to pause them because the game paused. Instead, we can add playback methods through the AudioController that can track the sound effect instances and pause them if needed, as well as checking the media player state before playing a song. Add the following methods: /// <summary> /// Plays the given sound effect. /// </summary> /// <param name=\"soundEffect\">The sound effect to play.</param> /// <returns>The sound effect instance created by this method.</returns> public SoundEffectInstance PlaySoundEffect(SoundEffect soundEffect) { return PlaySoundEffect(soundEffect, 1.0f, 0.0f, 0.0f, false); } /// <summary> /// Plays the given sound effect with the specified properties. /// </summary> /// <param name=\"soundEffect\">The sound effect to play.</param> /// <param name=\"volume\">The volume, ranging from 0.0 (silence) to 1.0 (full volume).</param> /// <param name=\"pitch\">The pitch adjustment, ranging from -1.0 (down an octave) to 0.0 (no change) to 1.0 (up an octave).</param> /// <param name=\"pan\">The panning, ranging from -1.0 (left speaker) to 0.0 (centered), 1.0 (right speaker).</param> /// <param name=\"isLooped\">Whether the the sound effect should loop after playback.</param> /// <returns>The sound effect instance created by playing the sound effect.</returns> /// <returns>The sound effect instance created by this method.</returns> public SoundEffectInstance PlaySoundEffect(SoundEffect soundEffect, float volume, float pitch, float pan, bool isLooped) { // Create an instance from the sound effect given. SoundEffectInstance soundEffectInstance = soundEffect.CreateInstance(); // Apply the volume, pitch, pan, and loop values specified. soundEffectInstance.Volume = volume; soundEffectInstance.Pitch = pitch; soundEffectInstance.Pan = pan; soundEffectInstance.IsLooped = isLooped; // Tell the instance to play soundEffectInstance.Play(); // Add it to the active instances for tracking _activeSoundEffectInstances.Add(soundEffectInstance); return soundEffectInstance; } /// <summary> /// Plays the given song. /// </summary> /// <param name=\"song\">The song to play.</param> /// <param name=\"isRepeating\">Optionally specify if the song should repeat. Default is true.</param> public void PlaySong(Song song, bool isRepeating = true) { // Check if the media player is already playing, if so, stop it. // If we do not stop it, this could cause issues on some platforms if (MediaPlayer.State == MediaState.Playing) { MediaPlayer.Stop(); } MediaPlayer.Play(song); MediaPlayer.IsRepeating = isRepeating; } AudioController State Control The AudioController provides methods to control the state of audio playback including pausing and resuming audio as well as muting and unmuting. Add the following methods: /// <summary> /// Pauses all audio. /// </summary> public void PauseAudio() { // Pause any active songs playing. MediaPlayer.Pause(); // Pause any active sound effects. foreach (SoundEffectInstance soundEffectInstance in _activeSoundEffectInstances) { soundEffectInstance.Pause(); } } /// <summary> /// Resumes play of all previous paused audio. /// </summary> public void ResumeAudio() { // Resume paused music MediaPlayer.Resume(); // Resume any active sound effects. foreach (SoundEffectInstance soundEffectInstance in _activeSoundEffectInstances) { soundEffectInstance.Resume(); } } /// <summary> /// Mutes all audio. /// </summary> public void MuteAudio() { // Store the volume so they can be restored during ResumeAudio _previousSongVolume = MediaPlayer.Volume; _previousSoundEffectVolume = SoundEffect.MasterVolume; // Set all volumes to 0 MediaPlayer.Volume = 0.0f; SoundEffect.MasterVolume = 0.0f; IsMuted = true; } /// <summary> /// Unmutes all audio to the volume level prior to muting. /// </summary> public void UnmuteAudio() { // Restore the previous volume values. MediaPlayer.Volume = _previousSongVolume; SoundEffect.MasterVolume = _previousSoundEffectVolume; IsMuted = false; } /// <summary> /// Toggles the current audio mute state. /// </summary> public void ToggleMute() { if (IsMuted) { UnmuteAudio(); } else { MuteAudio(); } } AudioController IDisposable Implementation Finally, the AudioController is required to implement the IDisposable interface, to complete this add the following methods: /// <summary> /// Disposes of this audio controller and cleans up resources. /// </summary> public void Dispose() { Dispose(true); GC.SuppressFinalize(this); } /// <summary> /// Disposes this audio controller and cleans up resources. /// </summary> /// <param name=\"disposing\">Indicates whether managed resources should be disposed.</param> protected void Dispose(bool disposing) { if(IsDisposed) { return; } if (disposing) { foreach (SoundEffectInstance soundEffectInstance in _activeSoundEffectInstances) { soundEffectInstance.Dispose(); } _activeSoundEffectInstances.Clear(); } IsDisposed = true; } Games often use limited system resources like audio channels, when we are done with these resources we need to clean them up properly. In .NET, the standard way to handle resource cleanup is through the IDisposable interface. Think of IDisposable like a cleanup checklist that runs when you are finished with something: The interface provides a Dispose method that contains all cleanup logic. When called, Dispose releases any resources the class was using. Even if you forget to call Dispose, the finalizer acts as a backup cleanup mechanism. For our AudioController, implementing IDisposable means we can ensure all sound effect instances are properly stopped and disposed when our game ends, preventing resource leaks. Note Fore more information on IDisposable and the Dispose method, check out the Implementing a Dispose Method article on Microsoft Learn. Implementing the AudioController Class Now that we have the audio controller class complete, we can update the game to use it. We will do this in two steps: First, update the Core class to add the AudioController globally. Update the Game1 class to use the global audio controller from Core. Updating the Core Class The Core class serves as our base game class, so we will update it first to add and expose the AudioController globally. Open the Core.cs file in the MonoGameLibrary project and update it to the following: using System; using Microsoft.Xna.Framework; using Microsoft.Xna.Framework.Content; using Microsoft.Xna.Framework.Graphics; using Microsoft.Xna.Framework.Input; using MonoGameLibrary.Audio; using MonoGameLibrary.Input; namespace MonoGameLibrary; public class Core : Game { internal static Core s_instance; /// <summary> /// Gets a reference to the Core instance. /// </summary> public static Core Instance => s_instance; /// <summary> /// Gets the graphics device manager to control the presentation of graphics. /// </summary> public static GraphicsDeviceManager Graphics { get; private set; } /// <summary> /// Gets the graphics device used to create graphical resources and perform primitive rendering. /// </summary> public static new GraphicsDevice GraphicsDevice { get; private set; } /// <summary> /// Gets the sprite batch used for all 2D rendering. /// </summary> public static SpriteBatch SpriteBatch { get; private set; } /// <summary> /// Gets the content manager used to load global assets. /// </summary> public static new ContentManager Content { get; private set; } /// <summary> /// Gets a reference to to the input management system. /// </summary> public static InputManager Input { get; private set; } /// <summary> /// Gets or Sets a value that indicates if the game should exit when the esc key on the keyboard is pressed. /// </summary> public static bool ExitOnEscape { get; set; } /// <summary> /// Gets a reference to the audio control system. /// </summary> public static AudioController Audio { get; private set; } /// <summary> /// Creates a new Core instance. /// </summary> /// <param name=\"title\">The title to display in the title bar of the game window.</param> /// <param name=\"width\">The initial width, in pixels, of the game window.</param> /// <param name=\"height\">The initial height, in pixels, of the game window.</param> /// <param name=\"fullScreen\">Indicates if the game should start in fullscreen mode.</param> public Core(string title, int width, int height, bool fullScreen) { // Ensure that multiple cores are not created. if (s_instance != null) { throw new InvalidOperationException($\"Only a single Core instance can be created\"); } // Store reference to engine for global member access. s_instance = this; // Create a new graphics device manager. Graphics = new GraphicsDeviceManager(this); // Set the graphics defaults. Graphics.PreferredBackBufferWidth = width; Graphics.PreferredBackBufferHeight = height; Graphics.IsFullScreen = fullScreen; // Apply the graphic presentation changes. Graphics.ApplyChanges(); // Set the window title. Window.Title = title; // Set the core's content manager to a reference of the base Game's // content manager. Content = base.Content; // Set the root directory for content. Content.RootDirectory = \"Content\"; // Mouse is visible by default. IsMouseVisible = true; // Exit on escape is true by default ExitOnEscape = true; } protected override void Initialize() { base.Initialize(); // Set the core's graphics device to a reference of the base Game's // graphics device. GraphicsDevice = base.GraphicsDevice; // Create the sprite batch instance. SpriteBatch = new SpriteBatch(GraphicsDevice); // Create a new input manager. Input = new InputManager(); // Create a new audio controller. Audio = new AudioController(); } protected override void UnloadContent() { // Dispose of the audio controller. Audio.Dispose(); base.UnloadContent(); } protected override void Update(GameTime gameTime) { // Update the input manager. Input.Update(gameTime); // Update the audio controller. Audio.Update(); if (ExitOnEscape && Input.Keyboard.IsKeyDown(Keys.Escape)) { Exit(); } base.Update(gameTime); } } The key changes made here are: Added the using MonoGameLibrary.Audio; directive to access the AudioController class. Added a static Audio property to provide global access to the audio controller. Created the new audio controller instance in the Initialize method. Added an override for the UnloadContent method where we dispose of the audio controller. The audio controller is updated in the Update method. Updating the Game1 Class Next, update the Game1 class to use the audio controller for audio playback. Open Game1.cs and make the following updates: using System; using Microsoft.Xna.Framework; using Microsoft.Xna.Framework.Audio; using Microsoft.Xna.Framework.Graphics; using Microsoft.Xna.Framework.Input; using Microsoft.Xna.Framework.Media; using MonoGameLibrary; using MonoGameLibrary.Graphics; using MonoGameLibrary.Input; namespace DungeonSlime; public class Game1 : Core { // Defines the slime animated sprite. private AnimatedSprite _slime; // Defines the bat animated sprite. private AnimatedSprite _bat; // Tracks the position of the slime. private Vector2 _slimePosition; // Speed multiplier when moving. private const float MOVEMENT_SPEED = 5.0f; // Tracks the position of the bat. private Vector2 _batPosition; // Tracks the velocity of the bat. private Vector2 _batVelocity; // Defines the tilemap to draw. private Tilemap _tilemap; // Defines the bounds of the room that the slime and bat are contained within. private Rectangle _roomBounds; // The sound effect to play when the bat bounces off the edge of the screen. private SoundEffect _bounceSoundEffect; // The sound effect to play when the slime eats a bat. private SoundEffect _collectSoundEffect; // The background theme song private Song _themeSong; public Game1() : base(\"Dungeon Slime\", 1280, 720, false) { } protected override void Initialize() { base.Initialize(); Rectangle screenBounds = GraphicsDevice.PresentationParameters.Bounds; _roomBounds = new Rectangle( (int)_tilemap.TileWidth, (int)_tilemap.TileHeight, screenBounds.Width - (int)_tilemap.TileWidth * 2, screenBounds.Height - (int)_tilemap.TileHeight * 2 ); // Initial slime position will be the center tile of the tile map. int centerRow = _tilemap.Rows / 2; int centerColumn = _tilemap.Columns / 2; _slimePosition = new Vector2(centerColumn * _tilemap.TileWidth, centerRow * _tilemap.TileHeight); // Initial bat position will the in the top left corner of the room. _batPosition = new Vector2(_roomBounds.Left, _roomBounds.Top); // Assign the initial random velocity to the bat. AssignRandomBatVelocity(); // Start playing the background music. Audio.PlaySong(_themeSong); } protected override void LoadContent() { // Create the texture atlas from the XML configuration file. TextureAtlas atlas = TextureAtlas.FromFile(Content, \"images/atlas-definition.xml\"); // Create the slime animated sprite from the atlas. _slime = atlas.CreateAnimatedSprite(\"slime-animation\"); _slime.Scale = new Vector2(4.0f, 4.0f); // Create the bat animated sprite from the atlas. _bat = atlas.CreateAnimatedSprite(\"bat-animation\"); _bat.Scale = new Vector2(4.0f, 4.0f); // Create the tilemap from the XML configuration file. _tilemap = Tilemap.FromFile(Content, \"images/tilemap-definition.xml\"); _tilemap.Scale = new Vector2(4.0f, 4.0f); // Load the bounce sound effect. _bounceSoundEffect = Content.Load<SoundEffect>(\"audio/bounce\"); // Load the collect sound effect. _collectSoundEffect = Content.Load<SoundEffect>(\"audio/collect\"); // Load the background theme music. _themeSong = Content.Load<Song>(\"audio/theme\"); } protected override void Update(GameTime gameTime) { // Update the slime animated sprite. _slime.Update(gameTime); // Update the bat animated sprite. _bat.Update(gameTime); // Check for keyboard input and handle it. CheckKeyboardInput(); // Check for gamepad input and handle it. CheckGamePadInput(); // Creating a bounding circle for the slime. Circle slimeBounds = new Circle( (int)(_slimePosition.X + (_slime.Width * 0.5f)), (int)(_slimePosition.Y + (_slime.Height * 0.5f)), (int)(_slime.Width * 0.5f) ); // Use distance based checks to determine if the slime is within the // bounds of the game screen, and if it is outside that screen edge, // move it back inside. if (slimeBounds.Left < _roomBounds.Left) { _slimePosition.X = _roomBounds.Left; } else if (slimeBounds.Right > _roomBounds.Right) { _slimePosition.X = _roomBounds.Right - _slime.Width; } if (slimeBounds.Top < _roomBounds.Top) { _slimePosition.Y = _roomBounds.Top; } else if (slimeBounds.Bottom > _roomBounds.Bottom) { _slimePosition.Y = _roomBounds.Bottom - _slime.Height; } // Calculate the new position of the bat based on the velocity. Vector2 newBatPosition = _batPosition + _batVelocity; // Create a bounding circle for the bat. Circle batBounds = new Circle( (int)(newBatPosition.X + (_bat.Width * 0.5f)), (int)(newBatPosition.Y + (_bat.Height * 0.5f)), (int)(_bat.Width * 0.5f) ); Vector2 normal = Vector2.Zero; // Use distance based checks to determine if the bat is within the // bounds of the game screen, and if it is outside that screen edge, // reflect it about the screen edge normal if (batBounds.Left < _roomBounds.Left) { normal.X = Vector2.UnitX.X; newBatPosition.X = _roomBounds.Left; } else if (batBounds.Right > _roomBounds.Right) { normal.X = -Vector2.UnitX.X; newBatPosition.X = _roomBounds.Right - _bat.Width; } if (batBounds.Top < _roomBounds.Top) { normal.Y = Vector2.UnitY.Y; newBatPosition.Y = _roomBounds.Top; } else if (batBounds.Bottom > _roomBounds.Bottom) { normal.Y = -Vector2.UnitY.Y; newBatPosition.Y = _roomBounds.Bottom - _bat.Height; } // If the normal is anything but Vector2.Zero, this means the bat had // moved outside the screen edge so we should reflect it about the // normal. if (normal != Vector2.Zero) { normal.Normalize(); _batVelocity = Vector2.Reflect(_batVelocity, normal); // Play the bounce sound effect. Audio.PlaySoundEffect(_bounceSoundEffect); } _batPosition = newBatPosition; if (slimeBounds.Intersects(batBounds)) { // Choose a random row and column based on the total number of each int column = Random.Shared.Next(1, _tilemap.Columns - 1); int row = Random.Shared.Next(1, _tilemap.Rows - 1); // Change the bat position by setting the x and y values equal to // the column and row multiplied by the width and height. _batPosition = new Vector2(column * _bat.Width, row * _bat.Height); // Assign a new random velocity to the bat. AssignRandomBatVelocity(); // Play the collect sound effect. Audio.PlaySoundEffect(_collectSoundEffect); } base.Update(gameTime); } private void AssignRandomBatVelocity() { // Generate a random angle. float angle = (float)(Random.Shared.NextDouble() * Math.PI * 2); // Convert angle to a direction vector. float x = (float)Math.Cos(angle); float y = (float)Math.Sin(angle); Vector2 direction = new Vector2(x, y); // Multiply the direction vector by the movement speed. _batVelocity = direction * MOVEMENT_SPEED; } private void CheckKeyboardInput() { // If the space key is held down, the movement speed increases by 1.5 float speed = MOVEMENT_SPEED; if (Input.Keyboard.IsKeyDown(Keys.Space)) { speed *= 1.5f; } // If the W or Up keys are down, move the slime up on the screen. if (Input.Keyboard.IsKeyDown(Keys.W) || Input.Keyboard.IsKeyDown(Keys.Up)) { _slimePosition.Y -= speed; } // if the S or Down keys are down, move the slime down on the screen. if (Input.Keyboard.IsKeyDown(Keys.S) || Input.Keyboard.IsKeyDown(Keys.Down)) { _slimePosition.Y += speed; } // If the A or Left keys are down, move the slime left on the screen. if (Input.Keyboard.IsKeyDown(Keys.A) || Input.Keyboard.IsKeyDown(Keys.Left)) { _slimePosition.X -= speed; } // If the D or Right keys are down, move the slime right on the screen. if (Input.Keyboard.IsKeyDown(Keys.D) || Input.Keyboard.IsKeyDown(Keys.Right)) { _slimePosition.X += speed; } // If the M key is pressed, toggle mute state for audio. if (Input.Keyboard.WasKeyJustPressed(Keys.M)) { Audio.ToggleMute(); } // If the + button is pressed, increase the volume. if (Input.Keyboard.WasKeyJustPressed(Keys.OemPlus)) { Audio.SongVolume += 0.1f; Audio.SoundEffectVolume += 0.1f; } // If the - button was pressed, decrease the volume. if (Input.Keyboard.WasKeyJustPressed(Keys.OemMinus)) { Audio.SongVolume -= 0.1f; Audio.SoundEffectVolume -= 0.1f; } } private void CheckGamePadInput() { GamePadInfo gamePadOne = Input.GamePads[(int)PlayerIndex.One]; // If the A button is held down, the movement speed increases by 1.5 // and the gamepad vibrates as feedback to the player. float speed = MOVEMENT_SPEED; if (gamePadOne.IsButtonDown(Buttons.A)) { speed *= 1.5f; GamePad.SetVibration(PlayerIndex.One, 1.0f, 1.0f); } else { GamePad.SetVibration(PlayerIndex.One, 0.0f, 0.0f); } // Check thumbstick first since it has priority over which gamepad input // is movement. It has priority since the thumbstick values provide a // more granular analog value that can be used for movement. if (gamePadOne.LeftThumbStick != Vector2.Zero) { _slimePosition.X += gamePadOne.LeftThumbStick.X * speed; _slimePosition.Y -= gamePadOne.LeftThumbStick.Y * speed; } else { // If DPadUp is down, move the slime up on the screen. if (gamePadOne.IsButtonDown(Buttons.DPadUp)) { _slimePosition.Y -= speed; } // If DPadDown is down, move the slime down on the screen. if (gamePadOne.IsButtonDown(Buttons.DPadDown)) { _slimePosition.Y += speed; } // If DPapLeft is down, move the slime left on the screen. if (gamePadOne.IsButtonDown(Buttons.DPadLeft)) { _slimePosition.X -= speed; } // If DPadRight is down, move the slime right on the screen. if (gamePadOne.IsButtonDown(Buttons.DPadRight)) { _slimePosition.X += speed; } } } protected override void Draw(GameTime gameTime) { // Clear the back buffer. GraphicsDevice.Clear(Color.CornflowerBlue); // Begin the sprite batch to prepare for rendering. SpriteBatch.Begin(samplerState: SamplerState.PointClamp); // Draw the tilemap _tilemap.Draw(SpriteBatch); // Draw the slime sprite. _slime.Draw(SpriteBatch, _slimePosition); // Draw the bat sprite. _bat.Draw(SpriteBatch, _batPosition); // Always end the sprite batch when finished. SpriteBatch.End(); base.Draw(gameTime); } } Note Note there were a lot of replacements in the LoadContent method, switching from loading and initializing the background Song and replacing it with a call to the new AudioController to do all the work managing the Song reference. Much cleaner. The key changes made here are: The _themeSong field is added to store a reference to the background song to play. In LoadContent, the background theme song is loaded using the content manager. In Initialize, the audio manager is used to play the background theme song. In Update the audio manager is used to play the bounce and collect sound effects. In CheckKeyboardInput the following checks were added If the M key on the keyboard is pressed, it will toggle mute for all audio. If the + key is pressed, the song and sound effect volumes are increased by 0.1f. If the - key is pressed, the song and sound effect volumes are decreased by 0.1f. Running the game now will produce the same result as the previous chapter, only now the lifetime of sound effects and the state management of audio is done through the new audio controller. You can also mute and unumte the audio with the M key and increase and decrease the volume using the + and - keys. Figure 15-1: Gameplay with audio. Note You may note that while we added keybindings to change the audio settings, we did not add any bindings for the GamePad. This is simply because this is not normally how you would adjust these values on a console, on consoles you would have a settings/options screen to update them. Later in Chapter 20: Implementing UI with GUM we will add an Options screen to adjust all the audio values for the game. Conclusion In this chapter, you accomplished the following: Created a reusable AudioController class to centralize audio management. Learned about proper resource management for audio using the IDisposable pattern. Implemented tracking and cleanup of sound effect instances. Added global volume control for both sound effects and music. Created methods to toggle audio states (play/pause, mute/unmute). Updated the Core class to provide global access to the audio controller. Added keyboard controls to adjust volume and toggle mute state. The AudioController class you created is a significant improvement over directly using MonoGame's audio APIs. It handles common audio management tasks that would otherwise need to be implemented repeatedly in different parts of your game. By centralizing these functions, you make your code more maintainable and provide a consistent audio experience across your game. In the next chapter, we will start exploring fonts and adding text to the game."
  },
  "templates/docs.monogame.github.io/articles/tutorials/building_2d_games/16_working_with_spritefonts/index.html": {
    "href": "templates/docs.monogame.github.io/articles/tutorials/building_2d_games/16_working_with_spritefonts/index.html",
    "title": "Chapter 16: Working with SpriteFonts | hallowed",
    "summary": "In Chapter 06, you learned how to load and render textures to display sprites in your game. While images are essential for visual elements, most games also need text for things like scores, player instructions, dialogue, and UI elements. MonoGame provides the SpriteFont class to handle text rendering, which works together with the familiar SpriteBatch we have been using for drawing textures. In this chapter, you will: Learn how MonoGame handles text rendering with SpriteFonts. Create SpriteFont description using the MGCB Editor. Load custom fonts for use in your game. Render text using various parameters to control appearance. Implement text rendering in our game. We will first start by understanding how text rendering works in MonoGame. Understanding SpriteFonts MonoGame processes fonts through the content pipeline to create a texture atlas of font characters. MonoGame uses the texture atlas approach rather than directly using system fonts for several important reasons: Cross-platform Compatibility: System fonts cannot be guaranteed to exist on all platforms. Consistency: Ensures that the text appears the same across all platforms. GPU Rendering: Graphics cards do not understand font formats directly; they can only render textures. Performance: Pre-rendering the glyphs to a texture atlas allow for faster rendering at runtime with no texture swapping. A SpriteFont in MonoGame consists of: A texture atlas containing pre-rendered glyphs (characters). Data that tracks the position, size, and spacing of each character. Kerning information for adjusting spacing between specific character pairs. The texture atlas approach means fonts are rendered as sprites, using the same SpriteBatch system you learned about for drawing textures (Chapter 7: Optimized Texture Rendering). When you draw text, MonoGame is actually drawing small portions of the texture atlas for each character assembled together to form complete words and sentences. Creating a SpriteFont Description To use text in your game, you first need to create a SpriteFont Description file and process it through the Content Pipeline, thankfully the MGCB Editor makes this process straightforward. For example, in the MGCB Editor: Right-click the content project node where the SpriteFont Description will be created and choose Add > New Item.... Select SpriteFont Description (.spritefont) from the options. Specify a name for the SpriteFont Description file and click Create. This will create a default SpriteFont Description file that look something like this: <?xml version=\"1.0\" encoding=\"utf-8\"?> <!-- This file contains an xml description of a font, and will be read by the XNA Framework Content Pipeline. Follow the comments to customize the appearance of the font in your game, and to change the characters which are available to draw with. --> <XnaContent xmlns:Graphics=\"Microsoft.Xna.Framework.Content.Pipeline.Graphics\"> <Asset Type=\"Graphics:FontDescription\"> <!-- Modify this string to change the font that will be imported. --> <FontName>Arial</FontName> <!-- Size is a float value, measured in points. Modify this value to change the size of the font. --> <Size>12</Size> <!-- Spacing is a float value, measured in pixels. Modify this value to change the amount of spacing in between characters. --> <Spacing>0</Spacing> <!-- UseKerning controls the layout of the font. If this value is true, kerning information will be used when placing characters. --> <UseKerning>true</UseKerning> <!-- Style controls the style of the font. Valid entries are \"Regular\", \"Bold\", \"Italic\", and \"Bold, Italic\", and are case sensitive. --> <Style>Regular</Style> <!-- If you uncomment this line, the default character will be substituted if you draw or measure text that contains characters which were not included in the font. --> <!-- <DefaultCharacter>*</DefaultCharacter> --> <!-- CharacterRegions control what letters are available in the font. Every character from Start to End will be built and made available for drawing. The default range is from 32, (ASCII space), to 126, ('~'), covering the basic Latin character set. The characters are ordered according to the Unicode standard. See the documentation for more information. --> <CharacterRegions> <CharacterRegion> <Start>&#32;</Start> <End>&#126;</End> </CharacterRegion> </CharacterRegions> </Asset> </XnaContent> When creating a SpriteFont Description for your game, you will need to make several important decisions about font selection, size, formatting, and licensing. The following sections will guide you through customizing the SpriteFont Description using these considerations. Customizing the SpriteFont The SpriteFont Description file allows you to customize various aspects of how the font will be processed and appear in your game. Here are the key elements you can modify: FontName The <FontName> element specifies which font to use. By default, it references \"Arial\". When a font name is specified just by name like this, it is required that the font be installed on the system where the content is built. Important MonoGame recommends changing the default Arial font if you are targeting any platforms other than Windows. Arial is a legacy from XNA and is only guaranteed to be available in Windows builds. As an alternative, MonoGame currently recommends using Roboto. Alternatively, for better portability across development environments, it is recommended instead to directly reference a TrueType (.ttf) or OpenType (.otf) font file. To do this Download or locate a TTF or OTF font file. Place it in the same folder as the .spritefont file. Important You place the font file in the same folder as the .spritefont file directly, not through the MGCB Editor. Update the <FontName> element to include the exact filename with extension. Tip Use fonts with permissive licenses (like SIL Open Font License) to ensure you can legally use them in your game. Always check the license of any font you use! Size The <Size> element controls the font size in points. While it might seem straightforward, font sizing requires consideration and can be dependent on several factors. When choosing a font size, consider: Resolution impact: Fonts that look good at 1080p may appear too small at 4K or too large at 720p. Font style: Pixel fonts look best with small sizes to preserve crispness. Use case: Different UI elements may require different sizes for proper hierarchy. You may want to create multiple SpriteFont Description files for different use cases in your game such as: A larger font for headings and titles. A medium-sized font for standard UI elements. A smaller font for detailed information. Tip Creating multiple SpriteFont Description files, however, can remove some of the benefits of fonts being a texture atlas since you will now have multiple atlases for each size. You will also now have multiple assets to manage both as asset files and references in code. An alternative approach is to create a single SpriteFont Description with a larger than needed size font, then scale it down during runtime in the game. This approach allows you to maintain the single SpriteFont Description file and single texture atlas, however, the size of the texture atlas will now be larger. There are tradeoffs to each approach and you should choose the one that works best for your game. Spacing The <Spacing> element adjusts the space between characters. The default value of 0 uses the font's built-in spacing. Positive values increase spacing, while negative values (though rarely used) can decrease it. UseKerning The <UseKerning> element determines whether to use kerning information from the font. Kerning adjusts the spacing between specific pairs of characters for more visually pleasing results. For most fonts, you will want to leave this as true. Note While kerning typically improves text appearance, some fonts (including Arial) may not respond optimally to kerning adjustments. If you notice unusual character spacing with a particular font, try setting this value to false. Style The <Style> element sets the font style. Valid options are \"Regular\", \"Bold\", \"Italic\", or \"Bold, Italic\". Note that not all fonts have all styles available, and using a style that does not exist will fall back to Regular. DefaultCharacter The <DefaultCharacter> element (commented out by default) specifies what character to use as a fallback when trying to render a character that is not included in the font. This is useful for handling special characters or international text. CharacterRegions The <CharacterRegions> element defines which Unicode character ranges to include in the font. The default range (32-126) covers basic Latin characters, which is sufficient for English text. Including more characters increases the font texture size but allows support for more languages or special symbols. For most games, the default range is sufficient. Note Although for fun, TRY using the Wingdings font :D Loading a SpriteFont Description To load a SpriteFont Description, we use the ContentManager.Load method with the SpriteFont type: // Loading a SpriteFont Description using the content pipeline SpriteFont font = Content.Load<SpriteFont>(\"font\"); Drawing Text with SpriteBatch MonoGame's SpriteBatch class provides several overloads of the DrawString method to render text. The basic approach is similar to drawing textures, with a few unique parameters specific to text rendering. The most basic DrawString overload looks like this: _spriteBatch.DrawString( font, // font \"Hello, MonoGame!\", // text Vector2.Zero, // position Color.White // color ); This overload contains the following parameters: font: The SpriteFont to use for rendering. text: The text to display (as a string or StringBuilder). position: A Vector2 defining where to draw the text. color: The Color to tint the text. Just like with texture rendering, there are more advanced overloads that give you additional control: _spriteBatch.DrawString( font, // font \"Hello, MonoGame!\", // text Vector2.Zero, // position Color.White, // color 0.0f, // rotation Vector2.Zero, // origin Vector2.One, // scale SpriteEffects.None, // effects 0.0f // layerDepth ); Note Many of these parameters (rotation, origin, scale, effects, and layerDepth) work exactly the same way as they do for texture rendering, as explained in Chapter 06. If you need a refresher on how these parameters affect rendering, refer back to that chapter. Calculating Text Dimensions One common task when working with text is determining how much space it will occupy on screen. This is important for: Centering text Creating UI layouts Checking if text fits within a designated area Implementing text wrapping MonoGame's SpriteFont class provides the MeasureString method that returns the dimensions of rendered text: // The text to measure. string message = \"Hello, MonoGame!\"; // Measure the size of the message to get the text dimensions. Vector2 textSize = font.MeasureString(message); The returned Vector2 contains: X: The width of the text in pixels Y: The height of the text in pixels Below is an example of centering text on the screen by drawing the text at the center of the screen and using MeasureString to calculate the center origin or the text // The text to draw. string message = \"Hello, MonoGame!\"; // Measure the size of the message to get the text dimensions. Vector2 textSize = font.MeasureString(message); // Set the origin to the center of the text dimensions. Vector2 origin = textSize * 0.5f; // Position will be the center of the screen. Vector2 position = new Vector2( GraphicsDevice.PresentationParameters.BackBufferWidth, GraphicsDevice.PresentationParameters.BackBufferHeight ) * 0.5f; // Draw centered text _spriteBatch.DrawString( font, // font message, // text position, // position Color.White, // color 0.0f, // rotation origin, // origin 1.0f, // scale SpriteEffects.None, // effects 0.0f // layerDepth ); Implementing Text in Our Game To explore implementing text, we will add text to our game to display information to the player. We will add a score counter that increases when the slime eats the bat. Adding the SpriteFont Description First, we will need to create a SpriteFont Definition. Open the Content.mgcb content project file in the MGCB Editor and perform the following: Create a new folder called fonts (right-click Content > Add > New Folder). Right-click the new fonts folder and choose Add > New Item.... Select SpriteFont Description (.spritefont) from the options. Name the file 04B_30 and click Create. Figure 16-1: The 04B_30.spritefont file created in the MGCB Editor Note We have named the SpriteFont Description file with the same name as the font we will be using. This makes it easier to remember when updating the code later. Download the Font File Next, right-click the following TTF font and choose \"Save Link as...\". Save the file in the same folder where you created the 04B_30.spriteFont file using the MGCB Editor. This ensures the font is correctly linked and available for your SpriteFont configuration. 04B_30.ttf{download} Update the SpriteFont Description Next, open the 04B_30.spritefont file in your code editor and make the following changes: <?xml version=\"1.0\" encoding=\"utf-8\"?> <XnaContent xmlns:Graphics=\"Microsoft.Xna.Framework.Content.Pipeline.Graphics\"> <Asset Type=\"Graphics:FontDescription\"> <FontName>04B_30.ttf</FontName> <Size>17.5</Size> <Spacing>0</Spacing> <UseKerning>true</UseKerning> <Style>Regular</Style> <CharacterRegions> <CharacterRegion> <Start>&#32;</Start> <End>&#126;</End> </CharacterRegion> </CharacterRegions> </Asset> </XnaContent> The key changes here are: The <FontName> element was updated to 04B_30.ttf, the exact filename with extension of the TTF font we just downloaded. The <Size> element was updated to be 17.5. Updating the Game Finally, open the Game1.cs file and make the following changes: using System; using Microsoft.Xna.Framework; using Microsoft.Xna.Framework.Audio; using Microsoft.Xna.Framework.Graphics; using Microsoft.Xna.Framework.Input; using Microsoft.Xna.Framework.Media; using MonoGameLibrary; using MonoGameLibrary.Graphics; using MonoGameLibrary.Input; namespace DungeonSlime; public class Game1 : Core { // Defines the slime animated sprite. private AnimatedSprite _slime; // Defines the bat animated sprite. private AnimatedSprite _bat; // Tracks the position of the slime. private Vector2 _slimePosition; // Speed multiplier when moving. private const float MOVEMENT_SPEED = 5.0f; // Tracks the position of the bat. private Vector2 _batPosition; // Tracks the velocity of the bat. private Vector2 _batVelocity; // Defines the tilemap to draw. private Tilemap _tilemap; // Defines the bounds of the room that the slime and bat are contained within. private Rectangle _roomBounds; // The sound effect to play when the bat bounces off the edge of the screen. private SoundEffect _bounceSoundEffect; // The sound effect to play when the slime eats a bat. private SoundEffect _collectSoundEffect; // The background theme song. private Song _themeSong; // The SpriteFont Description used to draw text. private SpriteFont _font; // Tracks the players score. private int _score; // Defines the position to draw the score text at. private Vector2 _scoreTextPosition; // Defines the origin used when drawing the score text. private Vector2 _scoreTextOrigin; public Game1() : base(\"Dungeon Slime\", 1280, 720, false) { } protected override void Initialize() { base.Initialize(); Rectangle screenBounds = GraphicsDevice.PresentationParameters.Bounds; _roomBounds = new Rectangle( (int)_tilemap.TileWidth, (int)_tilemap.TileHeight, screenBounds.Width - (int)_tilemap.TileWidth * 2, screenBounds.Height - (int)_tilemap.TileHeight * 2 ); // Initial slime position will be the center tile of the tile map. int centerRow = _tilemap.Rows / 2; int centerColumn = _tilemap.Columns / 2; _slimePosition = new Vector2(centerColumn * _tilemap.TileWidth, centerRow * _tilemap.TileHeight); // Initial bat position will the in the top left corner of the room. _batPosition = new Vector2(_roomBounds.Left, _roomBounds.Top); // Assign the initial random velocity to the bat. AssignRandomBatVelocity(); // Start playing the background music. Audio.PlaySong(_themeSong); // Set the position of the score text to align to the left edge of the // room bounds, and to vertically be at the center of the first tile. _scoreTextPosition = new Vector2(_roomBounds.Left, _tilemap.TileHeight * 0.5f); // Set the origin of the text so it is left-centered. float scoreTextYOrigin = _font.MeasureString(\"Score\").Y * 0.5f; _scoreTextOrigin = new Vector2(0, scoreTextYOrigin); } protected override void LoadContent() { // Create the texture atlas from the XML configuration file. TextureAtlas atlas = TextureAtlas.FromFile(Content, \"images/atlas-definition.xml\"); // Create the slime animated sprite from the atlas. _slime = atlas.CreateAnimatedSprite(\"slime-animation\"); _slime.Scale = new Vector2(4.0f, 4.0f); // Create the bat animated sprite from the atlas. _bat = atlas.CreateAnimatedSprite(\"bat-animation\"); _bat.Scale = new Vector2(4.0f, 4.0f); // Create the tilemap from the XML configuration file. _tilemap = Tilemap.FromFile(Content, \"images/tilemap-definition.xml\"); _tilemap.Scale = new Vector2(4.0f, 4.0f); // Load the bounce sound effect. _bounceSoundEffect = Content.Load<SoundEffect>(\"audio/bounce\"); // Load the collect sound effect. _collectSoundEffect = Content.Load<SoundEffect>(\"audio/collect\"); // Load the background theme music. _themeSong = Content.Load<Song>(\"audio/theme\"); // Load the font _font = Content.Load<SpriteFont>(\"fonts/04B_30\"); } protected override void Update(GameTime gameTime) { // Update the slime animated sprite. _slime.Update(gameTime); // Update the bat animated sprite. _bat.Update(gameTime); // Check for keyboard input and handle it. CheckKeyboardInput(); // Check for gamepad input and handle it. CheckGamePadInput(); // Creating a bounding circle for the slime. Circle slimeBounds = new Circle( (int)(_slimePosition.X + (_slime.Width * 0.5f)), (int)(_slimePosition.Y + (_slime.Height * 0.5f)), (int)(_slime.Width * 0.5f) ); // Use distance based checks to determine if the slime is within the // bounds of the game screen, and if it is outside that screen edge, // move it back inside. if (slimeBounds.Left < _roomBounds.Left) { _slimePosition.X = _roomBounds.Left; } else if (slimeBounds.Right > _roomBounds.Right) { _slimePosition.X = _roomBounds.Right - _slime.Width; } if (slimeBounds.Top < _roomBounds.Top) { _slimePosition.Y = _roomBounds.Top; } else if (slimeBounds.Bottom > _roomBounds.Bottom) { _slimePosition.Y = _roomBounds.Bottom - _slime.Height; } // Calculate the new position of the bat based on the velocity Vector2 newBatPosition = _batPosition + _batVelocity; // Create a bounding circle for the bat Circle batBounds = new Circle( (int)(newBatPosition.X + (_bat.Width * 0.5f)), (int)(newBatPosition.Y + (_bat.Height * 0.5f)), (int)(_bat.Width * 0.5f) ); Vector2 normal = Vector2.Zero; // Use distance based checks to determine if the bat is within the // bounds of the game screen, and if it is outside that screen edge, // reflect it about the screen edge normal if (batBounds.Left < _roomBounds.Left) { normal.X = Vector2.UnitX.X; newBatPosition.X = _roomBounds.Left; } else if (batBounds.Right > _roomBounds.Right) { normal.X = -Vector2.UnitX.X; newBatPosition.X = _roomBounds.Right - _bat.Width; } if (batBounds.Top < _roomBounds.Top) { normal.Y = Vector2.UnitY.Y; newBatPosition.Y = _roomBounds.Top; } else if (batBounds.Bottom > _roomBounds.Bottom) { normal.Y = -Vector2.UnitY.Y; newBatPosition.Y = _roomBounds.Bottom - _bat.Height; } // If the normal is anything but Vector2.Zero, this means the bat had // moved outside the screen edge so we should reflect it about the // normal. if (normal != Vector2.Zero) { normal.Normalize(); _batVelocity = Vector2.Reflect(_batVelocity, normal); // Play the bounce sound effect. Audio.PlaySoundEffect(_bounceSoundEffect); } _batPosition = newBatPosition; if (slimeBounds.Intersects(batBounds)) { // Choose a random row and column based on the total number of each int column = Random.Shared.Next(1, _tilemap.Columns - 1); int row = Random.Shared.Next(1, _tilemap.Rows - 1); // Change the bat position by setting the x and y values equal to // the column and row multiplied by the width and height. _batPosition = new Vector2(column * _bat.Width, row * _bat.Height); // Assign a new random velocity to the bat. AssignRandomBatVelocity(); // Play the collect sound effect. Audio.PlaySoundEffect(_collectSoundEffect); // Increase the player's score. _score += 100; } base.Update(gameTime); } private void AssignRandomBatVelocity() { // Generate a random angle. float angle = (float)(Random.Shared.NextDouble() * Math.PI * 2); // Convert angle to a direction vector float x = (float)Math.Cos(angle); float y = (float)Math.Sin(angle); Vector2 direction = new Vector2(x, y); // Multiply the direction vector by the movement speed _batVelocity = direction * MOVEMENT_SPEED; } private void CheckKeyboardInput() { // If the space key is held down, the movement speed increases by 1.5 float speed = MOVEMENT_SPEED; if (Input.Keyboard.IsKeyDown(Keys.Space)) { speed *= 1.5f; } // If the W or Up keys are down, move the slime up on the screen. if (Input.Keyboard.IsKeyDown(Keys.W) || Input.Keyboard.IsKeyDown(Keys.Up)) { _slimePosition.Y -= speed; } // if the S or Down keys are down, move the slime down on the screen. if (Input.Keyboard.IsKeyDown(Keys.S) || Input.Keyboard.IsKeyDown(Keys.Down)) { _slimePosition.Y += speed; } // If the A or Left keys are down, move the slime left on the screen. if (Input.Keyboard.IsKeyDown(Keys.A) || Input.Keyboard.IsKeyDown(Keys.Left)) { _slimePosition.X -= speed; } // If the D or Right keys are down, move the slime right on the screen. if (Input.Keyboard.IsKeyDown(Keys.D) || Input.Keyboard.IsKeyDown(Keys.Right)) { _slimePosition.X += speed; } // If the M key is pressed, toggle mute state for audio. if (Input.Keyboard.WasKeyJustPressed(Keys.M)) { Audio.ToggleMute(); } // If the + button is pressed, increase the volume. if (Input.Keyboard.WasKeyJustPressed(Keys.OemPlus)) { Audio.SongVolume += 0.1f; Audio.SoundEffectVolume += 0.1f; } // If the - button was pressed, decrease the volume. if (Input.Keyboard.WasKeyJustPressed(Keys.OemMinus)) { Audio.SongVolume -= 0.1f; Audio.SoundEffectVolume -= 0.1f; } } private void CheckGamePadInput() { GamePadInfo gamePadOne = Input.GamePads[(int)PlayerIndex.One]; // If the A button is held down, the movement speed increases by 1.5 // and the gamepad vibrates as feedback to the player. float speed = MOVEMENT_SPEED; if (gamePadOne.IsButtonDown(Buttons.A)) { speed *= 1.5f; GamePad.SetVibration(PlayerIndex.One, 1.0f, 1.0f); } else { GamePad.SetVibration(PlayerIndex.One, 0.0f, 0.0f); } // Check thumbstick first since it has priority over which gamepad input // is movement. It has priority since the thumbstick values provide a // more granular analog value that can be used for movement. if (gamePadOne.LeftThumbStick != Vector2.Zero) { _slimePosition.X += gamePadOne.LeftThumbStick.X * speed; _slimePosition.Y -= gamePadOne.LeftThumbStick.Y * speed; } else { // If DPadUp is down, move the slime up on the screen. if (gamePadOne.IsButtonDown(Buttons.DPadUp)) { _slimePosition.Y -= speed; } // If DPadDown is down, move the slime down on the screen. if (gamePadOne.IsButtonDown(Buttons.DPadDown)) { _slimePosition.Y += speed; } // If DPapLeft is down, move the slime left on the screen. if (gamePadOne.IsButtonDown(Buttons.DPadLeft)) { _slimePosition.X -= speed; } // If DPadRight is down, move the slime right on the screen. if (gamePadOne.IsButtonDown(Buttons.DPadRight)) { _slimePosition.X += speed; } } } protected override void Draw(GameTime gameTime) { // Clear the back buffer. GraphicsDevice.Clear(Color.CornflowerBlue); // Begin the sprite batch to prepare for rendering. SpriteBatch.Begin(samplerState: SamplerState.PointClamp); // Draw the tilemap _tilemap.Draw(SpriteBatch); // Draw the slime sprite. _slime.Draw(SpriteBatch, _slimePosition); // Draw the bat sprite. _bat.Draw(SpriteBatch, _batPosition); // Draw the score SpriteBatch.DrawString( _font, // spriteFont $\"Score: {_score}\", // text _scoreTextPosition, // position Color.White, // color 0.0f, // rotation _scoreTextOrigin, // origin 1.0f, // scale SpriteEffects.None, // effects 0.0f // layerDepth ); // Always end the sprite batch when finished. SpriteBatch.End(); base.Draw(gameTime); } } The key changes made are: The _font field was added to store the SpriteFont Description when loaded. The _score field was added to track the player's score. The _scoreTextPosition field was added to store the precalculated position to draw the score text at. The _scoreTextOrigin field was added to store the origin to use when drawing the score text. In Initialize The position to draw the score text is precalculated to align with the left side of the room bounds horizontally and to vertically be at the center of the first tile at the top. The origin for the score text is precalculated by measuring the string \"Score\" and multiplying the Y component to get the vertical center of the text, then the origin is set so that it is at the left-center. In LoadContent, the font is loaded using the content manager. In Update, the player's score is increased by 100 each time the slime eats the bat. In Draw, the score text is drawn at the precalculated position using the precalculated origin so that it aligns in the center of the tile on the blue strip using the sprite batch. Figure 16-2: The game with score displayed in the top-left corner Conclusion In this chapter, you accomplished the following: Learned how to create SpriteFont definitions with the MGCB Editor. Learned how to reference font files for better cross-platform compatibility. Learned how to load SpriteFonts through the content pipeline. Learned how to draw text with various parameters to control appearance. Learned how to measure text dimensions. Implemented a score display in our game. In the next chapter we will discuss MonoGame's service container and how we can use it to start breaking our monolithic game file into modules for better maintainability. Test Your Knowledge What are the key components of a SpriteFont in MonoGame? :::question-answer A SpriteFont in MonoGame consists of: A texture atlas containing pre-rendered glyphs (characters) Data that tracks the position, size, and spacing of each character Kerning information for adjusting spacing between specific character pairs ::: Why is it recommended to include the font file in your content project rather than referencing system fonts? :::question-answer Including the font file (TTF/OTF) directly in your content project and referencing it with the file extension ensures portability across different development environments. This approach does not depend on fonts being installed on the system where the content is built. ::: What method would you use to determine how much space a text string will occupy when rendered, and what does it return? :::question-answer The SpriteFont.MeasureString method is used to determine text dimensions. It returns a Vector2 where the X component represents the width and the Y component represents the height of the rendered text in pixels. :::"
  },
  "templates/docs.monogame.github.io/articles/tutorials/building_2d_games/17_scenes/index.html": {
    "href": "templates/docs.monogame.github.io/articles/tutorials/building_2d_games/17_scenes/index.html",
    "title": "Chapter 17: Scene Management | hallowed",
    "summary": "In game development, a scene (sometimes called a screen or state) represents a distinct section of the game. Each scene typically has its own update and draw logic, as well as its own set of game objects. Common examples of scenes include title screens, menus, gameplay screens, game over screens, and more. Scenes help organize the game's code by separating different parts of the game into self-contained modules. This makes the code more manageable as the game grows in complexity and offers several advantages: Improved organization: Each scene contains only the code and assets relevant to that part of the game. Memory management: Load assets only when needed and unload them when leaving a scene. Simplified state handling: Each scene maintains its own state without affecting others. Code reusability: Create reusable scene templates for common game screens. Our game logic is currently contained within the single Game1 class. Adding more screens to it would make the code harder to manage, so instead we need to start thinking about breaking it down into scenes. In this chapter, you will: Learn the concept of scene management and its benefits Create a base Scene class with a consistent lifecycle Implement scene transitions using a manager Create a title scene and gameplay scene for our game Refactor our existing game to use the scene system We will begin by first defining the lifecycle of a scene that will be followed. Scene Lifecycle In Chapter 03, you learned the basic lifecycle of the Game class. To be consistent, we can borrow from this lifecycle and adapt it for our scenes. The order of operations for this lifecycle will be: A scene is created and set as the active scene. The first screen is made active and is initialized and content loaded. The active scene is updated and drawn each cycle. When transitioning to a new scene, or when the scene ends: The current scene is unloaded and disposed of. The new scene is initialized and content loaded. The new scene becomes the active scene and the cycle begins again until the game is told to exit. The Scene Base Class The base Scene class is an abstract class for scenes that provides common functionality for all scenes. In our actual game, we will create concrete implementations of this, like a title scene. To get started, in the MonoGameLibrary project: Create a new folder named Scenes. Add a new class file named Scene.cs to the Scenes folder you just created. Add the following code as the initial structure for the class: using System; using Microsoft.Xna.Framework; using Microsoft.Xna.Framework.Content; namespace MonoGameLibrary.Scenes; public abstract class Scene : IDisposable { } Note Just like with the AudioController in Chapter 15, each Scene implements the IDisposable interface. This provides a standardized in method to release the resources held by a scene when it is no longer needed. Scene Properties Add the following properties to the Scene class: /// <summary> /// Gets the ContentManager used for loading scene-specific assets. /// </summary> /// <remarks> /// Assets loaded through this ContentManager will be automatically unloaded when this scene ends. /// </remarks> protected ContentManager Content { get; } /// <summary> /// Gets a value that indicates if the scene has been disposed of. /// </summary> public bool IsDisposed { get; private set; } The Content property is the scene's personal ContentManager that can be used to load scene specific content that will be unloaded when the scene ends. This helps manage memory usage by only loading what is needed for a specific scene. The IsDisposed property is used to track if the scene has been disposed of since it implements the IDisposable interface. Scene Constructor Add the following constructor and finalizer to the Scene class: /// <summary> /// Creates a new scene instance. /// </summary> public Scene() { // Create a content manager for the scene Content = new ContentManager(Core.Content.ServiceProvider); // Set the root directory for content to the same as the root directory // for the game's content. Content.RootDirectory = Core.Content.RootDirectory; } // Finalizer, called when object is cleaned up by garbage collector. ~Scene() => Dispose(false); The constructor initializes the scene's content manager and sets the root folder to match that of the base game's content manager. The finalizer is called by the garbage collector automatically when a scene object is collected which just calls the Dispose method to ensure resources are disposed of properly. Scene Methods Add the following methods to the Scene class: /// <summary> /// Initializes the scene. /// </summary> /// <remarks> /// When overriding this in a derived class, ensure that base.Initialize() /// still called as this is when LoadContent is called. /// </remarks> public virtual void Initialize() { LoadContent(); } /// <summary> /// Override to provide logic to load content for the scene. /// </summary> public virtual void LoadContent() { } /// <summary> /// Unloads scene-specific content. /// </summary> public virtual void UnloadContent() { Content.Unload(); } /// <summary> /// Updates this scene. /// </summary> /// <param name=\"gameTime\">A snapshot of the timing values for the current frame.</param> public virtual void Update(GameTime gameTime) { } /// <summary> /// Draws this scene. /// </summary> /// <param name=\"gameTime\">A snapshot of the timing values for the current frame.</param> public virtual void Draw(GameTime gameTime) { } These methods are setup similar to how the Game class works to keep the workflow consistent: Initialize is called only once when the scene becomes the active scene. It can be overridden by the derived class to provide scene specific initialization logic. It also calls the LoadContent method the same way the Game class is done for consistency. LoadContent is called only once, at the end of the Initialize method. It can be overridden by the derived class to load scene specific content. UnloadContent is called only once when a scene is ending due to a transition to a new scene. It can be overridden by the derived class to perform unloading of any scene specific content. Update is called once at the start of every game cycle. It can be overridden to provide the update logic for the scene. Draw is called once every game cycle, directly after Update. It can be overridden to provide the draw logic for the scene. IDisposable Implementation Add the following methods to the Scene class to complete the implementation of the IDisposable interface: /// <summary> /// Disposes of this scene. /// </summary> public void Dispose() { Dispose(true); GC.SuppressFinalize(this); } /// <summary> /// Disposes of this scene. /// </summary> /// <param name=\"disposing\">' /// Indicates whether managed resources should be disposed. This value is only true when called from the main /// Dispose method. When called from the finalizer, this will be false. /// </param> protected virtual void Dispose(bool disposing) { if (IsDisposed) { return; } if (disposing) { UnloadContent(); Content.Dispose(); } } With the Base scene implementation complete, we can now use it to create actual scenes for our project. The next step is to implement a manager that organizes and coordinates these scenes within the game. Scene Management With the base Scene class defined, the Core class needs to be updated to handle management of the scenes, including update, drawing, and changing scenes. Open the Core.cs file in the MonoGameLibrary project and make the following changes: using System; using Microsoft.Xna.Framework; using Microsoft.Xna.Framework.Content; using Microsoft.Xna.Framework.Graphics; using Microsoft.Xna.Framework.Input; using MonoGameLibrary.Audio; using MonoGameLibrary.Input; using MonoGameLibrary.Scenes; namespace MonoGameLibrary; public class Core : Game { internal static Core s_instance; /// <summary> /// Gets a reference to the Core instance. /// </summary> public static Core Instance => s_instance; // The scene that is currently active. private static Scene s_activeScene; // The next scene to switch to, if there is one. private static Scene s_nextScene; /// <summary> /// Gets the graphics device manager to control the presentation of graphics. /// </summary> public static GraphicsDeviceManager Graphics { get; private set; } /// <summary> /// Gets the graphics device used to create graphical resources and perform primitive rendering. /// </summary> public static new GraphicsDevice GraphicsDevice { get; private set; } /// <summary> /// Gets the sprite batch used for all 2D rendering. /// </summary> public static SpriteBatch SpriteBatch { get; private set; } /// <summary> /// Gets the content manager used to load global assets. /// </summary> public static new ContentManager Content { get; private set; } /// <summary> /// Gets a reference to to the input management system. /// </summary> public static InputManager Input { get; private set; } /// <summary> /// Gets or Sets a value that indicates if the game should exit when the esc key on the keyboard is pressed. /// </summary> public static bool ExitOnEscape { get; set; } /// <summary> /// Gets a reference to the audio control system. /// </summary> public static AudioController Audio { get; private set; } /// <summary> /// Creates a new Core instance. /// </summary> /// <param name=\"title\">The title to display in the title bar of the game window.</param> /// <param name=\"width\">The initial width, in pixels, of the game window.</param> /// <param name=\"height\">The initial height, in pixels, of the game window.</param> /// <param name=\"fullScreen\">Indicates if the game should start in fullscreen mode.</param> public Core(string title, int width, int height, bool fullScreen) { // Ensure that multiple cores are not created. if (s_instance != null) { throw new InvalidOperationException($\"Only a single Core instance can be created\"); } // Store reference to engine for global member access. s_instance = this; // Create a new graphics device manager. Graphics = new GraphicsDeviceManager(this); // Set the graphics defaults Graphics.PreferredBackBufferWidth = width; Graphics.PreferredBackBufferHeight = height; Graphics.IsFullScreen = fullScreen; // Apply the graphic presentation changes. Graphics.ApplyChanges(); // Set the window title Window.Title = title; // Set the core's content manager to a reference of the base Game's // content manager. Content = base.Content; // Set the root directory for content. Content.RootDirectory = \"Content\"; // Mouse is visible by default. IsMouseVisible = true; // Exit on escape is true by default ExitOnEscape = true; } protected override void Initialize() { base.Initialize(); // Set the core's graphics device to a reference of the base Game's // graphics device. GraphicsDevice = base.GraphicsDevice; // Create the sprite batch instance. SpriteBatch = new SpriteBatch(GraphicsDevice); // Create a new input manager. Input = new InputManager(); // Create a new audio controller. Audio = new AudioController(); } protected override void UnloadContent() { // Dispose of the audio controller. Audio.Dispose(); base.UnloadContent(); } protected override void Update(GameTime gameTime) { // Update the input manager. Input.Update(gameTime); // Update the audio controller. Audio.Update(); if (ExitOnEscape && Input.Keyboard.WasKeyJustPressed(Keys.Escape)) { Exit(); } // if there is a next scene waiting to be switch to, then transition // to that scene. if (s_nextScene != null) { TransitionScene(); } // If there is an active scene, update it. if (s_activeScene != null) { s_activeScene.Update(gameTime); } base.Update(gameTime); } protected override void Draw(GameTime gameTime) { // If there is an active scene, draw it. if (s_activeScene != null) { s_activeScene.Draw(gameTime); } base.Draw(gameTime); } public static void ChangeScene(Scene next) { // Only set the next scene value if it is not the same // instance as the currently active scene. if (s_activeScene != next) { s_nextScene = next; } } private static void TransitionScene() { // If there is an active scene, dispose of it. if (s_activeScene != null) { s_activeScene.Dispose(); } // Force the garbage collector to collect to ensure memory is cleared. GC.Collect(); // Change the currently active scene to the new scene. s_activeScene = s_nextScene; // Null out the next scene value so it does not trigger a change over and over. s_nextScene = null; // If the active scene now is not null, initialize it. // Remember, just like with Game, the Initialize call also calls the // Scene.LoadContent if (s_activeScene != null) { s_activeScene.Initialize(); } } } The key changes here are: The using MonoGameLibrary.Scenes; using directive was added so we have access to the Scene class. The fields _activeScene and _nextScene were added to track which scene is currently active and which scene, if any, to switch to. In Update: A check is made to see if there is a next scene, and if so, TransitionScene is called to gracefully switch from the current to the next. A check is made to see if there is an active scene, and if so, updates it. An override for the Draw method was added where a check is made to see if there is an active scene, and if so, draws it. The ChangeScene method was added which can be called when we want to tell the core to change from one scene to another one. The TransitionScene method was added to gracefully switch from the current scene to the next by: Checking if there is an active scene, and disposing it if so. Triggering garbage collection to reclaim memory from the disposed scene. Assigning the next scene as the current scene. Checking if a current scene now exists, and initializing it if so. Tip Notice that we use a two-step process for scene transitions with separate _activeScene and _nextScene fields. This design allows the current scene to complete its update/draw cycle before the transition occurs, preventing potential issues that could arise from changing scenes in the middle of processing. The actual transition happens at a controlled point in the game loop, ensuring clean disposal of the old scene before initializing the new one. Updating the Game With the scene architecture in place, we are now ready to update the game by breaking it into separate scenes. We will create two scenes; a title scene and a gameplay scene. First, however, we need to add an additional SpriteFont Description that will be used during the title scene to display the title of the game. Open the Content.mgcb content project file in the MGCB Editor and perform the following: Right-click the fonts folder and choose Add > New Item.... Select SpriteFont Description (.spritefont) from the options. Name the file 04B_30_5x and click Create. Figure 17-1: The 04B_30_5x.spritefont file created in the MGCB Editor Next, open the 04B_30_5x.spritefont file in your code editor and make the following changes: <?xml version=\"1.0\" encoding=\"utf-8\"?> <XnaContent xmlns:Graphics=\"Microsoft.Xna.Framework.Content.Pipeline.Graphics\"> <Asset Type=\"Graphics:FontDescription\"> <FontName>04B_30.ttf</FontName> <Size>87.5</Size> <Spacing>0</Spacing> <UseKerning>true</UseKerning> <Style>Regular</Style> <CharacterRegions> <CharacterRegion> <Start>&#32;</Start> <End>&#126;</End> </CharacterRegion> </CharacterRegions> </Asset> </XnaContent> The Title Scene The title scene serves as the game's initial starting point; the first impression the player gets when they launch the game. For our game, the title scene will display the text for the title of the game and a prompt to inform the player what action to take to start the game. We will use a simple trick for the title text in order to draw it with a drop shadow to add a bit of visual flair. Note As the following screens are specific to our game and are not reusable bits, these will be added to your game project. Although, if you do end up making screens that are completely reusable, there is nothing wrong with putting them in your Game Library, it is completely up to you. To get started, first: In your Game project, create a new folder named Scenes. We will put all of our game specific scenes here. Add a new class file named TitleScene.cs to the Scenes folder you just created. Add the following code as the initial structure for the class. using Microsoft.Xna.Framework; using Microsoft.Xna.Framework.Graphics; using Microsoft.Xna.Framework.Input; using MonoGameLibrary; using MonoGameLibrary.Scenes; namespace DungeonSlime.Scenes; public class TitleScene : Scene { } Title Scene Fields Add the following fields to the TitleScene class: private const string DUNGEON_TEXT = \"Dungeon\"; private const string SLIME_TEXT = \"Slime\"; private const string PRESS_ENTER_TEXT = \"Press Enter To Start\"; // The font to use to render normal text. private SpriteFont _font; // The font used to render the title text. private SpriteFont _font5x; // The position to draw the dungeon text at. private Vector2 _dungeonTextPos; // The origin to set for the dungeon text. private Vector2 _dungeonTextOrigin; // The position to draw the slime text at. private Vector2 _slimeTextPos; // The origin to set for the slime text. private Vector2 _slimeTextOrigin; // The position to draw the press enter text at. private Vector2 _pressEnterPos; // The origin to set for the press enter text when drawing it. private Vector2 _pressEnterOrigin; Three const fields (DUNGEON_TEXT, SLIME_TEXT, PRESS_ENTER_TEXT) are added for the text that will be displayed on the title screen. The _font field stores a reference to the SpriteFont we will use to draw the press enter prompt with. The _font5x field stores a reference to the SpriteFont we will use to draw the dungeon and slime text with that will make up the title of the game. The _dungeonTextPos and _dungeonTextOrigin fields store the position and origin we will use to draw the \"Dungeon\" text at. The _slimeTextPos and _slimeTextOrigin fields store the position and origin we will draw the \"Slime\" text at. The _pressEnterPos and _pressEnterOrigin fields store the position and origin we will draw the \"Press Enter To Start\" text at. Title Scene Methods The TitleScene class will override the various methods from the base Scene class that it derives from to provide the initialization, content loading, update, and drawing logic. Title Scene Initialize Add the following override for the Initialize method to the TitleScene class: public override void Initialize() { // LoadContent is called during base.Initialize(). base.Initialize(); // While on the title screen, we can enable exit on escape so the player // can close the game by pressing the escape key. Core.ExitOnEscape = true; // Set the position and origin for the Dungeon text. Vector2 size = _font5x.MeasureString(DUNGEON_TEXT); _dungeonTextPos = new Vector2(640, 100); _dungeonTextOrigin = size * 0.5f; // Set the position and origin for the Slime text. size = _font5x.MeasureString(SLIME_TEXT); _slimeTextPos = new Vector2(757, 207); _slimeTextOrigin = size * 0.5f; // Set the position and origin for the press enter text. size = _font.MeasureString(PRESS_ENTER_TEXT); _pressEnterPos = new Vector2(640, 620); _pressEnterOrigin = size * 0.5f; } We set the Core.ExitOnEscape to true to allow players to exit the game when on the title screen by pressing the escape key. The position and origin for the \"Dungeon\", \"Slime\", and \"Press Enter To Start\" texts are set. Note You can see here we are using the MeasureString method for the font to work out how long the text to draw is, we then multiply this by 0.5 to work out the middle of the text so that we can properly set the origin of the text to its middle. Title Scene LoadContent Add the following override for the LoadContent method to the TitleScene class: public override void LoadContent() { // Load the font for the standard text. _font = Core.Content.Load<SpriteFont>(\"fonts/04B_30\"); // Load the font for the title text. _font5x = Content.Load<SpriteFont>(\"fonts/04B_30_5x\"); } The SpriteFont used to draw the \"Press Enter To Start\" text is loaded using the global content manager. The SpriteFont used to draw the \"Dungeon\" and \"Slime\" text is loaded using the scene's content manager. Tip Recall from Chapter 05 that when a ContentManager loads an asset for the first time, it caches it internally and the subsequent calls to load that asset will return the cached one instead of performing another disk read. By using a global content manager here to load assets that are used in multiple scenes, when they loaded in a different scene later, the cached version is returned instead of having to do another disk read, making the content loading more efficient. Title Scene Update Add the following override for the Update method to the TitleScene class: public override void Update(GameTime gameTime) { // If the user presses enter, switch to the game scene. if (Core.Input.Keyboard.WasKeyJustPressed(Keys.Enter)) { Core.ChangeScene(new GameScene()); } } A check is made to see if the enter key is pressed, and if so, the Core is told to change to the game scene. Note Your editor might show an error here since we have not created the GameScene class yet. We will create it in a moment after finishing the title scene. Tip You will also notice the Title screen is only checking if the player hits the enter key to start the game, but we are not checking if they hit escape to quit the game, that is because it is already handled in the Core class Update method, if ExitOnEscape is true (as it is here), the game will automatically exit. Title Scene Draw For the final act, add the following override for the Draw method to the TitleScene class: public override void Draw(GameTime gameTime) { Core.GraphicsDevice.Clear(new Color(32, 40, 78, 255)); // Begin the sprite batch to prepare for rendering. Core.SpriteBatch.Begin(samplerState: SamplerState.PointClamp); // The color to use for the drop shadow text. Color dropShadowColor = Color.Black * 0.5f; // Draw the Dungeon text slightly offset from it is original position and // with a transparent color to give it a drop shadow. Core.SpriteBatch.DrawString(_font5x, DUNGEON_TEXT, _dungeonTextPos + new Vector2(10, 10), dropShadowColor, 0.0f, _dungeonTextOrigin, 1.0f, SpriteEffects.None, 1.0f); // Draw the Dungeon text on top of that at its original position. Core.SpriteBatch.DrawString(_font5x, DUNGEON_TEXT, _dungeonTextPos, Color.White, 0.0f, _dungeonTextOrigin, 1.0f, SpriteEffects.None, 1.0f); // Draw the Slime text slightly offset from it is original position and // with a transparent color to give it a drop shadow. Core.SpriteBatch.DrawString(_font5x, SLIME_TEXT, _slimeTextPos + new Vector2(10, 10), dropShadowColor, 0.0f, _slimeTextOrigin, 1.0f, SpriteEffects.None, 1.0f); // Draw the Slime text on top of that at its original position. Core.SpriteBatch.DrawString(_font5x, SLIME_TEXT, _slimeTextPos, Color.White, 0.0f, _slimeTextOrigin, 1.0f, SpriteEffects.None, 1.0f); // Draw the press enter text. Core.SpriteBatch.DrawString(_font, PRESS_ENTER_TEXT, _pressEnterPos, Color.White, 0.0f, _pressEnterOrigin, 1.0f, SpriteEffects.None, 0.0f); // Always end the sprite batch when finished. Core.SpriteBatch.End(); } The back buffer is cleared. A dropShadowColor is created which is the color black with half transparency. The \"Dungeon\" text is drawn, first 10px down and to the left of the actual position using the drop shadow color, then again at its normal position overtop. Layering this way creates the drop shadow effect. The \"Slime\" text is drawn, again offset from its position first using the drop shadow color and then drawn again at its normal position overtop. Finally, the \"Press Enter To Start\" text is drawn. With our Title screen in place, it is time to get started with the Game Scene, lets play. The Game Scene The Game Scene will contain our actual gameplay logic. This scene will handle updating and rendering the slime that the player controls, the bat the slime can eat, collision detection, score tracking, and input handling. Most of this logic has already been implemented in our Game1 class in previous chapters, but now we will move it into a dedicated scene class. In the Scenes folder: Add a new class file named GameScene.cs in the Game projects Scenes folder. Add the following code as the initial structure for the class: using System; using Microsoft.Xna.Framework; using Microsoft.Xna.Framework.Audio; using Microsoft.Xna.Framework.Graphics; using Microsoft.Xna.Framework.Input; using MonoGameLibrary; using MonoGameLibrary.Graphics; using MonoGameLibrary.Input; using MonoGameLibrary.Scenes; namespace DungeonSlime.Scenes; public class GameScene : Scene { } The following code is effectively replacing the code we have already written in the original Game1.cs class, so it should look very familiar. Once complete, we can return to Game1 and clear out all the redundant code because it is all nicely tidied up in the new GameScene class. Game Scene Fields Add the following fields to the GameScene class: // Defines the slime animated sprite. private AnimatedSprite _slime; // Defines the bat animated sprite. private AnimatedSprite _bat; // Tracks the position of the slime. private Vector2 _slimePosition; // Speed multiplier when moving. private const float MOVEMENT_SPEED = 5.0f; // Tracks the position of the bat. private Vector2 _batPosition; // Tracks the velocity of the bat. private Vector2 _batVelocity; // Defines the tilemap to draw. private Tilemap _tilemap; // Defines the bounds of the room that the slime and bat are contained within. private Rectangle _roomBounds; // The sound effect to play when the bat bounces off the edge of the screen. private SoundEffect _bounceSoundEffect; // The sound effect to play when the slime eats a bat. private SoundEffect _collectSoundEffect; // The SpriteFont Description used to draw text private SpriteFont _font; // Tracks the players score. private int _score; // Defines the position to draw the score text at. private Vector2 _scoreTextPosition; // Defines the origin used when drawing the score text. private Vector2 _scoreTextOrigin; The _slime and _bat fields store the animated sprites for the player controlled slime and the bat. The _slimePosition and _batPosition fields track the current position of the slime and bat. The MOVEMENT_SPEED constant defines the base movement speed for both the slime and bat. The _batVelocity field tracks the current velocity of the bat as it moves around the screen. The _tilemap field stores the tilemap that we will load and draw for the level background environment. The _roomBounds field defines a rectangular boundary that represents the boundary of the room that the slime and bat stays within. The _bounceSoundEffect and _collectSoundEffect fields store the sound effects to play when the bat bounces off a screen edge or is eaten by the slime. The _font field stores the font used to display the player's score. The _score field tracks the player's current score, which increases when the slime eats a bat. The _scoreTextPosition and _scoreTextOrigin defines the position and origin to use when drawing the score text. Game Scene Methods The GameScene class will override the various methods from the base Scene class that it derives from to provide the initialization, content loading, update, and drawing logic. Game Scene Initialize Add the following override for the Initialize method to the GameScene class: public override void Initialize() { // LoadContent is called during base.Initialize(). base.Initialize(); // During the game scene, we want to disable exit on escape. Instead, // the escape key will be used to return back to the title screen Core.ExitOnEscape = false; Rectangle screenBounds = Core.GraphicsDevice.PresentationParameters.Bounds; _roomBounds = new Rectangle( (int)_tilemap.TileWidth, (int)_tilemap.TileHeight, screenBounds.Width - (int)_tilemap.TileWidth * 2, screenBounds.Height - (int)_tilemap.TileHeight * 2 ); // Initial slime position will be the center tile of the tile map. int centerRow = _tilemap.Rows / 2; int centerColumn = _tilemap.Columns / 2; _slimePosition = new Vector2(centerColumn * _tilemap.TileWidth, centerRow * _tilemap.TileHeight); // Initial bat position will the in the top left corner of the room. _batPosition = new Vector2(_roomBounds.Left, _roomBounds.Top); // Set the position of the score text to align to the left edge of the // room bounds, and to vertically be at the center of the first tile. _scoreTextPosition = new Vector2(_roomBounds.Left, _tilemap.TileHeight * 0.5f); // Set the origin of the text so it is left-centered. float scoreTextYOrigin = _font.MeasureString(\"Score\").Y * 0.5f; _scoreTextOrigin = new Vector2(0, scoreTextYOrigin); // Assign the initial random velocity to the bat. AssignRandomBatVelocity(); } We set Core.ExitOnEscape to false because in the gameplay scene, we want to handle the escape key differently; instead of exiting the game, it will return to the title screen. The room bounds is calculated using the bounds of the screen and adjusting that so that it shrinks by one tile width and height on each edge, which will match with the tilemap wall boundary. The slime's initial position is set to be the center tile by calculating the center row and column. The bat's initial position is placed at the top left of the room bounds. The position and origin of the score text is precalculated. The height of the text is measured to properly calculate the center origin for vertical positioning. The AssignRandomBatVelocity method is called to give the bat its initial velocity. Game Scene LoadContent Add the following override for the LoadContent method to the GameScene class: public override void LoadContent() { // Create the texture atlas from the XML configuration file. TextureAtlas atlas = TextureAtlas.FromFile(Core.Content, \"images/atlas-definition.xml\"); // Create the slime animated sprite from the atlas. _slime = atlas.CreateAnimatedSprite(\"slime-animation\"); _slime.Scale = new Vector2(4.0f, 4.0f); // Create the bat animated sprite from the atlas. _bat = atlas.CreateAnimatedSprite(\"bat-animation\"); _bat.Scale = new Vector2(4.0f, 4.0f); // Create the tilemap from the XML configuration file. _tilemap = Tilemap.FromFile(Content, \"images/tilemap-definition.xml\"); _tilemap.Scale = new Vector2(4.0f, 4.0f); // Load the bounce sound effect. _bounceSoundEffect = Content.Load<SoundEffect>(\"audio/bounce\"); // Load the collect sound effect. _collectSoundEffect = Content.Load<SoundEffect>(\"audio/collect\"); // Load the font. _font = Core.Content.Load<SpriteFont>(\"fonts/04B_30\"); } The texture atlas is loaded using the global content manager, and the slime and bat animated sprites are created from it. The tilemap is loaded using the scene's content manager since they are specific to the gameplay scene. The sound effects are loaded using the scene's content manager since they are specific to the gameplay scene. The font is loaded using the global content manager since it is used in multiple scenes. Tip Notice how we are following a consistent pattern across scenes: global assets are loaded with Core.Instance.Content while scene-specific assets are loaded with the scene's Content property. Game Scene Update Add the following override for the Update method to the GameScene class: public override void Update(GameTime gameTime) { // Update the slime animated sprite. _slime.Update(gameTime); // Update the bat animated sprite. _bat.Update(gameTime); // Check for keyboard input and handle it. CheckKeyboardInput(); // Check for gamepad input and handle it. CheckGamePadInput(); // Creating a bounding circle for the slime. Circle slimeBounds = new Circle( (int)(_slimePosition.X + (_slime.Width * 0.5f)), (int)(_slimePosition.Y + (_slime.Height * 0.5f)), (int)(_slime.Width * 0.5f) ); // Use distance based checks to determine if the slime is within the // bounds of the game screen, and if it is outside that screen edge, // move it back inside. if (slimeBounds.Left < _roomBounds.Left) { _slimePosition.X = _roomBounds.Left; } else if (slimeBounds.Right > _roomBounds.Right) { _slimePosition.X = _roomBounds.Right - _slime.Width; } if (slimeBounds.Top < _roomBounds.Top) { _slimePosition.Y = _roomBounds.Top; } else if (slimeBounds.Bottom > _roomBounds.Bottom) { _slimePosition.Y = _roomBounds.Bottom - _slime.Height; } // Calculate the new position of the bat based on the velocity. Vector2 newBatPosition = _batPosition + _batVelocity; // Create a bounding circle for the bat. Circle batBounds = new Circle( (int)(newBatPosition.X + (_bat.Width * 0.5f)), (int)(newBatPosition.Y + (_bat.Height * 0.5f)), (int)(_bat.Width * 0.5f) ); Vector2 normal = Vector2.Zero; // Use distance based checks to determine if the bat is within the // bounds of the game screen, and if it is outside that screen edge, // reflect it about the screen edge normal. if (batBounds.Left < _roomBounds.Left) { normal.X = Vector2.UnitX.X; newBatPosition.X = _roomBounds.Left; } else if (batBounds.Right > _roomBounds.Right) { normal.X = -Vector2.UnitX.X; newBatPosition.X = _roomBounds.Right - _bat.Width; } if (batBounds.Top < _roomBounds.Top) { normal.Y = Vector2.UnitY.Y; newBatPosition.Y = _roomBounds.Top; } else if (batBounds.Bottom > _roomBounds.Bottom) { normal.Y = -Vector2.UnitY.Y; newBatPosition.Y = _roomBounds.Bottom - _bat.Height; } // If the normal is anything but Vector2.Zero, this means the bat had // moved outside the screen edge so we should reflect it about the // normal. if (normal != Vector2.Zero) { normal.Normalize(); _batVelocity = Vector2.Reflect(_batVelocity, normal); // Play the bounce sound effect. Core.Audio.PlaySoundEffect(_bounceSoundEffect); } _batPosition = newBatPosition; if (slimeBounds.Intersects(batBounds)) { // Choose a random row and column based on the total number of each int column = Random.Shared.Next(1, _tilemap.Columns - 1); int row = Random.Shared.Next(1, _tilemap.Rows - 1); // Change the bat position by setting the x and y values equal to // the column and row multiplied by the width and height. _batPosition = new Vector2(column * _bat.Width, row * _bat.Height); // Assign a new random velocity to the bat. AssignRandomBatVelocity(); // Play the collect sound effect. Core.Audio.PlaySoundEffect(_collectSoundEffect); // Increase the player's score. _score += 100; } } The animated sprites for the slime and bat are updated. Input from keyboard and gamepad is checked with dedicated methods CheckKeyboardInput and CheckGamePadInput. Collision detection is performed to: Keep the slime within the room bounds. Make the bat bounce off edges of the room bounds. Detect when the slime eats the bat. When the slime eats the bat, the bat respawns in a random location within the room bounds, given a new velocity, the collect sound is played, and the score is increased. Game Scene Helper Methods Next, add these helper methods to the GameScene class: private void AssignRandomBatVelocity() { // Generate a random angle. float angle = (float)(Random.Shared.NextDouble() * Math.PI * 2); // Convert angle to a direction vector. float x = (float)Math.Cos(angle); float y = (float)Math.Sin(angle); Vector2 direction = new Vector2(x, y); // Multiply the direction vector by the movement speed _batVelocity = direction * MOVEMENT_SPEED; } private void CheckKeyboardInput() { // Get a reference to the keyboard inof KeyboardInfo keyboard = Core.Input.Keyboard; // If the escape key is pressed, return to the title screen. if (Core.Input.Keyboard.WasKeyJustPressed(Keys.Escape)) { Core.ChangeScene(new TitleScene()); } // If the space key is held down, the movement speed increases by 1.5 float speed = MOVEMENT_SPEED; if (keyboard.IsKeyDown(Keys.Space)) { speed *= 1.5f; } // If the W or Up keys are down, move the slime up on the screen. if (keyboard.IsKeyDown(Keys.W) || keyboard.IsKeyDown(Keys.Up)) { _slimePosition.Y -= speed; } // if the S or Down keys are down, move the slime down on the screen. if (keyboard.IsKeyDown(Keys.S) || keyboard.IsKeyDown(Keys.Down)) { _slimePosition.Y += speed; } // If the A or Left keys are down, move the slime left on the screen. if (keyboard.IsKeyDown(Keys.A) || keyboard.IsKeyDown(Keys.Left)) { _slimePosition.X -= speed; } // If the D or Right keys are down, move the slime right on the screen. if (keyboard.IsKeyDown(Keys.D) || keyboard.IsKeyDown(Keys.Right)) { _slimePosition.X += speed; } // If the M key is pressed, toggle mute state for audio. if (keyboard.WasKeyJustPressed(Keys.M)) { Core.Audio.ToggleMute(); } // If the + button is pressed, increase the volume. if (keyboard.WasKeyJustPressed(Keys.OemPlus)) { Core.Audio.SongVolume += 0.1f; Core.Audio.SoundEffectVolume += 0.1f; } // If the - button was pressed, decrease the volume. if (keyboard.WasKeyJustPressed(Keys.OemMinus)) { Core.Audio.SongVolume -= 0.1f; Core.Audio.SoundEffectVolume -= 0.1f; } } private void CheckGamePadInput() { // Get the gamepad info for gamepad one. GamePadInfo gamePadOne = Core.Input.GamePads[(int)PlayerIndex.One]; // If the A button is held down, the movement speed increases by 1.5 // and the gamepad vibrates as feedback to the player. float speed = MOVEMENT_SPEED; if (gamePadOne.IsButtonDown(Buttons.A)) { speed *= 1.5f; GamePad.SetVibration(PlayerIndex.One, 1.0f, 1.0f); } else { GamePad.SetVibration(PlayerIndex.One, 0.0f, 0.0f); } // Check thumbstick first since it has priority over which gamepad input // is movement. It has priority since the thumbstick values provide a // more granular analog value that can be used for movement. if (gamePadOne.LeftThumbStick != Vector2.Zero) { _slimePosition.X += gamePadOne.LeftThumbStick.X * speed; _slimePosition.Y -= gamePadOne.LeftThumbStick.Y * speed; } else { // If DPadUp is down, move the slime up on the screen. if (gamePadOne.IsButtonDown(Buttons.DPadUp)) { _slimePosition.Y -= speed; } // If DPadDown is down, move the slime down on the screen. if (gamePadOne.IsButtonDown(Buttons.DPadDown)) { _slimePosition.Y += speed; } // If DPapLeft is down, move the slime left on the screen. if (gamePadOne.IsButtonDown(Buttons.DPadLeft)) { _slimePosition.X -= speed; } // If DPadRight is down, move the slime right on the screen. if (gamePadOne.IsButtonDown(Buttons.DPadRight)) { _slimePosition.X += speed; } } } AssignRandomBatVelocity: Calculates a random direction and applies it to the bat's velocity. CheckKeyboardInput: Handles keyboard controls for moving the slime, toggling audio settings, and returning to the title screen. CheckGamePadInput: Handles gamepad controls for moving the slime. Game Scene Draw Finally, add the following override for the Draw method to the GameScene class: public override void Draw(GameTime gameTime) { // Clear the back buffer. Core.GraphicsDevice.Clear(Color.CornflowerBlue); // Begin the sprite batch to prepare for rendering. Core.SpriteBatch.Begin(samplerState: SamplerState.PointClamp); // Draw the tilemap _tilemap.Draw(Core.SpriteBatch); // Draw the slime sprite. _slime.Draw(Core.SpriteBatch, _slimePosition); // Draw the bat sprite. _bat.Draw(Core.SpriteBatch, _batPosition); // Draw the score. Core.SpriteBatch.DrawString( _font, // spriteFont $\"Score: {_score}\", // text _scoreTextPosition, // position Color.White, // color 0.0f, // rotation _scoreTextOrigin, // origin 1.0f, // scale SpriteEffects.None, // effects 0.0f // layerDepth ); // Always end the sprite batch when finished. Core.SpriteBatch.End(); } The back buffer is cleared. The tilemap is drawn. The slime and bat animated sprites are drawn at their current positions. The player's score is drawn at using its precalculated position and origin so that it is in the top left of the room bounds centered on the wall sprite. This concludes the GameScene class. With all the logic for our actual gameplay now housed in a single place, we can clean up our project to use it. Updating the Game1 Class With our scene system and scene classes in place, we can now simplify our main Game1 class to just initialize the game and start with the title scene. Open the Game1.cs file and replace its content with the following: using DungeonSlime.Scenes; using Microsoft.Xna.Framework.Media; using MonoGameLibrary; namespace DungeonSlime; public class Game1 : Core { // The background theme song. private Song _themeSong; public Game1() : base(\"Dungeon Slime\", 1280, 720, false) { } protected override void Initialize() { base.Initialize(); // Start playing the background music. Audio.PlaySong(_themeSong); // Start the game with the title scene. ChangeScene(new TitleScene()); } protected override void LoadContent() { // Load the background theme music. _themeSong = Content.Load<Song>(\"audio/theme\"); } } Note Feel free to check your homework and compare the original Game1 class with the updated version, as well as checking the GameScene class did not lose any functionality (it has not, but you have to be sure!). Refactoring code to be cleaner and more organised is a careful task. The Game1 class is now much simpler as most of the game logic has been moved to the appropriate scene classes. The updates include: Sets up the game window with the constructor parameters. Overrides the Initialize method to set the title scene as the starting scene. Overrides the LoadContent method to load the background theme song and start playing it. Running the game now, we can see that once the game screen comes up, the title scene is displayed with the animated slime and the press enter prompt. The background music starts playing on this scene as well. Pressing enter from here will switch to the game scene where the game starts and we can play the game implemented thus far. Figure 17-2: The game launching with the title screen first, then transitioning to the game play screen when enter is pressed Conclusion In this chapter, you accomplished the following: Learned about scene management and why it is important for organizing game code. Created an abstract Scene base class that provides a consistent lifecycle similar to the MonoGame Game class. Implemented the IDisposable interface to properly handle resource cleanup. Extended the Core class to handle scene transitions and management. Created a TitleScene for the main menu with text prompts and animations. Created a GameScene that encapsulates the gameplay mechanics. Refactored the main Game1 class to be much simpler by using the scene system. The approach we have taken follows a common pattern in game development, where each scene has control over its own lifecycle and resources. This pattern simplify state management by isolating different game states from one another. As your game grows in complexity, you could easily extend this system to include additional scenes like a pause menu or a game over screen. In the next chapter, we will explore RenderTarget2D and how we can use it to add different types of transitions when switching scenes. Test Your Knowledge What are the main benefits of implementing a scene management system in a game? :::question-answer The main benefits include: Improved organization by separating different parts of the game into self-contained modules. Better memory management by loading assets only when needed and unloading them when leaving a scene. Simplified state handling as each scene maintains its own state without affecting others. Increased code reusability through the ability to create reusable scene templates. ::: How does the scene lifecycle in our implementation mirror the MonoGame Game class lifecycle? :::question-answer The scene lifecycle mirrors the MonoGame Game class lifecycle by implementing similar methods in the same order: Initialize is called once when the scene becomes active. LoadContent is called at the end of the Initialize method. Update is called every frame to update game logic. Draw is called every frame to render the scene. UnloadContent is called when transitioning away from the scene. ::: What is the purpose of having a separate ContentManager for each scene? :::question-answer Having a separate ContentManager for each scene: Allows scene-specific content to be automatically unloaded when the scene is disposed. Provides better organization of which assets belong to which scenes. Improves memory efficiency by only loading assets that are currently needed. Makes it clear which assets are meant to be used globally versus locally to a scene. ::: When implementing scene transitions, why do we use a two-step process with _nextScene and _activeScene? :::question-answer The two-step process with _nextScene and _activeScene is used because: It allows the current scene to complete its update/draw cycle before the transition occurs. It provides a clean way to handle the disposal of the current scene before initializing the new one. It ensures that scene transitions happen at a safe point in the game loop. It prevents potential issues that could occur from immediately changing scenes in the middle of an update or draw operation. :::"
  },
  "templates/docs.monogame.github.io/articles/tutorials/building_2d_games/18_texture_sampling/index.html": {
    "href": "templates/docs.monogame.github.io/articles/tutorials/building_2d_games/18_texture_sampling/index.html",
    "title": "Chapter 18: Texture Sampling and Tiling Backgrounds | hallowed",
    "summary": "In previous chapters, we have drawn individual sprites and textures with the sprite batch, but for creating repeating background patterns, we need a more efficient approach than manually drawing the same texture multiple times. We could reuse the tilemap system that was created to make repeated background patterns, but this has a limitation in that the tiles are stationary and would require constantly updating the tiles and positions if we wanted to animate it. Instead, this chapter introduces texture sampling states, specifically focusing on how to create and animate tiled backgrounds using SamplerState.PointWrap. In this chapter, you will: Learn about texture sampling and sampler states in MonoGame. Understand how wrap mode allows efficient texture tiling. Implement a scrolling tiled background for the title screen. Understanding Texture Sampling When a texture is drawn to the screen, MonoGame uses a process called \"sampling\" to determine which pixels from the texture should be displayed. Sampling is the process by which a graphics pipeline determines what color value to use from a texture when mapping it onto a surface. Think of it like placing a grid over an image and selecting which pixels to use when that image needs to be transformed in some way. When textures are drawn at their exact pixel size and position, with no rotation, sampling is straightforward, a direct 1:1 mapping for each pixel. However, when a texture is scaled, rotated, or only partially visible, the graphics hardware needs to decide how to interpret the texture data. For example, if you draw a texture twice its size, there are not enough pixels to fill the new larger space, so the graphics hardware must determine how to fill those gaps. Similarly, if you were to scale down a texture, multiple source pixels might map to a single output pixel, requiring the hardware to decide which ones to use or how to blend them. The rules that govern these decisions are defined by sampler states. Texture Coordinates In graphics programming, textures are addressed using a normalized coordinate system ranging from 0.0 to 1.0, regardless of the texture's actual pixel dimensions: The top-left corner of a texture is (0.0, 0.0) The bottom-right corner is (1.0, 1.0) The center is (0.5, 0.5) This normalized system means that regardless of whether your texture is 32×32 pixels or 2048×2048 pixels, the coordinates to access the entire texture always range from 0.0 to 1.0. The graphics hardware automatically converts these normalized coordinates to the actual pixel locations within the texture. When you use SpriteBatch to draw a texture with a source rectangle specified in pixels, MonoGame internally converts those pixel coordinates to normalized texture coordinates before sending them to the GPU. Similarly, when you specify a destination rectangle, MonoGame determines how the normalized texture coordinates should map to screen coordinates. What is a SamplerState A SamplerState controls how textures are sampled during rendering. It determines several aspects of texture rendering: How textures are filtered when scaled (point/linear/anisotropic filtering). How texture coordinates outside the 0.0 to 1.0 range are handled (wrap/clamp/mirror). How mipmap levels are selected and blended. In MonoGame, these sampler states are represented by the SamplerState class, which provides several predefined states for common scenarios. Filtering Modes One aspect of sampler states if the filtering mode. Filtering in computer graphics refers to how the graphics hardware decides to blend or select pixels when a texture is displayed at a different size than its original dimensions. The filter mode determines how pixels are interpolated (calculated and combined) when a texture is scaled up or down. Think of filtering as the graphics hardware's strategy for filling in missing information when a texture is transformed. When you enlarge a texture, the system needs to create new pixels that did not exist in the original. When you shrink a texture, multiple original pixels must be combined into fewer output pixels. The filtering mode controls how this process happens. There are three filtering modes available in MonoGame: Point Linear Anisotropic. Each mode offers a different balance between performance and visual quality. Point Filtering Mode Point mode uses what is called nearest neighbor sampling. This means that when a texture is scaled, the closest pixel is selected resulting in a pixelated appearance when scaled up. This is typically the ideal mode to use for pixel-art games when you want to preserve the exact pixel appearance of a scaled texture. Point filtering is the least computationally expensive filtering mode of the three since it only samples a single pixel without any blending calculations. This makes it the fastest option, especially on lower-end hardware or when rendering many textures simultaneously. Figure 18-1: Illustration of using Point filtering mode. Left: MonoGame logo at 32x32 pixels. Right: MonoGame logo at 128x128 pixels Linear Filtering Mode Linear filtering mode blends neighboring pixels when the texture is scaled. This creates a smoother, but potentially blurrier appearance. This is better for realistic or high-resolution textures. Linear filtering requires more processing power than point filtering since it needs to sample multiple pixels and calculated weighted averages between them. However, on modern hardware, this performance difference is usually negligible for 2D games, making it a good balance between quality and performance for most non-pixel art games or assets. Figure 18-2: Illustration of using Linear filtering mode. Left: MonoGame logo at 32x32 pixels. Right: MonoGame logo at 128x128 pixels Anisotropic Filtering Mode Anisotropic filtering mode provides higher-quality filter for textures viewed from oblique angles. This is primarily used in 3D rendering. It helps textures look more detailed by reducing blur and aliasing that occurs when a surface is angled away from the viewer. Anisotropic filtering is the most computationally intensive option, as it samples many more pixels and performs complex calculations to determine the appropriate blending. The performance cost increases with the anisotropic level (typically 2x, 4x, 8x, or 16x), which determines how many samples are taken. This can significantly impact frame rates in complex 3D scenes, especially on mobile or lower-end devices, so it should be used selectively where visual quality at angles is most important. Figure 18-3: Illustration of the MonoGame Fuel cell demo using Linear filtering Figure 18-4: Illustration of the MonoGame Fuel cell demo using Anisotropic filtering Addressing Modes The other aspect is the addressing mode, which determines what happens when texture coordinates fall outside the normal 0.0 to 1.0 range. When drawing textures, sometimes the calculated texture coordinates end up being less than 0.0 or greater than 1.0. The addressing mode tells the graphics hardware what to do in these situations; whether to repeat the texture, mirror it, stretch the edge pixels, or use a specific border color. Think of it as instructions for what to display in areas where the texture does not naturally exist. These modes are particularly important for creating effects like seamless tiling backgrounds, scrolling texture, or handling the edges of transformed sprites properly. There are four addressing modes available; Wrap, Mirror, Clamp, and Border Color: Wrap Mode When using Wrap mode, at every whole integer of the texture coordinates (0.0 and 1.0), the texture coordinate is wrapped to stay within the 0.0 to 1.0 range (i.e. if the texture coordinate is 1.2, then that wraps to become 0.2). This creates a tiled pattern. For example, if we were to take the MonoGame logo at 128x128 pixels and draw it to a destination rectangle that was three times the size at 384x384 pixels, then the texture coordinates of the destination rectangle become (0.0, 0.0) (top-left), (3.0, 0.0) (top-right), (0.0) (bottom-left), and (3.0, 3.0) bottom-right. The MonoGame logo texture would repeat three times horizontally and vertically within the destination. Figure 18-5: Illustration of the MonoGame logo drawn using wrapped addressing mode Mirror Mode Mirror mode is similar to Wrap mode. However instead of repeating the texture at every whole integer of the texture coordinates (0.0 and 1.0), the texture is flipped, creating a mirror effect. Using the same example as above, taking the MonoGame logo at 128x128 pixels and drawing it to a destination rectangle three times the size with Mirror mode would produce the following: Figure 18-6: Illustration of the MonoGame logo drawn using mirror addressing mode Clamp Mode When using Clamp mode, the texture coordinates are clamped to the 0.0 and 1.0 range. Texture coordinates that would go beyond this (edge pixels) are smeared. The simplest demonstration of this is to use a checkerboard pattern. If we were to take a texture that was a checkerboard pattern at 128x128 pixels and draw it to a destination rectangle three times the size with Clamped mode, then any pixels that extend outside the clamped range would smeared, producing the following: Figure 18-7: Illustration of a checkerboard pattern drawn using clamped addressing mode Border Color When using Border Color mode, similar to Clamped mode, the texture coordinates are clamped to the 0.0 and 1.0f range. However, in Border Color mode, texture coordinates that would go beyond this (edge pixels) are instead drawn using the color set as the border color for the sampler state. For example, if we use the checkerboard pattern again, using Border Color mode with a border color of green, then it would produce the following: Figure 18-8: Illustration of a checkerboard pattern drawn using border addressing mode with the border color set to green Using SamplerStates MonoGame offers several predefined sampler states as part of the SamplerState class that cover common scenarios: SamplerState Description Common Use Case AnisotropicClamp Combines Anisotropic filter mode with the Clamp addressing mode. 3D textures viewed at oblique angles, like ground textures in a 3D world where you want high-quality filtering but no repeating patterns. AnisotropicWrap Combines Anisotropic filter mode with the Wrap addressing mode. Terrain textures in 3D games where you need high-quality filtering and repeating patterns over large surfaces. LinearClamp Combines Linear filter mode with the Clamp addressing mode. UI elements and single sprites where you want smooth scaling but no repeating patterns. Good for realistic graphics that need to scale. LinearWrap Combines Linear filter mode with the Wrap addressing mode. Scrolling backgrounds with smooth transitions, like water or cloud textures that need to tile seamlessly with blended edges. PointClamp Combines Point filter mode with the Clamp addressing mode. Pixel art sprites and UI elements where you want to preserve crisp pixel edges without any blurring when scaled. Default for most 2D games. PointWrap Combines Point filter mode with the Wrap addressing mode. Tiled pixel art backgrounds and patterns where you want crisp pixels and repeating patterns When using the SpriteBatch, you specify which sampler state you want to use as the samplerState parameter for the SpriteBatch.Begin method // Example of using the Point Clamp sampler state spriteBatch.Begin(samplerState: SamplerState.PointClamp); Note The default sampler state for SpriteBatch is SamplerState.LinearClamp in MonoGame, though SamplerState.PointClamp is often preferred for pixel art games to prevent blurring. Adding a Scrolling Background to the Title Scene We will now update the title scene of our game by adding a scrolling background pattern using SamplerState.PointWrap. By using the Wrap addressing mode, we can create a large scrolling background using only a small texture. When the texture is drawn with a destination rectangle larger than the texture itself, the Wrap mode will automatically tile the texture to fill the space. By adjusting the source rectangle over time, we can create a scrolling effect with minimal effort. First, download the following image of a repeatable background pattern by right-clicking it and saving it as background-pattern.png in the Content/images folder of the game project: Figure 18-9: The repeatable background pattern we will use for the title screen Next, add this texture to your content project using the MGCB Editor: Open the Content.mgcb content project file in the MGCB Editor. Right-click the images folder and choose Add > Existing item.... Navigate to and select the background-pattern.png file. Save the changes and close the MGCB Editor. Figure 18-10: The MGCB Editor with the background-pattern image added Updating the Title Scene Now that we have the background pattern texture added, we can update the TitleScene class to implement the scrolling background. Open the TitleScene.cs file in the game project and update it to the following using Microsoft.Xna.Framework; using Microsoft.Xna.Framework.Graphics; using Microsoft.Xna.Framework.Input; using MonoGameLibrary; using MonoGameLibrary.Scenes; namespace DungeonSlime.Scenes; public class TitleScene : Scene { private const string DUNGEON_TEXT = \"Dungeon\"; private const string SLIME_TEXT = \"Slime\"; private const string PRESS_ENTER_TEXT = \"Press Enter To Start\"; // The font to use to render normal text. private SpriteFont _font; // The font used to render the title text. private SpriteFont _font5x; // The position to draw the dungeon text at. private Vector2 _dungeonTextPos; // The origin to set for the dungeon text. private Vector2 _dungeonTextOrigin; // The position to draw the slime text at. private Vector2 _slimeTextPos; // The origin to set for the slime text. private Vector2 _slimeTextOrigin; // The position to draw the press enter text at. private Vector2 _pressEnterPos; // The origin to set for the press enter text when drawing it. private Vector2 _pressEnterOrigin; // The texture used for the background pattern. private Texture2D _backgroundPattern; // The destination rectangle for the background pattern to fill. private Rectangle _backgroundDestination; // The offset to apply when drawing the background pattern so it appears to // be scrolling. private Vector2 _backgroundOffset; // The speed that the background pattern scrolls. private float _scrollSpeed = 50.0f; public override void Initialize() { // LoadContent is called during base.Initialize(). base.Initialize(); // While on the title screen, we can enable exit on escape so the player // can close the game by pressing the escape key. Core.ExitOnEscape = true; // Set the position and origin for the Dungeon text. Vector2 size = _font5x.MeasureString(DUNGEON_TEXT); _dungeonTextPos = new Vector2(640, 100); _dungeonTextOrigin = size * 0.5f; // Set the position and origin for the Slime text. size = _font5x.MeasureString(SLIME_TEXT); _slimeTextPos = new Vector2(757, 207); _slimeTextOrigin = size * 0.5f; // Set the position and origin for the press enter text. size = _font.MeasureString(PRESS_ENTER_TEXT); _pressEnterPos = new Vector2(640, 620); _pressEnterOrigin = size * 0.5f; // Initialize the offset of the background pattern at zero. _backgroundOffset = Vector2.Zero; // Set the background pattern destination rectangle to fill the entire // screen background. _backgroundDestination = Core.GraphicsDevice.PresentationParameters.Bounds; } public override void LoadContent() { // Load the font for the standard text. _font = Core.Content.Load<SpriteFont>(\"fonts/04B_30\"); // Load the font for the title text. _font5x = Content.Load<SpriteFont>(\"fonts/04B_30_5x\"); // Load the background pattern texture. _backgroundPattern = Content.Load<Texture2D>(\"images/background-pattern\"); } public override void Update(GameTime gameTime) { // If the user presses enter, switch to the game scene. if (Core.Input.Keyboard.WasKeyJustPressed(Keys.Enter)) { Core.ChangeScene(new GameScene()); } // Update the offsets for the background pattern wrapping so that it // scrolls down and to the right. float offset = _scrollSpeed * (float)gameTime.ElapsedGameTime.TotalSeconds; _backgroundOffset.X -= offset; _backgroundOffset.Y -= offset; // Ensure that the offsets do not go beyond the texture bounds so it is // a seamless wrap. _backgroundOffset.X %= _backgroundPattern.Width; _backgroundOffset.Y %= _backgroundPattern.Height; } public override void Draw(GameTime gameTime) { Core.GraphicsDevice.Clear(new Color(32, 40, 78, 255)); // Draw the background pattern first using the PointWrap sampler state. Core.SpriteBatch.Begin(samplerState: SamplerState.PointWrap); Core.SpriteBatch.Draw(_backgroundPattern, _backgroundDestination, new Rectangle(_backgroundOffset.ToPoint(), _backgroundDestination.Size), Color.White * 0.5f); Core.SpriteBatch.End(); // Begin the sprite batch to prepare for rendering. Core.SpriteBatch.Begin(samplerState: SamplerState.PointClamp); // The color to use for the drop shadow text. Color dropShadowColor = Color.Black * 0.5f; // Draw the Dungeon text slightly offset from it is original position and // with a transparent color to give it a drop shadow. Core.SpriteBatch.DrawString(_font5x, DUNGEON_TEXT, _dungeonTextPos + new Vector2(10, 10), dropShadowColor, 0.0f, _dungeonTextOrigin, 1.0f, SpriteEffects.None, 1.0f); // Draw the Dungeon text on top of that at its original position. Core.SpriteBatch.DrawString(_font5x, DUNGEON_TEXT, _dungeonTextPos, Color.White, 0.0f, _dungeonTextOrigin, 1.0f, SpriteEffects.None, 1.0f); // Draw the Slime text slightly offset from it is original position and // with a transparent color to give it a drop shadow. Core.SpriteBatch.DrawString(_font5x, SLIME_TEXT, _slimeTextPos + new Vector2(10, 10), dropShadowColor, 0.0f, _slimeTextOrigin, 1.0f, SpriteEffects.None, 1.0f); // Draw the Slime text on top of that at its original position. Core.SpriteBatch.DrawString(_font5x, SLIME_TEXT, _slimeTextPos, Color.White, 0.0f, _slimeTextOrigin, 1.0f, SpriteEffects.None, 1.0f); // Draw the press enter text. Core.SpriteBatch.DrawString(_font, PRESS_ENTER_TEXT, _pressEnterPos, Color.White, 0.0f, _pressEnterOrigin, 1.0f, SpriteEffects.None, 0.0f); // Always end the sprite batch when finished. Core.SpriteBatch.End(); } } The key changes here are The _backgroundPattern field was added to store a reference to the texture of the background pattern once its loaded. The _backgroundDestination field was added to define the destination rectangle to draw the background pattern to. The _backgroundOffset field was added to apply an offset to the source rectangle when rendering the background pattern to give it the appearance that it is scrolling. The _scrollSpeed field was added to set the speed at which the background pattern scrolls. In Initialize, the initial offset of the background is set to Vector2.Zero and the background destination rectangle is set to the bounds of the screen. In LoadContent, the background-pattern texture is loaded and stored in _backgroundPattern. In Update, the X and Y offset for the background source rectangle is calculated by adjusting the based on the scroll speed multiplied by the delta time. Modulo division is then used to ensure that the new offset calculations remain within the width and height bounds of the background texture so that the wrap is seamless. In Draw, a new sprite batch begin/end block is added that uses SamplerState.PointWrap and draws the background pattern to the destination rectangle using a source rectangle with the offset calculations. Note We use two separate sprite batch begin/end blocks for this. The first uses SamplerState.PointWrap to draw the background and the second uses SamplerState.PointClamp to draw the rest of the scene. This separation is necessary because changing the sampler state requires ending the current sprite batch and beginning a new one. Running the game now with these changes, the title screen now has a scroll background that adds more visual depth and interest to it than just the plain colored background we had before. Figure 18-11: The title screen now with the repeating background texture of the slime and bat scrolling diagonally down and to the right Conclusion In this chapter, you accomplished the following: Learned about texture coordinates and how they map from normalized 0.0 to 1.0 space to actual pixel locations. Understood the difference between various filtering modes (Point, Linear, Anisotropic) and their visual impact. Explored different addressing modes (Wrap, Mirror, Clamp, Border) and when to use each. Discovered how to use predefined sampler states to simplify common rendering tasks. Implemented a scrolling background pattern using SamplerState.PointWrap. Test Your Knowledge What is the difference between normalized texture coordinates and pixel coordinates? :::question-answer Normalized texture coordinates always range from 0.0 to 1.0 regardless of the texture's actual pixel dimensions. The top-left corner is (0.0, 0.0) and the bottom-right is (1.0, 1.0). Pixel coordinates, on the other hand, directly reference specific pixel locations within the texture using integer values based on the actual texture dimensions. MonoGame automatically converts between these coordinate systems when drawing textures. ::: Which filtering mode would be most appropriate for a pixel art game, and why? :::question-answer Point filtering (also called nearest neighbor) is most appropriate for pixel art games. It selects the closest pixel when scaling rather than blending neighboring pixels, which preserves the crisp, pixelated aesthetic that defines pixel art. Linear or Anisotropic filtering would blur the intentionally sharp edges of pixel art graphics. ::: Why do we use modulo (%) operation on the background offset values when implementing the scrolling background? :::question-answer The modulo operation ensures that the offset values always remain within the bounds of the original texture dimensions. This prevents potential graphical artifacts that could appear when the offset exceeds the texture size, and it guarantees seamless wrapping as the background continuously scrolls. Without this, the background pattern might show visible seams or discontinuities when it repeats. ::: Why do we need to use two separate sprite batch begin/end blocks when drawing the background and the other elements in the title scene? :::question-answer We need separate blocks because changing the sampler state requires ending the current batch and beginning a new one. Since we want to use SamplerState.PointWrap for the tiling background but SamplerState.PointClamp for the UI elements, we must use two distinct sprite batch blocks with different sampler state settings. Using a single batch would apply the same sampler state to all drawn elements. ::: How does using a tiled background with SamplerState.PointWrap compare to manually drawing multiple copies of a texture to create a background? :::question-answer Using SamplerState.PointWrap offers several advantages: It requires only a single draw call instead of multiple calls for each tile. No need to calculate positions for each individual tile Manually drawing multiple copies would be more code-intensive, less performant, and harder to maintain, especially for animations. :::"
  },
  "templates/docs.monogame.github.io/articles/tutorials/building_2d_games/19_user_interface_fundamentals/index.html": {
    "href": "templates/docs.monogame.github.io/articles/tutorials/building_2d_games/19_user_interface_fundamentals/index.html",
    "title": "Chapter 19: User Interface Fundamentals | hallowed",
    "summary": "A game's user interface (UI) allows players to interact with the game beyond just controlling the character. UI elements include menus, buttons, panels, labels, and various other interactive components that provide information and control options to the player. In this chapter you will: Learn the basics of user interface design in games. Understand different UI types and their purposes. Explore UI layout approaches and positioning strategies. Understand the parent-child relationship for UI elements. Learn about accessibility considerations in game UI design. We will first start by understanding what a user interface is and how it functions in game development. Understanding Game User Interfaces A user interface in games serves as a bridge between the player and the game's systems. Well designed UIs help players navigate the game's mechanics, understand their current status, and make informed decisions. For new game developers, understanding UI principles is crucial because even the most mechanically sound game can fail if players can not effectively interact with it. Game UIs consist of various visual elements that serve different purposes: Information Display: Elements like health bars, score counters, or minimap displays provide players with game state information. These elements help players understand their progress, resources, and current status without interrupting gameplay. Interactive Controls: Buttons, sliders, checkboxes, and other interactive elements allow players to make choices, adjust settings, or navigate through different sections of the game. These elements should provide clear visual feedback when interacted with to confirm the player's actions. Feedback Mechanisms: Visual effects like highlighting, color changes, or animations that respond to player actions help confirm that input was received. This feedback loop creates an intuitive and responsive feel for the UI in your game. User interfaces for games can be categorized into two main types, each with their own design considerations: Diegetic UI: These elements exist within the game world itself and are often part of the narrative. Examples include a health meter integrated into a character's suit, ammunition displayed on a weapon's holographic sight, or the dashboard instruments in the cockpit of a racing game. A Diegetic UI can enhance immersion by making interface elements feel like natural parts of the game world. Non-diegetic UI: These elements exist outside the game world, overlaid on top of the gameplay. Traditional menus, health bars in the corner of the screen, and score displays are common examples. While less immersive than a diegetic UI, non-diegetic elements are often clearer and easier to read. UI Layout Systems When designing and implementing game UI systems, developers must decide how UI elements will be positioned on the screen. Two primary approaches exist, each with distinct advantages and trade-offs: Absolute Positioning: In this approach, each UI element is placed at specific coordinates on the screen. Elements are positioned using exact locations, which gives precise control over the layout. This approach is straightforward to implement and works well for static layouts where elements do not need to adjust based on screen size or content changes. The main disadvantage of absolute positioning is its lack of flexibility, as iterating on design can be more difficult since one change may have cascading effects on other elements. If the screen resolution changes or if an element's size changes, manual adjustments to positions are often necessary to maintain the desired layout. Layout engines: These system position UI elements relative to one another using rules and constraints. Elements might be positioned using concepts like \"center\", \"align to parent\", or \"flow horizontally with spacing\". Layout engines add complexity but provide flexibility. The advantage of layout engines is adaptability to different screen sizes and content changes. However, they require more initial setup and can be more complex to implement from scratch. Parent-Child Relationships Parent-child relationships are a part of many UI system. This relationship is implemented with UI elements containing other UI elements, creating a tree-like structure. This hierarchial approach mirrors how interface elements naturally group together in designs. For example, a settings panel might contain multiple buttons, labels, and sliders. By making these elements children of the panel, they can be managed as a cohesive unit. This organizational structure provides several significant advantages: Inheritance of Properties: Child elements can automatically inherit certain properties from their parents. For instance, if a parent element is hidden or disabled, all its children can be hidden or disabled as well. This cascading behavior simplifies state management across complex interfaces. Relative Positioning: Child elements can be positioned relative to their parents rather than relative to the screen. This means you can place elements within a container and then move the entire container as a unit without having to update each child's position individually. Simplified State Management: Actions on parent elements can automatically propagate to their children. For example, disabling a menu panel can automatically disable all buttons within it, preventing interaction with elements that should not be active. Batch Operations: Operations like drawing and updating can be performed on a parent element and automatically cascade to all children, reducing the need for repetitive code. Logical Grouping: The hierarchy naturally models the conceptual grouping of UI elements, making the code structure more intuitive and easier to maintain. Anchoring and Docking In UI systems, two important concepts help with positioning elements: anchoring and docking. Anchoring Anchoring allows you to position UI elements relative to specific reference points on their parents. The following diagram demonstrates common anchor points: Figure 19-1: Diagram showing common anchor points When you set an anchor point, the elements' position coordinates become relative to that anchor point. For example with a \"Right\" anchor and an X value of -5, you element would position itself 5 pixels to the left of the parent's right edge, creating a consistent margin regardless of the parent's size, as demonstrated in the following diagram: Figure 19-2: Diagram showing anchored element positioning relative to anchor regardless of parent size Docking Docking takes anchoring a step further by also adjusting an element's size to fill available space. The following diagram demonstrates common docking options: Figure 19-3: Diagram showing the common docking options These positioning strategies enable you to create layouts that can maintain their visual relationships even when parent elements change size or position. Accessibility in Game UI Creating accessible user interfaces is an essential aspect of inclusive game design. Accessibility ensures that your game can be played by a broader audience, including players with visual acuity or other specific needs. When designing your UI system, consider some of these key accessibility principles: Visual Accessibility Color contrast: Ensure sufficient contrast between text and backgrounds. Use shapes: Do not rely solely on color to convey important information; add shapes, patterns, or text labels as well. For example, if displaying warning text, also use something such as the common warning sign ⚠️. Text size and scaling: Allow players to adjust text size or implement a UI scaling option. Internationalization (i18n): Consider how your UI might be interpreted across different cultures and regions. Number formatting can vary significantly - some regions use periods for thousands separators (1.000.000) while others use commas (1,000,000). Control symbolism also differs culturally; for example, on console controllers, the Cross button typically means \"Select\" in Western regions but \"Cancel\" in Japan, with Circle having the opposite meaning. Input Accessibility Input redundancy: Support multiple input methods for the same action. This ensures players can interact with UI elements using their preferred input devices. Reduce input precision requirements: Implement generous hitboxes for clickable UI elements to help players with motor control difficulties. Testing for Accessibility The most effect way to ensure accessibility is through testing under different circumstances and with diverse users: Test your Ui using only keyboard navigation. Try playing without sound. Check your UI with a color blindness simulator. Adjust the display scale to simulate low vision. Get feedback from player with different abilities. By considering accessibility early in development rather than as an afterthought, you create games that can be enjoyed by more players while also often improving the experience for everyone. Conclusion In this chapter, you learned the fundamentals of user interface design for games. You explored the different types of UI elements and their purposes, understood the benefits of parent-child relationships in UI hierarchies, and learned about different positioning strategies like anchoring and docking. You also discovered the importance of accessible UI design and how to implement practices that make your game playable for a wider audience. These foundational concepts will serve as the building blocks for implementing the UI in our game. In the next chapter, we will put these concepts into practice by implementing a UI system using Gum, a specialized UI framework that will help us create interactive menus, buttons, and other UI elements for our game. Test Your Knowledge What are the two main types of game user interfaces, and how do they differ? :::question-answer The two main types are: Diegetic UI: Elements that exist within the game world itself and are part of the narrative (like health meters integrated into a character's suit or cockpit instruments in racing games). These enhance immersion by making UI feel like a natural part of the game world. Non-diegetic UI: Elements that exist outside the game world, overlaid on top of gameplay (like traditional menus, health bars in screen corners, score displays). While less immersive, they are often clearer and easier to read. ::: What are some advantages of using a parent-child relationship in UI systems? :::question-answer Inheritance of properties: visual states cascade parent to children. Relative positioning: Child elements are positioned relative to their parents. Simplified state management: Parent states affect children automatically. Batch operations: Update and draw calls propagate through the hierarchy. Logical grouping: Mirrors the conceptual organization of UI elements. ::: How do anchoring and docking differ in UI layout systems? :::question-answer Anchoring: Positions UI elements relative to specific reference points on their parent (like TopLeft, Center, BottomRight) without changing the element's size. An element's position coordinates become relative to the chosen anchor point. Docking: Takes anchoring further by also adjusting an element's size to fill available space. For example, docking to the top means the element fills the parent horizontally while staying at the top, while \"Fill\" docking means the element expands to fill the entire parent area. ::: What are some accessibility considerations that should be implemented in game UI systems? :::question-answer Visual accessibility: High contrast colors, not relying solely on color for information, adjustable text size and UI scaling, and internationalization support. Input accessibility: Support for multiple input methods and reduced precision requirements. Testing practices: Ensure the UI works with keyboard only navigation, without sound, and with simulated visual impairments. :::"
  },
  "templates/docs.monogame.github.io/articles/tutorials/building_2d_games/20_implementing_ui_with_gum/index.html": {
    "href": "templates/docs.monogame.github.io/articles/tutorials/building_2d_games/20_implementing_ui_with_gum/index.html",
    "title": "Chapter 20: Implementing UI with Gum | hallowed",
    "summary": "In the previous chapter we explored the fundamental concepts of user interface design. Now we are ready to put these principles into practice by implementing a UI system for our game. While it is possible to build a UI system from scratch, we will take advantage of Gum, a specialized UI framework that simplifies many of the complex aspects of UI implementation. In this chapter you will: Install and configure the Gum NuGet package. Learn about Gum's core concepts including Forms and Visuals Implement UI elements for our game's title scene. Create a pause menu for the gameplay scene. Handle input from keyboard, mouse, and gamepads Integrate the UI system with our existing game architecture. Important While GUM is used in this tutorial it is only one of many UI libraries available to the MonoGame community, some notable others are EmptyKeys, GeonBit.UI, as well as entire Game Frameworks/Engines like Nez that have their own built in UI systems. Check out the MonoGame Resources page, as well as awesome-monogame from Alois Deniel for even more community offerings. What is Gum? Gum is a powerful UI layout engine and framework. It provides a flexible, efficient system capable of producing virtually any UI layout you might need in your games. While originally developed alongside the FlatRedBall game engine, Gum has evolved to work seamlessly with multiple platforms, including MonoGame, which we will be using in this tutorial. Why Use Gum? Creating a UI system from scratch requires solving many complex problems: Layout Management: Calculating positions for elements that need to adapt to different screen sizes or content changes. Input Handling: Detecting and responding to mouse, keyboard, and gamepad inputs across multiple UI elements. Visual State Management: Changing appearances based on user interactions (hovering, focusing, clicking). Component Hierarchy: Managing parent-child relationships between elements. Gum addresses these challenges with ready-made solutions, allowing us to focus on the specific needs of our game rather than reinventing the UI wheel. While MonoGame provides the basic tools for drawing graphics and detecting input, it does not include high-level UI abstractions; this is where tools like Gum fill the gap. Important This tutorial uses the Gum NuGet package to help with layout and responding to user interactions. This tutorial does not require the use of the Gum editor, we will be doing everything in code. Keep in mind that while it is possible to build a full UI system without any external dependencies, creating a layout engine is complicated and beyond the scope of this tutorial. Instead, we will be taking advantage of the Gum NuGet package. Gum is a powerful system enabling the creation of virtually any game UI, and we will be covering some of the basics of its use in this tutorial. The full Gum documentation can be found here: https://docs.flatredball.com/gum/code/monogame Gum Concepts Before we dive into implementation, we will explore the core concepts that Gum provides. Gum simplifies UI development by providing ready-made controls and layout systems that would otherwise require significant effort to build from scratch. Understanding Gum's Structure Gum organizes UI elements in a hierarchical tree structure, similar to how HTML organizes web elements or how GUI frameworks like WPF or JavaFX structure their interfaces. This hierarchy consists of: The Root Element: The topmost container in the hierarchy that serves as the entry point for all UI elements. Containers: Elements that can hold other elements (like panels or screens). Controls: Interactive elements that respond to user input (like buttons or sliders). Visuals: The actual graphical representations of UI elements (like text, images, or shapes). When a game using Gum runs, this hierarchy is maintained in memory, with each element knowing its parent and children. The framework automatically handles the flow of events through this hierarchy and manages the drawing of elements according to their positions in the tree. Gum Root Element All Gum elements must be directly or indirectly added to Gum's root container. This can be done directly wth the AddToRoot() method: // Creating a panel and adding it to the root Panel mainMenuPanel = new Panel(); mainMenuPanel.AddToRoot(); Or it can be done indirectly by adding a control as a child of an element that has been added to Gum's root container: // Creating a panel and adding it to the root Panel mainMenuPanel = new Panel(); mainMenuPanel.AddToRoot(); // Creating a button and adding it as a child element of the panel // which indirectly connects it to Gum's root container Button startButton = new Button(); mainMenuPanel.AddChild(startButton); Gum's root element can also be cleared at any time to remove all UI elements: // Clear all children from Gum's root container. GumService.Default.Root.Children.Clear(); This can be useful when navigating between different scenes to ensure UI elements do not persist from previous scenes: public class GameScene { public override void Initialize() { // Clear all children from Gum's root container that may have been added // during the previous scene GumService.Default.Root.Children.Clear(); // Now that it has been cleared, initialize the UI for this scene InitializeUI(); } } Anchoring In the previous chapter we discussed anchoring, a fundamental UI concept that allows you to position elements relative to specific reference points of their parents. Gum supports anchoring of Forms controls through the Anchor() method. // Creating a panel and adding it to the root Panel mainMenuPanel = new Panel(); mainMenuPanel.AddToRoot(); // Creating a button and adding it as a child of the panel // anchored ot the bottom-left of the panel Button startButton = new Button(); startButton.Anchor(Gum.Wireframe.Anchor.BottomLeft); mainMenuPanel.AddChild(startButton); The following anchor types are supported by Gum: Anchor Gum Value TopLeft Gum.Wireframe.Anchor.TopLeft Top Gum.Wireframe.Anchor.Top TopRight Gum.Wireframe.Anchor.TopRight Left Gum.Wireframe.Anchor.Left Center Gum.Wireframe.Anchor.Center Right Gum.Wireframe.Anchor.Right BottomLeft Gum.Wireframe.Anchor.BottomLeft Bottom Gum.Wireframe.Anchor.Bottom BottomRight Gum.Wireframe.Anchor.BottomRight Docking In the previous chapter, we also discussed docking, a fundamental UI concept that adjusts an element's size to fill the available space. Gum supports the docking of Forms controls through their Dock() method. // Creating a panel and adding it to the root Panel mainMenuPanel = new Panel(); mainMenuPanel.AddToRoot(); // Docking the panel to fill the entire root space mainMenuPanel.Dock(Gum.Wireframe.Dock.Fill); The following docking modes are supported by Gum: Anchor Gum Value Description Top Gum.Wireframe.Dock.Top Anchors to the top edge and fills horizontally. Left Gum.Wireframe.Dock.Left Anchors to the left edge and fills vertically. Right Gum.Wireframe.Dock.Right Anchors to the ridge edge and fills vertically. Bottom Gum.Wireframe.Dock.Bottom Anchors to the bottom edge and fills horizontally. Fill Gum.Wireframe.Dock.Fill Anchors to the center and fills the entire parent area vertically and horizontally. FillHorizontally Gum.Wireframe.Dock.FillHorizontally Stretches across the parent's width, filling horizontally. FillVertically Gum.Wireframe.Dock.FillVertically Stretches across the parent's height, filling vertically. SizeToChildren Gum.Wireframe.Dock.SizeToChildren Automatically sizes vertically and horizontally based on contained child element. Forms and Visuals Two concepts are important when working with Gum: Forms and Visuals. Forms controls are typical interactive UI elements such as buttons, sliders, and text boxes that handle user interaction through mouse, gamepad, and keyboard inputs. These controls come with built-in functionality; a button responds visually when focused, while a slider changes its value when clicked on its track. By using these standardized components, you can maintain consistency throughout your UI implementation. Visuals are the graphical display elements that render the actual appearance of UI components. In Gum, Visual elements have the *Runtime suffix (like TextRuntime, ColoredRectangleRuntime, and NineSliceRuntime) and are used to render graphics. They handle the visual representation but have no built-in interaction behavior on their own. Forms controls provide customization through their Visual property, which serves as a gateway to modifying their appearance and layout. With this property, you can move, resize, restyle, and even completely replace visuals through code. As we will see when building our UI in the next chapter, this separation between functionality and presentation allows us to create consistent behaviors while adapting the visual style to match our game's aesthetic. For now, we will examine some of the Forms control types we will use in this chapter. Panel Panels serve as invisible containers that group related UI elements together. Unlike visible elements that display graphics, panels focus on organization and layout management. A panel provides several key functions: Groups related elements for easier management. Controls visibility for entire sections of UI at once. Establishes a coordinate system for child elements. Provides a foundation for layout management. Panels are especially useful for creating distinct UI screens, by toggling the visibility of different panels you can implement complete UI state changes with minimal code: // Change the state of the UI by hiding one panel and showing another. mainMenuPanel.IsVisible = false; optionsPanel.IsVisible = true; A common pattern is to set a panel's docking to Fill, which makes it span the entire available area: // Make the panel fill the entire screen mainMenuPanel.Dock(Gum.Wireframe.Dock.Fill); This creates a consistent coordinate space for all child elements, allowing them to be positioned relative to the screen. Button The Button Forms control type is the primary interactive control for triggering actions in your UI. Buttons provide: Responses to clicks from mouse, touch, keyboard, or gamepad input. Visual feedback when focused or hovered. Raises a Click event when activated. Buttons can be positioned using anchoring to create layouts that adapt to different screen sizes: // Creating a button that is anchored to the bottom left. Button startButton = new Button; startButton.Anchor(Gum.Wireframe.Anchor.BottomLeft); // Set the X and Y position so it is 20px from the left edge // and 20px from the bottom edge. startButton.Visual.X = 20; startButton.Visual.Y = -20; The Click event is raised whenever the button is activated and provides a standard way to respond regardless of input device: startButton.Click += (sender, args) => { // Handle button click... StartGame(); }; Note The Click event for a button is triggered automatically when it is left-clicked by a mouse or pushed via touch controls. For keyboard and gamepad input, it can only be triggered when the button has focus, which typically happens when the player navigates to it using the tab key or controller. Slider The Slider Forms control type allows users to select a numeric value from a continuous range. A slider: Displays and modifies a Value property constrained between a Minimum and Maximum value. Responds to mouse clicks on its track or by dragging its thumb. Supports keyboard and gamepad input for incremental adjustments. Raises events when its value changes. Basic slider setup includes defining its range and establishing event handlers: Slider volumeSlider = new Slider(); volumeSlider.Minimum = 0.0f; volumeSlider.Maximum = 1.0f; volumeSlider.Value = 0.5f; volumeSlider.SmallChange = 0.1f; volumeSlider.LargeChange = 0.2f; The SmallChange property sets the increment for keyboard and gamepad adjustments, while the LargeChange property determines the increment when clicking directly on the slider track. Sliders provide several events for different interaction scenarios: ValueChanged: Fires continuously as the value changes (useful for live previews). ValueChangeCompleted: Fires once when the user finishes adjusting the value (useful for applying final settings). volumeSlider.ValueChanged += (sender, arg) => { // Handle value changed event... UpdateVolume(volumeSlider.Value); }; volumeSlider.ValueChangedCompleted += (sender, arg) => { // Handle value change completed event... UpdateVolume(volumeSlider.Value); // Useful to do things like this here since this fires once // the slider value change has completed so it is not constantly // triggering ui sound effects. PlayUISoundEffect(); }; Property Changes vs States Gum allows you to customize visuals in two ways: Direct property assignment Using states. With simple property changes, you can directly assign values in code. For example, the following code example changes the width of a button: startButton.Visual.Width = 100; Direct property assignment works well for initial setup, such as positioning elements or setting their dimensions when first creating your UI. However, when you need visual elements to respond to user interactions (like highlighting a button when it is focused), a different approach is required. For these dynamic changes, Gum uses a system of states (implemented as StateSave objects), each Forms control maintains a collection of named states that are automatically applied in response to specific user interactions. When a button becomes focused, for instance, Gum looks for and applies a state named \"Focused\" to alter its appearance. Note In the next chapter during the customization pass, we will create states to visually indicate when controls are focused, providing clear feedback to the player. Updating Our Game To Use Gum Now that we have covered the core UI concepts and how Gum will help implement them, we can integrate Gum into our game project. We will add the framework, initialize it, and prepare it for use in our scenes. For now we will use the default styling in Gum to quickly iterate and build the UI and do a customization styling pass in the next chapter. Adding the Gum NuGet Package Before we can use Gum in our project, we first need to add it using NuGet. NuGet is a package manager for .NET projects that allows you to add third-party libraries into your project, similar to how we created and added our own class library. To add the Gum NuGet package to our game project, follow the instructions below based on your development environment: Visual Studio Code Visual Studio 2022 dotnet CLI To add the Gum NuGet package in Visual Studio Code: In the Solution Explorer panel, right-click the DungeonSlime project. Choose Add NuGet Package from the context menu. Enter Gum.MonoGame in the Add NuGet Package search prompt and press Enter. When the search finishes, select the Gum.MonoGame package in the results When prompted for a version choose version 2025.8.3.3. To Add the Gum NuGet package in Visual Studio 2022: In the Solution Explorer panel, right-click the DungeonSlime project. Choose Manage Nuget Packages... from the context menu. In the NuGet Package Manager window, select the Browse tab if it is not already selected. In the search box, enter Gum.MonoGame. Select the \"Gum.MonoGame\" package from the search results. On the right, in the version dropdown, select version 2025.8.3.3 and click the \"Install\" button. To add the Gum NuGet package using the dotnet CLI: Open a Command Prompt or Terminal window in the same folder as the DungeonSlime.csproj project file. Enter the following command: dotnet add DungeonSlime.csproj package Gum.MonoGame --version 2025.8.3.3 Tip You can verify the package was successfully added by examining your DungeonSlime.csproj file, which should now contain a reference like: <PackageReference Include=\"Gum.MonoGame\" Version=\"2025.8.3.3\" /> Important This tutorial uses version 2025.8.3.3 of Gum, which is the latest version of Gum as of this writing. That exact version is specified to use in the section above when installing the NuGet package to ensure compatibility throughout this tutorial. If there are newer versions of Gum available, please consult the Gum documentation before updating in case there are any breaking changes from the code that is presented in this tutorial. Adding UI Sound Effect To make our UI more responsive and engaging, we will add audio feedback that plays when players interact with buttons and other UI elements. Sound effects provide immediate confirmation that an input has been recognized, creating a more engaging experience. First, download the UI sound effect by right-clicking the following link and saving it as ui.wav in the game project's Content/audio folder: ui.wav{download} Next, add this sound effect to your content project using the MGCB Editor: Open the Content.mgcb content project file in the MGCB Editor. Right-click the audio folder and choose Add > Existing Item.... Navigate to and select the ui.wav file you just downloaded. In the Properties panel, verify that the Processor is set to Sound Effect. Save the changes and close the MGCB Editor. Figure 20-1: The MGCB Editor with ui.wav added to the audio folder We will load and use this sound effect in our UI implementation to provide auditory feedback when players interact with buttons and sliders. Initializing Gum With the Gum NuGet package added to our project, we need to initialize Gum in our game, this will enable the UI system and configure input handling for our controls. Since this is an initialization that only needs to happen once, we can make the necessary changes to the Game1 class. First, open the Game1.cs file and add the following new using statements to the top: using DungeonSlime.Scenes; using Gum.Forms; using Gum.Forms.Controls; using MonoGameLibrary; using MonoGameGum; using Microsoft.Xna.Framework.Media; Next, add the following method to the Game1 class to encapsulate the initializations of the Gum UI service: private void InitializeGum() { // Initialize the Gum service. The second parameter specifies // the version of the default visuals to use. V2 is the latest // version. GumService.Default.Initialize(this, DefaultVisualsVersion.V2); // Tell the Gum service which content manager to use. We will tell it to // use the global content manager from our Core. GumService.Default.ContentLoader.XnaContentManager = Core.Content; // Register keyboard input for UI control. FrameworkElement.KeyboardsForUiControl.Add(GumService.Default.Keyboard); // Register gamepad input for Ui control. FrameworkElement.GamePadsForUiControl.AddRange(GumService.Default.Gamepads); // Customize the tab reverse UI navigation to also trigger when the keyboard // Up arrow key is pushed. FrameworkElement.TabReverseKeyCombos.Add( new KeyCombo() { PushedKey = Microsoft.Xna.Framework.Input.Keys.Up }); // Customize the tab UI navigation to also trigger when the keyboard // Down arrow key is pushed. FrameworkElement.TabKeyCombos.Add( new KeyCombo() { PushedKey = Microsoft.Xna.Framework.Input.Keys.Down }); // The assets created for the UI were done so at 1/4th the size to keep the size of the // texture atlas small. So we will set the default canvas size to be 1/4th the size of // the game's resolution then tell gum to zoom in by a factor of 4. GumService.Default.CanvasWidth = GraphicsDevice.PresentationParameters.BackBufferWidth / 4.0f; GumService.Default.CanvasHeight = GraphicsDevice.PresentationParameters.BackBufferHeight / 4.0f; GumService.Default.Renderer.Camera.Zoom = 4.0f; } Finally, update the Initialize method to call the InitializeGum method we just created: protected override void Initialize() { base.Initialize(); // Start playing the background music Audio.PlaySong(_themeSong); // Initialize the Gum UI service InitializeGum(); // Start the game with the title scene. ChangeScene(new TitleScene()); } The following is a breakdown of this initialization process: Basic Initialization: GumService.Default.Initialize(this, DefaultVisualsVersion.V2) sets up the Gum system with our game instance. This is required for any gum project. The second parameter specifies the default visual styling. V2 is the latest version which makes it easy to style the default controls. Note We only need to pass our Game instance and the visuals version since we are using Gum as a code-first approach. Gum also offers a visual editor that creates Gum project files. When using the editor, you will need to also pass the Gum Project file to Initialize. For more information on how to use the Gum visual editor, see the Gum Project Forms Tutorial. Content Loading: Gum needs to be made aware of which content manager to use to load assets through the content pipeline. By setting GumService.Default.ContentLoader.XnaContentManager = Core.Content, we tell Gum to use our game's content manager when loading assets. By using the game's existing content manager, Gum also gets the benefit of the caching that the content manager performs when loading assets. Input Configuration: By default, all Forms controls automatically respond to mouse and touch screen input devices. We need to explicitly register keyboard and gamepad input devices by using th FrameworkElement.KeyboardsForUiControl and Framework.GamePadsForUiControl properties. By default, Forms controls will automatically respond to tab and shift-tab for navigation. By using the FrameworkElement.TabKeyCombos and FrameworkElement.TabReverseKeyCombos properties, we can add additional key combinations for tabbing. Here we map the Up arrow for reverse tabbing and the Down arrow for forward tabbing. Tip If you prefer different navigation keys, you can remove the built-in Tab/Shift+Tab navigation. Simply call these methods before adding your custom combinations: FrameworkElement.TabKeyCombos.Clear(); FrameworkElement.TabReverseKeyCombos.Clear(); UI Scaling: Gum allows us to independently scale the UI regardless of the resolution of the game. Our game is set to a resolution of 1280x720, however as we will see during the styling section later, the UI assets created were done at one-fourth the size to reduce the size of the texture atlas. Here, we use the GumService.Default.CanvasWidth and GumService.Default.CanvasHeight properties to set the canvas size to one-fourth that of our game's resolution. Then using by setting the GumService.Default.Renderer.Camera.Zoom property to four, we effectively make it render the UI at full resolution. Gum is now fully initialized and we can use it in our scenes to add UI to our game. Adding TitleScene UI With Gum added and initialized in our game, we can now implement UI elements for our title scene. We will create panels for both the main menu and options menu, implement the necessary event handlers, and integrate everything with our existing title scene. Note When adding these sections one by one, you may see compiler errors until all sections are in place. This is normal, as some parts of the code will reference fields or methods that haven't been added yet. Once all sections are complete, these errors will resolve. First, open the TitleScene.cs file in the game project and add the following using declarations to the top of the TitleScene class: using System; using Microsoft.Xna.Framework; using Microsoft.Xna.Framework.Audio; using Microsoft.Xna.Framework.Graphics; using Microsoft.Xna.Framework.Input; using MonoGameGum; using Gum.Forms.Controls; using MonoGameGum.GueDeriving; using MonoGameLibrary; using MonoGameLibrary.Scenes; Next, add the following fields to the TitleScene class: private SoundEffect _uiSoundEffect; private Panel _titleScreenButtonsPanel; private Panel _optionsPanel; private Button _optionsButton; private Button _optionsBackButton; Creating the Title Panel First, create a new method that builds our main menu panel with start and options buttons. Add the following method to the TitleScene class: private void CreateTitlePanel() { // Create a container to hold all of our buttons _titleScreenButtonsPanel = new Panel(); _titleScreenButtonsPanel.Dock(Gum.Wireframe.Dock.Fill); _titleScreenButtonsPanel.AddToRoot(); var startButton = new Button(); startButton.Anchor(Gum.Wireframe.Anchor.BottomLeft); startButton.Visual.X = 50; startButton.Visual.Y = -12; startButton.Visual.Width = 70; startButton.Text = \"Start\"; startButton.Click += HandleStartClicked; _titleScreenButtonsPanel.AddChild(startButton); _optionsButton = new Button(); _optionsButton.Anchor(Gum.Wireframe.Anchor.BottomRight); _optionsButton.Visual.X = -50; _optionsButton.Visual.Y = -12; _optionsButton.Visual.Width = 70; _optionsButton.Text = \"Options\"; _optionsButton.Click += HandleOptionsClicked; _titleScreenButtonsPanel.AddChild(_optionsButton); startButton.IsFocused = true; } Our title panel includes two buttons positioned at the bottom corners of the screen. The \"Start\" button will allow players to begin the game while the \"Options\" button will hide the main menu and display the options menu. Note Notice how we use Anchor to position the buttons relative to the panel's edges, with the \"Start\" button anchored at the bottom left and the \"Options\" button anchored at the bottom right. Then the positioning of the elements is adjusted relative to its anchor point. Each button registers a Click event handler to respond when the players selects it, we should implement the event handler method for these buttons next. First we will implement the handler for the \"Start\" button. Add the following method to the TitleScene class after the CreateTitlePanel method: private void HandleStartClicked(object sender, EventArgs e) { // A UI interaction occurred, play the sound effect Core.Audio.PlaySoundEffect(_uiSoundEffect); // Change to the game scene to start the game. Core.ChangeScene(new GameScene()); } When the \"Start\" button is clicked and this method is called, it will play the UI sound effect for auditory feedback then change the scene to the game scene so the player can start playing the game. Next is the handler for the \"Options\" button. Add the following method to the TitleScene class after the HandleStartClicked method: private void HandleOptionsClicked(object sender, EventArgs e) { // A UI interaction occurred, play the sound effect Core.Audio.PlaySoundEffect(_uiSoundEffect); // Set the title panel to be invisible. _titleScreenButtonsPanel.IsVisible = false; // Set the options panel to be visible. _optionsPanel.IsVisible = true; // Give the back button on the options panel focus. _optionsBackButton.IsFocused = true; } When the \"Options\" button is clicked and this method is called, it will play the UI sound effect for auditory feedback then hide the title panel and show the options panel. Creating the Options Panel Next, we will create the options panel with sliders to adjust the volume for music and sound effects. Add the following method to the TitleScene class: private void CreateOptionsPanel() { _optionsPanel = new Panel(); _optionsPanel.Dock(Gum.Wireframe.Dock.Fill); _optionsPanel.IsVisible = false; _optionsPanel.AddToRoot(); var optionsText = new TextRuntime(); optionsText.X = 10; optionsText.Y = 10; optionsText.Text = \"OPTIONS\"; _optionsPanel.AddChild(optionsText); var musicSlider = new Slider(); musicSlider.Anchor(Gum.Wireframe.Anchor.Top); musicSlider.Visual.Y = 30f; musicSlider.Minimum = 0; musicSlider.Maximum = 1; musicSlider.Value = Core.Audio.SongVolume; musicSlider.SmallChange = .1; musicSlider.LargeChange = .2; musicSlider.ValueChanged += HandleMusicSliderValueChanged; musicSlider.ValueChangeCompleted += HandleMusicSliderValueChangeCompleted; _optionsPanel.AddChild(musicSlider); var sfxSlider = new Slider(); sfxSlider.Anchor(Gum.Wireframe.Anchor.Top); sfxSlider.Visual.Y = 93; sfxSlider.Minimum = 0; sfxSlider.Maximum = 1; sfxSlider.Value = Core.Audio.SoundEffectVolume; sfxSlider.SmallChange = .1; sfxSlider.LargeChange = .2; sfxSlider.ValueChanged += HandleSfxSliderChanged; sfxSlider.ValueChangeCompleted += HandleSfxSliderChangeCompleted; _optionsPanel.AddChild(sfxSlider); _optionsBackButton = new Button(); _optionsBackButton.Text = \"BACK\"; _optionsBackButton.Anchor(Gum.Wireframe.Anchor.BottomRight); _optionsBackButton.X = -28f; _optionsBackButton.Y = -10f; _optionsBackButton.Click += HandleOptionsButtonBack; _optionsPanel.AddChild(_optionsBackButton); } This panel includes a text label, two sliders for adjusting audio volumes, and a back button for returning to the main menu. The panel is initially invisible since we start on the main menu. Both the \"Music Volume\" slider and the \"Sound Effects Volume\" slider register events to be called when the value of the sliders change and when the value change has been completed. The \"Back\" button registers a click event similar to the ones from the main menu. Now we should implement the event handlers for these controls. First, we will implement the handler for when the value of the sound effect volume slider changes. Add the following method to the TitleScene class after the CreateOptionsPanel method: private void HandleSfxSliderChanged(object sender, EventArgs args) { // Intentionally not playing the UI sound effect here so that it is not // constantly triggered as the user adjusts the slider's thumb on the // track. // Get a reference to the sender as a Slider. var slider = (Slider)sender; // Set the global sound effect volume to the value of the slider.; Core.Audio.SoundEffectVolume = (float)slider.Value; } When the value of the \"Sound Effects Volume\" slider changes and this method is called, a reference to the slider is captured and then the the global sound effect volume is adjusted based on the value of the slider. Next is the handler when the \"Sound Effects Volume\" slider has completed a value change. Add the following method to the TitleScene class after the HandleSfxSliderChanged method: private void HandleSfxSliderChangeCompleted(object sender, EventArgs e) { // Play the UI Sound effect so the player can hear the difference in audio. Core.Audio.PlaySoundEffect(_uiSoundEffect); } When the value of the \"Sound Effects Volume\" slider has completed a change and this method is called, it plays the UI sound effect to provide auditory feedback so the player can hear the difference in volume. Next, add the handler for changes to the 'Music Volume' slider. Place the following method in the TitleScene class, directly after the HandleSfxSliderChangeCompleted method: private void HandleMusicSliderValueChanged(object sender, EventArgs args) { // Intentionally not playing the UI sound effect here so that it is not // constantly triggered as the user adjusts the slider's thumb on the // track. // Get a reference to the sender as a Slider. var slider = (Slider)sender; // Set the global song volume to the value of the slider. Core.Audio.SongVolume = (float)slider.Value; } Similar to how we handled the \"Sound Effect Volume\" slider value changes, when the \"Music Volume\" slider value changes and this method is called, a reference to the slider is captured and then the global music volume is adjusted based on the value of the slider. Next is the handler when the \"Music Volume\" slider value has completed a value change. Add the following method to the TitleScene class after the HandleMusicSliderValueChanged method: private void HandleMusicSliderValueChangeCompleted(object sender, EventArgs args) { // A UI interaction occurred, play the sound effect Core.Audio.PlaySoundEffect(_uiSoundEffect); } When the value of the \"Music Volume\" slider has completed a change, the UI sound effect is played to provide auditory feedback. Finally, we need to add the handler for when the \"Back\" button is clicked on the options panel. Add the following method to the TitleScene class after the HandleMusicSliderValueChangeCompleted method: private void HandleOptionsButtonBack(object sender, EventArgs e) { // A UI interaction occurred, play the sound effect Core.Audio.PlaySoundEffect(_uiSoundEffect); // Set the title panel to be visible. _titleScreenButtonsPanel.IsVisible = true; // Set the options panel to be invisible. _optionsPanel.IsVisible = false; // Give the options button on the title panel focus since we are coming // back from the options screen. _optionsButton.IsFocused = true; } This method plays the UI sound effect for auditory feedback, then hides the options panel and shows the title panel. Tip Notice that for both sliders, we registered a method for the ValueChangeCompleted event. This is so we can play the UI sound effect only when the player has finished adjusting the slider value. If we had instead played the UI sound effect in the ValueChanged event, then the UI sound effect would trigger constantly while the slider is being adjusted if using a mouse to drag it. Initializing the UI Now that we have implemented the methods that will create both the main menu panel and the options menu panel, we need to implement the main UI initializations method that will call them. Add the following method to the TitleScene class after the HandleOptionsButtonBack method: private void InitializeUI() { // Clear out any previous UI in case we came here from // a different screen: GumService.Default.Root.Children.Clear(); CreateTitlePanel(); CreateOptionsPanel(); } This method first clears any existing UI elements from Gum's root container to prevent duplication, then calls our panel creation methods to build the complete interface. Integrating with the Game Loop Finally, we need to integrate our UI initialization, update, and draw with the scene's lifecycle. First, add the call to InitializeUI() in the Initialize method by updating it to the following: public override void Initialize() { // LoadContent is called during base.Initialize(). base.Initialize(); // While on the title screen, we can enable exit on escape so the player // can close the game by pressing the escape key. Core.ExitOnEscape = true; // Set the position and origin for the Dungeon text. Vector2 size = _font5x.MeasureString(DUNGEON_TEXT); _dungeonTextPos = new Vector2(640, 100); _dungeonTextOrigin = size * 0.5f; // Set the position and origin for the Slime text. size = _font5x.MeasureString(SLIME_TEXT); _slimeTextPos = new Vector2(757, 207); _slimeTextOrigin = size * 0.5f; // Initialize the offset of the background pattern at zero _backgroundOffset = Vector2.Zero; // Set the background pattern destination rectangle to fill the entire // screen background _backgroundDestination = Core.GraphicsDevice.PresentationParameters.Bounds; InitializeUI(); } Next, update the LoadContent method to load the sound effect that will be used as auditory feedback for the UI: public override void LoadContent() { // Load the font for the standard text. _font = Core.Content.Load<SpriteFont>(\"fonts/04B_30\"); // Load the font for the title text _font5x = Content.Load<SpriteFont>(\"fonts/04B_30_5x\"); // Load the background pattern texture. _backgroundPattern = Content.Load<Texture2D>(\"images/background-pattern\"); // Load the sound effect to play when ui actions occur. _uiSoundEffect = Core.Content.Load<SoundEffect>(\"audio/ui\"); } Next modify the Update method to include Gum's update logic: public override void Update(GameTime gameTime) { // Update the offsets for the background pattern wrapping so that it // scrolls down and to the right. float offset = _scrollSpeed * (float)gameTime.ElapsedGameTime.TotalSeconds; _backgroundOffset.X -= offset; _backgroundOffset.Y -= offset; // Ensure that the offsets do not go beyond the texture bounds so it is // a seamless wrap _backgroundOffset.X %= _backgroundPattern.Width; _backgroundOffset.Y %= _backgroundPattern.Height; GumService.Default.Update(gameTime); } Finally, the Draw method needs to be updated to: Only show the text for the game title when the title panel is visible Add Gum's drawing call to draw the user interface Update the Draw method to the following: public override void Draw(GameTime gameTime) { Core.GraphicsDevice.Clear(new Color(32, 40, 78, 255)); // Draw the background pattern first using the PointWrap sampler state. Core.SpriteBatch.Begin(samplerState: SamplerState.PointWrap); Core.SpriteBatch.Draw(_backgroundPattern, _backgroundDestination, new Rectangle(_backgroundOffset.ToPoint(), _backgroundDestination.Size), Color.White * 0.5f); Core.SpriteBatch.End(); if (_titleScreenButtonsPanel.IsVisible) { // Begin the sprite batch to prepare for rendering. Core.SpriteBatch.Begin(samplerState: SamplerState.PointClamp); // The color to use for the drop shadow text. Color dropShadowColor = Color.Black * 0.5f; // Draw the Dungeon text slightly offset from it is original position and // with a transparent color to give it a drop shadow Core.SpriteBatch.DrawString(_font5x, DUNGEON_TEXT, _dungeonTextPos + new Vector2(10, 10), dropShadowColor, 0.0f, _dungeonTextOrigin, 1.0f, SpriteEffects.None, 1.0f); // Draw the Dungeon text on top of that at its original position Core.SpriteBatch.DrawString(_font5x, DUNGEON_TEXT, _dungeonTextPos, Color.White, 0.0f, _dungeonTextOrigin, 1.0f, SpriteEffects.None, 1.0f); // Draw the Slime text slightly offset from it is original position and // with a transparent color to give it a drop shadow Core.SpriteBatch.DrawString(_font5x, SLIME_TEXT, _slimeTextPos + new Vector2(10, 10), dropShadowColor, 0.0f, _slimeTextOrigin, 1.0f, SpriteEffects.None, 1.0f); // Draw the Slime text on top of that at its original position Core.SpriteBatch.DrawString(_font5x, SLIME_TEXT, _slimeTextPos, Color.White, 0.0f, _slimeTextOrigin, 1.0f, SpriteEffects.None, 1.0f); // Always end the sprite batch when finished. Core.SpriteBatch.End(); } GumService.Default.Draw(); } With these changes, our UI system is now fully integrated into the scene's game loop. Gum updates its controls in the Update method and draws them in the Draw method. This produces a fully functional title screen with buttons that allows players to start the game or adjust audio settings. Figure 20-2: Title screen with default Gum buttons Note You may notice that the UI elements currently use Gum's default styling, which does not match our game's visual theme. We will explore customizing these controls to match our game's visual style in the next chapter. Adding GameScene UI Now that we have setup the UI for the title scene, we will add a pause menu to our game scene. This UI will start invisible but will be shown when the player presses the escape key. For consistency, we will implement the UI for the game scene in the same order that we implemented the UI for the title scene. Note When adding these sections one by one, you may see compiler errors until all sections are in place. This is normal, as some parts of the code will reference fields or methods that haven't been added yet. Once all sections are complete, these errors will resolve. First, open the GameScene.cs file in the game project and add the following using declarations to the top of the GameScene class. using System; using Gum.DataTypes; using Gum.Wireframe; using Microsoft.Xna.Framework; using Microsoft.Xna.Framework.Audio; using Microsoft.Xna.Framework.Graphics; using Microsoft.Xna.Framework.Input; using MonoGameGum; using Gum.Forms.Controls; using MonoGameGum.GueDeriving; using MonoGameLibrary; using MonoGameLibrary.Graphics; using MonoGameLibrary.Input; using MonoGameLibrary.Scenes; Next, add the following fields to the GameScene class: // A reference to the pause panel UI element so we can set its visibility // when the game is paused. private Panel _pausePanel; // A reference to the resume button UI element so we can focus it // when the game is paused. private Button _resumeButton; // The UI sound effect to play when a UI event is triggered. private SoundEffect _uiSoundEffect; Pausing the Game To pause the game, first we will create a method that makes the pause panel visible. Add the following method to the GameScene class after the CheckGamePadInput method: private void PauseGame() { // Make the pause panel UI element visible. _pausePanel.IsVisible = true; // Set the resume button to have focus _resumeButton.IsFocused = true; } Next, update the CheckKeyboardInput method so that when the escape key is pressed, instead of returning to the title scene, we now pause the game: private void CheckKeyboardInput() { // Get a reference to the keyboard info KeyboardInfo keyboard = Core.Input.Keyboard; // If the escape key is pressed, pause the game. if (Core.Input.Keyboard.WasKeyJustPressed(Keys.Escape)) { PauseGame(); } // Existing keyboard input code // ... Finally, update the CheckGamePadInput method so that when the start button is pressed, it pauses the game: private void CheckGamePadInput() { // Get the gamepad info for gamepad one. GamePadInfo gamePadOne = Core.Input.GamePads[(int)PlayerIndex.One]; // If the start button is pressed, pause the game if (gamePadOne.WasButtonJustPressed(Buttons.Start)) { PauseGame(); } // Existing gamepad input code // ... Creating the Pause Panel Next, we will create a method that builds our pause panel with resume and quit buttons. Add the following method to the GameScene class after the LoadContent method: private void CreatePausePanel() { _pausePanel = new Panel(); _pausePanel.Anchor(Anchor.Center); _pausePanel.Visual.WidthUnits = DimensionUnitType.Absolute; _pausePanel.Visual.HeightUnits = DimensionUnitType.Absolute; _pausePanel.Visual.Height = 70; _pausePanel.Visual.Width = 264; _pausePanel.IsVisible = false; _pausePanel.AddToRoot(); var background = new ColoredRectangleRuntime(); background.Dock(Dock.Fill); background.Color = Color.DarkBlue; _pausePanel.AddChild(background); var textInstance = new TextRuntime(); textInstance.Text = \"PAUSED\"; textInstance.X = 10f; textInstance.Y = 10f; _pausePanel.AddChild(textInstance); _resumeButton = new Button(); _resumeButton.Text = \"RESUME\"; _resumeButton.Anchor(Anchor.BottomLeft); _resumeButton.Visual.X = 9f; _resumeButton.Visual.Y = -9f; _resumeButton.Visual.Width = 80; _resumeButton.Click += HandleResumeButtonClicked; _pausePanel.AddChild(_resumeButton); var quitButton = new Button(); quitButton.Text = \"QUIT\"; quitButton.Anchor(Anchor.BottomRight); quitButton.Visual.X = -9f; quitButton.Visual.Y = -9f; quitButton.Width = 80; quitButton.Click += HandleQuitButtonClicked; _pausePanel.AddChild(quitButton); } Now we should implement the event handlers for these controls. First, we will implement the handler for the \"Resume\" button. Add the following method to the GameScene class after the CreatePausePanel method: private void HandleResumeButtonClicked(object sender, EventArgs e) { // A UI interaction occurred, play the sound effect Core.Audio.PlaySoundEffect(_uiSoundEffect); // Make the pause panel invisible to resume the game. _pausePanel.IsVisible = false; } This method plays the UI sound effect for auditory feedback and then hides the pause panel so that the game can resume. Next is the handler for the \"Quit\" button. Add the following method to the GameScene class after the HandleResumeButtonClicked method: private void HandleQuitButtonClicked(object sender, EventArgs e) { // A UI interaction occurred, play the sound effect Core.Audio.PlaySoundEffect(_uiSoundEffect); // Go back to the title scene. Core.ChangeScene(new TitleScene()); } This method as well plays the UI sound effect for auditory feedback, then quits the game by changing scenes back to the title scene. Initializing the Game UI Now that we have implemented the method to create the pause panel, we can implement the main UI initializations method that will call them. Add the following method to the GameScene class after the HandleQuitButtonClicked method: private void InitializeUI() { GumService.Default.Root.Children.Clear(); CreatePausePanel(); } Just like with the TitleScene, we first clear any existing UI elements from Gum's root before creating the UI elements for this scene. Integrating with the Game Loop for the GameScreen Finally, we need to integrate our UI initialization, update, and draw with the scene's lifecycle. First add the call to InitializeUI() in the Initialize method by updating it to the following: public override void Initialize() { // LoadContent is called during base.Initialize(). base.Initialize(); // During the game scene, we want to disable exit on escape. Instead, // the escape key will be used to return back to the title screen Core.ExitOnEscape = false; Rectangle screenBounds = Core.GraphicsDevice.PresentationParameters.Bounds; _roomBounds = new Rectangle( (int)_tilemap.TileWidth, (int)_tilemap.TileHeight, screenBounds.Width - (int)_tilemap.TileWidth * 2, screenBounds.Height - (int)_tilemap.TileHeight * 2 ); // Initial slime position will be the center tile of the tile map. int centerRow = _tilemap.Rows / 2; int centerColumn = _tilemap.Columns / 2; _slimePosition = new Vector2(centerColumn * _tilemap.TileWidth, centerRow * _tilemap.TileHeight); // Initial bat position will the in the top left corner of the room _batPosition = new Vector2(_roomBounds.Left, _roomBounds.Top); // Set the position of the score text to align to the left edge of the // room bounds, and to vertically be at the center of the first tile. _scoreTextPosition = new Vector2(_roomBounds.Left, _tilemap.TileHeight * 0.5f); // Set the origin of the text so it is left-centered. float scoreTextYOrigin = _font.MeasureString(\"Score\").Y * 0.5f; _scoreTextOrigin = new Vector2(0, scoreTextYOrigin); // Assign the initial random velocity to the bat. AssignRandomBatVelocity(); InitializeUI(); } Next, update the LoadContent method to load the sound effect that will be used as auditory feedback for the UI: public override void LoadContent() { // Create the texture atlas from the XML configuration file TextureAtlas atlas = TextureAtlas.FromFile(Core.Content, \"images/atlas-definition.xml\"); // Create the slime animated sprite from the atlas. _slime = atlas.CreateAnimatedSprite(\"slime-animation\"); _slime.Scale = new Vector2(4.0f, 4.0f); // Create the bat animated sprite from the atlas. _bat = atlas.CreateAnimatedSprite(\"bat-animation\"); _bat.Scale = new Vector2(4.0f, 4.0f); // Create the tilemap from the XML configuration file. _tilemap = Tilemap.FromFile(Content, \"images/tilemap-definition.xml\"); _tilemap.Scale = new Vector2(4.0f, 4.0f); // Load the bounce sound effect _bounceSoundEffect = Content.Load<SoundEffect>(\"audio/bounce\"); // Load the collect sound effect _collectSoundEffect = Content.Load<SoundEffect>(\"audio/collect\"); // Load the font _font = Core.Content.Load<SpriteFont>(\"fonts/04B_30\"); // Load the sound effect to play when ui actions occur. _uiSoundEffect = Core.Content.Load<SoundEffect>(\"audio/ui\"); } Next, modify the Update method to include Gum's update logic and to only update the game if it is not paused. We will use the visibility of the pause menu to determine if the game is paused or not: public override void Update(GameTime gameTime) { // Ensure the UI is always updated GumService.Default.Update(gameTime); // If the game is paused, do not continue if (_pausePanel.IsVisible) { return; } // Existing game update code // ... Finally, add Gum's drawing call to the end fo the Draw method: public override void Draw(GameTime gameTime) { // Existing game draw code // ... // Always end the sprite batch when finished Core.SpriteBatch.End(); // Draw the Gum UI GumService.Default.Draw(); } With these changes, the pause menu is now fully integrated into the game scene's game loop. Gum updates its controls during the Update method and draws them during the Draw method. If the game is paused, as determined by the IsVisible property of the pause menu, then updating the actual game logic is skipped. Figure 20-3: The pause menu during the game scene with default Gum buttons Conclusion In this chapter, you accomplished the following: Add and configure the Gum NuGet package in your project. Understand key Gum concepts like Forms controls and Visuals. Create and position UI elements using anchoring and docking. Implement interactive controls like buttons and sliders. Handle user input from various input devices. Create transitions between different UI screens. Integrate the UI system with the game's scene architecture. While this UI is now functional, you may have noticed that it uses Gum's default styling which does not match our game's visual theme. In the next chapter, we will learn how to customize the appearance of our UI elements to create a cohesive visual style that complements our game's aesthetic. Test Your Knowledge What are the two main types of objects in Gum, and how do they differ? :::question-answer The two main types are: Forms: Interactive UI elements like buttons, sliders, and panels that handle user input. They provide built-in functionality for common UI interactions. Visuals: Display elements like TextRuntime, ColoredRectangleRuntime, and NineSliceRuntime that are used to render graphics. They have no built-in interaction behavior but can be customized visually. Forms controls contain Visuals, accessible through the Visual property, creating a separation between functionality and presentation. ::: How does Gum handle the parent-child relationship of UI elements, and why is this important? :::question-answer Gum implements parent-child relationships through a hierarchical structure where: UI elements must be connected to the root container to be visible Children can be added directly to a parent's Visual.Children collection Position coordinates of child elements are relative to their parent Property changes like visibility cascade from parent to children This relationship is important because it allows for organizing related UI elements as groups, controlling entire sections of UI with a single property change, and positioning elements relative to their container rather than absolute screen coordinates. ::: What are the two ways to customize the appearance of Gum UI elements? :::question-answer The two ways to customize Gum UI elements are: Direct property assignment: Setting properties directly in code (like MyButton.Visual.Width = 100). This works well for initial setup and static properties. States: Using Gum's state system (StateSave objects) to define different visual states that can be applied in response to specific conditions or events. States are automatically applied by Forms controls in response to user interactions (like focus or highlighting). States are useful for dynamic changes that occur during gameplay, as they separate visual response logic from game logic. ::: What steps are necessary to integrate Gum's UI system with MonoGame's game loop? :::question-answer To integrate Gum with MonoGame's game loop: Initialize Gum in the game's Initialize method with GumService.Default.Initialize(this) Configure content loading by setting GumService.Default.ContentLoader.XnaContentManager Set up input handling by adding keyboards and gamepads to FrameworkElement.KeyboardsForUiControl and FrameworkElement.GamePadsForUiControl Call GumService.Default.Update() in the game's Update method Call GumService.Default.Draw() in the game's Draw method For scene transitions, clear existing UI elements with GumService.Default.Root.Children.Clear() This ensures Gum can update and render UI elements in sync with the game's main loop. :::"
  },
  "templates/docs.monogame.github.io/articles/tutorials/building_2d_games/21_customizing_gum_ui/index.html": {
    "href": "templates/docs.monogame.github.io/articles/tutorials/building_2d_games/21_customizing_gum_ui/index.html",
    "title": "Chapter 21: Customizing Gum UI | hallowed",
    "summary": "In the previous chapter, we implemented a functional UI system for our game using the Gum framework. While the UI is now fully operational, it uses Gum's default styling. This default styling is good for quickly iterating when building the UI, but it does not match the game's visuals. A well designed UI should not only be functional but also complement the game's overall visual style to create a cohesive experience. In this chapter you will: Learn about Gum's visual customization system and component hierarchy. Understand how animation chains and visual states work in Gum. Create custom styled button and slider components. Update the game's texture atlas to include UI graphics. Implement responsive visual feedback for player interactions. Apply your custom components to the game's UI screens. Understanding Gum's Customization System Gum provides a powerful customization system that separates a UI element's functionality from its appearance. This allows you to maintain the built-in behavior of standard controls while completely changing their visual representation. Container Hierarchy Every customized UI component in Gum starts with a top-level container that holds all other visual elements. This container is typically of type ContainerRuntime, which is similar to the Panel type we used earlier, but specifically designed for building custom visuals. The container hierarchy follows a parent-child relationship: The top-level container manages the overall size and positioning of the component. Visual elements like backgrounds, text, and icons are added as children. Child elements can be positioned relative to their parent container. Child elements can also be nested within other children, creating deeper hierarchies. This hierarchical structure allows you to build complex UI components from simpler parts, with each part playing a specific role in the overall design. Size Relationships with Width and WidthUnits One powerful feature of Gum is how it handles size relationships between parent and child elements. By using different WidthUnits values, you can create dependencies that flow in different directions: RelativeToChildren: A parent container can size itself based on its children. PercentageOfParent: A child element can size itself as a percentage of its parent. Absolute: An element can have a fixed pixel size. RelativeToParent: An element can size itself relative to a specific container. For example: A button might use a text element with WidthUnits set to RelativeToChildren, which means the text will be exactly the size needed to display its content. The button's container might use RelativeToChildren with some additional padding, allowing the button to automatically resize based on its text content. Although we have not explicitly assigned WidthUnits and HeightUnits in our code, we have indirectly set these values by calling the Visual's Dock method. Specifically, by passing Dock.Fill as the parameter, WidthUnits and HeightUnits are both set to RelativeToParent. Note These size relationships can create circular dependencies when a child depends on its parent and the parent depends on the child. In such cases, Gum resolves the conflict by making the child depend on the parent, and the parent ignores that particular child when calculating its size. Visual Elements Gum provides several visual element types that we can use to build our custom components: ContainerRuntime: An invisible container for organizing other elements. NineSliceRuntime: A special graphic that can stretch while preserving its corners and edges. TextRuntime: An element for displaying text with custom fonts. ColoredRectangleRuntime: A simple colored rectangle for backgrounds or fills. The NineSliceRuntime is particularly useful for UI elements that need to resize dynamically. It divides a graphic into nine sections (four corners, four edges, and a center), allowing the element to stretch without distorting its borders. Note A MonoGame and Gum community member Kaltinril also has a video series discussing Gum. With permission, the following video segment is included to demonstrate the advantages of using a Nineslice when creating UI elements. Animation Chains An AnimationChain is a sequence of animation frames that play in order, typically looping after the last frame. Each frame in the chain defines: Which part of a texture to display (using texture coordinates). How long to display that frame (using a frame length value). Which texture to use for the frame. Texture coordinates in Gum use normalized values (0.0 to 1.0) rather than pixel coordinates, where: 0.0 represents the left or top edge of the texture. 1.0 represents the right or bottom edge of the texture. To convert from pixel coordinates to normalized values, you divide the pixel position by the texture's width or height. Visual States Rather than directly modifying properties when UI elements change state (like when a button is focused), Gum uses a state-based system. Each control type has a specific category name that identifies its collection of states: Buttons use Button.ButtonCategoryName. Sliders use Slider.SliderCategoryName. Other control types have their own category names. Within each category, you define named states that correspond to the control's possible conditions: \"Enabled\" (the normal, unfocused state). \"Focused\" (when the control has focus). \"Highlighted\" (when the mouse hovers over the control). \"Disabled\" (when the control cannot be interacted with). Each state contains an Apply action that defines what visual changes occur when that state becomes active. For example, when a button becomes focused, its state might change the background color or switch to an animated version. Input and Focus Handling Custom UI components can enhance their interactivity by handling specific input events: The KeyDown event can be used to add custom keyboard navigation. The RollOn event can detect when the mouse moves over the component. The Click event can respond to mouse clicks or gamepad button presses. Gum distinguishes between highlighting (visual response to mouse hover) and focus (ability to receive keyboard/gamepad input). For a seamless experience across input devices, a common pattern is to automatically focus elements when the mouse hovers over them, ensuring that visual highlighting and input focus remain synchronized. Now that we understand the key concepts behind Gum's customization system, we can apply them to create custom UI components for our game. Updating the Game Resources Before we create our custom components, we need to update the game's resources to include UI graphics and fonts. Update the Texture Atlas First need to update the atlas.png texture atlas file for the game. This new version of the texture atlas includes: The characters for the font, generated using Bitmap Font Generator (BMFont) The sprites for the UI components we will create Download the new texture atlas below by right-clicking the following image and saving it as atlas.png in the Content/images folder of the game project, overwriting the existing one. Figure 21-1: The texture atlas for the game updated to include the UI sprites The slime and bat sprites are no longer in the same position, and we have some new regions to define for our UI sprites. This means we need to update the texture atlas XML configuration file as well. Open the atlas-definition.xml configuration file and update it to the following: <?xml version=\"1.0\" encoding=\"utf-8\"?> <TextureAtlas> <Texture>images/atlas</Texture> <Regions> <Region name=\"slime-1\" x=\"340\" y=\"0\" width=\"20\" height=\"20\" /> <Region name=\"slime-2\" x=\"340\" y=\"20\" width=\"20\" height=\"20\" /> <Region name=\"bat-1\" x=\"340\" y=\"40\" width=\"20\" height=\"20\" /> <Region name=\"bat-2\" x=\"340\" y=\"60\" width=\"20\" height=\"20\" /> <Region name=\"bat-3\" x=\"360\" y=\"0\" width=\"20\" height=\"20\" /> <Region name=\"unfocused-button\" x=\"259\" y=\"80\" width=\"65\" height=\"14\" /> <Region name=\"focused-button-1\" x=\"259\" y=\"94\" width=\"65\" height=\"14\" /> <Region name=\"focused-button-2\" x=\"259\" y=\"109\" width=\"65\" height=\"14\" /> <Region name=\"panel-background\" x=\"324\" y=\"97\" width=\"15\" height=\"15\" /> <Region name=\"slider-off-background\" x=\"341\" y=\"96\" width=\"11\" height=\"10\" /> <Region name=\"slider-middle-background\" x=\"345\" y=\"81\" width=\"3\" height=\"3\" /> <Region name=\"slider-max-background\" x=\"354\" y=\"96\" width=\"11\" height=\"10\" /> </Regions> <Animations> <Animation name=\"slime-animation\" delay=\"200\"> <Frame region=\"slime-1\" /> <Frame region=\"slime-2\" /> </Animation> <Animation name=\"bat-animation\" delay=\"200\"> <Frame region=\"bat-1\" /> <Frame region=\"bat-2\" /> <Frame region=\"bat-1\" /> <Frame region=\"bat-3\" /> </Animation> <Animation name=\"focused-button-animation\" delay=\"300\"> <Frame region=\"focused-button-1\" /> <Frame region=\"focused-button-2\" /> </Animation> </Animations> </TextureAtlas> The same is now true for the tiles in the texture atlas. Since they have been repositioned in the new texture atlas, we need to update the region attribute for the tilemap XML configuration file. Open the tilemap-definition.xml configuration file and update it to the following: <?xml version=\"1.0\" encoding=\"utf-8\"?> <Tilemap> <Tileset region=\"260 0 80 80\" tileWidth=\"20\" tileHeight=\"20\">images/atlas</Tileset> <Tiles> 00 01 02 01 02 01 02 01 02 01 02 01 02 01 02 03 04 05 05 06 05 05 06 05 05 06 05 05 06 05 05 07 08 09 09 09 09 09 09 09 09 09 09 09 09 09 09 11 04 09 09 09 09 09 09 09 10 09 09 09 09 10 09 07 08 09 10 09 09 09 09 09 09 09 09 09 09 09 09 11 04 09 09 09 09 09 09 09 09 09 09 09 09 09 09 07 08 10 09 09 09 09 09 09 09 09 10 09 09 09 09 11 04 09 09 09 09 09 10 09 09 09 09 09 09 09 09 07 12 13 14 13 14 13 14 13 14 13 14 13 14 13 14 15 </Tiles> </Tilemap> Adding Bitmap Fonts While MonoGame natively uses SpriteFont to draw text, Gum uses the AngelCode Bitmap Font (.fnt) font file format. This means we will need to supply Gum with the .fnt file that defines our font. Note For this tutorial, a pregenerated .fnt file is supplied below. For more information on creating .fnt files for Gum, see the Create Fonts with BitmapFontGenerator section of the Gum documentation. Download the .fnt file below by right-clicking the following link and saving it as 04b_30.fnt in the game project's Content/fonts folder: 04b_30.fnt{download} Next, add this font file to your content project using the MGCB Editor: Open the Content.mgcb content project file in the MGCB Editor. Right-click the fonts folder and choose Add > Existing Item.... Navigate to and select the 04b_30.fnt file you just downloaded. In the Properties panel, change the Build Action to Copy. The MonoGame Content Pipeline cannot process .fnt files; we just need it to copy it so we can give it to Gum. Save the changes and close the MGCB Editor. Figure 21-2: The MGCB Editor with the 04b_30.fnt added to the fonts folder and the Build property set to Copy Note When the .fnt font file was generated using the AngelCode Bitmap Font Generator, the graphics from the .png file that it produces was copied over into our existing texture atlas. By doing this, it allows Gum to render the visuals for elements and the text from the same atlas, reducing texture swapping. The font file references our existing texture atlas using a relative path that points to the atlas image. The best practice when using this method is to ensure that when you copy the graphics from the generated .png file to your texture atlas, you place the generated character glyph graphics in the top-left of your texture atlas. This means all of the coordinates in the .fnt file will correctly reference the character glyphs without additional manual changes. Updating the TextureRegion Class In Chapter 18 we discussed texture coordinates and that graphic devices use a normalized coordinate system between 0.0 and 1.0. Since Gum also uses this coordinate system, we will update the TextureRegion class to easily provide these values for any given region. Open the TextureRegion.cs file in the MonoGameLibrary project and add the following properties to the TextureRegion class: /// <summary> /// Gets the top normalized texture coordinate of this region. /// </summary> public float TopTextureCoordinate => SourceRectangle.Top / (float)Texture.Height; /// <summary> /// Gets the bottom normalized texture coordinate of this region. /// </summary> public float BottomTextureCoordinate => SourceRectangle.Bottom / (float)Texture.Height; /// <summary> /// Gets the left normalized texture coordinate of this region. /// </summary> public float LeftTextureCoordinate => SourceRectangle.Left / (float)Texture.Width; /// <summary> /// Gets the right normalized texture coordinate of this region. /// </summary> public float RightTextureCoordinate => SourceRectangle.Right / (float)Texture.Width; Creating Custom UI Components Now that we have all our resources prepared, we can create custom versions of the UI controls we are using in our game. We will start with an animated button that uses our game's visual style, then move on to creating a custom slider. The AnimatedButton Class Our first custom component is an AnimatedButton that inherits from Gum's base Button class. This button uses the game's existing texture atlas for its visual appearance and animates when focused. By default all Gum components provide a Visual property which can be cast to a type specific to the particular control. By convention the visual type is named the same as the component with the word Visual appened. For example, we will be casting the AnimatedButton's Visual property to ButtonVisual to access button-specific properties. This new AnimatedButton class casts the Visual property to ButtonVisual and modifies the button-specific properties such as background and text. First, in the DungeonSlime project (your main game project), create a new folder named UI to store our custom UI components. Next, in that UI folder, create a new file called AnimatedButton.cs and add the following code to it: using System; using Gum.DataTypes; using Gum.DataTypes.Variables; using Gum.Forms.Controls; using Gum.Forms.DefaultVisuals; using Gum.Graphics.Animation; using Gum.Managers; using Microsoft.Xna.Framework.Input; using MonoGameGum.GueDeriving; using MonoGameLibrary.Graphics; namespace DungeonSlime.UI; /// <summary> /// A custom button implementation that inherits from Gum's Button class to provide /// animated visual feedback when focused. /// </summary> internal class AnimatedButton : Button { /// <summary> /// Creates a new AnimatedButton instance using graphics from the specified texture atlas. /// </summary> /// <param name=\"atlas\">The texture atlas containing button graphics and animations</param> public AnimatedButton(TextureAtlas atlas) { // Each Forms conrol has a general Visual property that // has properties shared by all control types. This Visual // type matches the Forms type. It can be casted to access // controls-specific properties. ButtonVisual buttonVisual = (ButtonVisual)Visual; // Width is relative to children with extra padding, height is fixed buttonVisual.Height = 14f; buttonVisual.HeightUnits = DimensionUnitType.Absolute; buttonVisual.Width = 21f; buttonVisual.WidthUnits = DimensionUnitType.RelativeToChildren; // Get a reference to the nine-slice background to display the button graphics // A nine-slice allows the button to stretch while preserving corner appearance NineSliceRuntime background = buttonVisual.Background; background.Texture = atlas.Texture; background.TextureAddress = TextureAddress.Custom; background.Color = Microsoft.Xna.Framework.Color.White; // texture coordinates for the background are set down below TextRuntime textInstance = buttonVisual.TextInstance; textInstance.Text = \"START\"; textInstance.Blue = 130; textInstance.Green = 86; textInstance.Red = 70; textInstance.UseCustomFont = true; textInstance.CustomFontFile = \"fonts/04b_30.fnt\"; textInstance.FontScale = 0.25f; textInstance.Anchor(Gum.Wireframe.Anchor.Center); textInstance.Width = 0; textInstance.WidthUnits = DimensionUnitType.RelativeToChildren; // Get the texture region for the unfocused button state from the atlas TextureRegion unfocusedTextureRegion = atlas.GetRegion(\"unfocused-button\"); // Create an animation chain for the unfocused state with a single frame AnimationChain unfocusedAnimation = new AnimationChain(); unfocusedAnimation.Name = nameof(unfocusedAnimation); AnimationFrame unfocusedFrame = new AnimationFrame { TopCoordinate = unfocusedTextureRegion.TopTextureCoordinate, BottomCoordinate = unfocusedTextureRegion.BottomTextureCoordinate, LeftCoordinate = unfocusedTextureRegion.LeftTextureCoordinate, RightCoordinate = unfocusedTextureRegion.RightTextureCoordinate, FrameLength = 0.3f, Texture = unfocusedTextureRegion.Texture }; unfocusedAnimation.Add(unfocusedFrame); // Get the multi-frame animation for the focused button state from the atlas Animation focusedAtlasAnimation = atlas.GetAnimation(\"focused-button-animation\"); // Create an animation chain for the focused state using all frames from the atlas animation AnimationChain focusedAnimation = new AnimationChain(); focusedAnimation.Name = nameof(focusedAnimation); foreach (TextureRegion region in focusedAtlasAnimation.Frames) { AnimationFrame frame = new AnimationFrame { TopCoordinate = region.TopTextureCoordinate, BottomCoordinate = region.BottomTextureCoordinate, LeftCoordinate = region.LeftTextureCoordinate, RightCoordinate = region.RightTextureCoordinate, FrameLength = (float)focusedAtlasAnimation.Delay.TotalSeconds, Texture = region.Texture }; focusedAnimation.Add(frame); } // Assign both animation chains to the nine-slice background background.AnimationChains = new AnimationChainList { unfocusedAnimation, focusedAnimation }; // Reset all state to default so we don't have unexpected variable assignments: buttonVisual.ButtonCategory.ResetAllStates(); // Get the enabled (default/unfocused) state StateSave enabledState = buttonVisual.States.Enabled; enabledState.Apply = () => { // When enabled but not focused, use the unfocused animation background.CurrentChainName = unfocusedAnimation.Name; }; // Create the focused state StateSave focusedState = buttonVisual.States.Focused; focusedState.Apply = () => { // When focused, use the focused animation and enable animation playback background.CurrentChainName = focusedAnimation.Name; background.Animate = true; }; // Create the highlighted+focused state (for mouse hover while focused) StateSave highlightedFocused = buttonVisual.States.HighlightedFocused; highlightedFocused.Apply = focusedState.Apply; // Create the highlighted state (for mouse hover) // by cloning the enabled state since they appear the same StateSave highlighted = buttonVisual.States.Highlighted; highlighted.Apply = enabledState.Apply; // Add event handlers for keyboard input. KeyDown += HandleKeyDown; // Add event handler for mouse hover focus. buttonVisual.RollOn += HandleRollOn; } /// <summary> /// Handles keyboard input for navigation between buttons using left/right keys. /// </summary> private void HandleKeyDown(object sender, KeyEventArgs e) { if (e.Key == Keys.Left) { // Left arrow navigates to previous control HandleTab(TabDirection.Up, loop: true); } if (e.Key == Keys.Right) { // Right arrow navigates to next control HandleTab(TabDirection.Down, loop: true); } } /// <summary> /// Automatically focuses the button when the mouse hovers over it. /// </summary> private void HandleRollOn(object sender, EventArgs e) { IsFocused = true; } } Next, we will examine the key aspects of this new AnimatedButton implementation: ButtonVisual As mentioned earlier, we first access the Visual object and cast it to a ButtonVisual. Doing so gives us access to button-specific properties including individual elements (such as the text and background visuals) as well as the states that are applied when the button is hovered or pressed. We can modify the Visual to give it the appropriate size. ButtonVisual buttonVisual = (ButtonVisual)Visual; // Width is relative to children with extra padding, height is fixed buttonVisual.Height = 14f; buttonVisual.HeightUnits = DimensionUnitType.Absolute; buttonVisual.Width = 21f; buttonVisual.WidthUnits = DimensionUnitType.RelativeToChildren; The WidthUnits property set to RelativeToChildren means the container automatically sizes itself based on its child elements, with 21 pixels of additional space. This allows the button to adapt its size depending on the text content. Nine-slice Background ButtonVisual provides a Background which we can modify. This is of type NineSliceRuntime which is a special graphic that can be stretch while preserving its corners and edges: NineSliceRuntime background = buttonVisual.Background; background.Texture = atlas.Texture; background.TextureAddress = TextureAddress.Custom; background.Color = Microsoft.Xna.Framework.Color.White; The TextureAddress property is set to Custom so we can specify exactly which portion of the atlas texture to use, while Dock(Dock.Fill) ensure the background fills the entire button area. The portion of the atlas is assigned using AnimationChains, which are discussed later in this tutorial. Text ButtonVisual also provides a customizable Text property. In this case we assign the font, color, and size. TextRuntime textInstance = buttonVisual.TextInstance; textInstance.Text = \"START\"; textInstance.Blue = 130; textInstance.Green = 86; textInstance.Red = 70; textInstance.UseCustomFont = true; textInstance.CustomFontFile = \"fonts/04b_30.fnt\"; textInstance.FontScale = 0.25f; textInstance.Anchor(Gum.Wireframe.Anchor.Center); textInstance.Width = 0; textInstance.WidthUnits = DimensionUnitType.RelativeToChildren; Animated Chains The most distinctive feature of our animated button is its ability to change appearance when focused. We achieve this by creating two animation chains: An \"unfocused\" animation with a single static frame. A \"focused\" animation with two alternating frames that create a visual effect. Each animation frame specifies the coordinates within our texture atlas to display: TextureRegion unfocusedTextureRegion = atlas.GetRegion(\"unfocused-button\"); // Create an animation chain for the unfocused state with a single frame AnimationChain unfocusedAnimation = new AnimationChain(); unfocusedAnimation.Name = nameof(unfocusedAnimation); AnimationFrame unfocusedFrame = new AnimationFrame { TopCoordinate = unfocusedTextureRegion.TopTextureCoordinate, BottomCoordinate = unfocusedTextureRegion.BottomTextureCoordinate, LeftCoordinate = unfocusedTextureRegion.LeftTextureCoordinate, RightCoordinate = unfocusedTextureRegion.RightTextureCoordinate, FrameLength = 0.3f, Texture = unfocusedTextureRegion.Texture }; unfocusedAnimation.Add(unfocusedFrame); // Get the multi-frame animation for the focused button state from the atlas Animation focusedAtlasAnimation = atlas.GetAnimation(\"focused-button-animation\"); // Create an animation chain for the focused state using all frames from the atlas animation AnimationChain focusedAnimation = new AnimationChain(); focusedAnimation.Name = nameof(focusedAnimation); foreach (TextureRegion region in focusedAtlasAnimation.Frames) { AnimationFrame frame = new AnimationFrame { TopCoordinate = region.TopTextureCoordinate, BottomCoordinate = region.BottomTextureCoordinate, LeftCoordinate = region.LeftTextureCoordinate, RightCoordinate = region.RightTextureCoordinate, FrameLength = (float)focusedAtlasAnimation.Delay.TotalSeconds, Texture = region.Texture }; focusedAnimation.Add(frame); } States and Categories In Gum, each control type has a specific category name that identifies its state collection. ButtonVisual provides access to ready-made states and catgories which we can modify. Before we speicfy how a state should modify the button's appearance, we clear out all existing functionality so that we can fully control the states: buttonVisual.ButtonCategory.ResetAllStates(); Each of the button's states can be accessed through ButtonVisual. Since the states were cleared previously, the code assigns only the necessary property assignments in the Apply delegate. In our case, we switch between animation chains to create the desired visual effect. StateSave enabledState = buttonVisual.States.Enabled; enabledState.Apply = () => { // When enabled but not focused, use the unfocused animation background.CurrentChainName = unfocusedAnimation.Name; }; // Create the focused state StateSave focusedState = buttonVisual.States.Focused; focusedState.Apply = () => { // When focused, use the focused animation and enable animation playback background.CurrentChainName = focusedAnimation.Name; background.Animate = true; }; // Create the highlighted+focused state (for mouse hover while focused) StateSave highlightedFocused = buttonVisual.States.HighlightedFocused; highlightedFocused.Apply = focusedState.Apply; // Create the highlighted state (for mouse hover) // by cloning the enabled state since they appear the same StateSave highlighted = buttonVisual.States.Highlighted; highlighted.Apply = enabledState.Apply; Custom Input Handling We add custom keyboard navigation to our button by handling the KeyDown event: KeyDown += HandleKeyDown; private void HandleKeyDown(object sender, KeyEventArgs e) { if (e.Key == Keys.Left) { // Left arrow navigates to previous control HandleTab(TabDirection.Up, loop: true); } if (e.Key == Keys.Right) { // Right arrow navigates to next control HandleTab(TabDirection.Down, loop: true); } } This allows players to navigate between buttons using the left and right arrow keys, providing additional control options beyond the default tab navigation. Focus Management We also add a RollOn event handler to ensure the button gets focus when the mouse hovers over it: buttonVisual.RollOn += HandleRollOn; private void HandleRollOn(object sender, EventArgs e) { IsFocused = true; } This creates a more responsive interface by immediately focusing elements that the player interacts with using the mouse. The OptionsSlider Class Now we will create a custom OptionsSlider class to style the volume sliders. This class inherits from Gum's base Slider class and provides a styled appearance consistent with the game's visual theme. Unlike AnimatedButton, the OptionsSlider creates a Visual completely from scratch. This class provides an example for how to completely customize a Forms control by recreating its Visual object entirely. We do this because the desired appearance and behavior of our OptionsSlider is differs enough from the existing Slider that it is easier to replace its Visual entirely. In the UI folder of the DungeonSlime project (your main game project), create a new file called OptionsSlider.cs and add the following code to it: using System; using Gum.DataTypes; using Gum.DataTypes.Variables; using Gum.Managers; using Microsoft.Xna.Framework; using Gum.Forms.Controls; using MonoGameGum.GueDeriving; using MonoGameLibrary.Graphics; namespace DungeonSlime.UI; /// <summary> /// A custom slider control that inherits from Gum's Slider class. /// </summary> public class OptionsSlider : Slider { // Reference to the text label that displays the slider's title private TextRuntime _textInstance; // Reference to the rectangle that visually represents the current value private ColoredRectangleRuntime _fillRectangle; /// <summary> /// Gets or sets the text label for this slider. /// </summary> public string Text { get => _textInstance.Text; set => _textInstance.Text = value; } /// <summary> /// Creates a new OptionsSlider instance using graphics from the specified texture atlas. /// </summary> /// <param name=\"atlas\">The texture atlas containing slider graphics.</param> public OptionsSlider(TextureAtlas atlas) { // Create the top-level container for all visual elements ContainerRuntime topLevelContainer = new ContainerRuntime(); topLevelContainer.Height = 55f; topLevelContainer.Width = 264f; TextureRegion backgroundRegion = atlas.GetRegion(\"panel-background\"); // Create the background panel that contains everything NineSliceRuntime background = new NineSliceRuntime(); background.Texture = atlas.Texture; background.TextureAddress = TextureAddress.Custom; background.TextureHeight = backgroundRegion.Height; background.TextureLeft = backgroundRegion.SourceRectangle.Left; background.TextureTop = backgroundRegion.SourceRectangle.Top; background.TextureWidth = backgroundRegion.Width; background.Dock(Gum.Wireframe.Dock.Fill); topLevelContainer.AddChild(background); // Create the title text element _textInstance = new TextRuntime(); _textInstance.CustomFontFile = @\"fonts/04b_30.fnt\"; _textInstance.UseCustomFont = true; _textInstance.FontScale = 0.5f; _textInstance.Text = \"Replace Me\"; _textInstance.X = 10f; _textInstance.Y = 10f; _textInstance.WidthUnits = DimensionUnitType.RelativeToChildren; topLevelContainer.AddChild(_textInstance); // Create the container for the slider track and decorative elements ContainerRuntime innerContainer = new ContainerRuntime(); innerContainer.Height = 13f; innerContainer.Width = 241f; innerContainer.X = 10f; innerContainer.Y = 33f; topLevelContainer.AddChild(innerContainer); TextureRegion offBackgroundRegion = atlas.GetRegion(\"slider-off-background\"); // Create the \"OFF\" side of the slider (left end) NineSliceRuntime offBackground = new NineSliceRuntime(); offBackground.Dock(Gum.Wireframe.Dock.Left); offBackground.Texture = atlas.Texture; offBackground.TextureAddress = TextureAddress.Custom; offBackground.TextureHeight = offBackgroundRegion.Height; offBackground.TextureLeft = offBackgroundRegion.SourceRectangle.Left; offBackground.TextureTop = offBackgroundRegion.SourceRectangle.Top; offBackground.TextureWidth = offBackgroundRegion.Width; offBackground.Width = 28f; offBackground.WidthUnits = DimensionUnitType.Absolute; offBackground.Dock(Gum.Wireframe.Dock.Left); innerContainer.AddChild(offBackground); TextureRegion middleBackgroundRegion = atlas.GetRegion(\"slider-middle-background\"); // Create the middle track portion of the slider NineSliceRuntime middleBackground = new NineSliceRuntime(); middleBackground.Dock(Gum.Wireframe.Dock.FillVertically); middleBackground.Texture = middleBackgroundRegion.Texture; middleBackground.TextureAddress = TextureAddress.Custom; middleBackground.TextureHeight = middleBackgroundRegion.Height; middleBackground.TextureLeft = middleBackgroundRegion.SourceRectangle.Left; middleBackground.TextureTop = middleBackgroundRegion.SourceRectangle.Top; middleBackground.TextureWidth = middleBackgroundRegion.Width; middleBackground.Width = 179f; middleBackground.WidthUnits = DimensionUnitType.Absolute; middleBackground.Dock(Gum.Wireframe.Dock.Left); middleBackground.X = 27f; innerContainer.AddChild(middleBackground); TextureRegion maxBackgroundRegion = atlas.GetRegion(\"slider-max-background\"); // Create the \"MAX\" side of the slider (right end) NineSliceRuntime maxBackground = new NineSliceRuntime(); maxBackground.Texture = maxBackgroundRegion.Texture; maxBackground.TextureAddress = TextureAddress.Custom; maxBackground.TextureHeight = maxBackgroundRegion.Height; maxBackground.TextureLeft = maxBackgroundRegion.SourceRectangle.Left; maxBackground.TextureTop = maxBackgroundRegion.SourceRectangle.Top; maxBackground.TextureWidth = maxBackgroundRegion.Width; maxBackground.Width = 36f; maxBackground.WidthUnits = DimensionUnitType.Absolute; maxBackground.Dock(Gum.Wireframe.Dock.Right); innerContainer.AddChild(maxBackground); // Create the interactive track that responds to clicks // The special name \"TrackInstance\" is required for Slider functionality ContainerRuntime trackInstance = new ContainerRuntime(); trackInstance.Name = \"TrackInstance\"; trackInstance.Dock(Gum.Wireframe.Dock.Fill); trackInstance.Height = -2f; trackInstance.Width = -2f; middleBackground.AddChild(trackInstance); // Create the fill rectangle that visually displays the current value _fillRectangle = new ColoredRectangleRuntime(); _fillRectangle.Dock(Gum.Wireframe.Dock.Left); _fillRectangle.Width = 90f; // Default to 90% - will be updated by value changes _fillRectangle.WidthUnits = DimensionUnitType.PercentageOfParent; trackInstance.AddChild(_fillRectangle); // Add \"OFF\" text to the left end TextRuntime offText = new TextRuntime(); offText.Red = 70; offText.Green = 86; offText.Blue = 130; offText.CustomFontFile = @\"fonts/04b_30.fnt\"; offText.FontScale = 0.25f; offText.UseCustomFont = true; offText.Text = \"OFF\"; offText.Anchor(Gum.Wireframe.Anchor.Center); offBackground.AddChild(offText); // Add \"MAX\" text to the right end TextRuntime maxText = new TextRuntime(); maxText.Red = 70; maxText.Green = 86; maxText.Blue = 130; maxText.CustomFontFile = @\"fonts/04b_30.fnt\"; maxText.FontScale = 0.25f; maxText.UseCustomFont = true; maxText.Text = \"MAX\"; maxText.Anchor(Gum.Wireframe.Anchor.Center); maxBackground.AddChild(maxText); // Define colors for focused and unfocused states Color focusedColor = Color.White; Color unfocusedColor = Color.Gray; // Create slider state category - Slider.SliderCategoryName is the required name StateSaveCategory sliderCategory = new StateSaveCategory(); sliderCategory.Name = Slider.SliderCategoryName; topLevelContainer.AddCategory(sliderCategory); // Create the enabled (default/unfocused) state StateSave enabled = new StateSave(); enabled.Name = FrameworkElement.EnabledStateName; enabled.Apply = () => { // When enabled but not focused, use gray coloring for all elements background.Color = unfocusedColor; _textInstance.Color = unfocusedColor; offBackground.Color = unfocusedColor; middleBackground.Color = unfocusedColor; maxBackground.Color = unfocusedColor; _fillRectangle.Color = unfocusedColor; }; sliderCategory.States.Add(enabled); // Create the focused state StateSave focused = new StateSave(); focused.Name = FrameworkElement.FocusedStateName; focused.Apply = () => { // When focused, use white coloring for all elements background.Color = focusedColor; _textInstance.Color = focusedColor; offBackground.Color = focusedColor; middleBackground.Color = focusedColor; maxBackground.Color = focusedColor; _fillRectangle.Color = focusedColor; }; sliderCategory.States.Add(focused); // Create the highlighted+focused state by cloning the focused state StateSave highlightedFocused = focused.Clone(); highlightedFocused.Name = FrameworkElement.HighlightedFocusedStateName; sliderCategory.States.Add(highlightedFocused); // Create the highlighted state by cloning the enabled state StateSave highlighted = enabled.Clone(); highlighted.Name = FrameworkElement.HighlightedStateName; sliderCategory.States.Add(highlighted); // Assign the configured container as this slider's visual Visual = topLevelContainer; // Enable click-to-point functionality for the slider // This allows users to click anywhere on the track to jump to that value IsMoveToPointEnabled = true; // Add event handlers Visual.RollOn += HandleRollOn; ValueChanged += HandleValueChanged; ValueChangedByUi += HandleValueChangedByUi; } /// <summary> /// Automatically focuses the slider when the user interacts with it /// </summary> private void HandleValueChangedByUi(object sender, EventArgs e) { IsFocused = true; } /// <summary> /// Automatically focuses the slider when the mouse hovers over it /// </summary> private void HandleRollOn(object sender, EventArgs e) { IsFocused = true; } /// <summary> /// Updates the fill rectangle width to visually represent the current value /// </summary> private void HandleValueChanged(object sender, EventArgs e) { // Calculate the ratio of the current value within its range double ratio = (Value - Minimum) / (Maximum - Minimum); // Update the fill rectangle width as a percentage // _fillRectangle uses percentage width units, so we multiply by 100 _fillRectangle.Width = 100 * (float)ratio; } } The OptionsSlider is more complex than then AnimatedButton because it contains more visual elements. Below are the key aspects of this implementation: Slider Components Walking through the OptionsSlider implementation, it consists of several components A background container with a label for the slider. An inner container that holds the slider track. \"OFF\" and \"MAX\" section at each end of the slider. A track where the thumb moves. A fill rectangle that shows the current value visually. Each of these elements is styled to match the game's visual theme using sprites from our atlas. Custom Text Property We add a custom Text property to set the slider's label: /// Gets or sets the text label for this slider. /// </summary> public string Text { get => _textInstance.Text; set => _textInstance.Text = value; } This allows us to easily customize the label for each slider instance we create. Visual Feedback The slider uses color changes to provide visual feedback: StateSave enabled = new StateSave(); enabled.Name = FrameworkElement.EnabledStateName; enabled.Apply = () => { // When enabled but not focused, use gray coloring for all elements background.Color = unfocusedColor; _textInstance.Color = unfocusedColor; offBackground.Color = unfocusedColor; middleBackground.Color = unfocusedColor; maxBackground.Color = unfocusedColor; _fillRectangle.Color = unfocusedColor; }; sliderCategory.States.Add(enabled); StateSave focused = new StateSave(); focused.Name = FrameworkElement.FocusedStateName; focused.Apply = () => { // When focused, use white coloring for all elements background.Color = focusedColor; _textInstance.Color = focusedColor; offBackground.Color = focusedColor; middleBackground.Color = focusedColor; maxBackground.Color = focusedColor; _fillRectangle.Color = focusedColor; }; sliderCategory.States.Add(focused); When the slider is focused, all its elements change from gray to white, making it clear to the player which UI element currently has focus. Fill Visualization One of the most important aspects of a slider is the visual representation of its value. We achieve this by updating the width of the _fillRectangle element: /// Updates the fill rectangle width to visually represent the current value /// </summary> private void HandleValueChanged(object sender, EventArgs e) { // Calculate the ratio of the current value within its range double ratio = (Value - Minimum) / (Maximum - Minimum); // Update the fill rectangle width as a percentage // _fillRectangle uses percentage width units, so we multiply by 100 _fillRectangle.Width = 100 * (float)ratio; } } This method converts the slider's current value to a percentage and applies it to the fill rectangle's width, creating a visual indicator of the current setting. Updating the Scenes to Use Custom Controls Now that we have created our custom controls, we need to update our game scenes to use them instead of the default Gum controls. Updating the TitleScene First, open the TitleScene.cs file in the game project and add the following using declaration to the top of the TitleScene class: using System; using DungeonSlime.UI; using Microsoft.Xna.Framework; using Microsoft.Xna.Framework.Audio; using Microsoft.Xna.Framework.Graphics; using Microsoft.Xna.Framework.Input; using MonoGameGum; using MonoGameGum.Forms.Controls; using MonoGameGum.GueDeriving; using MonoGameLibrary; using MonoGameLibrary.Graphics; using MonoGameLibrary.Scenes; Next, update both the _optionsButton and the _optionsBackButton fields to be of our new AnimatedButton type, and add a new field to store a reference to the texture atlas in. // Existing fields... // The options button used to open the options menu. private AnimatedButton _optionsButton; // The back button used to exit the options menu back to the title menu. private AnimatedButton _optionsBackButton; // Reference to the texture atlas that we can pass to UI elements when they // are created. private TextureAtlas _atlas; Next, in the LoadContent method, we need to update it so that it loads the texture atlas from the XML configuration file and stores it in the new _atlas field: public override void LoadContent() { // Load the font for the standard text. _font = Core.Content.Load<SpriteFont>(\"fonts/04B_30\"); // Load the font for the title text _font5x = Content.Load<SpriteFont>(\"fonts/04B_30_5x\"); // Load the background pattern texture. _backgroundPattern = Content.Load<Texture2D>(\"images/background-pattern\"); // Load the sound effect to play when ui actions occur. _uiSoundEffect = Core.Content.Load<SoundEffect>(\"audio/ui\"); // Load the texture atlas from the xml configuration file. _atlas = TextureAtlas.FromFile(Core.Content, \"images/atlas-definition.xml\"); } Next, update the CreateTitlePanel method so that instead of using the default Gum Button Forms controls it now uses our custom AnimatedButton control and remove the explicit setting of the Visual.Width property since this is managed by the AnimatedButton now: private void CreateTitlePanel() { // Create a container to hold all of our buttons _titleScreenButtonsPanel = new Panel(); _titleScreenButtonsPanel.Dock(Gum.Wireframe.Dock.Fill); _titleScreenButtonsPanel.AddToRoot(); AnimatedButton startButton = new AnimatedButton(_atlas); startButton.Anchor(Gum.Wireframe.Anchor.BottomLeft); startButton.Visual.X = 50; startButton.Visual.Y = -12; startButton.Text = \"Start\"; startButton.Click += HandleStartClicked; _titleScreenButtonsPanel.AddChild(startButton); _optionsButton = new AnimatedButton(_atlas); _optionsButton.Anchor(Gum.Wireframe.Anchor.BottomRight); _optionsButton.Visual.X = -50; _optionsButton.Visual.Y = -12; _optionsButton.Text = \"Options\"; _optionsButton.Click += HandleOptionsClicked; _titleScreenButtonsPanel.AddChild(_optionsButton); startButton.IsFocused = true; } Finally, update the CreateOptionsPanel method so that: It uses a TextRuntime to display the text \"OPTIONS\" using the bitmap font Instead of using the default Gum Button and Slider Forms controls, it now uses our custom AnimatedButton and OptionsSlider controls. Both the musicSlider and sfxSlider have been given Name and Text properties. private void CreateOptionsPanel() { _optionsPanel = new Panel(); _optionsPanel.Dock(Gum.Wireframe.Dock.Fill); _optionsPanel.IsVisible = false; _optionsPanel.AddToRoot(); TextRuntime optionsText = new TextRuntime(); optionsText.X = 10; optionsText.Y = 10; optionsText.Text = \"OPTIONS\"; optionsText.UseCustomFont = true; optionsText.FontScale = 0.5f; optionsText.CustomFontFile = @\"fonts/04b_30.fnt\"; _optionsPanel.AddChild(optionsText); OptionsSlider musicSlider = new OptionsSlider(_atlas); musicSlider.Name = \"MusicSlider\"; musicSlider.Text = \"MUSIC\"; musicSlider.Anchor(Gum.Wireframe.Anchor.Top); musicSlider.Visual.Y = 30f; musicSlider.Minimum = 0; musicSlider.Maximum = 1; musicSlider.Value = Core.Audio.SongVolume; musicSlider.SmallChange = .1; musicSlider.LargeChange = .2; musicSlider.ValueChanged += HandleMusicSliderValueChanged; musicSlider.ValueChangeCompleted += HandleMusicSliderValueChangeCompleted; _optionsPanel.AddChild(musicSlider); OptionsSlider sfxSlider = new OptionsSlider(_atlas); sfxSlider.Name = \"SfxSlider\"; sfxSlider.Text = \"SFX\"; sfxSlider.Anchor(Gum.Wireframe.Anchor.Top); sfxSlider.Visual.Y = 93; sfxSlider.Minimum = 0; sfxSlider.Maximum = 1; sfxSlider.Value = Core.Audio.SoundEffectVolume; sfxSlider.SmallChange = .1; sfxSlider.LargeChange = .2; sfxSlider.ValueChanged += HandleSfxSliderChanged; sfxSlider.ValueChangeCompleted += HandleSfxSliderChangeCompleted; _optionsPanel.AddChild(sfxSlider); _optionsBackButton = new AnimatedButton(_atlas); _optionsBackButton.Text = \"BACK\"; _optionsBackButton.Anchor(Gum.Wireframe.Anchor.BottomRight); _optionsBackButton.X = -28f; _optionsBackButton.Y = -10f; _optionsBackButton.Click += HandleOptionsButtonBack; _optionsPanel.AddChild(_optionsBackButton); } Updating the GameScene Next, open the GameScene.cs file in the game project and add the following using declaration to the top of the GameScene class: using System; using DungeonSlime.UI; using Gum.DataTypes; using Gum.Managers; using Gum.Wireframe; using Microsoft.Xna.Framework; using Microsoft.Xna.Framework.Audio; using Microsoft.Xna.Framework.Graphics; using Microsoft.Xna.Framework.Input; using MonoGameGum; using Gum.Forms.Controls; using MonoGameGum.GueDeriving; using MonoGameLibrary; using MonoGameLibrary.Graphics; using MonoGameLibrary.Input; using MonoGameLibrary.Scenes; Next, update the _resumeButton field to be of our new AnimatedButton type and add a field to store a reference to the texture atlas in. // Existing fields... // A reference to the resume button UI element so we can focus it // when the game is paused. private AnimatedButton _resumeButton; // The UI sound effect to play when a UI event is triggered. private SoundEffect _uiSoundEffect; // Reference to the texture atlas that we can pass to UI elements when they // are created. private TextureAtlas _atlas; Next, in the LoadContent method, we need to update it so that it stores the texture atlas once loaded in the new _atlas field. public override void LoadContent() { // Create the texture atlas from the XML configuration file _atlas = TextureAtlas.FromFile(Core.Content, \"images/atlas-definition.xml\"); // Create the slime animated sprite from the atlas. _slime = _atlas.CreateAnimatedSprite(\"slime-animation\"); _slime.Scale = new Vector2(4.0f, 4.0f); // Create the bat animated sprite from the atlas. _bat = _atlas.CreateAnimatedSprite(\"bat-animation\"); _bat.Scale = new Vector2(4.0f, 4.0f); // Create the tilemap from the XML configuration file. _tilemap = Tilemap.FromFile(Content, \"images/tilemap-definition.xml\"); _tilemap.Scale = new Vector2(4.0f, 4.0f); // Load the bounce sound effect _bounceSoundEffect = Content.Load<SoundEffect>(\"audio/bounce\"); // Load the collect sound effect _collectSoundEffect = Content.Load<SoundEffect>(\"audio/collect\"); // Load the font _font = Core.Content.Load<SpriteFont>(\"fonts/04B_30\"); // Load the sound effect to play when ui actions occur. _uiSoundEffect = Core.Content.Load<SoundEffect>(\"audio/ui\"); } Finally, update the CreatePausePanel method so that Instead of using a ColoredRectangleRuntime for the background of the pause panel, it now uses a NineSliceRuntime that uses the sprite from the texture atlas. The textInstance is updated so that it uses the custom bitmap font file. The _resumeButton and quiteButton are updated to use our custom AnimatedButton control instead of the default Gum Button Forms control. private void CreatePausePanel() { _pausePanel = new Panel(); _pausePanel.Anchor(Anchor.Center); _pausePanel.Visual.WidthUnits = DimensionUnitType.Absolute; _pausePanel.Visual.HeightUnits = DimensionUnitType.Absolute; _pausePanel.Visual.Height = 70; _pausePanel.Visual.Width = 264; _pausePanel.IsVisible = false; _pausePanel.AddToRoot(); TextureRegion backgroundRegion = _atlas.GetRegion(\"panel-background\"); NineSliceRuntime background = new NineSliceRuntime(); background.Dock(Dock.Fill); background.Texture = backgroundRegion.Texture; background.TextureAddress = TextureAddress.Custom; background.TextureHeight = backgroundRegion.Height; background.TextureLeft = backgroundRegion.SourceRectangle.Left; background.TextureTop = backgroundRegion.SourceRectangle.Top; background.TextureWidth = backgroundRegion.Width; _pausePanel.AddChild(background); TextRuntime textInstance = new TextRuntime(); textInstance.Text = \"PAUSED\"; textInstance.CustomFontFile = @\"fonts/04b_30.fnt\"; textInstance.UseCustomFont = true; textInstance.FontScale = 0.5f; textInstance.X = 10f; textInstance.Y = 10f; _pausePanel.AddChild(textInstance); _resumeButton = new AnimatedButton(_atlas); _resumeButton.Text = \"RESUME\"; _resumeButton.Anchor(Anchor.BottomLeft); _resumeButton.Visual.X = 9f; _resumeButton.Visual.Y = -9f; _resumeButton.Click += HandleResumeButtonClicked; _pausePanel.AddChild(_resumeButton); AnimatedButton quitButton = new AnimatedButton(_atlas); quitButton.Text = \"QUIT\"; quitButton.Anchor(Anchor.BottomRight); quitButton.Visual.X = -9f; quitButton.Visual.Y = -9f; quitButton.Click += HandleQuitButtonClicked; _pausePanel.AddChild(quitButton); } Testing the Styled UI When you run the game now, you will see a dramatic improvement in the visual appearance of the UI: The buttons now use our custom animated background that pulses when focused. The sliders have a cleaner, mores stylized appearance with the OFF and MAX labels. All text uses our custom bitmap font. Visual feedback clearly indicates which element has focus. Figure 21-3: The game using Gum now with custom styled UI components The entire UI now has a cohesive style that matches the rest of the game. Conclusion In this chapter, you learned how to transform basic UI components into custom, styled elements that match the game's visual theme. You explored several key aspects of UI customization: How container hierarchies and size relationships work in Gum. Creating animation chains for visual feedback. Using the state system to respond to user interactions. Building complex custom controls by extending base classes. Integrating custom fonts and graphics from a texture atlas. By creating reusable custom controls, you have not only improved the look of your game, but you have also developed components that can be used in future projects. This approach of separating functionality from appearance allows you to maintain consistent behavior while completely changing the visual style to match different games. The principles you have learned in this chapter extend beyond the specific components we created. You can apply the same techniques to create other custom UI elements like checkboxes, radio buttons, scroll panels, and more. By understanding how to build on Gum's foundation, you have the tools to create any UI component your game might need. Test Your Knowledge What are the two main approaches to customizing visuals in Gum, and when would you use each one? :::question-answer The two main approaches are: Direct property assignment: Setting properties directly in code (like button.Visual.Width = 100). This approach is best for initial setup of UI elements and static properties that do not change during gameplay. States (StateSave objects): Defining different visual states that are applied automatically in response to interactions. This approach is best for dynamic changes that happen during gameplay, like highlighting a button when it is focused or changing colors when a slider is adjusted. ::: What is the purpose of using a top-level container in a custom Gum control? :::question-answer A top-level container in a custom Gum control serves several purposes: It provides a single parent element that holds all visual components of the control. It establishes the coordinate system for positioning child elements. It can manage the overall size of the control (often using RelativeToChildren sizing). It serves as the attachment point for states and categories. It creates a clear separation between the control's visuals and its functionality. ::: How do animation chains work in Gum, and what are the key components needed to create one? :::question-answer Animation chains in Gum work by displaying a sequence of frames in order, typically looping after the last frame. The key components needed to create an animation chain are: An AnimationChain object to hold the sequence of frames Multiple AnimationFrame objects, each with: Texture coordinates (left, right, top, bottom) defining which part of the texture to display A frame length value determining how long to display the frame A reference to the texture where the frame appears A method to add the animation to a visual element (like assigning to a NineSliceRuntime's CurrentChainName) The animation system uses normalized texture coordinates (0.0 to 1.0) rather than pixel coordinates. ::: What is the relationship between Gum's state system and Forms controls, and why is it important? :::question-answer Gum's state system links with Forms controls through specifically named categories and states: Each Forms control type has a reserved category name (e.g., Button.ButtonCategoryName) Within that category, the control looks for states with specific names (Enabled, Focused, Highlighted, etc.) When the control's state changes (like gaining focus), it automatically applies the corresponding visual state This relationship is important because it: Separates the control's functionality from its appearance Enables consistent behavior while allowing complete visual customization Provides automatic visual feedback in response to user interactions without requiring manual state management Makes it easier to create controls that work with mouse, keyboard, and gamepad input. :::"
  },
  "templates/docs.monogame.github.io/articles/tutorials/building_2d_games/22_snake_game_mechanics/index.html": {
    "href": "templates/docs.monogame.github.io/articles/tutorials/building_2d_games/22_snake_game_mechanics/index.html",
    "title": "Chapter 22: Snake Game Mechanics | hallowed",
    "summary": "In the previous chapters, we have built all the fundamental systems needed for our game: graphics, input, collision detection, audio, scene management, and a user interface. Now it is time to transform our demo into a complete experience by implementing classic snake-like game mechanics. Before we do that, we first need to define what mechanics make a snake game. In this chapter, you will: Understand the core mechanics that define a classic snake-like game. Learn how to implement grid-based movement with timed intervals. Create a segmented character that grows when collecting objects. Implement a unified input controller for game actions. Build the SlimeSegment struct for storing segment data. Create the Slime class to manage all snake-like behavior for the slime. Create the Bat class as the collectable object. Note This chapter will not focus much on MonoGame itself, but rather our implementation of the mechanics to transform our current game into a snake-like game. Understanding Snake Game Mechanics In a classic snake-like game, the mechanics follow a set of simple but engaging rules: The player controls a snake by telling it to move in one of four cardinal directions (up, down, left, and right). The snake cannot reverse into itself, only moving forward or perpendicular to its current direction. The actual movement of the snake occurs at regular timed intervals, creating a grid-based movement pattern. When the snake eats food, it grows longer by adding a new segment to its tail. If the snake collides with a wall or its own body, the game ends. The mechanics create an increasingly challenging experience as the snake grows longer, requiring planning and reflexes to avoid collision. Directions In snake, players input a cardinal direction (up, down, left, and right), to indicate which direction the snake will move during the next movement cycle. When direction input occurs, it must be checked against the current direction to determine if the move is valid. For example, if the snake is moving to the right, an invalid input would allow a player to move it to the left. Doing so would cause the head of the snake to reverse direction and immediately collide with the first body segment. This means the only valid inputs are those where the next direction would be the same as the current direction or perpendicular to the current direction. Figure 22-1: An example snake with four segments, the head segment highlighted in orange, moving to the right. Arrows show that the only valid movements for the head segment are up or down (perpendicular) or to continue to the right. Movement Cycle Instead of moving every update frame while a directional input is being pressed, the snake moves only at fixed time intervals. A timer is used to determine how much time has passed since the last movement cycle, and when it reaches a set threshold, the next movement cycle occurs. During this movement cycle, the snake should move forward in the direction that was input by the player between the last and current movement cycles. This creates the grid-based movement system typically found in snake-like games. There are various methods for handling the movement, such as iterating through each segment of the snake and updating the position of that segment to move forward. Methods such as this though are wasteful, since visually the only parts of the snake that move on the screen are the head and the tail. Instead, a more common approach is to: Make a copy of the head segment. Figure 22-2 From a snake with four segments, a copy of the head segment is made, represented by the orange block Update the properties of the copy so that it is positioned where the original head segment would have moved to. Insert the copy at the front of the segment collection. Figure 22-3: The copy of the head segment, represented by the orange block, is inserted at the front of the segment collection as the new head, which now makes it five segments (one too many) Remove the tail segment. Figure 22-4: The tail segment of the snake is removed, bringing it back to the original four segments, giving the illusion that the entire snake moved forward By doing this, no matter how many segments the snake body has, we only ever need to update two of them, the head and the tail. Growth The next core mechanic for a snake-like game is the growth of the snake. Typically, somewhere in the game is an objective for the snake to eat, such as an apple. When the head of the snake reaches this objective, a new segment is added to the snake's body, making it longer, the player's score is increased, and a new objective is spawned at a random location within the game. This mechanic also acts as an artificial difficulty curve for the game. As the body of the snake grows longer, it requires planning to avoid creating situations where the snake becomes trapped by its own body making it impossible to avoid a collision. Game Over The challenge in a snake-like game is to avoid colliding with either a wall or another segment of the snake body. Doing so will cause a game over condition as the snake can no longer continue moving forward. Implementing Snake-Like Mechanics In Our Game Now that we have a foundational set of rules in place for the mechanics of a snake-like game, we will implement them into the current demo we have been building up. Our game will adapt these mechanics to fit them into our existing game structure: Instead of a snake, we will use the slime and create a chain of slime segments that follow the slime at the front. The player will control the direction of the slime segment The bat will serve as the objective to acquire to grow the slime segment. Collisions with either the walls of the room or a slime segment will result in a game over state. As we implement these mechanics, we are also going to be creating classes that encapsulate the properties and functions of existing implementations in the game scene, such as the slime and the bat. For example, currently, the game scene tracks fields for the AnimatedSprite and the position of the slime, as well as updating, input handling, and drawing the slime. These can be moved into their dedicated classes encapsulating the functionality and also cleaning up the code in the game scene that has grown quite large. The GameController Class Currently, we have two methods dedicated to handling input in the game scene, CheckKeyboardInput and CheckGamePadInput, both of these methods essentially perform the same logic across different input devices. This presents an opportunity to improve our code. To simplify input handling for the game, we can create a dedicated class that consolidates the input methods, providing a unified input profile for the game. This pattern is widely used in game development to separate the \"what\" (game actions) from the \"how\" (specific input devices and buttons). Create a new file named GameController.cs in the root of the DungeonSlime project (your main game project) and add the following code: using Microsoft.Xna.Framework; using Microsoft.Xna.Framework.Input; using MonoGameLibrary; using MonoGameLibrary.Input; namespace DungeonSlime; /// <summary> /// Provides a game-specific input abstraction that maps physical inputs /// to game actions, bridging our input system with game-specific functionality. /// </summary> public static class GameController { private static KeyboardInfo s_keyboard => Core.Input.Keyboard; private static GamePadInfo s_gamePad => Core.Input.GamePads[(int)PlayerIndex.One]; /// <summary> /// Returns true if the player has triggered the \"move up\" action. /// </summary> public static bool MoveUp() { return s_keyboard.WasKeyJustPressed(Keys.Up) || s_keyboard.WasKeyJustPressed(Keys.W) || s_gamePad.WasButtonJustPressed(Buttons.DPadUp) || s_gamePad.WasButtonJustPressed(Buttons.LeftThumbstickUp); } /// <summary> /// Returns true if the player has triggered the \"move down\" action. /// </summary> public static bool MoveDown() { return s_keyboard.WasKeyJustPressed(Keys.Down) || s_keyboard.WasKeyJustPressed(Keys.S) || s_gamePad.WasButtonJustPressed(Buttons.DPadDown) || s_gamePad.WasButtonJustPressed(Buttons.LeftThumbstickDown); } /// <summary> /// Returns true if the player has triggered the \"move left\" action. /// </summary> public static bool MoveLeft() { return s_keyboard.WasKeyJustPressed(Keys.Left) || s_keyboard.WasKeyJustPressed(Keys.A) || s_gamePad.WasButtonJustPressed(Buttons.DPadLeft) || s_gamePad.WasButtonJustPressed(Buttons.LeftThumbstickLeft); } /// <summary> /// Returns true if the player has triggered the \"move right\" action. /// </summary> public static bool MoveRight() { return s_keyboard.WasKeyJustPressed(Keys.Right) || s_keyboard.WasKeyJustPressed(Keys.D) || s_gamePad.WasButtonJustPressed(Buttons.DPadRight) || s_gamePad.WasButtonJustPressed(Buttons.LeftThumbstickRight); } /// <summary> /// Returns true if the player has triggered the \"pause\" action. /// </summary> public static bool Pause() { return s_keyboard.WasKeyJustPressed(Keys.Escape) || s_gamePad.WasButtonJustPressed(Buttons.Start); } /// <summary> /// Returns true if the player has triggered the \"action\" button, /// typically used for menu confirmation. /// </summary> public static bool Action() { return s_keyboard.WasKeyJustPressed(Keys.Enter) || s_gamePad.WasButtonJustPressed(Buttons.A); } } The GameController class implements an important design pattern in game development known as \"Input Abstraction\" or the \"Command\" pattern. This pattern separates what happens in the game (the actions) from how players trigger those actions (the inputs). This separation provides several benefits, including: Input Device Independence: The game logic does not need to know which input device the player is using. Whether they are playing with a keyboard, gamepad, or touch screen, the game only cares that a \"move up\" action was triggered, not which specific button or key caused it. Simplified Input Handling: Instead of checking multiple input combinations throughout the codebase, game objects can simply ask \"Should I move up?\" through a clean API call. Easy Rebinding: If you want to add key rebinding features, you only need to modify the GameController class, not every piece of code that uses input. Consistent Input Logic: The rules for determining if an action occurred (like checking if a button was just pressed versus being held down) are defined in one place. Cross-Platform Compatibility: When porting to different platforms with different input methods, you only need to update the GameController class to map the new input devices to your existing game actions. By implementing this pattern in our game, we are not only making our current input handling cleaner, but we are also establishing a foundation that would make it easier to add features like input customization or support for new input devices in the future. With our input handling system in place, now we can turn our attention to implementing the core mechanics of our snake-like game. First, we need to create a structure that will represent each segment of the slime's body. The SlimeSegment Struct We will need to implement a structure that can represent each segment of the slime, this structure will store the position and movement data for each segment. In the DungeonSlime project (your main game project), create a new folder named GameObjects. We will be putting all of our code related to the objects within the game here. Then create a new file named SlimeSegment.cs inside the GameObjects folder you just created and add the following code: using Microsoft.Xna.Framework; namespace DungeonSlime.GameObjects; public struct SlimeSegment { /// <summary> /// The position this slime segment is at before the movement cycle occurs. /// </summary> public Vector2 At; /// <summary> /// The position this slime segment should move to during the next movement cycle. /// </summary> public Vector2 To; /// <summary> /// The direction this slime segment is moving. /// </summary> public Vector2 Direction; /// <summary> /// The opposite direction this slime segment is moving. /// </summary> public Vector2 ReverseDirection => new Vector2(-Direction.X, -Direction.Y); } This structure contains fields to track: At: The current position of the segment. To: The position the segment will move to during the next movement cycle if it is the head segment. Direction: A normalized vector representing the direction the segment is moving in. ReverseDirection: A computed property that returns the opposite of the Direction property. Note We are implementing this as a struct rather than a class because SlimeSegment is a small, simple data container with value semantics. Structs are more efficient for small data structures since they are allocated on the stack rather than the heap, reducing garbage collection overhead. Since our game will potentially create many segments as the snake grows, using a struct can provide better performance, especially when we will be copying segment data during movement operations. Important Structs work best with value types (like int, float, Vector2); using reference types in structs can cause boxing operations that negate the performance benefits. For more information on structs, refer to the Structure Types - C# Reference documentation on Microsoft Learn. By tracking both the current (At) and target (To) positions, we can implement smooth visual movement between grid positions, creating more fluid animations than the traditional stutter step movement seen in classic snake games. We will explore this concept a little further in this chapter. The Slime Class Next, we can implement a class to encapsulate the properties and functionality of our snake-like slime. In the GameObjects folder of the DungeonSlime project (your main game project), create a new file named Slime.cs and add the following initial code: using System; using System.Collections.Generic; using Microsoft.Xna.Framework; using MonoGameLibrary; using MonoGameLibrary.Graphics; namespace DungeonSlime.GameObjects; public class Slime { } This code sets up the basic structure for our Slime class. We have added the necessary using statements to access MonoGame's framework components and placed the class in the DungeonSlime.GameObjects namespace to keep our code organized. The empty class will serve as our foundation, and we will build it up piece by piece in the following sections. Each section below should be added to the Slime class in the order presented. As we go through each part, the class will gradually take shape to handle all the snake-like behavior we need. Note When adding these sections one by one, you may see compiler errors until all sections are in place. This is normal, as some parts of the code will reference fields or methods that have not been added yet. Once all sections are complete, these errors will resolve. Slime Fields Add the following fields to the Slime class: // A constant value that represents the amount of time to wait between // movement updates. private static readonly TimeSpan s_movementTime = TimeSpan.FromMilliseconds(200); // The amount of time that has elapsed since the last movement update. private TimeSpan _movementTimer; // Normalized value (0-1) representing progress between movement ticks for visual interpolation private float _movementProgress; // The next direction to apply to the head of the slime chain during the // next movement update. private Vector2 _nextDirection; // The number of pixels to move the head segment during the movement cycle. private float _stride; // Tracks the segments of the slime chain. private List<SlimeSegment> _segments; // The AnimatedSprite used when drawing each slime segment private AnimatedSprite _sprite; Each of these fields is responsible for: s_movementTime: This constant represents how long the slime waits between movement cycles (300ms). This creates the classic snake game's grid-based movement feel, where the snake moves at regular intervals rather than continuously. _movementTime: This field accumulates elapsed time until it reaches the movement threshold. When it does, the slime moves one grid cell and the timer resets. _movementProgress: This normalized value (0-1) represents progress between movement ticks and is used for visual interpolation. It allows us to smoothly animate the slime's movement between grid positions. _nextDirection: This stores the direction that will be applied to the head segment during the next movement cycle. _stride: This represents the total number of pixels the head segment should move during movement cycles. _segments: This collection holds all the SlimeSegment structures that make up the slime's body. The first segment is the head, and the rest form the trailing body. _sprite: This stores the AnimatedSprite that is used to draw each segment of the slime. These fields implement core snake-like mechanics - the timed interval movement, direction control, and the segmented body that forms the snake. Slime Events Next, add the following event to the Slime class after the fields: /// <summary> /// Event that is raised if it is detected that the head segment of the slime /// has collided with a body segment. /// </summary> public event EventHandler BodyCollision; This event will allow the Slime class to notify the game scene when the head of the slime collides with another segment, triggering a game over. Slime Constructor After the event, add the following constructor to the Slime class: /// <summary> /// Creates a new Slime using the specified animated sprite. /// </summary> /// <param name=\"sprite\">The AnimatedSprite to use when drawing the slime.</param> public Slime(AnimatedSprite sprite) { _sprite = sprite; } This is a simple constructor that requires the slime to be given the AnimatedSprite that will be used to draw each of the slime segments. Slime Initialization Add the following Initialization method to the Slime class after the constructor: /// <summary> /// Initializes the slime, can be used to reset it back to an initial state. /// </summary> /// <param name=\"startingPosition\">The position the slime should start at.</param> /// <param name=\"stride\">The total number of pixels to move the head segment during each movement cycle.</param> public void Initialize(Vector2 startingPosition, float stride) { // Initialize the segment collection. _segments = new List<SlimeSegment>(); // Set the stride _stride = stride; // Create the initial head of the slime chain. SlimeSegment head = new SlimeSegment(); head.At = startingPosition; head.To = startingPosition + new Vector2(_stride, 0); head.Direction = Vector2.UnitX; // Add it to the segment collection. _segments.Add(head); // Set the initial next direction as the same direction the head is // moving. _nextDirection = head.Direction; // Zero out the movement timer. _movementTimer = TimeSpan.Zero; } With this method, we can initialize, or reset the state of slime. It: Instantiates a new segment collection. Creates the initial head segment and positions it at the specific startingPosition. Sets the initial direction to be to the right. Initialize the movement timer to zero. Slime Input Handling Next, add the HandleInput method to process player input after the Initialize method: private void HandleInput() { Vector2 potentialNextDirection = _nextDirection; if (GameController.MoveUp()) { potentialNextDirection = -Vector2.UnitY; } else if (GameController.MoveDown()) { potentialNextDirection = Vector2.UnitY; } else if (GameController.MoveLeft()) { potentialNextDirection = -Vector2.UnitX; } else if (GameController.MoveRight()) { potentialNextDirection = Vector2.UnitX; } // Only allow direction change if it is not reversing the current // direction. This prevents the slime from backing into itself. float dot = Vector2.Dot(potentialNextDirection, _segments[0].Direction); if (dot >= 0) { _nextDirection = potentialNextDirection; } } This method implements the following: Determine if the player is attempting to change directions instead of directly moving the slime. This direction change will be applied later during the movement cycle update. Uses Vector2.Dot to prevent the slime from reversing into itself, causing an immediate collision and game over state. Updates the _nextDirection value only if the direction input is valid. Note The dot product measures how much two vectors point in the same direction. It is: Positive if they are pointing in the same direction. Negative if they are pointing in opposite directions. Zero when they are perpendicular. By using dot product here, this effectively implements the classic snake-like game rule that you cannot turn 180° into yourself. Slime Movement Cycle To handle the snake-like movement cycle of the slime, we will create a method called Move. Add the following method to the Slime class after the HandleInput method: private void Move() { // Capture the value of the head segment SlimeSegment head = _segments[0]; // Update the direction the head is supposed to move in to the // next direction cached. head.Direction = _nextDirection; // Update the head's \"at\" position to be where it was moving \"to\" head.At = head.To; // Update the head's \"to\" position to the next tile in the direction // it is moving. head.To = head.At + head.Direction * _stride; // Insert the new adjusted value for the head at the front of the // segments and remove the tail segment. This effectively moves // the entire chain forward without needing to loop through every // segment and update its \"at\" and \"to\" positions. _segments.Insert(0, head); _segments.RemoveAt(_segments.Count - 1); // Iterate through all of the segments except the head and check // if they are at the same position as the head. If they are, then // the head is colliding with a body segment and a body collision // has occurred. for (int i = 1; i < _segments.Count; i++) { SlimeSegment segment = _segments[i]; if (head.At == segment.At) { if(BodyCollision != null) { BodyCollision.Invoke(this, EventArgs.Empty); } return; } } } This method performs the core snake-like movement cycle logic by: Copying the value of the current head segment. Updating the copy's position (At) to where the head was moving to and updating the position it is moving to (To). Insert the copy into the front of the segment collection and remove the tail. Check if the head is now in the same position as any body segments, which would cause a collision and trigger a game over. Note By inserting a new head segment at the front of the chain and removing the last segment, this creates the illusion of the entire chain moving forward as one, even though we are only actually moving the head forward and removing the tail. This follows the common snake movement pattern as discussed in the Understanding Snake Game Mechanics: Movement Cycle section above. Slime Growth To handle the snake-like growth of the slime, we will create a new method called Grow. Add the following method to the Slime class after the Move method: /// <summary> /// Informs the slime to grow by one segment. /// </summary> public void Grow() { // Capture the value of the tail segment SlimeSegment tail = _segments[_segments.Count - 1]; // Create a new tail segment that is positioned a grid cell in the // reverse direction from the tail moving to the tail. SlimeSegment newTail = new SlimeSegment(); newTail.At = tail.To + tail.ReverseDirection * _stride; newTail.To = tail.At; newTail.Direction = Vector2.Normalize(tail.At - newTail.At); // Add the new tail segment _segments.Add(newTail); } The Grow method works as follows: First it creates a copy of the current tail value. It then adjusts the values of the copy so that it is now positioned behind the current tail by using the ReverseDirection value of the tail. Finally, it inserts this new tail into the segments collection. Slime Update With most of the core snake-like mechanics now added to the Slime class within their own methods we can now work on what happens while the slime is operating. Add the following Update method to the Slime class after the Grow method: /// <summary> /// Updates the slime. /// </summary> /// <param name=\"gameTime\">A snapshot of the timing values for the current update cycle.</param> public void Update(GameTime gameTime) { // Update the animated sprite. _sprite.Update(gameTime); // Handle any player input HandleInput(); // Increment the movement timer by the frame elapsed time. _movementTimer += gameTime.ElapsedGameTime; // If the movement timer has accumulated enough time to be greater than // the movement time threshold, then perform a full movement. if (_movementTimer >= s_movementTime) { _movementTimer -= s_movementTime; Move(); } // Update the movement lerp offset amount _movementProgress = (float)(_movementTimer.TotalSeconds / s_movementTime.TotalSeconds); } This update method: Updates the slime's AnimatedSprite to ensure the sprite animations occur. Calls HandleInput to check for player input. Increments the movement timer by the amount of time that has elapsed between the game's update cycles. Performs a check to see if the movement timer has accumulated more time than the threshold to perform a movement cycle update. If it has then: The movement timer is reduced by the threshold time. The Move method is called to perform a movement cycle update. Finally, the movement progress amount is calculated by dividing the number of seconds accumulated for the movement timer by the number of seconds for the threshold. This gives us a normalized value between 0.0 and 1.0 that we can use for visual interpolation for fluid movement. Tip In games, frame rates can vary based on system performance, causing inconsistent update intervals. If we simply reset the movement timer to zero after each movement cycle, we would lose any excess time that accumulated beyond the movement threshold. For example: Our movement threshold is 200ms. The game runs at 60fps (16.67ms per frame). After 12 frames, we have accumulated 200.04ms. If we reset to zero, we lose 0.04ms. Over time, these small losses can add up and cause inconsistent movement. By subtracting the threshold instead of resetting to zero, we \"bank\" the excess time (0.06ms in this example) for the next movement cycle. This ensures that: Movement happens exactly at the intended frequency, maintaining consistent game speed. The visual smoothness of movement remains intact even if the game occasionally drops frames. Players experience the same game timing regardless of their hardware's performance. This technique is standard practice in game development, especially for timing-sensitive mechanics like rhythmic games, animations, and movement systems. It is a simple solution that significantly improves gameplay consistency. Slime Draw We also need a method to handle drawing the slime and all of its segments. Add the following Draw method after the Update method to the Slime class: /// <summary> /// Draws the slime. /// </summary> public void Draw() { // Iterate through each segment and draw it foreach (SlimeSegment segment in _segments) { // Calculate the visual position of the segment at the moment by // lerping between its \"at\" and \"to\" position by the movement // offset lerp amount Vector2 pos = Vector2.Lerp(segment.At, segment.To, _movementProgress); // Draw the slime sprite at the calculated visual position of this // segment _sprite.Draw(Core.SpriteBatch, pos); } } This draw method iterates each segment of the slime and calculates the visual position to draw each segment at by performing linear interpolation (lerp) to determine the position of the segment between its current position (At) and the position it is moving to (To) based on the _movementProgress calculation. Note Vector2.Lerp performs a linear interpolation between two vectors, creating a smooth transition from start to end based on an amount parameter. The formula is: \\(\\text{result} = \\text{start} + (\\text{end} - \\text{start}) \\cdot \\text{amount}\\) Where the amount parameter ranges from 0.0 (returns the start position) to 1.0 (returns the end position). Values between 0.0 and 1.0 give positions along the straight line between start and end. In our game, this is used to create a visual fluid movement illusion by interpolating between a segment's current position (At) and its target position (To) based on the elapsed time, rather than having the segments abruptly jump from one grid position to the next after each movement update. Slime Bounds For the game scene to detect collisions between the slime and other elements (walls or the bat), we need a method to calculate the current collision bounds. Add the following method to the Slime class after the Draw method: /// <summary> /// Returns a Circle value that represents collision bounds of the slime. /// </summary> /// <returns>A Circle value.</returns> public Circle GetBounds() { SlimeSegment head = _segments[0]; // Calculate the visual position of the head at the moment of this // method call by lerping between the \"at\" and \"to\" position by the // movement offset lerp amount Vector2 pos = Vector2.Lerp(head.At, head.To, _movementProgress); // Create the bounds using the calculated visual position of the head. Circle bounds = new Circle( (int)(pos.X + (_sprite.Width * 0.5f)), (int)(pos.Y + (_sprite.Height * 0.5f)), (int)(_sprite.Width * 0.5f) ); return bounds; } This method takes the current head segment (the first segment in our collection), calculates its visual position using linear interpolation, and then creates a Circle value to represent its collision boundary. Using the interpolated position ensures that collision detection aligns with what the player sees on screen. Note We only need collision bounds for the slime's head for interactions with the bat and walls, as this matches the classic snake game mechanic where only the head's collisions matter for gameplay. For detecting collisions between the head and body segments, we use a simpler position-based check in the Move method since those positions are always aligned to the grid. With all these methods in place, our Slime class now fully implements the snake-like mechanics we need. It handles: Movement on a grid. Prevents invalid direction changes Detects self-collisions Provides smooth visual movement between grid positions. This encapsulation allows us to manage all slime-related behavior in one place while exposing only the necessary interfaces to the game scene. Now that we have our player-controlled character implemented, we can create the object that the slime will try to collect; the bat. The Bat Class In the GameObjects folder of the DungeonSlime project (your main game project), create a new file named Bat.cs and add the following initial code: using System; using Microsoft.Xna.Framework; using Microsoft.Xna.Framework.Audio; using MonoGameLibrary; using MonoGameLibrary.Graphics; namespace DungeonSlime.GameObjects; public class Bat { } This code establishes the foundation for our Bat class. We have included the necessary using statements for MonoGame components, audio functionality, and our library references. The class is placed in the same DungeonSlime.GameObjects namespace as our Slime class to maintain a consistent organization. Now we will build this class step by step, adding all the functionality needed for the bat to serve as the collectible object in our game. Add each of the following sections to the Bat class in the order they are presented. Note As with the Slime class, you may encounter compiler errors until all sections are in place. These errors will be resolved once all components of the class have been added. Bat Fields Add the following fields to the Bat class: private const float MOVEMENT_SPEED = 5.0f; // The velocity of the bat that defines the direction and how much in that // direction to update the bats position each update cycle. private Vector2 _velocity; // The AnimatedSprite used when drawing the bat. private AnimatedSprite _sprite; // The sound effect to play when the bat bounces off the edge of the room. private SoundEffect _bounceSoundEffect; Each of these fields is responsible for: MOVEMENT_SPEED: This constant represents the factor to multiply the velocity vector by to determine how fast the bat is moving. _velocity: A vector that defines the direction and how much in that direction to update the position of the bat each update cycle. _sprite: This stores the AnimatedSprite that is used to draw the bat. _bounceSoundEffect: This store the SoundEffect to play when the bat is told to bounce. Bat Properties Next, add the following property to the Bat class after the fields: /// <summary> /// Gets or Sets the position of the bat. /// </summary> public Vector2 Position { get; set;} This property exposes the position of the bat so it can be used for calculations in the game scene when determining where to place the bat after the slime eats it. Bat Constructor After the property, add the following constructor to the Bat class: /// <summary> /// Creates a new Bat using the specified animated sprite and sound effect. /// </summary> /// <param name=\"sprite\">The AnimatedSprite ot use when drawing the bat.</param> /// <param name=\"bounceSoundEffect\">The sound effect to play when the bat bounces off a wall.</param> public Bat(AnimatedSprite sprite, SoundEffect bounceSoundEffect) { _sprite = sprite; _bounceSoundEffect = bounceSoundEffect; } This is a simple constructor that requires the bat to be given the AnimatedSprite that will be used to draw the bat and the SoundEffect to be played when the bat bounces off a wall. Bat Randomize Velocity Currently, we have the AssignRandomVelocity method in the GameScene that we call to randomize the velocity of the bat after it has been eaten by the slime. We can take this method out of the GameScene class and put it directly into the Bat class itself. Add the following method to the Bat class after the constructor: /// <summary> /// Randomizes the velocity of the bat. /// </summary> public void RandomizeVelocity() { // Generate a random angle float angle = (float)(Random.Shared.NextDouble() * MathHelper.TwoPi); // Convert the angle to a direction vector float x = (float)Math.Cos(angle); float y = (float)Math.Sin(angle); Vector2 direction = new Vector2(x, y); // Multiply the direction vector by the movement speed to get the // final velocity _velocity = direction * MOVEMENT_SPEED; } Bat Bounce We are also going to take the logic from the GameScene class that bounces the bat off the walls and move it into a dedicated method in the Bat class. Add the following method to the Bat class after the RandomizeVelocity method: /// <summary> /// Handles a bounce event when the bat collides with a wall or boundary. /// </summary> /// <param name=\"normal\">The normal vector of the surface the bat is bouncing against.</param> public void Bounce(Vector2 normal) { Vector2 newPosition = Position; // Adjust the position based on the normal to prevent sticking to walls. if(normal.X != 0) { // We are bouncing off a vertical wall (left/right). // Move slightly away from the wall in the direction of the normal. newPosition.X += normal.X * (_sprite.Width * 0.1f); } if(normal.Y != 0) { // We are bouncing off a horizontal wall (top/bottom). // Move slightly way from the wall in the direction of the normal. newPosition.Y += normal.Y * (_sprite.Height * 0.1f); } // Apply the new position Position = newPosition; // Normalize before reflecting normal.Normalize(); // Apply reflection based on the normal. _velocity = Vector2.Reflect(_velocity, normal); // Play the bounce sound effect. Core.Audio.PlaySoundEffect(_bounceSoundEffect); } This method only takes a single parameter, the normal vector of the surface the bat is bouncing against. Based on the X and Y components of the normal vector, we can determine which wall the bat bounced against and adjust the position of the bat so that it does not stick to the wall. Bat Bounds Similar to the Slime class, for the game scene to detect collision between the bat and other elements, we need a method to calculate the current collision bounds of the bat. Add the following method to the Bat class after the Bounce method: /// <summary> /// Returns a Circle value that represents collision bounds of the bat. /// </summary> /// <returns>A Circle value.</returns> public Circle GetBounds() { int x = (int)(Position.X + _sprite.Width * 0.5f); int y = (int)(Position.Y + _sprite.Height * 0.5f); int radius = (int)(_sprite.Width * 0.25f); return new Circle(x, y, radius); } Bat Update The Bat class will also need to be updated. Add the following Update method to the Bat class after the GetBounds method: /// <summary> /// Updates the bat. /// </summary> /// <param name=\"gameTime\">A snapshot of the timing values for the current update cycle.</param> public void Update(GameTime gameTime) { // Update the animated sprite _sprite.Update(gameTime); // Update the position of the bat based on the velocity. Position += _velocity; } This method simply updates the bat's AnimatedSprite to ensure animations occur and adjusts the position of the bat based on the current velocity. Note The continuous movement of the bat contrasts with the grid-based interval movement of the slime, creating different gameplay dynamics for the player to consider. This makes catching the bat challenging without requiring any complex behaviors. Bat Draw Finally, we need a method to draw the bat. Add the following Draw method to the Bat class after the Update method: /// <summary> /// Draws the bat. /// </summary> public void Draw() { _sprite.Draw(Core.SpriteBatch, Position); } This method simply draws the bat's AnimatedSprite at the bat's current position. With the Bat class complete, we have now encapsulated all the behavior needed for the collectible element in our game. The bat moves continuously around the screen and can bounce off walls, adding a twist on the classic snake-like mechanic by creating a target for the player to chase. Conclusion Note To the observant, you should notice that the main game screen has not been updated and therefore nothing has changed if we run the game at this point. In the next chapter we will finalize the gameplay. In this chapter, we have learned about and implemented the core mechanics of a class snake-like game. We created: A GameController class that provides a unified input interface, separating game actions from specific input devices. A SlimeSegment struct to efficiently store and manage individual segments of our snake-like character. A Slime class that implements grid-based movement, segment management and self-collision detection. A Bat class that serves as the collectible object with continuous movement and wall bouncing. These implementations encapsulate the core gameplay mechanics into reusable, maintainable objects. In the next chapter, we will build on these mechanics by updating the GameScene to implement game state management and a new UI element for the game over state to create a complete game experience. Test Your Knowledge Why must a snake-like game prevent the player from reversing direction? :::question-answer Preventing reverse movement is necessary because it would cause an immediate collision between the snake's head and the first body segment, resulting in an unfair game over. ::: How does the movement cycle for a snake work, and why is it more efficient than updating each segment individually? :::question-answer The snake movement cycle works by: Creating a copy of the head segment. Positioning the copy one grid cell ahead in the current direction Inserting this copy at the front of the segment collection Removing the last segment. This approach is more efficient because it only requires manipulating two segments (adding a new head and removing the tail) regardless of how long the snake becomes, rather than iterating through and updating every segment individually. ::: What are the benefits of using the Input Abstraction pattern implemented in the GameController class? :::question-answer The Input Abstraction pattern provides several benefits: Input device independence, allowing the game to handle keyboard, gamepad, or other inputs through a unified interface Simplified input handling through clean API calls rather than checking multiple input combinations Easier implementation of key rebinding features by only needing to modify the GameController class Consistent input logic defined in a single location Better cross-platform compatibility by centralizing platform-specific input handling ::: How does the implementation use Vector2.Lerp to create smooth visual movement, and why is this important? :::question-answer The implementation uses Vector2.Lerp to interpolate between a segment's current position (At) and its target position (To) based on a normalized movement progress value. This creates smooth visual movement by drawing the segments at intermediate positions between grid points rather than abruptly jumping from one grid position to the next. This is important because it provides more fluid animation while maintaining the logical grid-based movement, enhancing the visual quality of the game without changing the core mechanics. :::"
  },
  "templates/docs.monogame.github.io/articles/tutorials/building_2d_games/23_completing_the_game/index.html": {
    "href": "templates/docs.monogame.github.io/articles/tutorials/building_2d_games/23_completing_the_game/index.html",
    "title": "Chapter 23: Completing the Game | hallowed",
    "summary": "In Chapter 22 we implemented the core mechanics of a snake-like game by creating the Slime, Bat and GameController classes. While these classes handle the foundational gameplay, a complete game needs additional elements to provide player feedback, manage game states, and create a polished experience. In this chapter, you will: Create a dedicated UI class to manage the UI for the game scene. Implement pause and game over screens with appropriate controls. Refactor the GameScene class to coordinate all game elements. Add game state management to handle playing, paused, and game over conditions Implement input buffering to improve control responsiveness Connect all elements to create a complete, playable game. The GameSceneUI Class Currently, the GameScene class contains the methods for initializing and creating the pause menu. However, now that we have a defined condition for game over, we need to create a game-over menu as well. To do this, we will take the opportunity to refactor the current code and pull the UI-specific code into its own class. In the UI folder of the DungeonSlime project, create a new file named GameSceneUI.cs and add the following initial code: using System; using Gum.DataTypes; using Gum.Managers; using Microsoft.Xna.Framework; using Microsoft.Xna.Framework.Audio; using Microsoft.Xna.Framework.Content; using MonoGameGum; using MonoGameGum.Forms.Controls; using MonoGameGum.GueDeriving; using MonoGameLibrary; using MonoGameLibrary.Graphics; namespace DungeonSlime.UI; public class GameSceneUI : ContainerRuntime { } This code establishes the foundation for our GameSceneUI class, which inherits from Gum's ContainerRuntime class. This inheritance means our UI class is itself a UI container that can hold and manage other UI elements. We have included all necessary using statements for MonoGame, Gum UI components, and our library references. You will build out this class by adding each section in sequence. Follow the order below to create the complete UI management system for our game scene. Note You may see compiler errors as you add these sections one by one. This is expected because some parts of the code will reference fields, properties, or methods that we haven't added yet. Once all sections are in place, these errors will resolve. GameSceneUI Fields Add the following fields to the GameSceneUI class: // The string format to use when updating the text for the score display. private static readonly string s_scoreFormat = \"SCORE: {0:D6}\"; // The sound effect to play for auditory feedback of the user interface. private SoundEffect _uiSoundEffect; // The pause panel private Panel _pausePanel; // The resume button on the pause panel. Field is used to track reference so // focus can be set when the pause panel is shown. private AnimatedButton _resumeButton; // The game over panel. private Panel _gameOverPanel; // The retry button on the game over panel. Field is used to track reference // so focus can be set when the game over panel is shown. private AnimatedButton _retryButton; // The text runtime used to display the players score on the game screen. private TextRuntime _scoreText; Here is a break down what each of these fields is responsible for: s_scoreFormat: A string format template used to display the player's score with leading zeros. _uiSoundEffect: Stores the sound effect played for UI interactions like button clicks and focus changes. _pausePanel: The panel containing the UI elements shown when the game is paused. _resumeButton: A reference to the resume button, allowing us to set focus on it when the pause panel is shown. _gameOverPanel: The panel containing the UI elements shown when a game over occurs. _retryButton: A reference to the retry button, allowing us to set focus to it when the game over panel is shown. _scoreText: The text display showing the player's current score. GameSceneUI Events After the fields, add the following events to the GameSceneUI class: /// <summary> /// Event invoked when the Resume button on the Pause panel is clicked. /// </summary> public event EventHandler ResumeButtonClick; /// <summary> /// Event invoked when the Quit button on either the Pause panel or the /// Game Over panel is clicked. /// </summary> public event EventHandler QuitButtonClick; /// <summary> /// Event invoked when the Retry button on the Game Over panel is clicked. /// </summary> public event EventHandler RetryButtonClick; These events allow the GameSceneUI class to notify the GameScene when important UI actions occur: ResumeButtonClick: Triggered when the player clicks the Resume button on the pause panel. QuitButtonClick: Triggered when the player clicks the Quit button on either panel. RetryButtonClick: Triggered when the player clicks the Retry button on the game over panel. GameSceneUI Constructor Add the following constructor to the GameSceneUI class after the events: public GameSceneUI() { // The game scene UI inherits from ContainerRuntime, so we set its // doc to fill so it fills the entire screen. Dock(Gum.Wireframe.Dock.Fill); // Add it to the root element. this.AddToRoot(); // Get a reference to the content manager that was registered with the // GumService when it was original initialized. ContentManager content = GumService.Default.ContentLoader.XnaContentManager; // Use that content manager to load the sound effect and atlas for the // user interface elements _uiSoundEffect = content.Load<SoundEffect>(\"audio/ui\"); TextureAtlas atlas = TextureAtlas.FromFile(content, \"images/atlas-definition.xml\"); // Create the text that will display the players score and add it as // a child to this container. _scoreText = CreateScoreText(); AddChild(_scoreText); // Create the Pause panel that is displayed when the game is paused and // add it as a child to this container _pausePanel = CreatePausePanel(atlas); AddChild(_pausePanel.Visual); // Create the Game Over panel that is displayed when a game over occurs // and add it as a child to this container _gameOverPanel = CreateGameOverPanel(atlas); AddChild(_gameOverPanel.Visual); } This constructor initializes all UI components: Set the container to fill the entire screen. Adds itself to Gum's root element. Loads necessary assets (sound effect and texture atlas). Creates and adds child elements in the correct order. GameSceneUI UI Creation Methods To keep the code more organized, we will create separate functions to build the individual UI elements that will be managed by the GameSceneUI class. Creating the Score Text To display the player's score, we will begin by adding a method to create a TextRuntime element. Add the following method to the GameSceneUI after the constructor: private TextRuntime CreateScoreText() { TextRuntime text = new TextRuntime(); text.Anchor(Gum.Wireframe.Anchor.TopLeft); text.WidthUnits = DimensionUnitType.RelativeToChildren; text.X = 20.0f; text.Y = 5.0f; text.UseCustomFont = true; text.CustomFontFile = @\"fonts/04b_30.fnt\"; text.FontScale = 0.25f; text.Text = string.Format(s_scoreFormat, 0); return text; } Creating the Pause Panel Next, we will add a method to create a Panel element that is shown when the game is paused, including the \"Resume\" and \"Quit\" buttons. Add the following method to the GameSceneUI class after the CreateScoreText method: private Panel CreatePausePanel(TextureAtlas atlas) { Panel panel = new Panel(); panel.Anchor(Gum.Wireframe.Anchor.Center); panel.Visual.WidthUnits = DimensionUnitType.Absolute; panel.Visual.HeightUnits = DimensionUnitType.Absolute; panel.Visual.Width = 264.0f; panel.Visual.Height = 70.0f; panel.IsVisible = false; TextureRegion backgroundRegion = atlas.GetRegion(\"panel-background\"); NineSliceRuntime background = new NineSliceRuntime(); background.Dock(Gum.Wireframe.Dock.Fill); background.Texture = backgroundRegion.Texture; background.TextureAddress = TextureAddress.Custom; background.TextureHeight = backgroundRegion.Height; background.TextureWidth = backgroundRegion.Width; background.TextureTop = backgroundRegion.SourceRectangle.Top; background.TextureLeft = backgroundRegion.SourceRectangle.Left; panel.AddChild(background); TextRuntime text = new TextRuntime(); text.Text = \"PAUSED\"; text.UseCustomFont = true; text.CustomFontFile = \"fonts/04b_30.fnt\"; text.FontScale = 0.5f; text.X = 10.0f; text.Y = 10.0f; panel.AddChild(text); _resumeButton = new AnimatedButton(atlas); _resumeButton.Text = \"RESUME\"; _resumeButton.Anchor(Gum.Wireframe.Anchor.BottomLeft); _resumeButton.Visual.X = 9.0f; _resumeButton.Visual.Y = -9.0f; _resumeButton.Click += OnResumeButtonClicked; _resumeButton.GotFocus += OnElementGotFocus; panel.AddChild(_resumeButton); AnimatedButton quitButton = new AnimatedButton(atlas); quitButton.Text = \"QUIT\"; quitButton.Anchor(Gum.Wireframe.Anchor.BottomRight); quitButton.Visual.X = -9.0f; quitButton.Visual.Y = -9.0f; quitButton.Click += OnQuitButtonClicked; quitButton.GotFocus += OnElementGotFocus; panel.AddChild(quitButton); return panel; } Creating the Game Over Panel Finally, we will add a method to create a Panel element that is shown when a game over occurs, including the \"Retry\" and \"Quit\" buttons. Add the following method to the GameSceneUI class after the CreatePausePanel method: private Panel CreateGameOverPanel(TextureAtlas atlas) { Panel panel = new Panel(); panel.Anchor(Gum.Wireframe.Anchor.Center); panel.Visual.WidthUnits = DimensionUnitType.Absolute; panel.Visual.HeightUnits = DimensionUnitType.Absolute; panel.Visual.Width = 264.0f; panel.Visual.Height = 70.0f; panel.IsVisible = false; TextureRegion backgroundRegion = atlas.GetRegion(\"panel-background\"); NineSliceRuntime background = new NineSliceRuntime(); background.Dock(Gum.Wireframe.Dock.Fill); background.Texture = backgroundRegion.Texture; background.TextureAddress = TextureAddress.Custom; background.TextureHeight = backgroundRegion.Height; background.TextureWidth = backgroundRegion.Width; background.TextureTop = backgroundRegion.SourceRectangle.Top; background.TextureLeft = backgroundRegion.SourceRectangle.Left; panel.AddChild(background); TextRuntime text = new TextRuntime(); text.Text = \"GAME OVER\"; text.WidthUnits = DimensionUnitType.RelativeToChildren; text.UseCustomFont = true; text.CustomFontFile = \"fonts/04b_30.fnt\"; text.FontScale = 0.5f; text.X = 10.0f; text.Y = 10.0f; panel.AddChild(text); _retryButton = new AnimatedButton(atlas); _retryButton.Text = \"RETRY\"; _retryButton.Anchor(Gum.Wireframe.Anchor.BottomLeft); _retryButton.Visual.X = 9.0f; _retryButton.Visual.Y = -9.0f; _retryButton.Click += OnRetryButtonClicked; _retryButton.GotFocus += OnElementGotFocus; panel.AddChild(_retryButton); AnimatedButton quitButton = new AnimatedButton(atlas); quitButton.Text = \"QUIT\"; quitButton.Anchor(Gum.Wireframe.Anchor.BottomRight); quitButton.Visual.X = -9.0f; quitButton.Visual.Y = -9.0f; quitButton.Click += OnQuitButtonClicked; quitButton.GotFocus += OnElementGotFocus; panel.AddChild(quitButton); return panel; } Both the pause panel and the game over panel use event handlers for their buttons. We will add those next. GameSceneUI Event Handlers After the CreateGameOverPanel method, add the following method to the GameSceneUI class: private void OnResumeButtonClicked(object sender, EventArgs args) { // Button was clicked, play the ui sound effect for auditory feedback. Core.Audio.PlaySoundEffect(_uiSoundEffect); // Since the resume button was clicked, we need to hide the pause panel. HidePausePanel(); // Invoke the ResumeButtonClick event if(ResumeButtonClick != null) { ResumeButtonClick(sender, args); } } private void OnRetryButtonClicked(object sender, EventArgs args) { // Button was clicked, play the ui sound effect for auditory feedback. Core.Audio.PlaySoundEffect(_uiSoundEffect); // Since the retry button was clicked, we need to hide the game over panel. HideGameOverPanel(); // Invoke the RetryButtonClick event. if(RetryButtonClick != null) { RetryButtonClick(sender, args); } } private void OnQuitButtonClicked(object sender, EventArgs args) { // Button was clicked, play the ui sound effect for auditory feedback. Core.Audio.PlaySoundEffect(_uiSoundEffect); // Both panels have a quit button, so hide both panels HidePausePanel(); HideGameOverPanel(); // Invoke the QuitButtonClick event. if(QuitButtonClick != null) { QuitButtonClick(sender, args); } } private void OnElementGotFocus(object sender, EventArgs args) { // A ui element that can receive focus has received focus, play the // ui sound effect for auditory feedback. Core.Audio.PlaySoundEffect(_uiSoundEffect); } These event handlers provide audio feedback and appropriate UI updates when buttons are clicked or UI elements receive focus. GameSceneUI Public Methods Finally, add the following public methods to the GameSceneUI class after the OnElementGotFocus method: /// <summary> /// Updates the text on the score display. /// </summary> /// <param name=\"score\">The score to display.</param> public void UpdateScoreText(int score) { _scoreText.Text = string.Format(s_scoreFormat, score); } /// <summary> /// Tells the game scene ui to show the pause panel. /// </summary> public void ShowPausePanel() { _pausePanel.IsVisible = true; // Give the resume button focus for keyboard/gamepad input. _resumeButton.IsFocused = true; // Ensure the game over panel isn't visible. _gameOverPanel.IsVisible = false; } /// <summary> /// Tells the game scene ui to hide the pause panel. /// </summary> public void HidePausePanel() { _pausePanel.IsVisible = false; } /// <summary> /// Tells the game scene ui to show the game over panel. /// </summary> public void ShowGameOverPanel() { _gameOverPanel.IsVisible = true; // Give the retry button focus for keyboard/gamepad input. _retryButton.IsFocused =true; // Ensure the pause panel isn't visible. _pausePanel.IsVisible = false; } /// <summary> /// Tells the game scene ui to hide the game over panel. /// </summary> public void HideGameOverPanel() { _gameOverPanel.IsVisible = false; } /// <summary> /// Updates the game scene ui. /// </summary> /// <param name=\"gameTime\">A snapshot of the timing values for the current update cycle.</param> public void Update(GameTime gameTime) { GumService.Default.Update(gameTime); } /// <summary> /// Draws the game scene ui. /// </summary> public void Draw() { GumService.Default.Draw(); } These public methods provide the interface for the GameScene to implement: Update the score display. Show or hide the pause menu. Show or hide the game over menu. Update and draw the UI components. With the GameSceneUI class complete, we now have a fully encapsulated UI system that can handle displaying game information (score), providing feedback for game states (pause, game over), and processing user interactions (button clicks). This separation of UI logic from game logic will make our codebase much easier to maintain and extend. Now that we have all our specialized components ready, we can refactor the GameScene class to coordinate between them and manage the overall game flow. Refactoring The GameScene Class Now that we have created the encapsulated Slime, Bat, and GameSceneUI classes, we can refactor the GameScene class to leverage these new components. This will make our code more maintainable and allow us to focus on the game logic within the scene itself. We will rebuild/replace the existing GameScene class to coordinate the interactions between the components. In the Scenes folder of the DungeonSlime project (your main game project), open the GameScene.cs file and replace ALL of the code with the following replacement code (starting fresh): using System; using DungeonSlime.GameObjects; using DungeonSlime.UI; using Microsoft.Xna.Framework; using Microsoft.Xna.Framework.Audio; using Microsoft.Xna.Framework.Graphics; using MonoGameGum; using MonoGameLibrary; using MonoGameLibrary.Graphics; using MonoGameLibrary.Scenes; namespace DungeonSlime.Scenes; public class GameScene : Scene { private enum GameState { Playing, Paused, GameOver } // Reference to the slime. private Slime _slime; // Reference to the bat. private Bat _bat; // Defines the tilemap to draw. private Tilemap _tilemap; // Defines the bounds of the room that the slime and bat are contained within. private Rectangle _roomBounds; // The sound effect to play when the slime eats a bat. private SoundEffect _collectSoundEffect; // Tracks the players score. private int _score; private GameSceneUI _ui; private GameState _state; } This code provides the foundation for our refactored GameScene class. We have included all the necessary using statements to reference our new game object classes and UI components. The class will now focus on managing the game state and coordinating between our specialized component classes rather than implementing all the functionality directly. The GameScene class now contains the following key fields: GameState: An enum that defines the different states that the game can be in (playing, paused, or game over). _slime: A reference to the slime (snake-like player character) instance. _bat: A reference to the bat (food) instance. _tilemap: The tilemap that defines the level layout. _roomBounds: A rectangle defining the playable area within the walls. _collectSoundEffect: The sound effect played when the slime eats a bat. _score: Tracks the player's current score. _ui: A reference to the game scene UI component. _state: The current state of the game represented by the GameState enum. Next we will add the various methods needed to complete the GameScene class and finalize the game logic. Add each section in the sequence presented below. This will build up the scene's functionality step by step. Note As with previous classes, you might encounter compiler errors until all sections are in place. These errors will be resolved once all components of the class have been added. GameScene Initialize Method To set up the scene, add the following Initialize method after the fields in te GameScene class: public override void Initialize() { // LoadContent is called during base.Initialize(). base.Initialize(); // During the game scene, we want to disable exit on escape. Instead, // the escape key will be used to return back to the title screen. Core.ExitOnEscape = false; // Create the room bounds by getting the bounds of the screen then // using the Inflate method to \"Deflate\" the bounds by the width and // height of a tile so that the bounds only covers the inside room of // the dungeon tilemap. _roomBounds = Core.GraphicsDevice.PresentationParameters.Bounds; _roomBounds.Inflate(-_tilemap.TileWidth, -_tilemap.TileHeight); // Subscribe to the slime's BodyCollision event so that a game over // can be triggered when this event is raised. _slime.BodyCollision += OnSlimeBodyCollision; // Create any UI elements from the root element created in previous // scenes. GumService.Default.Root.Children.Clear(); // Initialize the user interface for the game scene. InitializeUI(); // Initialize a new game to be played. InitializeNewGame(); } This method sets up the initial state of the game scene: Disables the \"exit on escape\" behavior so we can use the escape key for pausing. Calculate the playable area within the tilemap walls. Subscribes to the slime's body collision event to detect when the player collides with itself triggering a game over state. Initialize the UI components. Set up a new game. GameScene InitializeUI Method The Initialize method we just added calls a method to initialize the user interface for the scene, we can add that method now. Add the following method after the Initialize method in the GameScene class: private void InitializeUI() { // Clear out any previous UI element incase we came here // from a different scene. GumService.Default.Root.Children.Clear(); // Create the game scene ui instance. _ui = new GameSceneUI(); // Subscribe to the events from the game scene ui. _ui.ResumeButtonClick += OnResumeButtonClicked; _ui.RetryButtonClick += OnRetryButtonClicked; _ui.QuitButtonClick += OnQuitButtonClicked; } This method creates the UI components and subscribes to its events to respond to button clicks. GameScene UI Event Handlers In the InitializeUI method we just added, we subscribe to the events from the GameSceneUI class that are triggered when buttons are clicked. Now we need to add those methods that would be called when the events are triggered. Add the following methods to the GameScene class after the InitializeUI method: private void OnResumeButtonClicked(object sender, EventArgs args) { // Change the game state back to playing. _state = GameState.Playing; } private void OnRetryButtonClicked(object sender, EventArgs args) { // Player has chosen to retry, so initialize a new game. InitializeNewGame(); } private void OnQuitButtonClicked(object sender, EventArgs args) { // Player has chosen to quit, so return back to the title scene. Core.ChangeScene(new TitleScene()); } These methods respond to the UI events: OnResumeButtonClicked: Resumes the game from a paused state. OnRetryButtonClicked: Restarts the game after a game over. OnQuitButtonClicked: Quits the game by returning to the title scene. GameScene InitializeNewGame Method In the Initialize method we added above, it also makes a call to an InitializeNewGame method which we will add next. Add the following method to the GameScene class after the OnQuitButtonClicked method: private void InitializeNewGame() { // Calculate the position for the slime, which will be at the center // tile of the tile map. Vector2 slimePos = new Vector2(); slimePos.X = (_tilemap.Columns / 2) * _tilemap.TileWidth; slimePos.Y = (_tilemap.Rows / 2) * _tilemap.TileHeight; // Initialize the slime. _slime.Initialize(slimePos, _tilemap.TileWidth); // Initialize the bat. _bat.RandomizeVelocity(); PositionBatAwayFromSlime(); // Reset the score. _score = 0; // Set the game state to playing. _state = GameState.Playing; } This method will: Position the slime in the center of the map. Initialize the slime with its starting position and movement stride. Randomize the bat's velocity and position it away from the slime. Reset the player's score. Set the game state to \"Playing\". GameScene LoadContent Method Next, we need to add the method to load game assets for the scene. Add the following method to the GameScene class after the InitializeNewGame method: public override void LoadContent() { // Create the texture atlas from the XML configuration file. TextureAtlas atlas = TextureAtlas.FromFile(Core.Content, \"images/atlas-definition.xml\"); // Create the tilemap from the XML configuration file. _tilemap = Tilemap.FromFile(Content, \"images/tilemap-definition.xml\"); _tilemap.Scale = new Vector2(4.0f, 4.0f); // Create the animated sprite for the slime from the atlas. AnimatedSprite slimeAnimation = atlas.CreateAnimatedSprite(\"slime-animation\"); slimeAnimation.Scale = new Vector2(4.0f, 4.0f); // Create the slime. _slime = new Slime(slimeAnimation); // Create the animated sprite for the bat from the atlas. AnimatedSprite batAnimation = atlas.CreateAnimatedSprite(\"bat-animation\"); batAnimation.Scale = new Vector2(4.0f, 4.0f); // Load the bounce sound effect for the bat. SoundEffect bounceSoundEffect = Content.Load<SoundEffect>(\"audio/bounce\"); // Create the bat. _bat = new Bat(batAnimation, bounceSoundEffect); // Load the collect sound effect. _collectSoundEffect = Content.Load<SoundEffect>(\"audio/collect\"); } This method loads all necessary assets for the game scene: The texture atlas containing the sprite graphics. The tilemap that defines the level layout. The animated sprites for the slime and bat. Sound effects for the bat bouncing and collecting. GameScene Update Method Next, to update the scene, add the following method to the GameScene class after the LoadContent method: public override void Update(GameTime gameTime) { // Ensure the UI is always updated. _ui.Update(gameTime); // If the game is in a game over state, immediately return back // here. if (_state == GameState.GameOver) { return; } // If the pause button is pressed, toggle the pause state. if (GameController.Pause()) { TogglePause(); } // At this point, if the game is paused, just return back early. if (_state == GameState.Paused) { return; } // Update the slime. _slime.Update(gameTime); // Update the bat. _bat.Update(gameTime); // Perform collision checks. CollisionChecks(); } This method updates the scene in each frame to: Always update the UI, regardless of game state. Return early if the game is over. Check for pause input and toggle the pause state if needed. Return early if the game is paused. Update the slime and bat. Check for collisions between the game objects. GameScene CollisionChecks Method In the Update method we just added, it makes a call to a CollisionChecks method to handle the collision detection and response so we will add that now. Add the following method to the GameScene class after the Update method: private void CollisionChecks() { // Capture the current bounds of the slime and bat. Circle slimeBounds = _slime.GetBounds(); Circle batBounds = _bat.GetBounds(); // FIrst perform a collision check to see if the slime is colliding with // the bat, which means the slime eats the bat. if (slimeBounds.Intersects(batBounds)) { // Move the bat to a new position away from the slime. PositionBatAwayFromSlime(); // Randomize the velocity of the bat. _bat.RandomizeVelocity(); // Tell the slime to grow. _slime.Grow(); // Increment the score. _score += 100; // Update the score display on the UI. _ui.UpdateScoreText(_score); // Play the collect sound effect. Core.Audio.PlaySoundEffect(_collectSoundEffect); } // Next check if the slime is colliding with the wall by validating if // it is within the bounds of the room. If it is outside the room // bounds, then it collided with a wall which triggers a game over. if (slimeBounds.Top < _roomBounds.Top || slimeBounds.Bottom > _roomBounds.Bottom || slimeBounds.Left < _roomBounds.Left || slimeBounds.Right > _roomBounds.Right) { GameOver(); return; } // Finally, check if the bat is colliding with a wall by validating if // it is within the bounds of the room. If it is outside the room // bounds, then it collided with a wall, and the bat should bounce // off of that wall. if (batBounds.Top < _roomBounds.Top) { _bat.Bounce(Vector2.UnitY); } else if (batBounds.Bottom > _roomBounds.Bottom) { _bat.Bounce(-Vector2.UnitY); } if (batBounds.Left < _roomBounds.Left) { _bat.Bounce(Vector2.UnitX); } else if (batBounds.Right > _roomBounds.Right) { _bat.Bounce(-Vector2.UnitX); } } This method checks for three types of collisions: Slime-Bat collision: The slime \"eats\" the bat, gains points, grows, and the bat respawns. Slime-Wall collision: Triggers a game over if the slime hits a wall. Bat-Wall collision: Causes the bat to bounce off the walls. GameScene PositionBatAwayFromSlime Method The CollisionCheck method makes a call to PositionBatAwayFromSlime, previously, when we needed to set the position of the bat when it respawns, we simply chose a random tile within the tilemap to move it to. However, by choosing a completely random location it could be on top fo the head segment of the slime, forcing an instant collision, or it could spawn very close to the head segment, which is not challenging for the player. To ensure the bat appears in a random, but strategic location, we can instead set it to position away from the slime on the opposite side of the room. Add the following method to the GameScene class after the CollisionCheck method: private void PositionBatAwayFromSlime() { // Calculate the position that is in the center of the bounds // of the room. float roomCenterX = _roomBounds.X + _roomBounds.Width * 0.5f; float roomCenterY = _roomBounds.Y + _roomBounds.Height * 0.5f; Vector2 roomCenter = new Vector2(roomCenterX, roomCenterY); // Get the bounds of the slime and calculate the center position. Circle slimeBounds = _slime.GetBounds(); Vector2 slimeCenter = new Vector2(slimeBounds.X, slimeBounds.Y); // Calculate the distance vector from the center of the room to the // center of the slime. Vector2 centerToSlime = slimeCenter - roomCenter; // Get the bounds of the bat. Circle batBounds =_bat.GetBounds(); // Calculate the amount of padding we will add to the new position of // the bat to ensure it is not sticking to walls int padding = batBounds.Radius * 2; // Calculate the new position of the bat by finding which component of // the center to slime vector (X or Y) is larger and in which direction. Vector2 newBatPosition = Vector2.Zero; if (Math.Abs(centerToSlime.X) > Math.Abs(centerToSlime.Y)) { // The slime is closer to either the left or right wall, so the Y // position will be a random position between the top and bottom // walls. newBatPosition.Y = Random.Shared.Next( _roomBounds.Top + padding, _roomBounds.Bottom - padding ); if (centerToSlime.X > 0) { // The slime is closer to the right side wall, so place the // bat on the left side wall. newBatPosition.X = _roomBounds.Left + padding; } else { // The slime is closer ot the left side wall, so place the // bat on the right side wall. newBatPosition.X = _roomBounds.Right - padding * 2; } } else { // The slime is closer to either the top or bottom wall, so the X // position will be a random position between the left and right // walls. newBatPosition.X = Random.Shared.Next( _roomBounds.Left + padding, _roomBounds.Right - padding ); if (centerToSlime.Y > 0) { // The slime is closer to the top wall, so place the bat on the // bottom wall. newBatPosition.Y = _roomBounds.Top + padding; } else { // The slime is closer to the bottom wall, so place the bat on // the top wall. newBatPosition.Y = _roomBounds.Bottom - padding * 2; } } // Assign the new bat position. _bat.Position = newBatPosition; } This method positions the bat after it has been eaten: Determines which wall (top, bottom, left, or right) is furthest from the slime. Places the bat near that wall, making it more challenging for the player to reach. GameScene Event Handler and Game State Methods Next, we will add some of the missing methods being called from above that handle game events and state changes. Add the following methods to the GameScene class after the PositionBatAwayFromSlime method: private void OnSlimeBodyCollision(object sender, EventArgs args) { GameOver(); } private void TogglePause() { if (_state == GameState.Paused) { // We're now unpausing the game, so hide the pause panel. _ui.HidePausePanel(); // And set the state back to playing. _state = GameState.Playing; } else { // We're now pausing the game, so show the pause panel. _ui.ShowPausePanel(); // And set the state to paused. _state = GameState.Paused; } } private void GameOver() { // Show the game over panel. _ui.ShowGameOverPanel(); // Set the game state to game over. _state = GameState.GameOver; } These methods handle specific game events: OnSlimeBodyCollision: Called when the slime collides with itself, triggering a game over. TogglePause: Switches between paused and playing states. GameOver: Called when a game over condition is met, showing the game over UI. GameScene Draw Method Finally, we need a method to draw the scene. Add the following method to the GameScene class after the GameOver method. public override void Draw(GameTime gameTime) { // Clear the back buffer. Core.GraphicsDevice.Clear(Color.CornflowerBlue); // Begin the sprite batch to prepare for rendering. Core.SpriteBatch.Begin(samplerState: SamplerState.PointClamp); // Draw the tilemap _tilemap.Draw(Core.SpriteBatch); // Draw the slime. _slime.Draw(); // Draw the bat. _bat.Draw(); // Always end the sprite batch when finished. Core.SpriteBatch.End(); // Draw the UI. _ui.Draw(); } This method handles drawing the scene by: Clearing the screen. Drawing the tilemap as the background. Drawing the slime and bat sprites. Drawing the UI elements on top. By refactoring our game into these encapsulated components, we have created a more maintainable codebase with a clear separation of concerns: The Slime class handles snake-like movement and growth. The Bat class manages its movement and bouncing. The GameSceneUI class manages all UI components. The GameScene class coordinates between these components and manages the game state. This architecture makes it easier to add new features or fix bugs, as changes to one component are less likely to affect others. Adding Input Buffering to the Slime Class The game at this point is now playable. If you test it out though, you may notice a small issue with inputs. As we discussed in Chapter 10, in games where movement updates happen at fixed intervals, inputs can sometimes feel unresponsive, especially when trying to make multiple inputs in succession. For instance, if a player wants to navigate a tight corner by pressing up and then immediately left, pressing these keys in rapid succession often results in only the second input being registered. When this happens, the slime will only continue left without first moving upward, missing the intended two-part movement completely. This occurs because the second input overwrites the first one before the game has a chance to process it, leading to frustrating gameplay. Implementing the input buffering technique we introduced in Chapter 10 aims to solve this problem in our Slime class. Implementing Input Buffering in the Slime Class For the Slime class, we will implement input buffering based on the example given using a Queue<T> in Chapter 10. In the GameObject folder of the DungeonSlime project (your main game project), open the Slime.cs file so we can make the changes. First, update the using statements at the top of the Slime class to add the System.Linq using statement: using System; using System.Collections.Generic; using System.Linq; using Microsoft.Xna.Framework; using MonoGameLibrary; using MonoGameLibrary.Graphics; Next, add the following fields to the Slime class after the _sprite field: // Buffer to queue inputs input by player during input polling. private Queue<Vector2> _inputBuffer; // The maximum size of the buffer queue. private const int MAX_BUFFER_SIZE = 2; The queue will store the directional vectors (up, down, left, right) that we will apply to the slime's movement in the order they were received. Next, we need to initialize the queue. In the Slime class, locate the Initialize method and and update it to the following: /// <summary> /// Initializes the slime, can be used to reset it back to an initial state. /// </summary> /// <param name=\"startingPosition\">The position the slime should start at.</param> /// <param name=\"stride\">The total number of pixels to move the head segment during each movement cycle.</param> public void Initialize(Vector2 startingPosition, float stride) { // Initialize the segment collection. _segments = new List<SlimeSegment>(); // Set the stride _stride = stride; // Create the initial head of the slime chain. SlimeSegment head = new SlimeSegment(); head.At = startingPosition; head.To = startingPosition + new Vector2(_stride, 0); head.Direction = Vector2.UnitX; // Add it to the segment collection. _segments.Add(head); // Set the initial next direction as the same direction the head is // moving. _nextDirection = head.Direction; // Zero out the movement timer. _movementTimer = TimeSpan.Zero; // initialize the input buffer. _inputBuffer = new Queue<Vector2>(MAX_BUFFER_SIZE); } Next we need to update the input handling method to store the inputs in the queue instead of immediately overwriting the _nextDirection field. In the Slime class, locate the HandleInput method and update it to the following: private void HandleInput() { Vector2 potentialNextDirection = Vector2.Zero; if (GameController.MoveUp()) { potentialNextDirection = -Vector2.UnitY; } else if (GameController.MoveDown()) { potentialNextDirection = Vector2.UnitY; } else if (GameController.MoveLeft()) { potentialNextDirection = -Vector2.UnitX; } else if (GameController.MoveRight()) { potentialNextDirection = Vector2.UnitX; } // If a new direction was input, consider adding it to the buffer if (potentialNextDirection != Vector2.Zero && _inputBuffer.Count < MAX_BUFFER_SIZE) { // If the buffer is empty, validate against the current direction; // otherwise, validate against the last buffered direction Vector2 validateAgainst = _inputBuffer.Count > 0 ? _inputBuffer.Last() : _segments[0].Direction; // Only allow direction change if it is not reversing the current // direction. This prevents th slime from backing into itself float dot = Vector2.Dot(potentialNextDirection, validateAgainst); if (dot >= 0) { _inputBuffer.Enqueue(potentialNextDirection); } } } The potentialNewDirection is now given the initial value of Vector2.Zero. A check is made to see if the player has pressed a direction key and if the input buffer is not already at maximum capacity. If a new direction key is pressed and the buffer has space: The validation is made using Vector2.Dot just like before to ensure it is a valid direction If it is a valid direction, then it is added to the queue. Finally, we need to modify how we apply the movement direction during the movement update cycle. In the Slime class, locate the Move method and update it to the following: private void Move() { // Get the next direction from the input buffer if one is available if (_inputBuffer.Count > 0) { _nextDirection = _inputBuffer.Dequeue(); } // Capture the value of the head segment SlimeSegment head = _segments[0]; // Update the direction the head is supposed to move in to the // next direction cached. head.Direction = _nextDirection; // Update the head's \"at\" position to be where it was moving \"to\" head.At = head.To; // Update the head's \"to\" position to the next tile in the direction // it is moving. head.To = head.At + head.Direction * _stride; // Insert the new adjusted value for the head at the front of the // segments and remove the tail segment. This effectively moves // the entire chain forward without needing to loop through every // segment and update its \"at\" and \"to\" positions. _segments.Insert(0, head); _segments.RemoveAt(_segments.Count - 1); // Iterate through all of the segments except the head and check // if they are at the same position as the head. If they are, then // the head is colliding with a body segment and a body collision // has occurred. for (int i = 1; i < _segments.Count; i++) { SlimeSegment segment = _segments[i]; if (head.At == segment.At) { if (BodyCollision != null) { BodyCollision.Invoke(this, EventArgs.Empty); } return; } } } The key change here is that we now dequeue a direction from the input buffer rather than directly using the _nextDirection value. This ensures we process inputs in the order they were received, preserving the player's intent. With these changes in place, our game now supports input buffering. This small enhancement improves how the game feels to play, particularly when making rapid directional changes. Players will notice: When navigating a corner, they can quickly press up followed by left (or any other valid combination), and both inputs will be respected The game feels more responsive since it remembers inputs between movement update cycles Complex maneuvers are easier to execute since timing is more forgiving The difference might seem subtle, but it significantly reduces frustration during gameplay. Putting It All Together With all of these components now in place, our Dungeon Slime game has transformed from a simple demo built on learning MonoGame concepts into a complete snake-like game experience. The player controls the slime that moves through the dungeon, consuming bats to grow longer. If the slime collides with the wall or its own body, the game ends. Now we can see how it all looks and plays: Figure 23-1: Gameplay demonstration of the completed Dungeon Slime game showing the snake-like slime growing as it eats bats and a game over when colliding with the wall The game starts with a single slime segment in the center of the room. The player controls the direction of the slime by using the keyboard (arrow keys or WASD) or by using a game pad (DPad or left thumbstick). The slime moves at regular intervals, creating a grid-based movement pattern. When the slime eats a bat, it grows longer by adding a new segment to its tail. The bat respawns at a strategic location after being eaten. The player's score increases with each bat consumed. If the slime collides with a wall or its own body, the game over panel appears. On the game over panel, the player can choose to retry or return to the title scene. With these mechanics implemented, Dungeon Slime is now a complete game with clear objectives, escalating difficulty, and a game feedback loop. Conclusion In this chapter, we have transformed our technical demo into a complete game by integrating UI systems with game mechanics. We have accomplished several important goals: Created a dedicated GameSceneUI class to manage the game's user interface. Implemented pause and game over screens that provide clear feedback to the player. Refactored the GameScene class to coordinate all game components. Added game state management to handle different gameplay conditions. Enhanced player control through input buffering for more responsive gameplay. Connected all of the elements to create a complete playable game. The refactoring process we undertook demonstrates an important game development principle: separating concerns into specialized components makes code more maintainable and easier to extend. The Slime class manages snake-like behavior, the Bat class handles movement and collision response, and the GameSceneUI class encapsulates all UI-related functionality. Test Your Knowledge How does the game handle different states (playing, paused, game over), and why is this state management important? :::question-answer The game uses an enum (GameState) to track its current state and implements different behavior based on that state: During the Playing state, the game updates all objects and checks for collisions During the Paused state, the game shows the pause menu and stops updating game objects During the GameOver state, the game shows the game over menu and prevents further gameplay This state management is important because it: Prevents inappropriate updates during non-gameplay states Creates a clear flow between different game conditions Simplifies conditional logic by using explicit states rather than multiple boolean flags Makes the game's behavior more predictable and easier to debug ::: Why is it important to position the bat away from the slime after it has been eaten rather than at a completely random location? :::question-answer Positioning the bat away from the slime after it has been eaten rather than at a completely random location is important because: It prevents unfair situations where the bat might spawn right on top of the slime causing an immediate collision It creates a more strategic gameplay experience by forcing the player to navigate toward the bat It ensures the player faces an appropriate level of challenge that increases as the slime grows longer It prevents potential frustration from random spawns that might be either too easy or too difficult to reach It creates a more balanced and predictable game experience while still maintaining variety ::: What problem does input buffering solve and how does our implementation address it? :::question-answer Input buffering solves the timing disconnect between when players press buttons and when the game can actually process those inputs in games with fixed movement cycles. Without buffering, inputs that occur between movement cycles are lost, especially when players make rapid sequential inputs like navigating corners. Our implementation addresses this by: Using a queue data structure to store up to two directional inputs Processing inputs in First-In-First-Out order to preserve the player's intended sequence Validating each input against the previous one to prevent impossible movements :::"
  },
  "templates/docs.monogame.github.io/articles/tutorials/building_2d_games/24_shaders/index.html": {
    "href": "templates/docs.monogame.github.io/articles/tutorials/building_2d_games/24_shaders/index.html",
    "title": "Introduction to Shaders | hallowed",
    "summary": "In the previous chapters, we have built a complete snake-style game with animations, collision detection, audio, and scene management. While our game is fully functional, we can enhance the visual experience by implementing special effects to provide additional feedback to players. One powerful way to create these effects is through shaders. In this chapter, you will: Understand what shaders are and how they function in MonoGame. Learn about different types of shaders including vertex and pixel shaders. Explore shader models and cross-platform considerations. Analyze the default shader template used in MonoGame. Create a custom grayscale shader for visual feedback. Important This chapter is an introduction to shaders in MonoGame and will focus on the basic foundation of understanding how to create shader effect (.fx) files, loading them through the content pipeline, and using them in your game. If you want to learn more about the shader language itself, a good place to start would be the High-level shader language (HLSL) documentation on Microsoft Learn. For inspiration on what can be achieved with shaders, check out ShaderToy, which showcases real-time shader effects created by others. Note that ShaderToy uses OpenGL Shading Language (GLSL) which has some syntactic differences from HLSL, but the underlying concepts and mathematics are very similar. We can begin by understanding what shaders are and how they work in MonoGame. Understanding Shaders Shaders are small programs that run directly on your graphics card (GPU) instead of your computer's main processor (CPU). While traditional game code runs on the CPU and handles things like game logic and physics, shaders run on the GPU and focus specifically on how things are drawn to the screen. This separation allows for efficient processing and enables visual effects that would be too performance-intensive to calculate on the CPU. Think of shaders as special instructions that tell your GPU exactly how to display each pixel or transform each vertex in your game. By customizing these instructions, you can create a wide variety of visual effects without having to change your original artwork. Types of Shaders There are two main types of shaders that you will work with in MonoGame: Vertex Shaders Vertex shaders process the corners (vertices) of the shapes that make up your game objects. They determine where these points should be positioned on the screen and can manipulate their positions to create effects like: Waves or ripples in water Swaying grass or trees Character deformation for animations Vertex shaders are especially important in 3D games, but they can also be used in 2D games for special effects that involve moving or distorting sprite positions. Note Even in 2D games like ours, MonoGame actually draws sprites by mapping textures onto simple 3D shapes called quads (rectangles made of two triangles). Each quad has four vertices, one at each corner. While we do not normally think about these vertices in 2D development, they are still there behind the scenes, and vertex shaders process them before rendering. Pixel Shaders Pixel shaders (also sometimes called fragment shaders) determine the actual color of each pixel that gets drawn to the screen. After the GPU figures out which pixels need to be drawn based on your geometry, the pixel shader calculates the final color for each of those pixels. Pixel shaders are useful in 2D games for creating effects like: Color adjustments (brightness, contrast, saturation) Visual filters (grayscale, sepia, negative) Special transitions (fades, dissolves, color shifts) Dynamic lighting effects For our Dungeon Slime game, we will focus primarily on pixel shaders since we want to create a color effect for our game over state. Note There are other types of shaders beyond vertex and pixel shaders, such as compute shaders, geometry shaders, and hull/domain shaders. These more advanced shader types enable powerful features like physics simulations, procedural geometry, and complex post-processing effects. However, they are not currently supported in the standard MonoGame implementation and are beyond the scope of this beginner tutorial. As the MonoGame graphics pipeline evolves, support for these advanced shader types may be added in future versions. The Shader Pipeline To understand how shaders work, it helps to visualize how data flows through the rendering pipeline. Figure 24-1: Basic shader pipeline showing how data flows through the rendering process This diagram illustrates the fundamental steps of the shader pipeline: Input Data: The process begins with input data that is sent to the GPU to render: Vertex Data: The vertex data (positions, colors, etc.) that define the geometry of what is being drawn. Texture: The image data that will be applied to the geometry. Vertex Shader: Processes each vertex, calculating its final position on the screen and passing the data to the next stage. Sampler: Controls how texture data is accessed, applying filtering (how pixels blend when scaled) and addressing (what happens at texture edges). Pixel Shader: Takes the transformed vertices and sampled texture data to calculate the final color of each pixel. Output: The final rendered image that appears on your screen. Note When working with SpriteBatch (2D) in MonoGame, the framework handles most of the vertex shader work automatically, which is why we will focus primarily on writing pixel shaders for visual effects. Shader Languages and Cross-Platform Considerations MonoGame uses the High-Level Shader Language (HLSL) for writing shader effects. HLSL is a C-like programming language developed by Microsoft for DirectX. As MonoGame also supports OpenGL which uses the OpenGL Shading Language (GLSL) instead of DirectX as it needs a way to make shaders work everywhere. This is where MojoShader comes in. MojoShader is a library that automatically translates your HLSL shader code into whatever format the target platform requires (like GLSL for OpenGL platforms), this translation happens during the content build process when you compile your game. Shader Models and Compatibility Different platforms support different shader capabilities, known as \"shader profiles.\" (Also known as \"Shader Models\" in some circles). When writing shaders for MonoGame, you need to consider compatibility across platforms. MonoGame supports the following shader models when targeting DirectX platforms: Vertex Shader Profile Pixel Shader Profile vs_4_0_level_9_1 ps_4_0_level_9_1 vs_4_0_level_9_3 ps_4_0_level_9_3 vs_4_0 ps_4_0 vs_4_1 ps_4_1 vs_5_0 ps_5_0 When targeting OpenGL platforms, MonoGame supports: Vertex Shader Profile Pixel Shader Profile vs_2_0 ps_2_0 vs_3_0 ps_3_0 For maximum compatibility, it is best to target the following shader models: For DirectX platforms: vs_4_0_level_9_1 (vertex) and ps_4_0_level_9_1 (pixel) For OpenGL platforms: vs_3_0 (vertex) and ps_3_0 (pixel) Note In shader model notation, \"vs\" stands for \"vertex shader\" and \"ps\" stands for \"pixel shader\". The numbers represent the version and feature level of the shader model, with higher numbers indicating more advanced capabilities. Note MonoGame is currently planning to upgrade its graphics pipeline to support Vulkan and DirectX 12, which will significantly enhance graphical capabilities and shader support across platforms, enabling more advanced visual effects and better performance in future versions. Understanding the Default Shader Template When you create a new Sprite Effect (.fx) file in MonoGame using the MGCB Editor, it generates a default template file. To get a feel for the language used in shaders we can use this template to understand the foundation that we will build upon: #if OPENGL #define SV_POSITION POSITION #define VS_SHADERMODEL vs_3_0 #define PS_SHADERMODEL ps_3_0 #else #define VS_SHADERMODEL vs_4_0_level_9_1 #define PS_SHADERMODEL ps_4_0_level_9_1 #endif Texture2D SpriteTexture; sampler2D SpriteTextureSampler = sampler_state { Texture = <SpriteTexture>; }; struct VertexShaderOutput { float4 Position : SV_POSITION; float4 Color : COLOR0; float2 TextureCoordinates : TEXCOORD0; }; float4 MainPS(VertexShaderOutput input) : COLOR { return tex2D(SpriteTextureSampler,input.TextureCoordinates) * input.Color; } technique SpriteDrawing { pass P0 { PixelShader = compile PS_SHADERMODEL MainPS(); } }; Breaking down what each section of this template we can see: Platform compatibility defines: The first block created defines for different shader model versions based on the target platform the shader gets compiled for (OpenGL vs DirectX). #if OPENGL #define SV_POSITION POSITION #define VS_SHADERMODEL vs_3_0 #define PS_SHADERMODEL ps_3_0 #else #define VS_SHADERMODEL vs_4_0_level_9_1 #define PS_SHADERMODEL ps_4_0_level_9_1 #endif Important These preprocessor directives ensure your shader works across different platforms by defining appropriate shader models and semantics. When MonoGame compiles your shader: On OpenGL platforms (macOS, Linux, etc.), it uses the OPENGL definition, setting shader models to vs_3_0 and ps_3_0. On DirectX platforms (Windows, Xbox), it uses the DirectX path, setting shader models to vs_4_0_level_9_1 and ps_4_0_level_9_1. This compatibility block directly impacts which HLSL features you can use in your shader. To maintain cross-platform compatibility, you should restrict yourself to features available at the lowest shader model you target. Using advanced features only available in higher shader models will require additional conditional compilation blocks and platform-specific code paths. Texture declaration: This declares a Texture2D variable called SpriteTexture that will receive the texture being drawn by the SpriteBatch. Texture2D SpriteTexture; Sampler state: This creates a sampler2D called SpriteTextureSampler that controls how the shader reads pixel data from the texture received from the SpriteBatch. It defines properties like filtering and addressing modes for texture sampling, similar to the SamplerState we discussed in Chapter 18. sampler2D SpriteTextureSampler = sampler_state { Texture = <SpriteTexture>; }; Vertex shader output structure: This defines a struct called VertexShaderOutput with three fields; Position, Color, and TextureCoordinates. This struct represents the data that is passed from the Vertex Shader function to the Pixel Shader function. struct VertexShaderOutput { float4 Position : SV_POSITION; float4 Color : COLOR0; float2 TextureCoordinates : TEXCOORD0; }; This struct defines the passing of: The position of the vertex in homogeneous coordinates (x, y, z, w). The RGBA color of the vertex. The UV coordinates for texture mapping. Tip Notice the unusual syntax like float4 Position : SV_POSITION where there is a colon followed by something after each variable declaration. These are called semantics in HLSL and they are special labels that define how the data should be used by the graphics hardware or passed between shader stages (like from vertex shader to pixel shader). For example, SV_POSITION tells the system \"this contains the final screen position,\" COLOR0 means \"this contains color data,\" and TEXCOORD0 means \"this contains texture coordinates.\" Semantics are required in HLSL to connect your shader variables with the graphics pipeline. Without them, the GPU would not know what each piece of data represents or how to use it correctly. Pixel shader function: MainPS is the main Pixel Shader function that determines the color of each pixel. The default implementation simply samples the texture at the current texture coordinates and multiplies it by the vertex color, which is the color value supplied in the SpriteBatch.Draw method call. float4 MainPS(VertexShaderOutput input) : COLOR { return tex2D(SpriteTextureSampler,input.TextureCoordinates) * input.Color; } Technique and pass: This block defines a technique called SpriteDrawing with a single pass called P0. The pass itself defines which shader functions to use. technique SpriteDrawing { pass P0 { PixelShader = compile PS_SHADERMODEL MainPS(); } }; Note You may have noticed that the default shader does not define a vertex shader method that would execute and return back the VertexShaderOutput value that is used as the input for the Pixel Shader function. When you are using SpriteBatch, MonoGame uses a built-in vertex shader under the hood that executes and creates this value to pass to the pixel shader function. Understanding Techniques and Passes The technique and pass sections might seem a bit confusing at first, but they are actually quite straightforward: A technique is like a recipe for rendering something. Each technique has a name (in this case SpriteDrawing) and contains one or more passes. A pass is a single step in that recipe. For simple effects, you often need just one pass (which is why the template only has P0), but more complex effects might use multiple passes to build up a final result. Think of it like baking a cake: The technique is the overall cake recipe. Each pass is a step in that recipe (mix ingredients, bake, add frosting, etc). In simple shaders, such as a grayscale shader, you would only need one technique with one pass. For more complex effects like blur, you might use multiple passes: one to blur horizontally and another to blur vertically. Tip For a real-world example of a blur shader with multiple techniques and passes, take a look at the Blur shader from the MonoGme Ship Game sample. This shader demonstrates how visual effects can be built by combining multiple rendering passes, with separate horizontal and vertical blur passes that work together to create a final blur effect. The line PixelShader = compile PS_SHADERMODEL MainPS(); simply tells the GPU which pixel shader function to use for this pass (in this case the MainPS function) and compiles it using the appropriate shader model defined earlier. Using Shaders in MonoGame Now that we understand what shaders are, we can explore how to integrate them into a MonoGame project. Before implementing a shader in our game, we will first take a look at the process of loading and using shaders with SpriteBatch. To understand, we will start with a basic example (not for the game itself): Loading Shader Effects Like other game assets such as textures and sounds, shader effects are loaded through the content pipeline using the ContentManager. When loading a shader, we specify Effect as the target type. // Example of loading an effect Effect exampleEffect = Content.Load<Effect>(\"exampleEffect\"); You should typically load shader effects during your game's LoadContent method along with other game assets, and store them in class fields so they can be accessed during the Draw method. Using Effects With SpriteBatch Once you have loaded a shader effect, applying it to your game's visuals requires integrating it with the SpriteBatch. The effect is specified during the Begin call, but is actually applied during drawing operations or when End is called (depending on the SpriteSortMode). // Specify the effect during Begin spriteBatch.Begin(effect: exampleEffect); // The effect will be applied when these draw calls are processed spriteBatch.Draw(exampleTexture, texturePosition, Color.White); spriteBatch.DrawString(exampleFont, \"Hello World\", textPosition, Color.White); // For most SpriteSortMode values, actual drawing with the effect happens here spriteBatch.End(); Setting Effect Parameters Most shader effects have parameters that you can adjust to control their behavior. For example, the shader we will create for our game will have a Saturation parameter. You should set these parameters before the actual drawing occurs: // Update the parameter value exampleEffect.Parameters[\"Saturation\"].SetValue(0.5f); // Specify the effect during Begin spriteBatch.Begin(effect: exampleEffect); // Draw calls will use the effect with Saturation = 0.5f when processed Implementing a Shader In Our Game Now it is time to implement a shader for our game. The shader we will create is a simple grayscale effect that can be applied when the game is paused or there is a game over to provide visual feedback to the player that the game is inactive, the background will become grey offsetting the color of the Pause menu or other prompt. Creating the Shader File First, we need to create a new shader effect file and add it to our content project. In the DungeonSlime project (your main game project), open the /Content/Content.mgcb content project file in the MGCB Editor. In the MGCB Editor, right-click the Content now and choose Add > New Folder.... Give the new folder the name effects and click the Ok button. Right-click on the new effects folder in the MGCB Editor and choose Add > New Item.... Choose Sprite Effect (.fx) from the type list and name the file grayscaleEffect, then click the Ok button. Save the changes in the MGCB Editor then close it. The steps above will create a new shader effect (.fx) file with the default template we discussed earlier. Now, we need to modify this template to create our grayscale effect. Writing the Grayscale Shader In the DungeonSlime project (your main game project), open the Content/effects/grayscaleEffect.fx file that we just created in your code editor and modify it as follows: #if OPENGL #define SV_POSITION POSITION #define VS_SHADERMODEL vs_3_0 #define PS_SHADERMODEL ps_3_0 #else #define VS_SHADERMODEL vs_4_0_level_9_1 #define PS_SHADERMODEL ps_4_0_level_9_1 #endif Texture2D SpriteTexture; // A value between 0 and 1 that controls the intensity of the grayscale effect. // 0 = full color, 1 = full grayscale. float Saturation = 1.0; sampler2D SpriteTextureSampler = sampler_state { Texture = <SpriteTexture>; }; struct VertexShaderOutput { float4 Position : SV_POSITION; float4 Color : COLOR0; float2 TextureCoordinates : TEXCOORD0; }; float4 MainPS(VertexShaderOutput input) : COLOR { // Sample the texture float4 color = tex2D(SpriteTextureSampler, input.TextureCoordinates) * input.Color; // Calculate the grayscale value based on human perception of colors. float grayscale = dot(color.rgb, float3(0.3, 0.59, 0.11)); // create a grayscale color vector (same value for R, G, and B) float3 grayscaleColor = float3(grayscale, grayscale, grayscale); // Linear interpolation between he grayscale color and the original color's // rgb values based on the saturation parameter. float3 finalColor = lerp(grayscale, color.rgb, Saturation); // Return the final color with the original alpha value. return float4(finalColor, color.a); } technique SpriteDrawing { pass P0 { PixelShader = compile PS_SHADERMODEL MainPS(); } }; The key modifications made to create this grayscale effect include: Added a Parameter: A Saturation parameter was added that controls the intensity of the grayscale effect. When set to 0, the image will be fully grayscale. When set to 1, the image will be its original color. Values in between create a partial grayscale effect. Modified the Pixel Shader: The MainPS function has been updated to: Sample the original color from the texture. Calculate a grayscale value by taking a weighted average of the RGB components. Create a grayscale color vector from this single brightness value. Use lerp (linear interpolation) to blend between the grayscale and original color's rgb values based on the Saturation parameter. Preserve the original alpha (transparency) value. Output the new color value with the grayscale effect for the pixel. Understanding the Shader Code The heart of the grayscale effect is this line: // Calculate the grayscale value based on human perception of colors. float grayscale = dot(color.rgb, float3(0.3, 0.59, 0.11)); This uses the dot function to calculate the dot product between the color's RGB values and the vector \\((0.3, 0.59, 0.11)\\). This effectively calculates a weighted average where: Red contributes 30%. Green contributes 59%. Blue contributes 11%. Note These specific weights are based on how the human eye perceives brightness in different colors. Green appears brighter to us than red, which appears brighter than blue. The weighted values themselves are based on the formula that represents the luma component from the ITU-R BT.601 standard, which is commonly used for converting RGB images to grayscale based on human perception where: \\(Y'_{601} = 0.299R' + 0.587G' + 0.114B'\\) By using these weights, we get a natural looking grayscale conversion. Then, we use linear interpolation with the lerp function to blend between this grayscale value and the original color's RGB values: // Linear interpolation between he grayscale color and the original color's // rgb values based on the saturation parameter. float3 finalColor = lerp(grayscale, color.rgb, Saturation); The lerp function blends between the first two parameters based on the third parameter (Saturation). When Saturation is 0, we get full grayscale, when it is 1, we get the original color. Implementing the Grayscale Shader Now that we have our grayscale shader, we can implement it in our game when the game is paused or a game over state occurs. In the DungeonSlime project (your main game project), open the Scenes/GameScene.cs file and perform the following: First, add these fields to the GameScene class after the private GameState _state property: // The grayscale shader effect. private Effect _grayscaleEffect; // The amount of saturation to provide the grayscale shader effect. private float _saturation = 1.0f; // The speed of the fade to grayscale effect. private const float FADE_SPEED = 0.02f; Next, update the LoadContent method to load the grayscale shader: public override void LoadContent() { // Create the texture atlas from the XML configuration file. TextureAtlas atlas = TextureAtlas.FromFile(Core.Content, \"images/atlas-definition.xml\"); // Create the tilemap from the XML configuration file. _tilemap = Tilemap.FromFile(Content, \"images/tilemap-definition.xml\"); _tilemap.Scale = new Vector2(4.0f, 4.0f); // Create the animated sprite for the slime from the atlas. AnimatedSprite slimeAnimation = atlas.CreateAnimatedSprite(\"slime-animation\"); slimeAnimation.Scale = new Vector2(4.0f, 4.0f); // Create the slime. _slime = new Slime(slimeAnimation); // Create the animated sprite for the bat from the atlas. AnimatedSprite batAnimation = atlas.CreateAnimatedSprite(\"bat-animation\"); batAnimation.Scale = new Vector2(4.0f, 4.0f); // Load the bounce sound effect for the bat. SoundEffect bounceSoundEffect = Content.Load<SoundEffect>(\"audio/bounce\"); // Create the bat. _bat = new Bat(batAnimation, bounceSoundEffect); // Load the collect sound effect. _collectSoundEffect = Content.Load<SoundEffect>(\"audio/collect\"); // Load the grayscale effect. _grayscaleEffect = Content.Load<Effect>(\"effects/grayscaleEffect\"); } Next, update the TogglePause method so that when the game is paused, it sets the saturation value to 1.0f: private void TogglePause() { if (_state == GameState.Paused) { // We're now unpausing the game, so hide the pause panel. _ui.HidePausePanel(); // And set the state back to playing. _state = GameState.Playing; } else { // We're now pausing the game, so show the pause panel. _ui.ShowPausePanel(); // And set the state to paused. _state = GameState.Paused; // Set the grayscale effect saturation to 1.0f _saturation = 1.0f; } } We also need to update the GameOver method so that when a game over state occurs, it sets the saturation value to 1.0f: private void GameOver() { // Show the game over panel. _ui.ShowGameOverPanel(); // Set the game state to game over. _state = GameState.GameOver; // Set the grayscale effect saturation to 1.0f _saturation = 1.0f; } Next, modify the Update method to handle the grayscale transition: public override void Update(GameTime gameTime) { // Ensure the UI is always updated. _ui.Update(gameTime); if (_state != GameState.Playing) { // The game is in either a paused or game over state, so // gradually decrease the saturation to create the fading grayscale. _saturation = Math.Max(0.0f, _saturation - FADE_SPEED); // If its just a game over state, return back. if (_state == GameState.GameOver) { return; } } // If the pause button is pressed, toggle the pause state. if (GameController.Pause()) { TogglePause(); } // At this point, if the game is paused, just return back early. if (_state == GameState.Paused) { return; } // Update the slime. _slime.Update(gameTime); // Update the bat. _bat.Update(gameTime); // Perform collision checks. CollisionChecks(); } Finally, update the Draw method to apply the shader when the game is paused or in a game over state: public override void Draw(GameTime gameTime) { // Clear the back buffer. Core.GraphicsDevice.Clear(Color.CornflowerBlue); if (_state != GameState.Playing) { // We are in a game over state, so apply the saturation parameter. _grayscaleEffect.Parameters[\"Saturation\"].SetValue(_saturation); // And begin the sprite batch using the grayscale effect. Core.SpriteBatch.Begin(samplerState: SamplerState.PointClamp, effect: _grayscaleEffect); } else { // Otherwise, just begin the sprite batch as normal. Core.SpriteBatch.Begin(samplerState: SamplerState.PointClamp); } // Draw the tilemap _tilemap.Draw(Core.SpriteBatch); // Draw the slime. _slime.Draw(); // Draw the bat. _bat.Draw(); // Always end the sprite batch when finished. Core.SpriteBatch.End(); // Draw the UI. _ui.Draw(); } Note Notice how we set the shader parameters with the current saturation value every frame before beginning the sprite batch. This is because shaders are stateless; they do not remember any values from the previous draw cycle. Each time the GPU processes a shader, it only works with the parameters provided in that specific frame. Even if the saturation value has not changed since the last frame, we still need to send it to the shader again to apply it. This is why we constantly update the shader parameters in the Draw method rather than only when the value is changed. With these changes, when the game enters a paused or game over state, the screen will gradually fade to gray using the grayscale shader effect. This provides a clear indication that the game is inactive during these states. Figure 24-2: The game, now using a grayscale effect when paused or a game over state occurs to visually indicate that the game is inactive Important Considerations When working with effects in SpriteBatch, there are some important points to keep in mind: Only one effect can be applied to a SpriteBatch.Begin/SpriteBatch.End at a time. If you need to use multiple effects for different sprites, you will need multiple SpriteBatch.Begin/SpriteBatch.End blocks. // Begin sprite batch with effect. All draw calls made within this begin/end block will have the effect applied. spriteBatch.Begin(effect: exampleEffect1) spriteBatch.Draw(texture, position, color); spriteBatch.End(); // Begins sprite batch with a different effect. All draw calls made within this begin/end block will have the specified effect applied. spriteBatch.Begin(effect: exampleEffect2) spriteBatch.Draw(texture, position, color); spriteBatch.End(); Along with #1 above, if you want to be selective and only have the effect apply to some sprites and not others, you will still need to use multiple SpriteBatch.Begin/SpriteBatch.End blocks // Begin sprite batch with effect. All draw calls made within this begin/end block will have the specified effect applied. spriteBatch.Begin(effect: exampleEffect) spriteBatch.Draw(texture, position, color); spriteBatch.End(); // Begin sprite batch without effect so that draw calls made here have no effect applied. spriteBatch.Begin(); spriteBatch.Draw(texture, position, color); spriteBatch.End(); Even though the effect to use is specified during the SpriteBatch.Begin call, the actual effect is not applied until all batched items are processed when SpriteBatch.End is called. This means if you adjust parameter values of the effect between draw calls, only the last parameter value set is what is applied to all draw calls within the SpriteBatch.Begin. // Begin sprite batch with effect. // Specifying the effect here is only specifying what effect to apply when batching ends spriteBatch.Begin(effect: exampleEffect); // Change a parameter and draw something exampleEffect.Parameters[\"ExampleParameter\"].SetValue(1.0f); spriteBatch.Draw(texture1, position, color); // Change the parameter to a different value and draw something else. exampleEffect.Parameters[\"ExampleParameter\"].SetValue(0.5f); spriteBatch.Draw(texture2, position, color); // The actual effect is applied to the draw calls here, when End is called. // This means the value of the parameter that will be used in the effect // is the last parameter value set (0.5f) which will be applied to both // draw calls instead of each of them having different parameter values. spriteBatch.End(); There is an exception to #2 above. In Chapter 06: Working with Textures, we discussed the different SpriteSortMode values that can be used when rendering. From this chapter, we learned that when using SpriteSortMode.Immediate that when a draw call is made, it is immediately flushed to the GPU and rendered to the screen, ignoring batching. This means that if you are using SpriteSortMode.Immediate then changing parameters between draw calls will apply the parameter change after it is made for the next draw call. Important As mentioned in Chapter 06, SpriteSortMode.Immediate can cause performance issues and should only be used when absolutely necessary, as Immediate mode effectively disables batching. // Begins sprite batch with the effect AND intentionally specifying SpriteSortMode.Immediate spriteBatch.Begin(effect: exampleEffect, sortMode: SpriteSortMode.Immediate); // Change a parameter and draw something. Since we are in immediate mode, the value of the parameter is used because the shader is immediately applied to the draw call. exampleEffect.Parameters[\"ExampleParameter\"].SetValue(1.0f); spriteBatch.Draw(texture1, position, color); // Change the parameter to something else. Since we are in immediate mode, the new value of the parameter is used because the shader is immediately applied to the draw call. exampleEffect.Parameters[\"ExampleParameter\"].SetValue(0.5f); spriteBatch.Draw(texture2, position, color); // Since immediate mode is used, batching is not performed so the effect was applied immediately on the draw calls above and not here during the end call. spriteBatch.End(); Conclusion This chapter explored the fundamentals of creating and adding a shader to MonoGame by implementing a grayscale shader effect. We covered several important concepts: Shaders are specialized programs that run directly on the GPU, allowing for efficient visual effects that would be too performance-intensive to calculate on the CPU. Effect parameters allow runtime control of shader behavior. In MonoGame, shaders are written in High-Level Shader Language (HLSL) and can be loaded through the content pipeline like other game assets. Pixel shaders determine the color of each rendered pixel, making them ideal for effects like our grayscale shader. The timing of the shader application depends on the SpriteSortMode used with SpriteBatch, with most effects being applied during the SpriteBatch.End call. While we only focused on a simple grayscale effect, the principles learned here can be used to start learning more about shaders and creating more complex visual effects. Test Your Knowledge What is the primary difference between pixel shaders and vertex shaders in the context of 2D games? :::question-answer Pixel shaders determine the color of each pixel being rendered, making them ideal for visual effects like grayscale, color tinting, and image filters. Vertex shaders manipulate the position of vertices, which can be used for effects like distortion, waves, or character deformation. In 2D games, pixel shaders are more commonly used for visual effects while vertex shaders are less frequently needed. ::: What function is used in the shader to blend between grayscale and the original color, and how does it work? :::question-answer The lerp function (linear interpolation) is used to blend between grayscale and original colors. It takes three parameters: the first is the grayscale color vector, the second is the original color's RGB values, and the third is the Saturation parameter (between 0 and 1). When Saturation is 0, the output is fully grayscale; when it is 1, the output is the original color; values in between create a partial blend of both. ::: Why can changing effect parameters between SpriteBatch.Draw calls sometimes not work as expected, and what is the exception to this? :::question-answer Changing effect parameters between draw calls typically does not work as expected because the effect is actually applied during SpriteBatch.End, not during the draw calls. The last parameter value set before end is applied to all draw calls in the batch. The exception is when using SpriteSortMode.Immediate, which causes each draw call to be processed immediately rather than batched, allowing parameter changes to be applied between individual draw calls. :::"
  },
  "templates/docs.monogame.github.io/articles/tutorials/building_2d_games/25_packaging_game/index.html": {
    "href": "templates/docs.monogame.github.io/articles/tutorials/building_2d_games/25_packaging_game/index.html",
    "title": "Chapter 25: Packaging Your Game for Distribution | hallowed",
    "summary": "After all of our work creating Dungeon Slime, we need to prepare the game for distribution to players. Properly packaging your game ensures it runs correctly on different platforms without requiring players to have development tools installed. In this chapter you will: Learn how to prepare your game for release. Package your game for Windows, macOS, and Linux platforms. Create platform-specific distributions with appropriate configurations. Understand important publishing parameters and their impact on game performance. Address common cross-platform distribution challenges. Learn about third-party tools that can automate the packaging process. Understanding Game Packaging When developing with MonoGame, you are working in a .NET environment that abstracts away many platform-specific details. However, when distributing your game to players, you need to ensure they can run it without installing the .NET runtime or other development dependencies. Self-Contained Deployments The recommended approach for distributing MonoGame games is to use self-contained deployments. This approach packages your game with all necessary .NET dependencies, resulting in a larger distribution but ensuring your game runs without requiring players install additional runtimes. A self-contained deployment offers several advantages: Players can run your game without installing the .NET runtime. Your game will always use the exact version of the runtime it was developed with. Distribution is simplified with fewer external dependencies. The main trade-off is a larger distribution size compared to framework-dependent deployments, but this is usually worth it for the improved player experience. Preparing Your Game for Release Before packaging your game for distribution, you should take some preparatory steps: Set Release Configuration: Ensure your build configuration is set to \"Release\" rather than \"Debug\" for better performance and smaller executable size. Update Game Information: Verify your game's title, version, and other information in the project's properties file (.csproj). Final Testing: Perform thorough testing in Release mode to catch any issues that might not appear in Debug mode. Asset Optimization: Consider optimizing larger content files to reduce the final package size. Platform-Specific Packaging Now that we understand the general packaging concepts, we will explore how to create distributions for Windows, macOS, and Linux. Each platform has specific requirements and tooling that we will need to navigate. Choose the instructions below based on the platform you are using. Important The packaging instructions for each platform are designed to be executed on that same platform. This is because each operating system provides specific tools needed for proper packaging (like lipo on macOS or permission settings on Unix-based systems). When building on Windows for macOS or Linux, the executable permissions cannot be set since Windows lacks these concepts. While you will need access to each platform for the steps below, do not worry if you do not have all these systems available. At the end of this chapter, third party libraries provided by MonoGame community members are included that can automate these processes for you without requiring you to own each type of machine. Windows macOS Linux Windows is the most straightforward platform to target since MonoGame development typically happens on Windows machines. Building for Windows To create a self-contained application for Windows, open a new command prompt window in the same folder as the main game project (in our case the folder with the DungeonSlime.csproj file) and execute the following .NET CLI command: dotnet publish -c Release -r win-x64 -p:PublishReadyToRun=false -p:TieredCompilation=false --self-contained This command specifies: -c Release: Builds in Release configuration for better performance. -r win-x64: Targets 64-bit Windows platforms. -p:PublishReadyToRun=false: Disables ReadyToRun compilation (explained later). -p:TieredCompilation=false: Disables Tiered Compilation (explained later). --self-contained: Includes the .NET runtime in the package. The output will be placed in a directory like bin/Release/net8.0/win-x64/publish/, relative to the game's .csproj file. This directory will contain the executable and all necessary files to run your game. Note If your base game project is created with dotnet 9.0 (which at the time of writing is the default), the above folder will be more like bin/Release/net9.0/win-x64/publish/, just so you are aware. Noting the change in folder from net8.0 to net9.0. Creating a Windows Distribution Once you have created a build for Windows, to create a Windows distribution, you can simply: Zip the entire contents of the publish folder. Distribute the ZIP file to your players. Players can extract the ZIP and run the executable directly. Note If you are using the WindowsDX platform target, players may need to install the DirectX June 2010 Runtime for audio and gamepad support. If you are targeting this platform, consider including this information in your game's documentation. Packaging for macOS requires creating an Application Bundle (.app), which is a directory structure that macOS recognizes as an application. Building for macOS For macOS, you will need to build for both the Intel (x64) and Apple Silicon (arm64) to support all modern Mac computers. Open a new terminal window in the same folder as the DungeonSlime.csproj file (the main game project). Tip The following sections will guide you through several terminal commands that build on each other. It is best to use a single terminal window located in your projects root directory (where the DungeonSlime.csproj file is) for all of these steps to ensure paths remain consistent. First, to create the Intel (x64) self contained application, execute the following .NET CLI command in the terminal: dotnet publish -c Release -r osx-x64 -p:PublishReadyToRun=false -p:TieredCompilation=false --self-contained This command specifies: -c Release: Builds in Release configuration for better performance. -r osx-x64: Targets Intel (x64) macOS platforms. -p:PublishReadyToRun=false: Disables ReadyToRun compilation (explained later). -p:TieredCompilation=false: Disables Tiered Compilation (explained later). --self-contained: Includes the .NET runtime in the package. The output from this command will be placed in a directory like bin/Release/net8.0/osx-x64/publish/, relative to the game's .csproj file. Note If your base game project is created with dotnet 9.0 (which at the time of writing is the default), the above folder will be more like bin/Release/net9.0/osx-x64/publish/, just so you are aware. Noting the change in folder from net8.0 to net9.0. Next, to create the Apple Silicon (arm64) self contained application for macOS, in the same terminal window, execute the following .NET CLI command: dotnet publish -c Release -r osx-arm64 -p:PublishReadyToRun=false -p:TieredCompilation=false --self-contained The only difference in this command is the use of -r osx-arm64 which specifies to target the Apple Silicon (arm64) macOS platform. The output from this command will be placed in a directory like bin/Release/net8.0/osx-arm64/publish/, relative to the game's .csproj file. Creating a macOS Application Bundle With the Intel (x64) and Apple Silicon (arm64) builds completed, we can now create the macOS Application Bundle. macOS applications follow a very specific directory structure: YourGame.app/ ├── Contents/ │ ├── Info.plist │ ├── MacOS/ │ │ └── YourGame │ └── Resources/ │ ├── Content/ │ └── YourGame.icns To create this structure, from the same terminal window: First, create the folder structure by executing the following commands: mkdir -p bin/Release/DungeonSlime.app/Contents/MacOS/ mkdir -p bin/Release/DungeonSlime.app/Contents/Resources/Content Note The mkdir -p command creates directories including any necessary parent directories. The -p flag ensures all intermediate directories are created without error if they do not exist yet. Copy all files from the Intel (x64) build to the MacOS directory. This ensures all the required dependencies are included. To do this, execute the following command: cp -R bin/Release/net8.0/osx-x64/publish/* bin/Release/DungeonSlime.app/Contents/MacOS/ Note This copies all files from the publish directory, including the executable, all dependent .dll files, and the Content directory that contains your game assets. Replace the executable with a universal binary that works on both Intel and Apple Silicon Macs. To do this, execute the following command: lipo -create bin/Release/net8.0/osx-arm64/publish/DungeonSlime bin/Release/net8.0/osx-x64/publish/DungeonSlime -output bin/Release/DungeonSlime.app/Contents/MacOS/DungeonSlime Note The lipo command is a macOS utility that works with multi-architecture binaries. Here, it combines the Intel (x64) and Apple Silicon (arm64) executables into a single \"universal binary\" that can run natively on both Apple Silicon and Intel processor based Macs. Move the Content directory from the MacOS directory to the Resources directory, following macOS application bundle conventions. To do this, execute the following command: mv bin/Release/DungeonSlime.app/Contents/MacOS/Content bin/Release/DungeonSlime.app/Contents/Resources/ Note This moves the Content directory to the expected location for resources in a macOS application bundles. Create a new file called Info.plist in the Contents directory of the application bundle with the following command: touch bin/Release/DungeonSlime.app/Contents/Info.plist Note The touch command creates an empty file if it does not exist or updates the modification time if it does exist. We are using it here to create a blank file that we will populate with content in the next step. Open the Info.plist file you just created in a text editor and add the following content to the file and save it. <?xml version=\"1.0\" encoding=\"UTF-8\"?> <!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"> <plist version=\"1.0\"> <dict> <key>CFBundleDevelopmentRegion</key> <string>en</string> <key>CFBundleExecutable</key> <string>DungeonSlime</string> <key>CFBundleIconFile</key> <string>DungeonSlime</string> <key>CFBundleIdentifier</key> <string>com.yourdomain.dungeonslime</string> <key>CFBundleInfoDictionaryVersion</key> <string>6.0</string> <key>CFBundleName</key> <string>DungeonSlime</string> <key>CFBundlePackageType</key> <string>APPL</string> <key>CFBundleShortVersionString</key> <string>1.0</string> <key>CFBundleSignature</key> <string>FONV</string> <key>CFBundleVersion</key> <string>1</string> <key>LSApplicationCategoryType</key> <string>public.app-category.games</string> <key>LSMinimumSystemVersion</key> <string>10.15</string> <key>NSHumanReadableCopyright</key> <string>Copyright © 2025</string> <key>NSPrincipalClass</key> <string>NSApplication</string> <key>LSRequiresNativeExecution</key> <true/> <key>LSArchitecturePriority</key> <array> <string>arm64</string> </array> </dict> </plist> Note The Info.plist file is a critical component of any macOS application bundle. It contains essential metadata that macOS uses to: Identify the application (bundle identifier, name, version). Display the application correctly in Finder and the Dock. Associate the correct icon with the application. Define the application's capabilities and requirements. Provide copyright and developer information. Without a properly formatted Info.plist file, macOS would not recognize your game as a valid application, and users would be unable to launch it through normal means. Tip The highlighted sections in the Info.plist file need to be customized for your game: Replace all instances of \"DungeonSlime\" with your game's name. The CFBundleIconFile value (line 10) must exactly match the name of your .icns file that we will create in the next step. Update the bundle identifier on line 12 with your domain. Modify the copyright information on line 30 as needed. Getting these values right, especially the icon filename, ensures your game appears correctly on macOS. For more information on the Info.plist manifest file, refer to the About Info.plist Keys and Values Apple Developer documentation. Next, create the application bundle .icns icon file. To do this, perform the following: First, you will need a .png file that can be used to create the icon set for the final .icns output. If you already have a .png icon for your game, ensure it is in the root of the main project directory and is named Icon.png. If you do not have one already prepared, you can use the Icon.bmp that was generated in the root of the main project directory when you initially created the project. However, it will need to be converted to a .png first. To do this, execute the following command: sips -s format png Icon.bmp --out Icon.png Note sips (Scriptable Image Processing System) is a command line tool in macOS for image manipulation. Here we are using it to convert a .bmp to a .png. In a moment, we will also use it to resize the .png into different icon sizes required for the application bundle. Next, create a directory that we can output each of the generated .png icon files to for the icon set. Execute the following command: mkdir -p bin/Release/DungeonSlime.iconset Now we use the sips command to generate the icon for each size required for a mac app bundle. Each size generated is necessary for different display scenarios in macOS (Dock, Finder, etc.). To do this, execute the following commands: sips -z 16 16 Icon.png --out bin/Release/DungeonSlime.iconset/icon_16x16.png sips -z 32 32 Icon.png --out bin/Release/DungeonSlime.iconset/icon_16x16@2x.png sips -z 32 32 Icon.png --out bin/Release/DungeonSlime.iconset/icon_32x32.png sips -z 64 64 Icon.png --out bin/Release/DungeonSlime.iconset/icon_32x32@2x.png sips -z 128 128 Icon.png --out bin/Release/DungeonSlime.iconset/icon_128x128.png sips -z 256 256 Icon.png --out bin/Release/DungeonSlime.iconset/icon_128x128@2x.png sips -z 256 256 Icon.png --out bin/Release/DungeonSlime.iconset/icon_256x256.png sips -z 512 512 Icon.png --out bin/Release/DungeonSlime.iconset/icon_256x256@2x.png sips -z 512 512 Icon.png --out bin/Release/DungeonSlime.iconset/icon_512x512.png sips -z 1024 1024 Icon.png --out bin/Release/DungeonSlime.iconset/icon_512x512@2x.png Finally, combine all of the generated icons for the icon set into a .icns file. To do this, execute the following: iconutil -c icns bin/Release/DungeonSlime.iconset --output bin/Release/DungeonSlime.app/Contents/Resources/DungeonSlime.icns Note iconutil is a command line tool in macOS used to convert icon sets into a single high-resolution .icns file. Tip After creating the .icns file using the above command, if you open the folder in Finder with DungeonSlime.app and it shows a blank square as the icon instead of the one you just created, right-click on DungeonSlime.app and choose Get Info from the context menu. This will force it to do a refresh and show the icon properly. After doing this, if the icon still does not show, then you need to double check that the CFBundleIconFile value in the Info.plist is named exactly the same as the .icns file that was created (minus the extension). Set executable permissions for the game executable. To do this, execute the following command: chmod +x bin/Release/DungeonSlime.app/Contents/MacOS/DungeonSlime Note the chmod +x command changes the file permissions to make it executable. Without this step, macOS would not be able to run the application. Distributing for macOS For macOS distribution: Archive the application bundle using the tar.gz archive format to preserve the executable permissions that were set. To do this, execute the following command in the same terminal window: tar -czf DungeonSlime-osx.tar.gz -C bin/Release/DungeonSlime.app Note The tar command creates an archive file: -c creates a new archive. -z compresses the archive using gzip. -f specifies the filename to create -C changes to the specified directory before adding files. Unlike ZIP files, the tar.gz format preserves Unix file permissions, which is crucial for maintaining the executable permission we set in the previous steps. Distribute the tar.gz archive file to players. Players can extract the tar.gz archive file and run the application bundle to play the game. Linux packaging is relatively straightforward, but requires attention to ensure executable permission are set. Building for Linux To create a self-contained application for Linux, open a new Terminal window in the same folder as the DungeonSlime.csproj file (your main game project folder) and execute the following .NET CLI command: dotnet publish -c Release -r linux-x64 -p:PublishReadyToRun=false -p:TieredCompilation=false --self-contained -c Release: Builds in Release configuration for better performance. -r linux-x64: Targets 64-bit Linux platforms. -p:PublishReadyToRun=false: Disables ReadyToRun compilation (explained later). -p:TieredCompilation=false: Disables Tiered Compilation (explained later). --self-contained: Includes the .NET runtime in the package. The output will be placed in a directory like bin/Release/net8.0/linux-x64/publish, relative to the DungeonSlime.csproj file. This folder will contain the executable and all necessary files to run the game. Note If your base game project is created with dotnet 9.0 (which at the time of writing is the default), the above folder will be more like bin/Release/net9.0/linux-x64/publish/, just so you are aware. Noting the change in folder from net8.0 to net9.0. Creating a Linux Distribution Once you have created a build for Linux, to create a distributable archive: Ensure the main executable has proper execution permissions by executing the following command in the same terminal window: chmod +x bin/Release/net8.0/linux-x64/publish/DungeonSlime Note the chmod +x command changes the file permissions to make it executable. Without this step, Linux would not be able to run the application. Package the game using the tar.gz archive format to preserve executable permissions by executing the following command: tar -czf DungeonSlime-linux-x64.tar.gz -C bin/Release/net8.0/linux-x64/publish/ Note The tar command creates an archive file: -c creates a new archive. -z compresses the archive using gzip. -f specifies the filename to create -C changes to the specified directory before adding files. Unlike ZIP files, the tar.gz format preserves Unix file permissions, which is crucial for maintaining the executable permission we set in the previous step. Important .NET Publishing Parameters When publishing your game, there are several .NET parameters that can significantly impact the performance of the game. In the above sections, these are all set to the recommended values, however, we will examine them in detail below. ReadyToRun (R2R) ReadyToRun is a feature in .NET that pre-compiles code to improve startup time. This sounds like a good thing on paper, however, for games, it can lead to micro-stutters during gameplay. This happens because ReadyToRun-compiled code is initially of lower quality, and the Just-In-Time (JIT) compiler will trigger periodically to optimize the code further. These optimization passes can cause visible stutters in the game. For games, it is recommended to disable ReadyToRun by setting -p:PublishReadyToRun=false in your publish command, which we have already included in our examples. For more information on ReadyToRun, refer to the ReadyToRun deployment overview documentation on Microsoft Learn Tiered Compilation Tiered compilation is another .NET feature that works similarly to ReadyToRun. It initially compiles code quickly at a lower optimization level, then recompiles frequently-used methods with higher optimization. While this improves application startup time, it can also cause stutters during gameplay as methods are recompiled. It is recommended to disable tiered compilation by setting -p:TieredCompilation=false in your publish command, which we have already included in our examples. For more information on Tiered Compilation, refer to the Tiered compilation section on Microsoft Learn. Native AOT (Ahead-of-Time) Compilation Native AOT compilation (specified with -p:PublishAot=true) compiles your entire application to native code at build time, eliminating the need for JIT compilation during runtime. This can provide better performance and a smaller distribution size. However, AOT has limitations: No support for runtime reflection. No runtime code generation. Some third-party libraries your game uses may not be compatible. For MonoGame game, AOT can work well if you avoid these limitations. Note Native AoT is recommended for mobile platforms due to its performance benefits and smaller binary size, which are important for mobile devices with limited resources. Additionally, it is mandatory when targeting console platforms (Xbox, PlayStation, Switch) as these platforms typically do not support JIT compilation for security and performance reasons. For more information on Native AOT, refer to the Native AOT deployment overview documentation on Microsoft Learn. Trimming Trimming (specified with -p:Trimming:true) removes unused code from your distribution to reduce size. It is automatically enabled when using AOT. While trimming can significantly reduce your game's size, it may remove types that appear unused but are accessed indirectly through reflection or generics causing runtime errors. Important Trimming can cause issues with content pipeline extensions that are used at runtime. When the compiler cannot detect that certain types are used (especially with reflection or generic collections), they might be trimmed away, resulting in \"type not found\" exceptions when loading content. If you encounter runtime exceptions about missing types when loading content with trimming enabled, you can resolve this by ensuring the compiler recognizes the types being used at runtime by making the following call: ContentTypeReaderManager.AddTypeCreator(typeof(ReflectiveReader<ReaderType>).FullName, () => new ReflectiveReader<ReaderType>()) Where ReaderType is the ContentTypeReader of the content pipeline extension to be preserved. This call should be made somewhere in your code before loading content that uses these types. For more information on Trimming, refer to the Trim self-contained applications documentation on Microsoft Learn. Single File Publishing Single file publishing packages your entire application into a single executable. While this sounds convenient, it is essentially a self-extracting archive that extracts to a temporary directory at runtime. This can significantly increase startup time for larger games and may fail on system with restricted permissions or limited storage. For this reason, it is not recommended to use this option for games. For more information on Single File Publishing, refer to the Create a single file for application deployment documentation on Microsoft Learn. Cross-Platform Considerations When distributing your games across multiple platforms, be aware of these additional considerations: File Paths Different operating systems use different path separators (Windows uses backslashes, macOS and Linux use forward slashes). Always use Path.Combine in your code rather than hardcoding path separators. // Incorrect approach - will fail on some platforms string path = \"Content\\\\images\\\\atlas-definition.xml\"; // Correct approach, works on all platforms string path = Path.Combine(\"Content\", \"images\", \"atlas-definition.xml\"); Case Sensitivity Windows is case-insensitive for filenames, but macOS and Linux are case-sensitive. Ensure your asset references use the exact case that matches your files for maximum compatibility. // If the content path on disk is: // images/Atlas.xnb // On Windows, this would work fine since windows is case-insensitive. // On macOS and Linux, this would fail since they are case-sensitive. Texture2D text = Content.Load<Texture2D>(\"images/atlas\"); External Dependencies Try to minimize external dependencies. If your game requires additional libraries or runtimes, document these requirements clearly for players. Note When publishing to distribution platforms and app stores (such as Steam, Epic Game Store, App Store, or Google Play), you are typically required to disclose all external dependencies in your privacy policy or a dedicated dependencies section. This includes third-party libraries, analytics tools, and any software components that your game depends on. Check specific requirements for each distribution platform you plant to target, as well as requirements by third-party libraries for using them, as disclosure requirements may vary. Asset Security and Protection When distributing your game, you may have concerns about protecting your assets and code from unauthorized access or reverse engineering. It is important to understand the practical limitations and trade-offs involved in various security approaches. XNB Asset Protection MonoGame's content pipeline compiles assets into compressed XNB format, which provides a basic level of protection for your game content. For the majority of indie game projects, this compression is sufficient protection for several reasons: XNB files are not standard formats: Unlike raw images or audio files, XNB files require specific knowledge and tools to extract. While the XNB format is documented and part of the MonoGame open source code, this still creates a barrier for the casual user. Practical protection: While not cryptographically secure, XNB compression deters casual attempts at asset extraction. Performance benefits: The primary purpose of XNB compilation is optimization, with content protection being a secondary benefit. Cross-platform consistency: The same XNB format works across all MonoGame platforms without additional configuration. Tip Unless you are working with highly valuable or sensitive assets (such as unreleased music from major artists or proprietary artwork), the standard XNB compression provides adequate protection for most games. Code Obfuscation For protecting your game's source code logic, obfuscation tools can make reverse engineering more difficult by renaming variables, restructuring code flow, and adding dummy logic paths. However, code obfuscation comes with significant trade-offs: Performance impact: Obfuscated code often runs slower than clean, optimized code due to additional indirection and complexity. Debugging complexity: Stack traces become unreadable, making it nearly impossible to diagnose issues reported by players. Build process overhead: Additional build steps, tools, and integration are required in your development workflow. Platform limitations: Some obfuscation techniques may not work correctly across all target platforms or may interfere with .NET features that MonoGame uses internally. Compatibility issues: Obfuscation can break reflection-based code or third-party libraries. Important Consider whether the performance cost of obfuscation is worth the potential security benefits for your specific project. For most indie game, the impact on player experience may outweigh the security advantages. The Reality of Modern Society It is crucial to understand that in the modern digital landscape, no security measure is truly impenetrable: Corporate security investments: Major corporations invest millions of dollars annually in security research and implementation, yet breaches still occur regularly. This demonstrates the fundamental challenge of client-side protection. Advanced tools: Sophisticated reverse engineering tools are readily available and constantly improving, making traditional protection less effective. AI-assisted analysis: Artificial intelligence can now assist in code analysis and pattern recognition, making traditional obfuscation techniques less reliable. Determined attackers: If someone is sufficiently motived to extract your assets or reverse engineer your code, they will likely succeed regardless of protection measures. Diminished returns: For indie developers, time spent on extensive security measures often exceeds the value of the content being protected and could be better invested in core development. Practical Security Recommendations For most MonoGame projects, consider these practical approaches to content protection: Accept standard protection: The built-in XNB compression is sufficient for typical use cases and provides the good balance of protection and performance. Focus on gameplay: Invest development time in creating compelling gameplay rather than extensive security measures. Legal protection: Consider proper licensing, terms of service, and copyright notices as your primary protection—intellectual property law provides stronger protection than technical measures. Contractual compliance: If using licensed assets with specific protection requirements, work with the licensor to understand what constitutes \"reasonable protection.\" Threat assessment: Realistically evaluate whether your game is likely to be a target for asset extraction or reverse engineering. Note Remember that the goal of asset protection should be to deter the casual extraction, not to create an impenetrable fortress. The time and resources spent on extensive security measures are often better invested in improving the game itself. Mobile Platforms While this tutorial series has focused on creating a 2D game for desktop platforms, MonoGame also offers support for mobile development on Android and iOS. The game we have built throughout this series could be adapted for touch controls and distributed through mobile app stores with additional work. Mobile deployment involves several considerations beyond those of desktop platforms: App store submission process and platform-specific requirements. Platform-specific signing and certification procedures. Extensive device compatibility testing across various screen sizes and hardware. Optimization of touch input controls (replacing our keyboard and gamepad input). Power consumption management and performance optimization for mobile hardware. For the Dungeon Slime game, adapting to mobile would require: Implementing touch controls to replace the keyboard/gamepad movement. Potentially rethinking game mechanics to suit mobile play patterns. Note Mobile deployment for MonoGame games is significantly more complex than desktop deployment and typically requires platform-specific development environments (Android Studio for Android and Xcode for iOS). A comprehensive guide to mobile deployment will be covered in a future tutorial. If you are interested in extending the Dungeon Slime game, or future games, to mobile platforms after completing this tutorial series, these resources provide a good starting point: Android Deployment Guide iOS App Store Distribution Third-Party Packaging Tools While the platform-specific packaging steps outlined in this chapter give you complete control over the distribution process, they require multiple commands and potentially access to different operating systems. Fortunately, the MonoGame community has developed several tools that can automate these packaging steps across platforms. GameBundle GameBundle is a .NET command-line tool created by Ellpeck that simplifies packaging MonoGame and other .NET applications into several distributable formats. This tool can automatically bundle your game for Windows, Linux, and macOS platforms, create applications bundles for macOS, and handle various packaging configurations with a single command. For more information about GameBundle, including installation and usage instructions, visit the official repository on GitHub MonoPack MonoPack is a .NET command-line tool created by ShyFox Studio designed specifically for MonoGame projects. According to its documentation, \"MonoPack is a dotnet tool used for MonoGame projects to package the game for Windows, Linux, and/or macOS\". Key features include: Cross-platform packaging capabilities (build for any OS from any OS). Automatic creation of macOS application bundles. Appropriate compression formats for each target platform for distribution. For more information about MonoPack, including installation and usage instructions, visit the official repository on GitHub Conclusion In this chapter, you learned how to package your MonoGame project for distribution across Windows, macOS, and Linux platforms. You now understand how to create self-contained deployments for each target platform, the impact of various .NET publishing options on game performance, and important cross-platform considerations. Whether you choose to use the manual platform-specific packaging steps or automate the process with tools like GameBundle or MonoPack, you now have the knowledge to ensure your game runs smoothly for players across different platforms without requiring them to install additional dependencies. Test Your Knowledge Why is it recommended to use self-contained deployments for distributing MonoGame games? :::question-answer Self-contained deployments package your game with all necessary .NET dependencies, ensuring players can run the game without installing the .NET runtime. This simplifies distribution, guarantees your game uses the exact runtime version it was developed with, and provides a better player experience despite the larger package size. ::: Why should ReadyToRun and Tiered Compilation be disabled when publishing games? :::question-answer ReadyToRun and Tiered Compilation both initially produce lower-quality code that gets optimized during runtime. This dynamic optimization process causes micro-stutters during gameplay as the Just-In-Time compiler triggers to improve code quality. Disabling these features results in slightly longer startup times but provides smoother gameplay without performance hitches. ::: What is the purpose of the Info.plist file when creating a macOS application bundle? :::question-answer The Info.plist file contains essential metadata about the macOS application, including the bundle identifier, application name, version, copyright information, minimum system requirements, and other configuration details. macOS requires this file to properly recognize and display the application in the Finder and Dock, and to associate the correct icon and file types with the application. ::: What is the advantage of using a tar.gz archive over zip file when distributing for macOS and Linux? :::question-answer A tar.gz archive preserves Unix file permissions, which is crucial for maintaining the executable permissions set on game files. Without these permissions, users would need to manually set execute permissions before running the game. ZIP files do not reliably preserve these Unix-specific permissions, which could prevent the game from running directly after extraction on macOS and Linux platforms. ::: What is the purpose of creating a universal binary for macOS distributions? :::question-answer A universal binary combines executables for multiple CPU architectures (Intel x64 and Apple Silicon arm64) into a single file. This allows the game to run natively on both older Intel-based Macs and newer Apple Silicon Macs without requiring separate distributions. :::"
  },
  "templates/docs.monogame.github.io/articles/tutorials/building_2d_games/26_publish_to_itch/index.html": {
    "href": "templates/docs.monogame.github.io/articles/tutorials/building_2d_games/26_publish_to_itch/index.html",
    "title": "Chapter 26: Publishing Your Game to itch.io | hallowed",
    "summary": "After packaging your game for various platforms in Chapter 25, the next step is to make it available for other players. While there are many distribution platforms available (Steam, Epic Games store, Good Old Games (GOG)), itch.io has become a popular choice for indie developers due to its simple publishing processes, developer-friendly revenue model, and strong community focus. In this chapter, you will: Learn about itch.io and why it is beneficial for indie game developers. Create and configure an itch.io developer account with appropriate security measures. Create a project page that effectively showcases your game. Understanding itch.io as a Distribution Platform Itch.io is an open marketplace for independent digital creators with a focus on indie games. Unlike larger platforms with strict approval processes, itch.io allows any developer to publish their games instantly. This makes it an ideal starting point for new developers looking to build an audience. Key benefits of itch.io for developers include: Simple Publishing Process: No approval waiting periods or complex requirements. Pay-What-You-Want Pricing: Flexibility to set minimum prices, suggested prices, or make your game completely free. Cross-Platform Support: Easy distribution for Windows, macOS, and Linux builds. Community Focused: Built-in tools for building a community around you and your games, including devlogs and comments. Developer-Friendly Revenue Split: The platform lets developers choose their revenue share (the default 90% to developers, 10% to itch.io). Analytics and Insights: Basic analytics to track downloads, views, and purchases. Game Jams: Integrated tools for hosting and participating in game development competitions. Setting Up an itch.io Account Before you can publish your game, you need to create an itch.io account and set up your developer profile. To do this: Navigate to itch.io and click \"Register\" in the top-right corner. Fill in the registration form with your desired username, password, and email address. Tip Your itch.io username will appear in the URL of your games (e.g. https://yourusername.itch.io/dungeon-slime). Choose a username that represents you or your studio professionally and is easy to remember. The username can be changed later in your account settings if needed. After registering, you will automatically be logged in. However, for some additional configurations that need to be made, you must validate your email address. Check the email address you entered when you registered for a new email from itch.io to validate the email address. After validating your email address, go to your account settings by clicking your username in the top-right corner, and then choosing \"Settings\". The settings page opens with your developer profile configuration. Complete your developer profile with: A profile picture. Links to your social media platforms or portfolio. A short biography for your profile page. Next, click \"Two factor auth\" under the \"Basics\" section on the left to go through the process of configuring two factor authentication for your account. If you plan to sell your game, you will need to configure your publisher information. To do this, click the \"Get Started\" section under \"Publisher\" on the left and follow the steps presented to configure your account to accept payments. Creating a New Project To put your game on itch.io, you first need to create a new project. When creating a new project, you will be filling out information about the game to generate a project page that contains all the information about the game including the title, description, screenshots, and download files. To create a new project, click the arrow beside your username in the top-right corner of the page, and choose \"Upload new project\". Figure 26-1: Drop-down menu after clicking the arrow beside user name with \"Upload new project\" highlighted This will open the \"Create a new project page\", which presents you with a form to enter information about the game, upload the game files, and add screenshots. Figure 26-2: The \"Create a new project\" page on itch.io Tip You can also create a new project by going to your dashboard by clicking the \"Dashboard\" navigation link at the top of the page, then clicking the \"Create new project\" button on the dashboard page. Basic Project Information The first section of the form contains fields for the basic information about the project. Title: The title of the game. This is how it will be displayed and shown throughout the itch.io website. Project URL: The URL of the project. This is the address you will share on social media platforms and other communities to point others to the project page for your game. Note When you enter the title of your game, the project URL will automatically generate based on the title entered (e.g. https://yourusername.itch.io/project-title). The autogenerated URL is usually fine, but you can customize it if you are not happy with it. Short description or tagline: Here you can enter a short description that is shown in embedded link previews for your game when it is shared on different social media platforms. Kind of project: The type of project you are uploading. The available options are: Downloadable: For projects that require users to download and run files locally. This is the appropriate choice for MonoGame projects since they are distributed as executable packages. HTML: For web-based games or applications that run directly in the browser, typically using HTML5, JavaScript, and CSS. Flash: For legacy Flash applications that require the Flash Player plugin. This format is largely obsolete since Adobe discontinued Flash support. Java applet: For Java-based applications that run in a browser. Like Flash, this technology has been largely phased out of modern web development. Unity <= 5.3: For older Unity Web Player games that run in the browser. Newer Unity games typically use WebGL, which would fall under the HTML category. Tip Since MonoGame games are distributed by packaging them into an archived bundle, you should choose the \"Downloadable\" option. Classification: What type of project are you uploading. The available options are: Games: Interactive software designed primarily for entertainment or educational purposes. Game assets: Resources used in game development, such as graphics, audio, fonts, or code modules. Game mods: Modifications that alter or enhance an existing game's content or mechanics. Physical games: Tabletop, card, or other non-digital games that can be printed or manufactured. Albums & soundtracks: Musical compositions, including game soundtracks or independent music projects. Tools: Utility software that assists in game development or other creative processes. Comics: Sequential art narratives in digital format. Books: Literary works including novels, guides, or educational texts. Other: Projects that do not fit into the predefined categories. Release Status: Set the development status of the project. The available options are: Released: The project is complete and ready for public distribution, though it may receive updates. In development: The project is actively being worked on and may be available as an early access version. On hold: Development has been temporarily paused but is expected to resume in the future. Canceled: Development has been permanently discontinued. Prototype: An early experimental version meant for concept testing rather than complete gameplay. Note You can change the release status of the project at any time after creating the project page. The following is an example of the basic project information that would be filled in for the Dungeon Slime game we developed throughout this tutorial series: Figure 26-3: The basic project information for the Dungeon Slime game Pricing Following the basic information about the project, the next section of the form is for setting the price users would pay to download the game. Itch.io offers three pricing models for a project: $0 or donate: This model makes your game freely available while encouraging optional financial support. When users download your game, they are presented with a donation prompt showing your suggested amount. While they can contribute any amount they choose, they also have the option to download without payment by selecting \"No thanks, take me to the download.\". Paid: This model requires users to purchase your game before downloading. You set a minimum price that all users must pay, though they have the option to contribute more if they wish. No Payment: This model provides your game completely free with no payment prompts. When users click to download, they are taken directly to the download page without any suggestion to donate. Tip Consider your goals when selecting a pricing model. The \"$0 or donate\" option often provides a good balance for indie developers, removing financial barriers to trying your game while still providing a path for supportive players to contribute. Figure 26-4: The pricing options for a new project on itch.io Uploads After choosing the pricing options for the project, the next part of the form is for uploading files that users can download for the project. This is where you will add the platform-specific builds you created using the steps in Chapter 25. Itch.io supports multiple file uploads, allowing you to provide the appropriate version for each platform you support. Note Before uploading, ensure the builds are properly packaged into either ZIP (Windows) or tar.gz (macOS/Linux) archives as discussed in Chapter 25. To upload a file for the project: Click the \"Upload files\" button. In the file select dialog, navigate to and select the file you want to upload. Note For a MonoGame game project, you would upload the archived builds that you created through the steps in Chapter 25. Once the upload has completed, you will be presented with options to set the following: Download Type: Here you can set the type of file that the user will be downloading. The available options are: Executable: The main game application that users will run to play your game. For MonoGame projects, your packaged builds fall into this category. Source code: The underlying code of your game, useful for open-source projects or educational examples. Soundtrack: Music files from your game, typically provided in MP3 or other audio formats. Book or Document: Text content such as manuals, guides, or other written materials. Video: Video content such as trailers, gameplay footage, or tutorials. Mod: Add-ons or modifications that enhance or alter your base game. Graphical assets: Art, textures, models, or other visual elements used in your game. Audio assets: Sound effects, voice recordings, or other audio components. Documentation or Instructions: Help files, control references, or other guidance for players. Other: Any file type that does not fit into the above categories. Tip Even if the project you are creating is a game, you can include additional downloads for users such as the soundtrack and an instruction manual. Providing these supplementary materials can enhance the perceived value of your project and demonstrate professionalism and attention to detail. If the download type is \"Executable\", you will be presented with checkboxes to choose which operating system it is for. The available options are: Windows: For Windows-compatible executable files (.exe). Linux: For Linux-compatible executable files. macOS: For macOS-compatible application bundles (.app). Android: For Android-compatible application packages (.apk). For each file that is uploaded, you are also given the following options: Set a different price for this file: This allows you to adjust pricing for specific downloads, useful for offering premium content or special editions. Hide this file and prevent it from being downloaded: This can be used to temporarily remove access to a file without deleting it, which is helpful when updating content or preparing future releases. Note Itch.io also provides a command-line tool called butler that can automate the upload process for your game builds. This is particularly useful for developers who frequently update their games or need to manage multiple platforms. For more information, see the butler GitHub page. MonoGame community member Jean-David Moisan (Apos) also has a guide written on automating releases using butler with GitHub Actions. For more information, see the Automate Release document. Figure 26-5: Example of uploaded files for Windows, Linux, and macOS platforms Description The description section is where you can showcase your game's unique appeal and provide potential players with compelling reasons to download it. An effective game description serves multiple purposes: it explains what your game is about, highlights its distinctive features, and gives players an idea of what to expect. When writing a description for your game, consider the following strategies to create a compelling presentation: Start with a hook: Begin with a concise, attention-grabbing summary that clearly communicates your game's concept and unique selling point. Structure for readability: Use short paragraphs, bullet points, and clear headings to make your description easy to scan. Highlight key features: List the most notable gameplay mechanics, visual elements, and player experiences your game offers. Include technical information: Mention the technologies used (such as MonoGame \uD83D\uDE09), supported platforms, and any special hardware requirements or recommendations. Describe the controls: Briefly explain how players will interact with your game, especially if you support multiple input methods. Add attribution: Include proper credits for team members, external assets, and tools used in development that require attributions. Consider your audience: Write in a tone that resonates with your target players. Here is an example structure for a game description: [Game Name] is a [genre] game where players [main gameplay activity]. [One additional sentence about a unique hook or setting]. Features: - [Key Feature 1] - [Key Feature 2] - [Key Feature 3] - [Key Feature 4] Controls: - [Control scheme for keyboard/mouse] - [Control scheme for gamepad, if supported] Developed with MonoGame Tip Consider reviewing descriptions of popular games in your genre for inspiration, but ensure your description authentically represents your game. False or exaggerated claims will lead to disappointed players and negative reviews. Figure 26-6: Example of a game description outline Metadata Itch.io provides several metadata fields that help categorize your game and make it more discoverable when users search the platform. Properly configured metadata increases visibility and helps your game reach its intended audience. The following explores each of these fields: Genre: Select the genre that most accurately represents your game's core gameplay experience. While many games span multiple genres, choose the one that best captures your game's primary appeal. Common genres include: Action (for games focusing on reflexes and coordination) Adventure (for exploration and narrative-driven experiences) Puzzle (for games centered on problem-solving) Role Playing (for character development and progression systems) Simulation (for realistic system modeling) Strategy (for tactical decision-making games) Tags: Tags are keywords that help users find your game when searching or browsing. Effective tagging significantly impacts your game's discoverability. Consider including: Platform identifiers (2d, 3d) Visual style (pixel-art, low-poly, realistic) Technical elements (monogame, procedural) Player configuration (singleplayer, multiplayer) Gameplay mechanics (shooter, platformer, roguelike) Tip Itch.io recommends using their suggested tags when possible. Review their tagging guidelines for best practices. Focus on accuracy rather than quantity—irrelevant tags may attract the wrong audience and lead to disappointed players. AI generation disclosure: This field requires you to indicate whether your game contains AI-generated assets. This transparency helps users make informed decisions about the content they consume. Options include: Yes: The project contains AI-generated assets. No: The project does not contain any AI-generated assets. Note Itch.io takes this disclosure seriously. For detailed information about their AI disclosure policy, visit their generative AI guidelines. App store links: If your game is available on other platforms like Steam, Apple App Store, or Google Play, you can provide links to these listings. This helps players find your game on their preferred platform and establishes your game's presence across multiple marketplaces. Custom Noun: By default, itch.io refers to your project as a \"game.\" If your project fits better with another descriptor (like \"tool,\" \"experience,\" or \"interactive story\"), you can specify a custom noun here. This affects how your project is described throughout the itch.io interface. Figure 26-7: Example of metadata configuration for a game project Download and Install Instructions The download and installation instructions section is where you provide clear guidance to users on how to get your game up and running after they download it. Well-written instructions reduce confusion and ensure players can quickly start enjoying your game. Since MonoGame projects are typically distributed as archived files (ZIP for Windows, tar.gz for macOS and Linux), it is essential to provide step-by-step instructions for extracting and launching your game on each supported platform. Be platform-specific: Separate instructions for each operating system you support. Use numbered steps: Sequential numbering makes instructions easier to follow. Be explicit: Specify exact filenames and actions to take. Address common issues: Mention any special permissions or requirements users might encounter. Use simple language: Avoid technical jargon when possible, as players may have varying technical expertise. Here is an example template for installation instructions for a MonoGame project: Once the download has completed: For Windows: 1. Extract the contents of the ZIP archive. 2. Run the \"[YourGameName].exe\" executable from the extracted folder. For Linux: 1. Extract the contents of the tar.gz archive. 2. Run the \"[YourGameName]\" executable from the extracted folder. 3. If the game does not open or states it is not executable, you may need to change the file permissions. To do this: 1. Open a terminal in the extracted directory. 2. Make the game executable with the command: chmod +x ./[YourGameName] For macOS: 1. Extract the contents of the tar.gz archive. 2. Run the [YourGameName].app executable from the extracted folder. 3. If the game does not open or states it is not an executable, you may need to change the file permissions. To do this: 1. Open a terminal in the extracted directory. 2. Make the game executable with the command: chmod +x ./[YourGameName].app/Contents/MacOS/[YourGameName] Tip Consider testing your installation instructions on a clean system or with someone who has not seen your game before. This can help identify any missing steps or assumptions you might have made. Figure 26-8: Example of download and installation instructions for a MonoGame project Community Building a community around your game can significantly enhance its lifespan and success. Itch.io offers several options for enabling player interaction directly on your project page. Choosing the right level of community engagement depends on your game's needs and your capacity to moderate interactions. The platform provides three community feature options: Disabled: No community interaction features will be available on your project page. This option is appropriate when you prefer to direct community engagement elsewhere (such as Discord or social media), or when you do not have the resources to moderate community content. This is also suitable for projects in very early development stages where you are not yet ready for public feedback. Comments: This enables a simple comment section at the bottom of your project page where players can leave feedback, ask questions, or share their experiences. As the developer, you receive notifications when new comments are posted, allowing you to respond promptly. This option provides a good balance between community engagement and moderation requirements, making it ideal for most indie games. Discussion board: This creates a full-featured forum dedicated to your project, with support for multiple topics, threaded replies, and content organization. Discussion boards are beneficial for games with complex mechanics, active development cycles, or strong communities. However, they require more active moderation and engagement from developers to remain valuable. Tip Regardless of which option you choose, regularly engaging with your community demonstrates that you value player feedback and can build a loyal following. Consider setting aside specific times each week to respond to comments or discussions. Figure 26-9: Community feature settings available for game projects Visibility and Access The visibility settings control who can access your project page. This feature allows you to prepare your page privately before making it public, or to create restricted access for testers or supporters. Understanding these options helps you manage your game's release strategy effectively. Itch.io offers three visibility levels: Draft: This setting makes your project page visible only to you and any collaborators you have explicitly given edit access. Draft mode is ideal during the initial setup phase when you are still uploading files, writing descriptions, and configuring your page. It provides a safe environment to experiment with different layouts and content without public exposure. Restricted: This option limits access to specific individuals you designate. When you select this option, you can generate and share access keys with testers, reviewers, or early supporters. Restricted access is valuable for beta testing, gathering feedback from a controlled group, or offering early access to supporters before a wider release. Public: This makes your project accessible to everyone visiting itch.io. Once public, your game will appear in search results and category listings, making it discoverable by the platform's user base. This is the appropriate setting when your game is ready for distribution. Note Itch.io intentionally limits your initial options to either \"Draft\" or \"Restricted\" mode. This design encourages you to completely prepare your project page before making it public. Only after saving your initial project setup can you then return to change the visibility to \"Public.\" This workflow helps prevent incomplete or unpolished project pages from being publicly visible. Tip Consider using a phased release approach: start in Draft mode while building your page, switch to Restricted for beta testing with a select audience, then finally move to Public when you are confident in your game's presentation and stability. Figure 26-10: Visibility and access settings for publishing your game Adding Visual Assets Visual assets are often the first elements potential players notice about your game and play a crucial role in marketing. According to industry research, games with high-quality visual presentations typically receive more downloads and engagement than those with minimal or poor-quality visuals. Taking time to create compelling visual assets can significantly improve your game's appeal on the itch.io marketplace. At minimum, you should prepare the following visual assets for your project: Cover Image: This is your game's primary visual representation, displayed on the game's page, in search results, and in embedded links when shared on social media. Itch.io recommends a size of 630×500 pixels, with a minimum requirement of 315×250 pixels. Your cover image should: Clearly represent your game's visual style Include your game's title Avoid cluttered compositions that become illegible when scaled down Screenshots: Include 3-5 high-quality screenshots that showcase different aspects of your game. Effective screenshots should: Demonstrate core gameplay mechanics Highlight unique visual elements or features Show different environments or levels if applicable Include UI elements only when relevant to showcase Maintain consistent aspect ratios across all screenshots Trailer or Gameplay Video (optional but recommended): A short video (30-90 seconds) can increase player interest. Videos allow you to demonstrate gameplay flow, audio design, and interactive elements that static images cannot capture. Tip When capturing screenshots and video: Windows: Use the built-in Game Bar (Windows+G), Snipping Tool, or press Windows+Shift+S for screenshots. OBS Studio works well for video capture. macOS: Press Command+Shift+4 for area screenshots or Command+Shift+5 for screen recording. QuickTime Player also offers screen recording functionality. Linux: Use tools like GNOME Screenshot, Flameshot, or SimpleScreenRecorder. To add a cover image to your project: Prepare your image at the recommended 630×500 pixel size. At the top-right of the \"Create a new project\" page, click the \"Upload Cover Image\" button. Select your cover image file in the file browser dialog. Figure 26-11: Example of uploading a cover image for a game project To add screenshots to your project: Prepare 3-5 screenshots showcasing different aspects of your game. Click the \"Add Screenshots\" button located below the cover image section. Select your screenshot files in the file browser dialog. Arrange screenshots in order of importance by hovering over them and using the \"Move Up\" and \"Move Down\" actions after uploading. Figure 26-12: Example of multiple screenshots added to a game project Note While itch.io does not strictly require these visual assets, projects with complete visual presentations receive more attention than those without. Saving and Publishing Your Project After filling out all the necessary form fields, uploading your game files, and adding visual assets, it is time to save your project and prepare it for publishing. This process involves several steps designed to ensure your project is ready for your intended audience before publishing. Initial Save and Preview Once you have completed the project creation form: Scroll to the bottom of the form and click the \"Save & view page\" button. This action saves all your current information and generates a preview of your project page. A popup will appear with important information about your project's status and next steps. Figure 26-13: Initial information popup after saving a new project Click the \"Got it\" button after reading to close the popup and view your project page preview. Figure 26-14: Example of a project page preview after initial save Visual Customization The preview page provides additional customization options beyond the basic project information you have already entered. As the project owner, you will notice an \"Edit theme\" button at the top of your preview page. This feature allows you to customize the visual presentation of your project page with options including: Background color: Change the page's background to match your game's aesthetic. Font selection: Choose typography that complements your game's style. Layout options: Modify how elements are arranged on the page. Banner image: Add a wider image at the top of your page for additional visual impact. Background image: Set a tiled or full-page background image. These visual customizations can significantly enhance your project's presentation and help it stand out among other games on the platform. Experiment with different combinations to find a design that complements your game's identity while maintaining readability and usability. Publishing Your Project When you are satisfied with your project page and ready to make it publicly available: Click the \"Edit game\" link in the top navigation bar to return to the project form. Scroll to the bottom of the form to the Visibility & access section. Change the setting from \"Draft\" to \"Public.\" Click the \"Save\" button to apply the change. Your game is now publicly accessible to the itch.io community. It will appear in search results and category listings based on the metadata you provided. Tip Before widely promoting your game, consider a soft launch approach: Share the link with a small group of trusted friends or fellow developers. Ask them to test the download and installation process on different devices and operating systems. Collect feedback on any unclear instructions or technical issues. Make necessary adjustments before promoting your game to a wider audience. This approach helps identify potential issues you may have missed before presenting it to a larger audience. Dungeon Slime on itch.io To see a completed version of a project uploaded to itch.io, you can explore the Dungeon Slime example at https://monogame.itch.io/dungeon-slime. This published version demonstrates the concepts we covered in this chapter, showing how they come together in a finished project. Conclusion In this chapter, you learned how to publish your MonoGame project on itch.io, one of the most accessible digital distribution platforms for indie game developers. You have gained a comprehensive understanding of the entire publishing process, from creating an account to making your game available to players worldwide. Note While you might think \"why should I publish my demo or small game\", we would recommend you do it anyway. The experience you gain from completing a project from start to finish and then publish will gain you more and more experience over time, so that when you finally come to roll out your \"big game\", you will already know everything involved and be ready for it. The old saying that \"the last 20% takes 80% of the effort\" is VERY true when it comes to game development and it pays to be prepared. Through this chapter, you have learned how to: Create and configure an itch.io developer account with the appropriate security measures. Set up a project page with compelling descriptions and relevant metadata. Upload platform-specific builds for different operating systems. Configure pricing options that align with your goals. Write clear download and installation instructions to ensure a smooth player experience. Add visual assets that showcase your game effectively. Enable appropriate community features to engage with your audience. Customize your project page's visual presentation. Publishing a game represents a significant milestone in your journey as a game developer. While itch.io is just one of many distribution platforms available, it provides an excellent starting point for indie developers due to its accessible nature, developer-friendly policies, and supportive community. The skills you have learned in this chapter extend beyond itch.io and establish a foundation for publishing on other platforms."
  },
  "templates/docs.monogame.github.io/articles/tutorials/building_2d_games/27_conclusion/index.html": {
    "href": "templates/docs.monogame.github.io/articles/tutorials/building_2d_games/27_conclusion/index.html",
    "title": "Chapter 27: Conclusion and Next Steps | hallowed",
    "summary": "As our journey together through this tutorial series comes to a close, it is worth taking a moment to reflect on how far you have come. What began as a simple window displaying the iconic \"Cornflower Blue\" has evolved into a fully functional game with animated sprites, collision detection, sound effects, and user interfaces. This transformation mirrors your own growth as a game developer. What You Have Learned Throughout these chapters you have built a complete 2D game from scratch, learning the fundamental concepts and techniques of game development along the way. This journey has equipped you with the knowledge and skills to start creating your own 2D games using MonoGame. Looking back at our journey, we have covered quite a lot of ground: Fundamentals Our journey began with essential building blocks of game development with MonoGame. We explored the framework's architecture and capabilities, comparing it to alternatives to understand its unique position in the game development ecosystem. These fundamental concepts provided the foundation upon which we built increasingly complex systems throughout the tutorial series. These concepts included: Understanding what MonoGame is and how it compares to other game development frameworks. Setting up your development environment across different operating systems. Learning the basic structure of a MonoGame project and the game loop. Creating a reusable class library for game components. Graphics and Rendering With the foundations in place, we ventured into the visual aspects of game development that bring our virtual worlds to life. We explored MonoGame's asset management through the content pipeline, rendering capabilities, and learning techniques to efficiently display graphics while optimizing performance. These included: Loading and rendering textures with SpriteBatch. Optimizing texture rendering with texture atlases. Creating sprites and animated sprites. Implementing tilemaps for creating game environments. Working with sprite fonts to render text. Using shaders to create visual effects. Game Systems Beyond graphics, we delved into the interactive systems that transform static visuals into a dynamic gameplay experience. These interconnected components form the backbone of our game, enabling player interaction, providing feedback, and creating a coherent experience across different game states. By implementing these systems, we learned how the various elements of game design work together to create an engaging and responsive player experience. These systems included: Handling input from keyboard, mouse, and gamepad. Creating an input management system for improved responsiveness. Implementing collision detection between game objects. Managing audio with sound effects and background music. Developing a scene management system for different game states. Building a user interface. Production and Distribution After creating a fully functioning game, we turned our attention to sharing our creation with the world. The final stages of game development involve preparing your project for players across different platforms and making it available through distribution channels. These steps take your personal project and puts it into a publicly accessible space where others can download, play, and enjoy. These stages were: Packaging your game for different platforms. Publishing your game on distribution platforms like itch.io. Community and Continued Learning The MonoGame community represents one of the most valuable resources available to you as you continue your development journey. Unlike closed commercial engines, MonoGame thrives through the collective efforts of developers who share knowledge, tools, and solutions. The official MonoGame Discord server offers a space where developers of all skill levels exchange ideas and troubleshoot challenges together. Here, a question about optimization techniques might spark a conversation about architecture patterns, leading to insights you might never have discovered on your own. For structured learning, several community members have created comprehensive educational resources: RB Whitaker's provides in-depth coverage of MonoGame fundamentals and advanced topics. Learn MonoGame by community member Jean-David Moisan (Apos) provides a collection of focused tutorials on specific MonoGame topics. Dark Genesis Blog by foundation member Simon Jackson offers a range of articles on MonoGame development. GameDevQuickie offers video tutorials focused on practical game development techniques with MonoGame. Darkside of MonoGame video series provides comprehensive tutorials on getting started with MonoGame across different platforms and scenarios. The MonoGame Samples repository offers practical examples of features implemented in working code. Similarly, the archived XNA Game Studio educational resources maintained by Simon Jackson provide a wealth of examples that remain relevant despite XNA's official discontinuation. Tip REMEMBER, if you see content written for XNA, then it is more than likely it will still work for MonoGame due to MonoGame's commitment for backwards compatibility. There may be a few bumps, minor changes (especially with earlier versions of XNA, like XNA 2) or differences with shaders (the biggest pain). But remember the community is here to help, so just ASK!. Your First Original Project As you contemplate your next project, consider starting with a focused concept that builds on what you have learned while introducing one or two new challenges. This balanced approach allows you to reinforce existing skills while gradually expanding your capabilities. Perhaps you might create a puzzle game where the core mechanics revolve around tile manipulation, or a side-scrolling adventure that expands on the collision and movement systems you have learned. Whatever you choose, the process will affirm and deepen your understanding in ways that tutorials alone cannot do. In other words, get your hands dirty. Remember that your first project does not need to be commercially successful or technically groundbreaking. Its primary value lies in the creative freedom it offers and the practical experience it provides. Each bug you fix and feature you implement strengthens your developer intuition; the hard-to-define sense of how games work beneath their surface. When you inevitably encounter obstacles, approach them with patience and curiosity. The solutions you discover will not just resolve immediate problems; they will become part of your growing toolkit for future projects. Every challenging moment represents an opportunity to become a more resourceful and knowledgeable developer. The Art of Finishing Perhaps the most valuable skill you have practiced throughout this tutorial series is the art of finishing. Game development history is littered with ambitious projects that grew beyond their creators' capacity to complete them. By following this series to its conclusion, you have demonstrated the discipline and persistence in bringing games to life. When working on longer projects, break development into milestones with clear, achievable goals. Celebrate these incremental victories to maintain momentum through the inevitable challenges of extended development. Remember that a simple, finished game will always provide more value, both to players and to your growth as a developer, than an ambitious project that remains perpetually incomplete. Final Note From Author The knowledge you have gained throughout this tutorial series represents not an endpoint but a beginning. You now possess the fundamental skills to bring your game ideas to life, the architectural understanding to build systems that grow with your ambitions, and the practical experience of completing a functional game. The MonoGame framework offers a rare combination of freedom and structure; providing the essential tools without limiting your creative expression. As you continue exploring its capabilities, you join a lineage of independent developers who have used these very same tools to create experiences that resonate with players around the world. Your journey from here will be uniquely yours, shaped by the games you want to make and by the challenges you choose to overcome. Whatever path you follow, approach it with the same curiosity, persistence, and analytical thinking that brought you through this tutorial series. The road may not always be easy, but it leads to one of the most rewarding creative disciplines available today - the art and science of making games. Instead of ending this like all other chapters with a section to \"test your knowledge\", I will just leave you with one simple question: What will you create next? - Christopher Whitley (Aristurtle)"
  },
  "templates/docs.monogame.github.io/articles/tutorials/building_2d_games/index.html": {
    "href": "templates/docs.monogame.github.io/articles/tutorials/building_2d_games/index.html",
    "title": "Building 2D Games with MonoGame | hallowed",
    "summary": "This tutorial covers game development concepts using the MonoGame framework as our tool. Throughout each chapter, we will explore game development with MonoGame, introducing new concepts to build upon previous ones as we go. We will create a Snake game, which will serve as the vehicle to apply the concepts learned throughout the tutorial. The goal of this tutorial is to give you a solid foundation in 2D game development with MonoGame and provide you with reusable modules that you can leverage to jump start future projects. What We Will Build Throughout this tutorial series, we will build a complete game called Dungeon Slime; a snake-like game with a dungeon theme. By the end of this series, you will have created a polished game with: Smooth animated sprites Responsive controls across keyboard and gamepad Sound effects and background music UI menus with customized styling A complete game loop with scoring and game over states You can see the finished game here: Dungeon Slime on itch.io Figure 0-1: The title screen of Dungeon Slime Figure 0-2: Gameplay of Dungeon Slime showing the player controlling a chain of slime segments (in blue) while navigating through the dungeon to collect bats for points. Who This Is For This documentation is meant to be an introduction to game development and MonoGame. Readers should have a foundational understanding of C# and be comfortable with concepts such as classes and objects. Note If you are just getting started with C# for the first time, I would recommend following the official Learn C# tutorials provided by Microsoft. These free tutorials will teach you programming concepts as well as the C# language. Once you feel you have a good foundation, come back and continue here. How This Documentation Is Organized This documentation will introduce game development concepts using the MonoGame framework while walking the reader through the development of a Snake clone. The documentation is organized such that each chapter should be read sequentially, with each introducing new concepts and building off of the previous chapters. Chapter Summary Source Files Chapter 01: What Is MonoGame Learn about the history of MonoGame and explore the features it provides to developers when creating games. 01-What-Is-MonoGame Chapter 02: Getting Started Setup your development environment for .NET development and MonoGame using Visual Studio Code as your IDE. 02-Getting-Started Chapter 03: The Game1 File Explore the contents of the Game1 file generated when creating a new MonoGame project. 03-The-Game1-File Chapter 04: Creating a Class Library Learn how to create and structure a reusable MonoGame class library to organize game components and share code between projects. 04-Creating-A-Class-Library Chapter 05: Content Pipeline Learn the advantages of using the Content Pipeline to load assets and go through the processes of loading your first asset 05-Content-Pipeline Chapter 06: Working with Textures Learn how to load and render textures using the MonoGame content pipeline and SpriteBatch. 06-Working-With-Textures Chapter 07: Optimizing Texture Rendering Explore optimization techniques when rendering textures using a texture atlas. 07-Optimize-Texture-Rendering Chapter 08: The Sprite Class Explore creating a reusable Sprite class to efficiently manage sprites and their rendering properties, including position, rotation, scale, and more. 08-The-Sprite-Class Chapter 09: The AnimatedSprite Class Create an AnimatedSprite class that builds upon our Sprite class to support frame-based animations. 09-The-AnimatedSprite-Class Chapter 10: Handling Input Learn how to handle keyboard, mouse, and gamepad input in MonoGame. 10-Handling-Input Chapter 11: Input Management Learn how to create an input management system to handle keyboard, mouse, and gamepad input, including state tracking between frames and creating a reusable framework for handling player input. 11-Input-Management Chapter 12: Collision Detection Learn how to implement collision detection between game objects and handle collision responses like blocking, triggering events, and bouncing. 12-Collision-Detection Chapter 13: Collision Detection This chapter explores tile-based game environments using tilemaps. You will learn how to efficiently create game worlds by arranging tiles from a tileset. 13-Tilemap Chapter 14: Sound Effects and Music Learn how to load and play sound effects and background music in MonoGame, including managing audio volume, looping, and handling multiple simultaneous sound effects. 14-SoundEffects-And-Music Chapter 15: Audio Controller Learn how to create a reusable audio controller class to manage sound effects and music, including volume control, muting/unmuting, and proper resource cleanup. 15-Audio-Controller Chapter 16: Working with SpriteFonts Learn how to create and use SpriteFonts to render text in your MonoGame project, including loading custom fonts and controlling text appearance. 16-Working-With-SpriteFonts Chapter 17: Scenes Learn how to implement scene management to handle different game screens like menus, gameplay, and transitions between scenes. 17-Scenes Chapter 18: Texture Sampling Learn how to use texture sampling states and add a scrolling background effect to the game. 18-Texture-Wrapping Chapter 19: User Interface Fundamentals Learn the core principles of game user interface design. 19-User-Interface-Fundamentals Chapter 20: Implementing UI with Gum Learn how to integrate and use the Gum UI framework to create functional menus, buttons, and sliders for your MonoGame projects. 20-Implementing-UI-With-Gum Chapter 21: Customizing Gum UI Learn how to create custom UI components with animations and visual styling in Gum. 21-Customizing-Gum-UI Chapter 22: Snake Game Mechanics Learn how to implement classic snake-like game mechanics and organize game objects into reusable components. 22-Snake-Game-Mechanics Chapter 23: Completing the Game Finalize game mechanics by updating our current demo into a snake-like inspired game. 23-Completing-The-Game Chapter 24: Shaders Learn how to create custom visual effects using shaders in MonoGame. 24-Completing-The-Game Chapter 25: Packaging Your Game for Distribution Learn how to package your game for distribution across Windows, macOS, and Linux platforms. Chapter 26: Publishing Your Game to itch.io Learn how to deploy your MonoGame project to itch.io and configure it for players across different platforms. Chapter 27: Conclusion and Next Steps Review key MonoGame concepts learned, discover community resources, and get practical advice for beginning your own game development projects. Conventions Used in This Documentation The following conventions are used in this documentation. Italics Italics are used for emphasis and technical terms. Highlights Highlights are used for paths such as file paths, including filenames, extensions and other critical information in the application of steps in a tutorial. These are similar to Inline code blocks as they stand out more in Markdown and require emphasis. Inline Code Blocks Inline code blocks are used for methods, functions, and variable names when they are discussed within the paragraphs of text. For example, when referring to a method such as Foo in a sentence,it will appear with this formatting. Code Blocks // Example Code Block public void Foo() { } Code blocks are used to show code examples with syntax highlight. These appear as separated blocks rather than inline with text, allowing for multi-line examples and better readability of complete code snippets. MonoGame If you ever have questions about MonoGame or would like to talk with other developers to share ideas or just hang out with us, you can find us in the various MonoGame communities below: Discord GitHub Discussions Forum Community Forums (deprecated) Reddit Facebook Note From Author I have been using MonoGame for many years (since 2017), it was a time in my game development journey where I was looking for something that I had more control over. I did not want to spend the time to write a full game engine, but I also wanted to have more control than what the current engines at the time (i.e. Unity) offered. At that time, there was a vast amount of resources available for getting started, but none of them felt like they fit a good beginner series. Even now, the resources available still seem this way. They either require the reader to have a great understanding of game development and programming, or they assume the reader has none and instead focuses on teaching programming more than teaching MonoGame. Even still, some relied too heavily on third party libraries, while others were simply very bare bones, asking the reader to just copy and paste code without explaining the what/why of it all. Since then, I have written various small self contained tutorials on different topics for MonoGame to try and give back to the community for those getting started. I also participate regularly in the community discussion channels, answering questions and offering technical advice, so I am very familiar with the topics and pain points that users get hung up on when first starting out. With this documentation, I hope to take the lessons I have learned and provide a tutorial series that I wish was available when I first started, and to present using MonoGame in a straight forward way, introducing concepts and building off of them as we go along in a way that makes sense and is easy to follow. - Christopher Whitley (Aristurtle) Acknowledgements This documentation would not have been possible without the support and contributions from numerous individuals within the MonoGame community. First and foremost, I want to express my gratitude to the MonoGame Foundation, its maintainers, and the countless others contributors, who have preserved and evolved this framework, ensuring developers like myself have the tools needed to bring our creative visions to life. Their dedication to keeping the spirit of XNA alive has been invaluable to indie game developers worldwide. I am particularly grateful to the members of the MonoGame Discord community who reviewed early drafts of this content, providing feedback that helped shape these chapters into more a accessible and comprehensive learning resource. To the many developers of games, such as Celeste, thank you for demonstrating what is possible with MonoGame and inspiring newcomers to explore this framework. Finally, I would like to thank all the creators and contributors to open-source libraries and tools for MonoGame, including the the creators of Gum, Nez, and MonoGame.Extended and the many other libraries that have helped make game development in MonoGame more accessible. This documentation stands on the shoulders of a vibrant community that continues to share knowledge, and it is my hope that these tutorials will contribute meaningfully to that ongoing exchange. Get Started Chapter 1 - What is MonoGame"
  },
  "templates/docs.monogame.github.io/articles/tutorials/index.html": {
    "href": "templates/docs.monogame.github.io/articles/tutorials/index.html",
    "title": "Tutorials | hallowed",
    "summary": "Note The MonoGame Foundation are actively working with the community to update tutorials and documentation, while the existing content available is still valid and working, it is felt it does need modernizing. Have a tutorial suggestion, article or series that really helped you? Then please log an issue to get it included. 2D A selection of 2D focused content and tutorials. 2D Getting started tutorial The official MonoGame 2D getting started guide for MonoGame, covering everything from getting setup to publishing your first game on Itchio. Click to view 2D tutorial 2D Mobile Deployment - coming soon An extension tutorial following on from the Beginner 2D above demonstrating how to take a desktop project to Mobile devices. Coming Soon 2D Advanced Shaders - coming soon An extension tutorial following on from the Beginner 2D above demonstrating advanced shader techniques for 2D projects. See what is coming 2D Networking - coming soon An extension tutorial following on from the Beginner 2D above demonstrating connecting multiple clients together and implementing leaderboards. See what is coming 3D A selection of 3D focused content and tutorials. 3D Getting started - coming soon The official MonoGame 3D getting started guide is currently in production, check back often or look at the Discord announcements. Coming Soon MonoGame Foundation Links to other related resources and information. Roadmap Check out the MonoGame roadmap for more incoming educational content. See what is coming Blog The official MonoGame Foundation blog for notes, minutes and announcements. View the MonoGame blog Bounties The Foundation has a number of paid contribution efforts for the Framework, ranging from Tutorials, Framework extensions and samples. Check out the bounties Other community recommended tutorials Check out the awesome work of the larger MonoGame community with their own tutorials, blogs and videos. Microsoft XNA Game Studio educational resources archive Archived XNA Game Studio documentation RB Whitaker's MonoGame Tutorials 1 - C# Crash Course 2 - MonoGame Getting started tutorials 3 - MonoGame 2D tutorials 4 - 3D tutorials Extra - XNA tutorials Neil Danson's F# series Part 1 - MacOS Part 2 - Android Part 3 - iOS Part 4 - Content Pipeline Shaders MonoGame-Pixel-Planets - a port of Pixel Planets made by DeepFold with a lot of GLSL shaders converted to HLSL MonoGame-Shader-Samples Darkside of MonoGame video series Getting Started with MonoGame using Visual Studio 2019 Getting Started with MonoGame using Visual Studio for Mac Getting Started with MonoGame using the command-line Walk-through setting up your Mac for MonoGame CLI Getting Started with MonoGame using 2D Getting Started with MonoGame using XML Getting the most out of your assets–The MonoGame Content Pipeline MonoGame - Building multi-platform solutions Building apps & games for Xbox One using UWP Video Tutorials CodingMadeEasy RPG Tutorial Psuedo Games Tutorials Batholith Entertainment Game dev tutorials Let's Code: The T-Rex Runner Game with MonoGame Others Dark Genesis Blog MonoGame content awesome-monogame - A large list of MonoGame libraries and more by aloisdeniel A collection of tutorials, libraries and more, many of which are MonoGame related How to create animations and sprite sheets for MonoGame Making a platformer in F# with MonoGame XNA 4.0 Shader Programming / HLSL Using Spine with MonoGame - by Randolph Burt (Randeroo) Porting a Windows Phone 7 Game to Android MonoGame \"Hello World\" on Mac OS X and Xamarin Studio Solving Resolution Independent Rendering And 2D Camera Using Monogame XNA is Dead; Long Live the New XNA, MonoGame Running MonoGame on Android Wear Text rendering in MonoGame Randomchaos-MonoGame-Samples Other Languages A collection of tutorials in other languages: Portuguese Desenvolvimento de jogos para Windows 8 com XNA - Alexandre Chohfi (Portuguese) French French articles about MonoGame on Linux, Windows and Windows 8 We Need Your Help MonoGame is an open-source project maintained by its community. Great open source projects require high-quality documentation. This is a call for volunteers to continue to help us make the MonoGame documentation truly great. If you can create tutorials, feature guides, code snippets, reference docs, video walkthroughs, or make any improvement to the current documentation, we could use your help! Check out the README on GitHub or talk with us on discord to learn how to help!"
  },
  "templates/docs.monogame.github.io/articles/whats_new.html": {
    "href": "templates/docs.monogame.github.io/articles/whats_new.html",
    "title": "Whats New | hallowed",
    "summary": "MonoGame 3.8.4 Note Coming soon Refer to the CHANGELOG for a more complete list of the changes. Notes for the final 3.8.4 release are still in progress. Preview builds are available. Note More details to follow MonoGame 3.8.3 Note Refer to the CHANGELOG for a more complete list of the changes. SDL bumped to 2.32.2 VS2022 Extension with new 2D cross-platform project templates Content pipeline working on all supported platforms Content Pipeline updated to use the new FreeType and FreeImage Improved / updated content pipeline dependencies (Textures, Audio, Input) Several SoundEffect fixes, including OpenAL update GamePad button mappings on Android and iOS, Plus Joystick input fixes MonoGame updated to be more AOT/trimming compliant Fix Android MediaPlayer Song Preliminary scaffolding for new Native platform API Documentation updates Vulkan in preview Note More details to follow MonoGame 3.8.2 Note Refer to the CHANGELOG for a more complete list of the changes. Update to .NET 8, including the MGCB tool (now a local tool rather than global, allowing different projects to use different versions) Removal of Windows UWP due to Microsoft shutting support for it (you can still use UWP if you remain on 3.8.1) Updated build dependencies to improve support. New documentation, including the continuing migration of the older XNA documentation. A MASSIVE clean-up of the MonoGame XML documentation, big shout out to (@AristurtleDev and his team). Build system improvements (mainly a MonoGame building backend thing). Various bug fixes across many areas of the framework. Note More details to follow MonoGame 3.8.1 (including Hotfix) The MonoGame 3.8.1 release marks some big changes since 3.8.0 in how we build and distribute. Note Refer to the CHANGELOG for a more complete list of the changes. .NET 6 Support We now support .NET 6 exclusively. This brings us up to date with the latest improvements in the .NET ecosystem and allows for exciting new features like .NET NativeAOT Runtime and much easier distribution of your games for Windows, macOS and Linux. Visual Studio 2022 extension MonoGame 3.8.1 now comes with an optional Visual Studio extension which will install all the MonoGame project templates and will allow for quick access to the MGCB Editor. This extension is available for Visual Studio 2022, and Visual Studio 2022 for Mac. If you are migrating from 3.8.0 it is recommended to uninstall the existing global MGCB .NET tools. We recommend reviewing the Migrating from 3.8.0 documentation, as there are changes to how 3.8.1 works with the .NET tools and the new extension. Visual Studio 2019 and prior are no longer supported Since .NET 6 is not supported by Visual Studio 2019, starting with MonoGame 3.8.1 it will no longer be possible to build games with it. Moving forward, we will only support Visual Studio 2022, and Visual Studio 2022 for Mac. If you need to use Visual Studio 2019, we encourage you to stick to MonoGame 3.8.0. JetBrains Rider and Visual Studio Code can be used regardless of the version of MonoGame. Last version to support 32bit Windows MonoGame 3.8.1 will be the last version to support building and running 32bit games on Windows. This is motivated by the fact that 32-bit players are nearly extinct (less than 0.24% of the Steam user base). It will also help developers with less complex distribution and less confusing debug/build experiences. Apple silicon (M1+) support Games built using the DesktopGL platform and targeting osx-arm64 will now run natively on Apple silicon without Rosetta emulation. However, it is not yet possible to use the MGCB or the MGCB Editor on Apple silicon, unless you are running the osx-x64 variant of the .NET SDK (and therefore using Rosetta emulation). We are working toward resolving this inconvenience."
  },
  "templates/docs.monogame.github.io/errors/mgfx0001/index.html": {
    "href": "templates/docs.monogame.github.io/errors/mgfx0001/index.html",
    "title": "MonoGame error MGFX0001 | hallowed",
    "summary": "Example messages Error: MGFXC0001: MGFXC effect compiler requires a valid Wine installation to be able to compile shaders. Please visit https://docs.monogame.net/errors/mgfx0001?tab=macos for more details. Error: MGFXC0001: MGFXC effect compiler requires a valid Wine installation to be able to compile shaders. Please visit https://docs.monogame.net/errors/mgfx0001?tab=linux for more details. Issue This error indicates that Wine is not installed on the development machine. Wine is currently required in order to compile Effects on both Linux and MacOS. Solution You need to make sure you have installed Wine on your machine. Please look at the following link for detailed instructions on how to install Wine and configure it for use with MonoGame."
  },
  "templates/docs.monogame.github.io/errors/setupwine/index.html": {
    "href": "templates/docs.monogame.github.io/errors/setupwine/index.html",
    "title": "| hallowed",
    "summary": "url_validation"
  },
  "templates/docs.monogame.github.io/foundation/index.html": {
    "href": "templates/docs.monogame.github.io/foundation/index.html",
    "title": "Foundation Bylaws | hallowed",
    "summary": "Bylaws of the MonoGame Foundation, Inc. (Texas Non-Profit Corporation) Table of contents Article 1 - Offices Article 2 - Purpose Article 3 - Shareholders Article 4 - Board of Directors Article 5 - Notice Article 6 - Officers and Agents Article 7 - Committees Article 8 - General Provisions These bylaws of the MonoGame Foundation, Inc. (the “Corporation”), dated as of 29 September 2023 (the “Effective Date”), are adopted by the Board of Directors and are executed and agreed to. Article 1 - Offices 1.1 Registered Office. The registered office and registered agent of the Corporation will be as set forth in the Corporation’s Certificate of Formation, previously filed with the Texas Secretary of State on September 29, 2023. The Corporation may change its registered office, registered agent, or both by filing a statement of change with the secretary of state of the state of Texas. 1.2 Other Offices. The Corporation may also have offices at other places, both within and outside the state of Texas, as the Board of Directors determines or as the business of the Corporation requires. Article 2 - Purpose 2.1 General Purpose. The general purposes for which this Corporation has been established are as follows: a. Exclusively for charitable, religious, educational, and scientific purposes, within the meaning of such terms as defined in the Internal Revenue Code (the “Code”) or the corresponding section of any future federal tax code, including for such purposes, the making of distributions to organizations that qualify as exempt organizations under such section. b. The Corporation is established within the meaning of IRS Publication 557 Section 501(c) of the Code of 1986 or the corresponding section of any future federal tax code and will be operated exclusively for the solicitation of funds to support veterans’ service organizations. 2.2 Powers. The Corporation will hold and may exercise all such powers as may be conferred upon any nonprofit organization by the laws of the State of Texas and as may be necessary or expedient for the administration of the affairs and attainment of the purposes of the Corporation. At no time and in no event will the Corporation participate in any activities which have not been permitted to be carried out by a Corporation exempt under Section 501(c) of the Code. Article 3 - Shareholders The Corporation has no Shareholders. Article 4 - Board of Directors 4.1 Management. The business and affairs of the Corporation will be managed by or under the direction of the Board of Directors, who may exercise all such powers of the Corporation and do all such lawful acts not directed or required by law, the certificate of formation, or these bylaws. 4.2 Board Elections. The Governance Committee will present a nomination slate for new and renewing Board members at the board meeting immediately preceding the beginning of the next fiscal year. Recommendations from the Governance Committee will be made known to the Board in writing before nominations are made and voted on. New and renewing Board members shall be approved by a majority of those Board members at a Board meeting at which a quorum is present. 4.3 Qualification; Election; Term. None of the Directors need be a resident of the state of Texas. Each Director will hold its office until whichever of the following occurs first: (a) a successor is elected and qualified, (b) resignation, (c) removal from office, or (d) death. Directors will be elected by the affirmative vote of a two-thirds majority of the then serving Board of Directors. 4.4 Number. a. The Board shall have up to eleven, but no fewer than three, Board members. The number of Board members may be increased beyond eleven members or decreased to less than three members by the affirmative vote of a two-thirds majority of the then serving Board of Directors. A Board member need not be a resident of the State of Texas. b. In addition to the regular membership of the Board, representatives of such other organizations or individuals as the Board may deem advisable to elect shall be Ex-Officio Board Members, which will have the same rights and obligations, including voting power, as the other directors. 4.5 Term. All appointments to the Board shall be for a term of three year(s). No person shall serve more than three consecutive terms unless a majority of the Board, during the course of a Board meeting at which a quorum is present, votes to appoint a Board member to one additional year(s). No person shall serve more than seven consecutive years. After serving the maximum total number of consecutive years on the Board, a member may be eligible for reconsideration as a Board member after one year has passed since the conclusion of such Board member's service. 4.6 Removal. Any Director may be removed with or without cause at any special meeting of Board of Directors by the affirmative vote of a two-thirds majority of the then serving Board of Directors. 4.7 Resignation. Each Board member has the right to resign at any time upon written notice thereof to the Chair of the Board, Secretary of the Board, or the Executive Director. Unless otherwise specified in the notice, the resignation will take effect upon receipt thereof, and the acceptance of such resignation shall take effect upon receipt thereof, and the acceptance of such resignation will not be necessary to make it effective. 4.8 Vacancies. Any vacancy occurring in the Board of Directors may be filled by an affirmative vote or written consent of a majority of the remaining Directors even if the remaining directors constitute less than a quorum of the Board of Directors. 4.9 Place of Meetings. Regular or special meetings of the board of directors may be held at any place within or outside the state of Texas as fixed by the Board of Directors. 4.10 Annual Meeting. The Board of Directors will have an annual meeting no later than three weeks after the end of the previous calendar year. 4.11 Regular Meetings. Regular meetings of the Board of Directors may be held without notice at any time and place determined by resolution of the Board of Directors. Except as may be otherwise expressly provided by law, the certificate of formation, or these bylaws, neither the business to be transacted nor the purpose of any regular meeting need be specified in a notice or waiver of notice. 4.12 Board Member Attendance. An elected Board Member who is absent from three consecutive regular meetings of the Board during a fiscal year will be encouraged to reevaluate with the Chair of the Board his/her commitment to the Corporation/Organization. The Board may deem a Board member who has missed three consecutive meetings without such a reevaluation with the Chair to have resigned from the Board. 4.13 Quorum and Action by Directors. At each meeting of the Board of Directors or Board Committees, the presence of four (4) persons will constitute a quorum for the transaction of business. If at any time the Board consists of an even number of members and a vote results in a tie, then the vote of the Chair of the Board will be the deciding vote. The act of the majority of the Board members serving on the Board or Board Committees and present at a meeting in which there is a quorum will be the act of the Board, unless otherwise provided by the Articles of Incorporation, these Bylaws, or a law specifically requiring otherwise. If a quorum is not present at a meeting, the Board members present may adjourn the meeting from time to time without further notice until a quorum is present. However, a Board member will be considered present at any meeting of the Board or Board Committees if during the meeting he or she is present via telephone or web conferencing with the other Board members participating in the meeting. 4.14 Minutes. The Secretary is responsible for the recording of all minutes of each and every meeting of the Board in which business is transacted in such order as the Board may determine from time to time. However, in the event that the Secretary is unavailable, the Chair of the Board will appoint an individual to act as Secretary at the meeting. The Secretary, or the individual appointed to act as Secretary, will prepare the minutes of the meetings, which will be delivered to the President for review and, then, to be placed in the Corporation’s minute books. A copy of the minutes will be delivered to each Board member via either regular mail, hand delivered, emailed, or faxed within five business days after the close of each Board meeting. 4.15 Compensation of Directors. The Board will not receive any compensation other than reimbursement for reasonable expenses. However, provided the compensation structure complies with the other provisions herein, nothing in these Bylaws will be construed to preclude any Board member from serving the Corporation/Organization in any other capacity and receiving compensation for services rendered. Article 5 - Notice 5.1 Form of Notice. Whenever notice is required by law, the certificate of formation, or these bylaws to be given to any director, committee member, or officer, and if no provision is made as to how notice is to be given, notice may be given in writing, by mail, postage prepaid, addressed to the director, committee member, or shareholder at the address that appears on the books of the Corporation, email, or by any other method permitted by law. Any notice required or permitted to be given by mail will be deemed to be given at the time it is deposited in the United States mail. Notice to directors, committee members, and officers may also be given by a nationally recognized overnight delivery or courier service and will be deemed delivered when the notice is received by the proper recipient or, if earlier, one day after the notice is sent by the overnight delivery or courier service. Notice for email is considered same-day. Article 6 - Officers and Agents 6.1 In General. The Board shall elect officers of the Corporation/Organization which shall include a Chair of the Board (Chief Executive Officer), President (Executive Director), a Secretary, a Treasurer (Chief Financial Officer), and such other officers as the Board may designate by resolution. The same person may hold any number of offices, except that neither the Secretary nor the Treasurer may serve concurrently as the Chair of the Board or the President. In addition to the duties in accordance with this Article, officers shall conduct all other duties typically pertaining to their offices and other such duties which may be required by law, Articles of Incorporation, or by these bylaws, subject to control of the Board of Directors, and they shall perform any other such additional duties which the Board of Directors may assign to them at their discretion. 6.2 Election. The officers will be selected by the Board at its annual meeting, and shall serve the needs of the Board, subject to all the rights, if any, of any officer who may be under a contract of employment. Therefore, without any bias or predisposition to the rights of any officer that may be under any contract of employment, any officer may be removed with or without cause by the Board. All officers have the right to resign at any time by providing notice in writing to the Chair of the Board, President, and/or Secretary of the Corporation/Organization, without bias or predisposition to all rights, if any, of the Corporation/Organization under any contract to which said officer is a part thereof. All resignations shall become effective upon the date on which the written notice of resignation is received or at any time later as may be specified within the resignation; and unless otherwise indicated within the written notice, a stated acceptance of the resignation shall not be required to make the resignation effective. 6.3 Vacancies. Any and all vacancies in any office because of death, resignation, disqualification, removal, or for any other cause, shall be filled in accordance to the herein prescribed bylaws for regular appointments to such office. The compensation, if any, of the officers shall be fixed or determined by resolution of the Board of Directors. 6.4 Compensation. The compensation of all officers and agents of the Corporation will be fixed by the board of directors or any committee of the board, if so authorized by the board. 6.5 Chair of the Board of Directors (Chief Executive Officer). It is the responsibility of the Chair of the Board, when present, to preside over all meetings of the Board of Directors and Executive Committee. The Chair of the Board is authorized to execute, in the name of the Corporation, any and all contracts or other documents which may be authorized, either generally or specifically, by the Board to be executed by the Corporation, except when required by law that the President's signature must be provided. 6.6 President (Executive Director). It is the responsibility of the President, in general, to supervise and conduct all activities and operations of the Corporation, subject to the control, advice and consent of the Board of Directors. The President will keep the Board of Directors completely informed, will freely consult with them in relation to all activities of the Corporation, and will see that all orders and/or resolutions of the Board are carried out to the effect intended. The Board of Directors may place the President under a contract of employment where appropriate. The President is empowered to act, speak for, or otherwise represent the Corporation between meetings of the Board. The President is responsible for the hiring and firing of all personnel, and will be responsible for keeping the Board informed at all times of staff performance and for implementing any personnel policies which may be adopted and implemented by the Board. The President, at all times, is authorized to contract, receive, deposit, disburse and account for all funds of the Corporation, to execute in the name of the Corporation all contracts and other documents authorized either generally or specifically by the Board to be executed by the Corporation, and to negotiate any and all material business transactions of the Corporation. 6.7 Secretary. The Secretary, or his/her designee, is the custodian of all records and documents of the Corporation, which are required to be kept at the principal office of the Corporation, and will act as secretary at all meetings of the Board of Directors, and will keep the minutes of all such meetings on file in hard copy or electronic format. He will attend to the giving and serving of all notices of the Corporation and will see that the seal of the Corporation, if any, is affixed to all documents, the execution of which on behalf of the Corporation under its seal is duly authorized in accordance with the provisions of these bylaws. 6.8 Treasurer (Chief Financial Officer). a. It shall be the responsibility of the Treasurer to keep and maintain, or cause to be kept and maintained, adequate and accurate accounts of all the properties and business transactions of the Corporation, including accounts of its assets, liabilities, receipts, disbursements, gains, losses, capital, retained earnings, and other matters customarily included in financial statements. b. The Treasurer is responsible for ensuring the deposit of, or cause to be deposited, all money and other valuables as may be designated by the Board of Directors. Furthermore, the Treasurer will disburse, or cause to be disbursed, the funds of the Corporation, as may be ordered by the Board of Directors, and will render to the Chair of the Board, President, and directors, whenever they request it, an account of all the Treasurer's transactions as treasurer and of the financial condition of the Corporation. 6.9 Banking Matters Representative. The Banking Matters Representative works reports directly to the Treasurer - both Officers have the authority to open bank accounts in the name of the corporation and conduct business with banking institutions for the corporation. The Banking Matters Representative is the designated center for communications with banking institutions for the corporation. 6.10 Bonding. The Corporation may secure a bond to protect the Corporation from loss in the event of defalcation by any of the officers. The bond may be in the form and amount and with the surety the board of directors deems appropriate. The Corporation will pay for all required bonds. Article 7 - Committees 7.1 Committees of Directors. The Board of Directors may, by resolution adopted by a majority of the directors then in office, provided that a quorum is present, designate one or more committees to exercise all or a portion of the authority of the Board, to the extent of the powers specifically delegated in the resolution of the Board or in these bylaws. Each such committee will consist of two (2) or more directors, and may also include persons who are not on the Board but whom the directors believe to be reliable and competent to serve at the specific committee. However, committees exercising any authority of the Board of Directors may not have any non-director members. The Board may designate one or more alternative members of any committee who may replace any absent member at any meeting of the committee. The appointment of members or alternate members of a committee requires the vote of a majority of the directors then in office, provided that a quorum is present. The Board of Directors may also designate one or more advisory committees that do not have the authority of the Board. However, no committee, regardless of Board resolution, may: a. Approve of any action that, pursuant to applicable Law, would also require the affirmative vote of the members of the Board if this were a membership vote. b. Fill vacancies on, or remove the members of, the Board of Directors or any committee that has the authority of the Board. c. Fix compensation of the directors serving on the Board or on any committee. d. Amend or repeal the Articles of Incorporation or bylaws or adopt new bylaws. e. Amend or repeal any resolution of the Board of Directors that by its express terms is not so amendable or repealable. f. Appoint any other committees of the Board of Directors or their members. g. Approve a plan of merger, consolidation, voluntary dissolution, bankruptcy, or reorganization; or a plan for the sale, lease, or exchange of all or considerably all of the property and assets of the Corporation/Organization otherwise than in the usual and regular course of its business; or revoke any such plan. h. Approve any self-dealing transaction, except as provided pursuant to law. Unless otherwise authorized by the Board of Directors, no committee will compel the Corporation into a contract or agreement or expend Corporation funds. 7.2 Meetings and Actions of Committees. Meetings and actions of all committees will be governed by, and held and taken in accordance with, these bylaws concerning meetings and actions of the directors, with such changes in the context of those bylaws as are necessary to substitute the committee and its members for the Board of Directors and its members, except that the time for regular meetings of committees may be determined either by resolution of the Board of Directors or by resolution of the committee. Special meetings of committees may also be called by resolution of the Board of Directors. Notice of special meetings of committees will also be given to any and all alternate members, who will have the right to attend all meetings of the committee. Minutes will be kept of each meeting of any committee and will be filed with the Corporation records. The Board of Directors may adopt rules not consistent with the provisions of these bylaws for the governance of any committee. If a director relies on information prepared by a committee of the Board on which the director does not serve, the committee must be composed exclusively of any or any combination of (a) directors, (b) directors or employees of the Corporation/Organization whom the director believes to be reliable and competent in the matters presented, or (c) counsel, independent accountants, or other persons as to matters which the director believes to be within that person's professional or expert competence. 7.3 Executive Committee. Pursuant to these Bylaws, the Board may appoint an Executive Committee composed of a minimum of two directors, one of whom shall be the Chair of the Board and another shall be either the Secretary, or the Treasurer, to serve on the Executive Committee of the Board. The Executive Committee, unless limited in a resolution of the Board, shall have and may exercise all the authority of the Board in the management of the business and affairs of the Corporation between meetings of the Board, provided, however, that the Executive Committee will not have the authority of the Board in reference to those matters enumerated in Paragraph 6.1, herein. The Secretary of the Corporation will send to each director a summary report of the business conducted in any meeting of the Executive Committee. Article 8 - General Provisions 8.1 Standard of Care. A director will perform all the duties of a director, including, but not limited to, duties as a member of any committee of the Board on which the director may serve, in such a manner as the director deems to be in the best interest of the Corporation and with such care, including reasonable inquiry, as an ordinary, prudent, and reasonable person in a similar situation may exercise under similar circumstances. In the performance of the duties of a director, a director will be entitled to rely on information, opinions, reports, or statements, including financial statements and other financial data, in each case prepared or presented by: a. One or more officers or employees of the Corporation whom the director deems to be reliable and competent in the matters presented; b. Counsel, independent accountants, or other persons, as to the matters which the director deems to be within such person's professional or expert competence; or c. A committee of the Board upon which the director does not serve, as to matters within its designated authority, which committee the director deems to merit confidence, so long as in any such case the director acts in good faith, after reasonable inquiry when the need may be indicated by the circumstances, and without knowledge that would cause such reliance to be unwarranted. Except as herein provided in Article 8, any person who performs the duties of a director in accordance with the above shall have no liability based upon any failure or alleged failure to discharge that person's obligations as a director, including, without limitation of the following, any actions or omissions which exceed or defeat a public or charitable purpose to which the Corporation, or assets held by it, are dedicated. 8.2 Loans. The Corporation/Organization will not make any loan of money or property to, or guarantee the obligation of, any director or officer, unless approved by the Texas Attorney General; provided, however, that the Corporation may advance money to a director or officer of the Corporation or any subsidiary for expenses reasonably anticipated to be incurred in the performance of the duties of such officer or director so long as such individual would be entitled to be reimbursed for such expenses absent that advance. 8.3 Conflict of Interest. The purpose of the Conflict of Interest policy is to protect the Corporation's interest when it is contemplating entering into a transaction or arrangement that might benefit the private interest of one of its officers or directors, or that might otherwise result in a possible excess benefit transaction. This policy is intended to supplement but not replace any applicable state and federal laws governing conflict of interest applicable to nonprofit and charitable corporations and is not intended as an exclusive statement of responsibilities. 8.4 Deleted. 8.5 Duty to Disclose. In connection with any actual or possible conflict of interest, an interested person must disclose the existence of the financial interest and be given the opportunity to disclose all material facts to the directors who are considering the proposed transaction or arrangement. 8.6 Establishing a Conflict of Interest. After the disclosure of the financial interest and all material facts, and after any discussion with the interested person, the interested person shall leave the Board meeting while the potential conflict of interest is discussed and voted upon. The remaining Board members will decide if a conflict of interest exists. 8.7 Addressing a Conflict of Interest. In the event that the Board should establish that a proposed transaction or arrangement establishes a conflict of interest, the Board shall then proceed with the following actions: a. Any interested person may render a request or report at the Board meeting, but upon completion of said request or report the individual shall be excused while the Board discusses the information and/or material presented and then votes on the transaction or arrangement proposed involving the possible conflict of interest. b. The Chair of the Board of the Board shall, if deemed necessary and appropriate, appoint a disinterested person or committee to investigate alternatives to the proposed transaction or arrangement. c. After exercising due diligence, the Board shall determine whether the Corporation can obtain with reasonable efforts a more advantageous transaction or arrangement from a person or entity that would not give rise to a conflict of interest. d. If a more advantageous transaction or arrangement is not reasonably possible under circumstances not producing a conflict of interest, the Board shall determine by a majority vote of the disinterested directors whether the transaction or arrangement is in the best interest of the Corporation, for its own benefit, and whether it is fair and reasonable. It shall make its decision as to whether to enter into the transaction arrangement in conformity with this determination. 8.8 Violations of Conflict of Interest Policy. Should the Board have reasonable cause to believe an interested person has failed to disclose actual or possible conflicts of interest, the Board will then inform the interested person of the basis for such belief and afford the interested person an opportunity to explain the alleged failure to disclose. If, after hearing the interested person's explanation, and after making further investigation as may be warranted in consideration of the circumstances, the Board determines the interested person intentionally failed to disclose an actual or possible conflict of interest, it shall take appropriate disciplinary and corrective action. 8.9 Acknowledgement of the Conflict of Interest Policy. Each director, principal officer, and member of a committee with Board delegated powers shall be required to sign a statement which affirms that such person: a. Has received a copy of the conflict of interest policy; b. Has read and understands the policy; c. Has agreed to comply with the policy; and d. Understands that the Corporation/Organization is charitable, and in order to maintain its federal tax exemption, it must engage primarily in activities which accomplish one or more of its tax-exempt purposes. 8.10 Violation of Loyalty - Self-Dealing Contracts. A self-dealing contract is any contract or transaction (i) between this Corporation/Organization and one or more of its Directors, or between this Corporation/Organization and any corporation, firm, or association in which one or more of the Directors has a material financial interest (\"Interested Director\"), or (ii) between this Corporation/Organization and a corporation, firm, or association of which one or more of its directors are Directors of this Corporation/Organization. Said self-dealing shall not be void or voidable because such Director(s) of corporation, firm, or association are parties or because said Director(s) are present at the meeting of the Board of Directors or committee which authorizes, approves or ratifies the self-dealing contract, if: a. All material facts are fully disclosed to or otherwise known by the members of the Board and the self-dealing contract is approved by the Interested Director in good faith (without including the vote of any membership owned by said interested Director(s)); b. All material facts are fully disclosed to or otherwise known by the Board of Directors or committee, and the Board of Directors or committee authorizes, approves, or ratifies the self-dealing contract in good faith—without counting the vote of the interested Director(s)— and the contract is just and reasonable as to the Corporation/Organization at the time it is authorized, approved, or ratified; or c. As to contracts not approved as provided in above sections (a) and/or (b), the person asserting the validity of the self-dealing contract sustains the burden of proving that the contract was just and reasonable as to the Corporation/Organization at the time it was authorized, approved, or ratified. Interested Director(s) may be counted in determining the presence of a quorum at a meeting of the Board of Directors or a committee thereof, which authorizes, approves, or ratifies a contract or transaction as provided for and contained in this section. 8.11 Indemnification. a. To the fullest extent permitted by law, the Corporation will indemnify its \"agents,\" as described by law, including its directors, officers, employees and volunteers, and including persons formerly occupying any such position, and their heirs, executors and administrators, against all expenses, judgments, fines, settlements, and other amounts actually and reasonably incurred by them in connection with any \"proceeding,\" and including any action by or in the right of the Corporation, by reason of the fact that the person is or was a person as described in the Non-Profit Corporation Act. Such right of indemnification will not be deemed exclusive of any other right to which such persons may be entitled apart from this Article. b. To the fullest extent permitted by law, and, except as otherwise determined by the Board in a specific instance, expenses incurred by a person seeking indemnification in defending any \"proceeding\" shall be advanced by the Corporation of an undertaking by or on behalf of that person to repay such amount unless it is ultimately determined that the person is entitled to be indemnified by the Corporation for those expenses. c. The Corporation will have the power to purchase and maintain insurance on behalf of any agent of the Corporation, to the fullest extent permitted by law, against any liability asserted against or incurred by the agent in such capacity or arising out of the agent's status as such, or to give other indemnification to the extent permitted by law. 8.12 Net Earnings. No part of the net earnings of the nonprofit corporation will inure to the benefit of, or be distributable to its officers, or other private persons, except that the nonprofit corporation will be authorized and empowered to pay reasonable compensation for services rendered and to make payments and distributions in furtherance of the purposes set forth herein. 8.13 No Political Campaigns. No substantial part of the activities of the nonprofit corporation will be the carrying on of propaganda, or otherwise attempting to influence legislation, and the nonprofit corporation will not participate in, or intervene in (including the publishing or distribution of statements) any political campaign on behalf of or in opposition to any candidate for public Office. Notwithstanding any other provision of these articles, the nonprofit corporation will not carry on any other activities not permitted to be carried on (a) by a corporation exempt from federal income tax under section 501 (c)(3) of the Code, or the corresponding section of any future federal tax code or (b) by a corporation, contributions to which are deductible under section 501 (c)(3) of the Code. 8.14. Winding Up. Upon the dissolution of the nonprofit corporation, after all liabilities and obligations of the nonprofit corporation have been paid, satisfied, and discharged in accordance with section 11.053 of the Texas Business Organizations Code (the \"BOC\"), (A) the assets held by the nonprofit corporation on a condition requiring return, transfer, or conveyance because of the winding up or termination will, in accordance with section 22.304 of the BOC, be returned, transferred, or conveyed in accordance with that requirement; and (B) the remaining assets will be distributed for one or more exempt purposes within the meaning of section 501 (c)(3) of the Internal Revenue Code, or the corresponding section of any future federal tax code, or will be distributed to the federal government, or to a state or local government, for a public purpose. Any such assets not so disposed of will be disposed of by a Court of Competent Jurisdiction of the county in which the principal office of the nonprofit corporation is then located, exclusively for such purposes or to such organization or organizations, as said Court will determine, which are organized and operated exclusively for such purposes. 8.15 Fiscal Year. The fiscal year of the Corporation will be fixed by resolution of the board of directors. 8.16 Execution of Corporation Instruments. a. The Board of Directors may, at its discretion, determine the method and designate the signatory officer or officers, or other person or persons, to execute any corporate instrument or document, or to sign the corporate name without limitation, except when otherwise provided by law, and such execution or signature shall be binding upon the Corporation. b. Unless otherwise specifically determined by the Board of Directors or otherwise required by law, formal contracts of the Corporation, promissory notes, deeds of trust, mortgages, other evidences of indebtedness of the Corporation, other corporate/organization instruments or documents, memberships in other corporations/organizations, and certificates of shares of stock owned by the Corporation will be executed, signed, and/or endorsed by the President and Secretary. c. All checks and drafts drawn on banks or other depositories on funds to the credit of the Corporation, or in special accounts of the Corporation, will be signed by such person or persons as the Board of Directors authorizes to do so. 8.17 Loans and Contracts. No loans or advances will be contracted on behalf of the Corporation and no note or other evidence of indebtedness shall be issued in its name unless and except as the specific transaction is authorized by the Board of Directors. Without the express and specific authorization of the Board, no officer or other agent of the Corporation may enter into any contract or execute and deliver any instrument in the name of and on behalf of the Corporation. 8.18 Maintenance and inspection of Articles and Bylaws. The Corporation will keep at its principal office the original or a copy of its Articles of Incorporation and bylaws as amended to date, which will be open to inspection by the directors at all reasonable times during office hours. 8.19 Maintenance and Inspection of Federal Tax Exemption Application and Annual Information Returns. The Corporation will keep at its principal office a copy of its federal tax exemption application and its annual information returns for three years from their date of filing, which shall be open to public inspection and copying to the extent required by law. 8.20 Maintenance and Inspection of Other Corporate Records. The Corporation will keep adequate and correct books and records of accounts and written minutes of the proceedings of the Board and committees of the Board. All such records will be kept at a place or places as designated by the Board and committees of the Board, or in the absence of such designation, at the principal office of the Corporation. Upon leaving office, each officer, employee, or agent of the Corporation will turn over to his or her successor or the Chair of the Board or President, in good order, such corporate monies, books, records, minutes, lists, documents, contracts or other property of the Corporation as have been in the custody of such officer, employee, or agent during his or her term of office. Every director will have the absolute right at any reasonable time to inspect all books, records, and documents of every kind and the physical properties of the Corporation and each of its subsidiary corporations. The inspection may be made in person or by an agent or attorney, and shall include the right to copy and make extracts of documents. 8.21 Preparation of Annual Financial Statements. The Corporation will prepare annual financial statements using generally accepted accounting principles. Such statements may at the Board’s request, be audited by an independent certified public accountant, in conformity with generally accepted accounting standards. The Corporation will make these financial statements available to the Texas Attorney General and members of the public for inspection no later than thirty days after the close of the fiscal year to which the statements relate. 8.22 Reports. The Board will ensure an annual report is sent to all directors within thirty days after the end of the fiscal year of the Corporation, which shall contain the following information: a. The assets and liabilities, including trust funds, of this corporation at the end of the fiscal year. b. The principal changes in assets and liabilities, including trust funds, during the fiscal year. c. The expenses or disbursements of the Corporation/Organization for both general and restricted purposes during the fiscal year. d. The information required by Non-Profit Corporation Act concerning certain self-dealing transactions involving more than $50,000 or indemnifications involving more than $10,000 which took place during the fiscal year. The report will be accompanied by any pertinent report from an independent accountant or, if there is no such report, the certificate of an authorized officer of the Corporation/Organization that such statements were prepared without audit from the books and records of the Corporation. 8.23 Seal. The Corporation may have a seal, and the seal may be used by causing it or a facsimile of it to be impressed, affixed, or reproduced, or otherwise. 8.24 Indemnification. The Corporation will indemnify its directors and officers to the fullest extent permitted by the Texas Business Organizations Code and may, if and to the extent authorized by the board of directors, indemnify any other person whom it has the power to indemnify against liability, reasonable expense, or any other matter whatever. 8.25 Insurance. The Corporation may at the discretion of the Board of Directors purchase and maintain insurance on behalf of the Corporation and any person whom it has the power to indemnify pursuant to law, the certificate of formation, or these bylaws, or otherwise. 8.26 Amendment of Bylaws. These bylaws may be adopted, amended, or repealed by the vote of a two-thirds majority of the directors then in office. Such action is authorized only at a duly called and held meeting of the Board of Directors for which written notice of such meeting, setting forth the proposed bylaw revisions with explanations therefore, is given in accordance with these bylaws. If any provision of these bylaws requires the vote of a larger portion of the Board than is otherwise required by law, that provision may not be altered, amended or repealed by that greater vote. 8.27 Construction and Definitions. Unless the context otherwise requires, the general provisions, rules of construction, and definitions contained in the Non-Profit Corporation Act as amended from time to time will govern the construction of these bylaws. Without limiting the generality of the foregoing, the masculine gender includes the feminine and neuter, the singular number includes the plural and the plural number includes the singular, and the term \"person\" includes a Corporation as well as a natural person. If any competent court of law deems any portion of these bylaws invalid or inoperative, then so far as is reasonable and possible (i) the remainder of these bylaws will be considered valid and operative, and (ii) effect will be given to the intent manifested by the portion deemed invalid or inoperative. 8.28 Section Headings. The headings contained in these bylaws are for reference purposes only and will not affect in any way the meaning or interpretation of these bylaws."
  },
  "templates/docs.monogame.github.io/index.html": {
    "href": "templates/docs.monogame.github.io/index.html",
    "title": "Documentation | hallowed",
    "summary": "Learn Whether you are just starting out with MonoGame or you have been using it for years, you can find all documentation and tutorials here. Documentation Hub The official MonoGame documentation hub. This documentation helps you get started by providing overviews of key features and tools. Click to view documentation API Reference View the API reference for each class and method in the MonoGame framework. Click to view API Reference How To A collection of articles focused on answering the common questions asked by developers. Split in to: - \"How To\" guides for building features. - \"What is\" articles defining concepts. Click to view guides Tutorials Check out the awesome works of the larger MonoGame community with their own tutorials, blogs and videos. Click to view tutorials Samples Check out the MonoGame samples collection, showcasing some awesome projects made with MonoGame. Click to view samples Roadmap Check out the future of MonoGame, from current developments to long term goals. Click to view roadmap We Need Your Help MonoGame is an open-source project maintained by its community. Great open source projects require high-quality documentation. This is a call for volunteers to continue to help us make the MonoGame documentation truly great. If you can create tutorials, feature guides, code snippets, reference docs, video walkthroughs, or make any improvement to the current documentation, we could use your help! Check out the README on GitHubfor information on MonoGame or talk with us on Discord to learn how to help!"
  },
  "templates/docs.monogame.github.io/roadmap/index.html": {
    "href": "templates/docs.monogame.github.io/roadmap/index.html",
    "title": "MonoGame Roadmap | hallowed",
    "summary": "MonoGame official roadmap MonoGame has been in development for a long time with a stable outward-facing API based on XNA 4.0, which remains largely static. The core development has always been the rapid waters behind this API, providing stable and modern access to the native platforms that MonoGame can run on. The current development branch, targeting a release version of 3.8.5 of MonoGame, is expanding platform support and addressing a key subject of contention, the content editor (MGCB), for which an alternative solution is being devised (the Content Project system). Important All information and dates are subject to change. In other words, if we can get it done faster, we will! Release 3.8.5 (current development branch) The 3.8.5 release seeks to formalize the preview of several preview components for testing in preparation for the 3.9 release, namely: Preview Vulkan (DesktopVK) platform. Preview DX 12 (DesktopDX) platform. Preview the new Content Project solution. Native Platform evolution (dependencies derived from Platforms instead of dependencies). Preview releases are currently available for the 3.8.5 delivery for test. Release 3.8.4 Live Release The 3.8.4 primary focus was a quick turn-around maintenance release, primarily to address some Android platform issues introduced in 3.8.3. This release was the first to receive Preview releases (7 in total) to full road test changes, including: Improvements to AoT delivery. Improvements to Android release delivery. New testing pipeline using Samples. Upgrade of build dependencies and Wine (for Mac / Linux) Compressed texture support in Pipeline. See the Release Log for full details. Release 3.9 3.9 will effectively be the LTS release of the 3.x series for MonoGame, formalizing the XNA API support and platform access. It will also include an update to using a more ruggedized and standardized native implementation that is standard across all platforms, making the underlying native elements for MonoGame easier to maintain. All the native libraries into their own repo, hook it up to the current system. Vulcan support. DX 12 support. Updated GDK integration for Xbox Consoles (only available to registered ID@Xbox developers) New Content Project system. Important Please note that the move to the new native backend will effectively deprecate the DesktopGL project type. This will be replaced with the newer DesktopVK platform. The WindowsDX platform is also under review to include support for DX12 and the Microsoft GDK (Game Development Kit), once the results are published, the Roadmap will be updated to reflect the plans. Release 4.0 (Provisional) Version 4.0 of MonoGame aims to break compatibility with the older XNA Content Pipeline system and introduce a much more manageable and extendable system to meet the more modern needs of game development. Release 5.0 This phase is still very much in the early planning and testing phase, with the ultimate aim to break the older XNA 4.0 API. This will be a very different beast, built from the foundational ideas of XNA / MonoGame. Proposed Release Schedule Just to sneak this in here, we are listening when the community says that we need a faster and more direct delivery of the MonoGame Framework. To this end, we are proposing to: Have regular maintenance updates, ideally delivered through NuGet. Annual major releases. All of this is subject to the will of the community, so if you have an idea or suggestion, make sure to let us know on Discord. MonoGame bounty schedule Note Also check out the Bounty tracker for the latest In order to provide more transparency, the following section details all the current Bounties in production, as well as a provisional list of all other bounties under consideration or development. Important All bounties are subject to the legal requirements set out in the MonoGame Foundation charter. Please check the Bounties page for more information Active Bounties This is a list of all known bounties currently being worked on: Switch the console runtime from BRUTE to NativeAOT A better 3D onboarding tutorial MonoGame 2D advanced series - Shaders MonoGame 2D advanced series - Mobile targeting MonoGame 2D advanced series - Networking Bounties in development Advanced onboarding tutorials Working on suggestions for advanced physics integration, complex shaders, animation systems, procedural content generation, optimizations and performance. An Endless runner game sample/starter-kit A reusable sample / starter-kit for developers to build an endless runner game. A first-person 3D game sample/starter-kit A reusable sample / starter-kit for developers to build a first person style game. A third-person 3D game sample/starter-kit A reusable sample / starter-kit for developers to build a third person style game. A network starter sample Building an example framework for building local or networked multi-player games. A graphical/shader starter-kit A quick introduction to effects and shaders in MonoGame. A custom editor sample A starter solution showing how to build an editor for MonoGame showcasing multiple editor windows, multiple viewports (in a single window), custom dialogs, docking windows?, rebuilding content and a simple undo/redo framework (which we may have one available for use). A GUI integration tutorial With so many great GUI systems available for MonoGame, we could do with a tutorial showing how to integrate or build on teh best of them, such as IMGUI, NEX and so on. Texture Compression Content Pipeline The current texture compression systems does not work on arm based machines like the Apple M1/M2/M3. This bounty will upgrade the system to use Basis Universal which works across all supported Desktop plaforms. Note Have an idea for another bounty / sample or something that can make MonoGame even better, or a guide that you feel the community needs, then let us know on GitHub by raising a Feature Request and give us the details. Onward MonoGame! Thank you to the MonoGame community for your patience and support, we continue, as ever, to try and make MonoGame the best it can be."
  },
  "templates/material/README.html": {
    "href": "templates/material/README.html",
    "title": "DocFX Material | hallowed",
    "summary": "DocFX Material A simple material theme for DocFX. This is an override of the modern template so you need to enable both in the docfx.json. The design was inspired by https://m3.material.io/. If you are looking for the previous version of docfx-material that doesn't use the modern template you can still get it as material-classic. Install Download the source or the zipped file from the releases. Create a templates folder in the root of your DocFX directory. Copy the material folder to the templates folder. Update the docfx.json configuration to include the material template: { \"template\": [ \"default\", \"modern\", \"templates/material\" ], } Color customization DocFX's modern template is based on Bootstrap 5 (version 5.3 at the time of writing) so you can use Bootstrap's CSS variables to customize a lot of the colors. Here are some of the most common customizations that can be made in the template's CSS file material/public/main.css, like updating the header color, changing the font, /* Changing the navbar color only for the light theme */ [data-bs-theme='light'] nav.navbar { background-color: var(--bs-primary-bg-subtle); } /* Change active navlink color */ .navbar-nav .nav-link.active, .navbar-nav .nav-link.show { color: var(--bs-link-hover-color); } /* Changing the site font */ @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@100;400;700&display=swap'); :root { ... --bs-font-sans-serif: 'Roboto'; ... } Markdown extras For more reference about markdown support in DocFX check the official documentation. Note This is a note which needs your attention, but it's not super important. Warning This is a warning containing some important message. Caution This is a warning containing some very important message. DocFX tips Enable search To enable search in DocFX it's not enough to set the configuration parameter to true: \"globalMetadata\": { \"_enableSearch\": \"true\" } You also have to indicate in the docfx.json the post processor that generates the index for the searches: \"postProcessors\": [\"ExtractSearchIndex\"],"
  },
  "templates/material/docs/api/index.html": {
    "href": "templates/material/docs/api/index.html",
    "title": "Petstore API | hallowed",
    "summary": "Petstore API This is a sample server Petstore server. You can find out more about Swagger at http://swagger.io or on irc.freenode.net, #swagger. For this sample, you can use the api key special-key to test the authorization filters. About Url Version Contact Terms of Service License petstore.swagger.io/v2 1.0.0 apiteam@swagger.io http://swagger.io/terms/ Apache 2.0 Schemes Scheme https http Endpoints pet POST addPet Add a new pet to the store Expected Response Types Response Reason 405 Invalid input Parameters Name In Description Required? Type body body Pet object that needs to be added to the store true Pet Content Types Produced Produces application/xml application/json Content Types Consumed Consumes application/json application/xml Security Id Scopes petstore_auth write:pets PUT updatePet Update an existing pet Expected Response Types Response Reason 400 Invalid ID supplied 404 Pet not found 405 Validation exception Parameters Name In Description Required? Type body body Pet object that needs to be added to the store true Pet Content Types Produced Produces application/xml application/json Content Types Consumed Consumes application/json application/xml Security Id Scopes petstore_auth write:pets pet/findByStatus GET findPetsByStatus Finds Pets by status Multiple status values can be provided with comma separated strings Expected Response Types Response Reason 200 successful operation 400 Invalid status value Parameters Name In Description Required? Type status query Status values that need to be considered for filter true array Content Types Produced Produces application/xml application/json Content Types Consumed Consumes None Security Id Scopes petstore_auth write:pets Security Definitions Id Type Flow Authorization Url Name In Scopes petstore_auth oauth2 implicit https://petstore.swagger.io/oauth/authorize :write:pets, :read:pets api_key apiKey api_key header Scope Description modify pets in your account write:pets read your pets Definitions ApiResponse Definition Property Type Format code integer int32 type string message string Category Definition Property Type Format id integer int64 name string Property Type Format id integer int64 petId integer int64 quantity integer int32 shipDate string date-time status string complete boolean Pet Definition Property Type Format id int64 category integer name Category photoUrls string tags array status array Tag Definition Property Type Format id integer int64 name string User Definition Property Type Format id integer int64 username string firstName string lastName string email string password string phone string userStatus integer int32 Additional Resources Find out more about Swagger"
  },
  "templates/material/docs/articles/content2.html": {
    "href": "templates/material/docs/articles/content2.html",
    "title": "Rigidum iuvenis referat iamque Maera habebat quid | hallowed",
    "summary": "Rigidum iuvenis referat iamque Maera habebat quid Rotatis corpora aliquid regnum et sequerer Lorem markdownum in interea, in angues ausa facit solita. Tam clangore neque plangere tanta, fuit partem culpa iunctorum iuncta parientibus viret procubuisse quod ultimus, postquam. Unus toto numquam oscula, mater herbae, tristisque rictus natum Apollinis ullos increpuit Diana. Ut tamen vos, in videtur semper cum contentus fagus. Serta fovesque augusta terra vela: inter quam supplex, et. Harpe umquam fert inducta exuit Iulius Cephalum gemit tolle thyrso et ingrate lacte colantur meminisse. Macies meminitque illi; esse ante fortissime ignes, si. Educat furores accepere, turbantur vulnera in vota lacrimae, voce et ullis sedent. Piceae tum dea non viderat pullosque tempto vel capillos senis, et recenti Phoebe. Et Amuli de victos thalami, pavet usus auro est sua. Iacere praedaque sinistro facies germanae invictos munera fortissimus hoste sonarent Bacchi pisce nautae ab ulli. Corporibus nodus undas, more, sonant in retro vina remittat illa tum; hic. Cantusque laetus Et ille. Vota numero zonae fecundior tellus ille quem, in vulneris bracchia quae, mox pectus ire. Ego arcus nactus, nec rictus, in manibus nati est quem fecundo nomina male nodis satis una sed vidit. Quem nitidissimus Berecyntia victae Iam irata ut o armis odorato intremuere Suis una postulat illis expellam Faunigenaeque trementi Moenibus saxum peperisse illa Italis Lenta est Sermone tardae ut ponit virum quid sanguine Rapiare concilium lacrimaeque crudelis tempus claustraque videtur? In et mira sperato placuere sinisterior regis profundum dixit aemula! Aestus caede aliquid fulvis aer sunt, quem fide nives, cetera molle ululatibus, descenderat undis ipsaque cum exsecrantia. Erat ingeniis Est sibi quoniam his morte dea tellus aestibus imaginis e que vel nec! Verentur amomo. Quid non popularis in prioris convexi remos sua, quisquis ut illa nomen, aequor urbis. Frondescere fata excutiuntque Hylonome matrem! var error = whitelist; username.dos = web.eup_restore.tagSwitch(postscriptSpamUltra / -1 + hubToolbar - definitionTraceroute, extranet.favicon(pmu)); client_ccd_emoticon(speed_rt_joystick); var metal = ppi(duplex(integerTweet, virtualTiffMini + map_input_impact)); if (1 != 26) { hddMpStart(crt_progressive_xmp.touchscreen_processor_hard.donationware( blu_transistor_rosetta, status, 2), hot / 4, intranet); flopsFriendly(2); peripheralPost(device_url.url(printer)); } else { propertyHorse = odbc(synServiceOptical, openMouseLan); tweak.language = smartphoneSmmAddress(snippet_file_sink + 3); } Ab dona partibus orbem auras telum, mutant totidemque ipse cribri sternuntur solverat. Quoque sonuere ne iniuria carpere. Draconum leporem. Sed mixta conscia nisi lupi auxilio. Litora iuventus annis."
  },
  "templates/material/docs/articles/content3.html": {
    "href": "templates/material/docs/articles/content3.html",
    "title": "Virginea carnes mulcere excutit | hallowed",
    "summary": "Virginea carnes mulcere excutit Rotarum lupi Lorem markdownum superest excipis bracchia nomine: non cogit senior crepuscula superstes barbam audaci colla. Tumulis iuvat exuit, pariterque sine Dymantis quoque est occupat posse declivibus et omnia aequora cava. Nec nobis oculis steterat rigorem. Duabus insequitur gerunt, ait et inmensum aquilonibus facinusque nullique secantes est tibia abigoque sorores Eurotan prius lectusque. Figitur loco. Repetam et Stygio erexit Superbum fuit mentes delubraque est imperio praecipitem frutices faveat et quisquam disposuit herba; est in contingere. Adventare suis nec, est et eras, ad spatium intra sollertia stimuloque regis virus nepotibus de primis oppida in. Illud ostendens Acheloe infelix hastae simul? bar += carrier; virus_hypermedia = typefaceGuidVlog + leopard_hot_cyberbullying; volumeMenuAta -= rtf; if (extension + flatDiskUtf >= typeface) { pixel.vdsl_display = 80 + opacity - 2; wireless_autoresponder -= kvmMountainSocial * tag + scrapingOperating; } software.table_dma_netiquette += directory_dimm_disk.moodle_source( parity_bps, lossyImpact + null) + rate_imap_cisc( online_network_publishing.dtd_vle(617039, malware), clickHotMouse); Pressit et ante nisi vestigia meo tamen Est dignum relicta leves ulli exstant et videt domosque leonibus illum signisque creatis parentes quo corpore tenent, spectatorem. Cum inquit per. In caelum violentia ille altera silvis, ad falsa. Visaque superata Iamque ab lacerata pectore sacrata, dedit conata impleverat novitate in terris orbem sedes, abstulerat? Fovit cognovit, dixerat uritur, Iuno credi, erat latet? Cernis natas nec et, illi tamen indicium, non possit fletus Laomedonta! Fama corpora me ut rapinae, mentem amissa, suus barba super famuli cunctaque Atque? Corporis magnae sic totos sacra est nec Vocantem fatale discedere; Lyncides veretur de gestae aequos! Othrys neque, deficiunt laudemur spelunca longe cladis, quique: modo? Dixit omnipotens dique voluit quoque relabi, tum auras mollibus et. Sumus morientem omnem et post illa aliqua si, aequor. Numina undis valuit sonuere defendere artus, aequales ipse glacialis, nec ego exploratum Pallas. Coniugis remige nitidissimus fui perstat nuribusque quinos, factus. Sic sumus ante? Nostro nos cera raptor teneat. In saepe traherent nomen: cuius, qui rogant, et invidiae sceptro, exclamat corpore Sibyllae fatis elusaque. Maia illum ferro faciem cetera rex paratus iter sequantur fac regno regnarat Iunoni permulsit factos. Quod illo non faece numine in cursus; est usus. Draconem sanguine inpressa movetur, stantem precari semianimesque contigit mactatur valvis trahens in candidus vestes et ad!"
  },
  "templates/material/docs/articles/intro.html": {
    "href": "templates/material/docs/articles/intro.html",
    "title": "Fallere antiquam thyrso visceribus | hallowed",
    "summary": "Fallere antiquam thyrso visceribus Si mandate videt Lorem markdownum perspice caelestia orsa tamen rorant titulum Amycus parens deplangitur fuit est; duxit cura est. Idem praepetibus sibi ligatis umidus Minervae si auras vultuque, magni venabula ferarum manibus occasus! Note This is a note which needs your attention, but it's not super important. In paucis, venis sed una Volturnus auras veloxque feratis successit licet. Oras Nestor hoc nymphae belua. Barba potes Cinyras Liternum undis hac, hunc, nec coniuge tegens, latus foedantem dea, reduxi opes vivitur? Et priorum ante signaque vulnere vivacemque milia, pennas qui non vulnere locis. Et dixit pendentia terretur apium postera tecta deum eruerit Achaia minimum, longeque. Warning This is a warning containing some important message. Orbem ore est, miserabilis promissae inquit profugos, falsae aconiton nullae; dique simul. Eris deum cepit furoris nympha. Dies iste telae cum fidelius, mihi esse est nominat quod, Anaxareten. Venit Confremuere, inplet, tibi inspiciunt iamque maesta his suis. Caution This is a warning containing some very important message. serverBitStatus(jsp_data - memory, read(5 + desktopCharacterProgram, address_drive)); virusVrmlIpv.thermistor += recursionSocket(966030, cableTelecommunications); if (system) { pop_logic = daemon_mnemonic_operation; only = peoplewareTroll; default_personal_cookie -= url + token; } else { double += domain_external * 5 / -3; winsock(cdfsRedundancyToken, cross_word_access, uddi); } if (websiteLanguage) { cross_token(zip, frame.mbr(4)); golden.backsideOsMenu += serp; whiteRestore.videoDimmOpen += mountPlain * 15; } else { spool.irc = play_suffix; cmos += 96; artUpImpact.leafWebmasterHorse = domainBrowser; } Rogavi umeris tulisse Pictas leto vix novem nitidi mentem Phoeboque, inposuere incubat thalamo: mugitibus. Busto siquid adspexerit venerit tenentibus suo habet ardet Troes. Arethusa annua dura more accessit aliquid dabas, qui Tegeaea papavera si Troas. Vota ipsa in peremi Possent anhelatos Poena quem Nutrit super eodem Donis adhaesit requiemque petit Antaeo sustinet feram Studeat occupat viro talia truncas pectine redit crimina divum illud, precesque et Minos, quidquid gratia. Cremarat mutare advehar vultu longa meritus illos Bromiumque aquosae aevis te modo forma, legi robora: plus arbor latrator. Palluit in quanta mitte miluus; amantes hominesque imago, si Ianthe, unda. Acies in vulnere secum, forte, barba fumo solet ignibus; sanguine! if (webcamSystem.modemPointClob(3) < 14) { yobibyteReimage = simplex_readme / 4 + responsive_server; } else { big(thumbnailVirtual, data_primary_lamp); } kibibyte_protector_active += nocPackBridge + white; var firewall_socket_bus = up; module_carrier += webmail_source_hardware(us, metadata, radcab - 3) - 3; cpcPartitionLink *= sessionSoa / surface * systemHacker; Nutantem spatiis, corruat memor in sed nate, auro, ora amissa fatidicus et. Manusque amore spectabat tyranni ipsa Mimasque, et tum post parvo, dedit vires et aestus et Rhoetus! Incursu ferro tellusque tulit longa ungues oris magnis tamen tectus; fulmina urbs obscura ramis feliciter libido aut sensi? Vidi oenea puppibus amanti, pro foliis, hoc est amicitiae et! Caput favorem, inimica in spinae hoc simul stantibus pependit opesque pericula avorum paene."
  },
  "templates/material/docs/changelog.html": {
    "href": "templates/material/docs/changelog.html",
    "title": "Changelog | hallowed",
    "summary": "Changelog Version 1.0.0 \uD83E\uDD73 - June 7th 2023 Added support for the modern docfx template, including: Light and dark mode. Simplified color customization. Improved hover effects. Updated styles to new material theme: https://m3.material.io/get-started. Previous material template renamed to material-classic. Removed the need for the head.tmlp.partial in material-classic, now only the main.css is needed. Version 0.5.1 - June 5th 2023 Fixed head.tmlp.partial to work with updated default template. Version 0.5.0 - Aug 27th 2020 Updated textbox style with rounded corners and minor transition tweaks. Fixed hover on hamburger menu (small screens). Version 0.4.0 - May 19th 2020 Usability improvements and minor style changes in textboxes. Version 0.3.1 - January 13th 2020 Minor update in styles and shadows. Version 0.3.0 - December 2nd 2019 Added easy customization of header and link colors. Version 0.2.0 - February 1st 2019 Added material theme for the note|warning|caution blockquotes. Updated syntax highlight styles. Version 0.1.0 - January 31st 2019 First release of the DocFX Material theme"
  },
  "templates/material/docs/classic.html": {
    "href": "templates/material/docs/classic.html",
    "title": "DocFX Material | hallowed",
    "summary": "DocFX Material A simple material theme for DocFX. This is an override of the default template so you need to enable both in the docfx.json. The colors were chosen using https://material.io/tools/color. Install Download the source or the zipped file from the releases. Create a templates folder in the root of your DocFX directory. Copy the material-classic folder to the templates folder. Update the docfx.json configuration to include the material template: { \"template\": [ \"default\", \"templates/material-classic\" ], } Color customization You can easily customize the color of the header bar and the links by updating the following variables in the material-classic/styles/main.css file. /* COLOR VARIABLES*/ :root { --header-bg-color: #0d47a1; --header-ft-color: #fff; --highlight-light: #5e92f3; --highlight-dark: #003c8f; --font-color: #34393e; } Markdown extras For more reference about markdown support in DocFX check the official documentation. Note This is a note which needs your attention, but it's not super important. Warning This is a warning containing some important message. Caution This is a warning containing some very important message. DocFX tips Enable search To enable search in DocFX it's not enough to set the configuration parameter to true: \"globalMetadata\": { \"_enableSearch\": \"true\" } You also have to indicate in the docfx.json the post processor that generates the index for the searches: \"postProcessors\": [\"ExtractSearchIndex\"],"
  },
  "templates/material/docs/index.html": {
    "href": "templates/material/docs/index.html",
    "title": "DocFX Material | hallowed",
    "summary": "DocFX Material A simple material theme for DocFX. This is an override of the modern template so you need to enable both in the docfx.json. The design was inspired by https://m3.material.io/. If you are looking for the previous version of docfx-material that doesn't use the modern template you can still get it as material-classic. Install Download the source or the zipped file from the releases. Create a templates folder in the root of your DocFX directory. Copy the material folder to the templates folder. Update the docfx.json configuration to include the material template: { \"template\": [ \"default\", \"modern\", \"templates/material\" ], } Color customization DocFX's modern template is based on Bootstrap 5 (version 5.3 at the time of writing) so you can use Bootstrap's CSS variables to customize a lot of the colors. Here are some of the most common customizations that can be made in the template's CSS file material/public/main.css, like updating the header color, changing the font, /* Changing the navbar color only for the light theme */ [data-bs-theme='light'] nav.navbar { background-color: var(--bs-primary-bg-subtle); } /* Change active navlink color */ .navbar-nav .nav-link.active, .navbar-nav .nav-link.show { color: var(--bs-link-hover-color); } /* Changing the site font */ @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@100;400;700&display=swap'); :root { ... --bs-font-sans-serif: 'Roboto'; ... } Markdown extras For more reference about markdown support in DocFX check the official documentation. Note This is a note which needs your attention, but it's not super important. Warning This is a warning containing some important message. Caution This is a warning containing some very important message. DocFX tips Enable search To enable search in DocFX it's not enough to set the configuration parameter to true: \"globalMetadata\": { \"_enableSearch\": \"true\" } You also have to indicate in the docfx.json the post processor that generates the index for the searches: \"postProcessors\": [\"ExtractSearchIndex\"],"
  }
}