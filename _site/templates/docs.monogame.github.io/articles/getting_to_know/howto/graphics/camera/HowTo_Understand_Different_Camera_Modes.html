<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>

    <head>
      <meta charset="utf-8">
      <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
      <title>Understanding different camera modes | hallowed </title>
      <meta name="viewport" content="width=device-width">
      <meta name="title" content="Understanding different camera modes | hallowed ">
      <meta name="generator" content="docfx ">
  
      <link rel="shortcut icon" href="../../../../../../../favicon.ico">
      <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/night-owl.min.css">
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css" integrity="sha384-EvBWSlnoFgZlXJvpzS+MAUEjvN7+gcCwH+qh7GRFOGgZO0PuwOFro7qPOJnLfe7l" crossorigin="anonymous">
      <link rel="stylesheet" href="../../../../../../../styles/config.css">
      <link rel="stylesheet" href="../../../../../../../styles/singulink.css">
      <link rel="stylesheet" href="../../../../../../../styles/main.css">
      <meta property="docfx:navrel" content="../../../../../../../toc.html">
      <meta property="docfx:tocrel" content="../../../../toc.html">
  
  <meta property="docfx:rel" content="../../../../../../../">
  
    </head>
    <body>
        <!-- Header required for docfx anchor scroll to work -->
        <header id="head"></header>
        <div class="top-navbar">
            <a class="burger-icon" onclick="toggleMenu()">
                <svg name="Hamburger" style="vertical-align: middle;" width="34" height="34" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" clip-rule="evenodd" d="M20 6H4V9H20V6ZM4 10.999H20V13.999H4V10.999ZM4 15.999H20V18.999H4V15.999Z"></path></svg>
            </a>


            <a class="brand" href="../../../../../../../index.html">
              <img src="../../../../../../../logo.svg" alt="hallowed" class="logomark">
              <span class="brand-title">hallowed</span>
            </a>        </div>

        <div class="body-content">
            <div id="blackout" class="blackout" onclick="toggleMenu()"></div>

            <nav id="sidebar" role="navigation">
                <div class="sidebar">

                    <div>
                      <div class="mobile-hide">

                        <a class="brand" href="../../../../../../../index.html">
                          <img src="../../../../../../../logo.svg" alt="hallowed" class="logomark">
                          <span class="brand-title">hallowed</span>
                        </a>                      </div>

                      <div class="sidesearch">
                        <form id="search" role="search" class="search">
                            <i class="bi bi-search search-icon"></i>
                            <input type="text" id="search-query" placeholder="Search" autocomplete="off">
                        </form>
                      </div>

                      <div id="navbar">
                      </div>
                    </div>                    <div class="sidebar-item-separator"></div>

                        <div id="sidetoggle">
                          <div id="sidetoc"></div>
                        </div>
                </div>
                <div class="footer">
  
  <strong><a href='https://dotnet.github.io/docfx/'>DocFX</a> + <a href='https://www.singulink.com'>Singulink</a> = â™¥</strong>
                </div>            </nav>

            <main class="main-panel">

                <div id="search-results" style="display: none;">
                  <h1 class="search-list">Search Results for <span></span></h1>
                  <div class="sr-items">
                    <p><i class="bi bi-hourglass-split index-loading"></i></p>
                  </div>
                  <ul id="pagination" data-first=First data-prev=Previous data-next=Next data-last=Last></ul>
                </div>
 

                <div role="main" class="hide-when-search">

                        <div class="subnav navbar navbar-default">
                          <div class="container hide-when-search" id="breadcrumb">
                            <ul class="breadcrumb">
                              <li></li>
                            </ul>
                          </div>
                        </div>

                         <div class="contribution">
                               <a href="https://github.com/MonoGame/docs.monogame.github.io/blob/main/articles/getting_to_know/howto/graphics/camera/HowTo_Understand_Different_Camera_Modes.md/#L1" class="contribution-link">Edit this page</a>
                         </div>

                    <article class="content wrap" id="_content" data-uid="">

<h2 id="overview">Overview</h2>
<p>This example is different from most as it is demonstrating several techniques to update a camera's view and position to achieve different camera modes or operations, including:</p>
<ul>
<li>A Fixed Camera.</li>
<li>A Fixed tracking camera - follows the target.</li>
<li>A first person camera.</li>
<li>A third person camera - with spring.</li>
<li>A top-down fixed camera view.</li>
<li>A top-down view centered on a target.</li>
</ul>
<h3 id="end-result">End result</h3>
<p>These are the kinds of camera modes demonstrated in this sample:</p>
<table>
<thead>
<tr>
<th>Fixed View</th>
<th>Fixed Tracking</th>
<th>First Person View</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="../images/HowTo_CameraModes_Fixed.gif" alt="Fixed"></td>
<td><img src="../images/HowTo_CameraModes_Tracking.gif" alt="Fixed Tracking"></td>
<td><img src="../images/HowTo_CameraModes_FirstPerson.gif" alt="First Person"></td>
</tr>
<tr>
<td>Third Person View</td>
<td>Top Down</td>
<td>Top Down tracking</td>
</tr>
<tr>
<td><img src="../images/HowTo_CameraModes_ThirdPerson.gif" alt="Third Person"></td>
<td><img src="../images/HowTo_CameraModes_TopDownFixed.gif" alt="Top-Down"></td>
<td><img src="../images/HowTo_CameraModes_TopDownTracking.gif" alt="Top Down tracking"></td>
</tr>
</tbody>
</table>
<h2 id="sample">Sample</h2>
<p>As the sample is quite large and contains several pieces of content for the demonstration, the full source is available here:</p>
<h3 id="basic-camera-example-source"><a href="https://github.com/MonoGame/MonoGame.Samples/tree/3.8.2/Tutorials/BasicCameraExample">Basic Camera Example Source</a></h3>
<h2 id="understanding-the-different-camera-modes">Understanding the different camera modes</h2>
<p>To understand how these different camera modes work, the principle is fairly strait forward.</p>
<div class="TIP">
<h5>Tip</h5>
<p>Please review the <a href="../../../whatis/graphics/WhatIs_Camera.html">What is Camera</a> guide for more detail on the concepts discussed here.</p>
</div>
<h3 id="world">World</h3>
<p>The world that the camera and models are contained in usually static (at least for a single &quot;world&quot; or game level), for simplicity, this is usually kept at the center of the world which is <code>0,0,0</code> or <code>Matrix.Identity</code>.</p>
<p>All content is then Transformed / positioned relative to this central world point.</p>
<h3 id="projection">Projection</h3>
<p>The project of the view is also normally fixed for any single camera (although you might use different perspectives for different cameras, e.g. a map view).  This is defined once in either a Perspective or Orthographic (with or without depth).  This is then applied to the drawing methods to define the bounds of what is drawn to the screen.</p>
<div class="TIP">
<h5>Tip</h5>
<p>Elements drawn outside of the camera view / projection are culled or ignored by the graphics device.  However, unless you control what data is sent, you are still paying for the performance to send to the graphics card and consider it for drawing.  This is where techniques are used to limit the data sent to the graphics card and ONLY send models and textures that you know will be actually drawn and limiting what is discarded.</p>
</div>
<h2 id="camera-views">Camera Views</h2>
<p>The sample separates out the actual work in drawing each camera mode based on what is active at the time in the <code>Update</code> loop, as shown here:</p>
<pre><code class="lang-csharp">        switch (currentCameraMode)
        {
            case CameraMode.Fixed:
                UpdateFixedCamera();
                break;

            case CameraMode.Tracking:
                UpdateTrackingCamera();
                break;

            case CameraMode.FirstPerson:
                UpdateFirstPersonCamera();
                break;

            case CameraMode.ThirdPerson:
                UpdateThirdPersonCamera((float)gameTime.ElapsedGameTime.TotalSeconds);
                break;

            case CameraMode.TopDownFixed:
                UpdateTopDownFixedCamera();
                break;

            case CameraMode.TopDownCentred:
                UpdateTopDownCenteredCamera();
                break;
        }
</code></pre>
<p>You would not normally do this, it is only done this way for the purposes of the sample.  In reality you would only use the mode relevant to the current game view (although a lot of first person games do allow switching between First Person and Third Person), however, as you will see, you are only updating the way the View Matrix is generated along with the camera position, in 3D the content is always drawn the same regardless.</p>
<h3 id="the-fixed-camera-view">The Fixed Camera view</h3>
<p>This is the simplest way of rendering a camera, you just create a <code>View Matrix</code> using the Camera's current position and looking at the center of the world (or whatever you want it to look at).  For example:</p>
<pre><code class="lang-csharp">    void UpdateCameraView(Vector3 aCameraPosition, Vector3 aCameraTarget)
    {
        // Update the camera view matrix with the `Matrix.LookAt` method.
        currentCameraView = Matrix.CreateLookAt(aCameraPosition, aCameraTarget, Vector3.Up);
    }

    // Set the position of the camera in world space, for the fixed camera view matrix.
    private Vector3 cameraFixedPosition = new Vector3(0.0f, 1550.0f, 5000.0f);

    void UpdateFixedCamera()
    {
        // Fixed view, the camera is always in the same position and looking the same way, no updates.
        UpdateCameraView(cameraFixedPosition, Vector3.Zero);
    }
</code></pre>
<h3 id="the-tracking-camera">The Tracking Camera</h3>
<p>Giving the camera something to look at is also quite simple, instead of looking at the center of the world (assuming the world is <code>Matrix.Identity</code>), we instead &quot;Look at&quot; the model itself, dymanically updated each frame, as follows:</p>
<pre><code class="lang-csharp">    // Set the position of the camera in world space, for the fixed camera view matrix.
    private Vector3 cameraFixedPosition = new Vector3(0.0f, 1550.0f, 5000.0f);

    void UpdateTrackingCamera()
    {
        // Tracking view, the camera is always in the same position but changes the view matrix to &quot;look&quot; towards a target.

        // Set up our world matrix, view matrix and projection matrix.
        UpdateCameraView(cameraFixedPosition, modelPosition);
    }
</code></pre>
<p>Run once per update, wherever in the world the target ends up, the camera will rotate to <code>LookAt</code> the target.</p>
<h3 id="the-first-person-camera">The First Person Camera</h3>
<p>There are several ways of achieving a first person view, some use the camera as the player and update the camera position, some (as in this example) take the player position and then transform the camera to it.  Either way is fine (although in practice, if you want to use multiple camera views, it is better to keep them separate).</p>
<p>In this example, we apply all the same transformations to the camera we perform on the &quot;player&quot; model to achieve this effect:</p>
<pre><code class="lang-csharp">    // 1st Person camera position relative to player model
    private Vector3 cameraFirstPersonPosition = new Vector3(0.0f, 50.0f, 500.0f);

    void UpdateFirstPersonCamera()
    {
        // First person view, the camera moves based on the Model's position (which is moved by input) and the view matrix is updated to always look &quot;forward&quot; from the model.

        // Create a rotational matrix based on the current model's heading.
        Matrix rotationMatrix = Matrix.CreateRotationY(modelRotation);

        // Create a vector pointing the direction the camera is facing.
        Vector3 transformedReference = Vector3.Transform(cameraFirstPersonPosition, rotationMatrix);

        // Calculate the position the camera is looking from.
        currentCameraPosition = transformedReference + modelPosition;

        // Set up our world matrix, view matrix and projection matrix.
        UpdateCameraView(currentCameraPosition, modelPosition);
    }
</code></pre>
<p>You may want to look at other examples of First Person translation for cameras before deciding what works best for your game.</p>
<h3 id="third-person-camera">Third Person Camera</h3>
<p>Compared to the first person camera, the Third Person view is a much simpler approach, as the Model/Player and the Camera have to be kept separate. In most scenarios though, you have more considerations that the basic first person view, such as:</p>
<ul>
<li>Wall clipping</li>
<li>Obscuring by other world objects</li>
<li>Bad viewing angles</li>
</ul>
<p>These are two complex to go into for now, so you may want to do some further reading.</p>
<p>In this sample we have included a simple physics based &quot;Spring&quot; system, so that the camera's view follows the player in a much smoother way (it also looks REALLY cool when the players ship &quot;jumps&quot; to a new location, try resetting the ships position after moving in the sample in this mode).  The code is as follows:</p>
<pre><code class="lang-csharp">    // 3rd Person camera position relative to player model
    private Vector3 cameraThirdPersonPosition = new Vector3(0.0f, 1550.0f, 5000.0f);

    void UpdateThirdPersonCamera(float aElapsed)
    {
        // First person view, the camera is offset behind and above the model and moves with it,the view matrix is updated to always look &quot;forward&quot; from the model.
        // It also includes an optional spring physics system to smooth out the camera movement.

        // Create a rotational matrix based on the current model's heading.
        Matrix rotationMatrix = Matrix.CreateRotationY(modelRotation);

        // Create a vector pointing the direction the camera is facing.
        Vector3 transformedReference = Vector3.Transform(cameraThirdPersonPosition, rotationMatrix);

        // If camera spring is enabled, update the position and rotation of the camera over several frames
        if (cameraSpringEnabled)
        {
            // Calculate the position where we would like the camera to be looking from.
            Vector3 desiredPosition = transformedReference + modelPosition;

            // Calculate spring force            
            Vector3 stretch = currentCameraPosition - desiredPosition;
            Vector3 force = -cameraStiffness * stretch - cameraDamping * cameraVelocity;

            // Apply acceleration 
            Vector3 acceleration = force / cameraMass;
            cameraVelocity += acceleration * aElapsed;

            // Apply velocity
            currentCameraPosition += cameraVelocity * aElapsed;
        }
        // If not, just move the camera without smoothing
        else
        {
            // Calculate the position the camera is looking from.
            currentCameraPosition = transformedReference + modelPosition;
        }

        // Set up our world matrix, view matrix and projection matrix.
        UpdateCameraView(currentCameraPosition, modelPosition);
    }
</code></pre>
<p>The main difference between the First Person and Third Person views is that the &quot;Position&quot; of the camera is offset behind and above the center of the player, this is then transformed and added to the players current position before constructing the view.</p>
<h3 id="top-down-camera">Top Down Camera</h3>
<p>The same as the <a href="#the-fixed-camera-view">Fixed Camera</a> view, the camera simply has a position and looks at the center of the world, however, it is positioned far above the world so that it is looking down.</p>
<div class="TIP">
<h5>Tip</h5>
<p>In this sample it has been kept as a Perspective Camera and evaluates depth, however, if you are having a Map camera then it is more likely to use an orthographic projection instead.</p>
</div>
<pre><code class="lang-csharp">    // Top Down camera position relative to player model
    private Vector3 cameraTopDownPosition = new Vector3(0.0f, 25000.0f, 1.0f);

    void UpdateTopDownFixedCamera()
    {
        // A Top-Down fixed view, the camera is always in the same position and looking down onto the game scene.
        // Note, there are no boundaries to prevent the model from moving out of view.
    
        // Set up our world matrix, view matrix and projection matrix.
        UpdateCameraView(cameraTopDownPosition, Vector3.Zero);
    }
</code></pre>
<h3 id="top-down-tracked-camera">Top Down Tracked Camera</h3>
<p>To finish off these camera modes, the top-down tracked view is more of a combination of a third person and top-down view, wherein the camera is way above the world and follows only the target on a 2D plane, like the third person view the camera is simply placed above the model/player and then transforms/updates its position based on the movement of the player.</p>
<pre><code class="lang-csharp">    // Top Down camera position relative to player model
    private Vector3 cameraTopDownPosition = new Vector3(0.0f, 25000.0f, 1.0f);

    void UpdateTopDownCenteredCamera()
    {
        // A Top-Down view that moves according to two dimensional position of the model, looking down onto the model.

        // Create a rotational matrix based on the current model's heading.
        Matrix rotationMatrix = Matrix.CreateRotationY(modelRotation);

        // Create a vector pointing the direction the camera is facing.
        Vector3 transformedReference = Vector3.Transform(cameraTopDownPosition, rotationMatrix);

        // Calculate the position the camera is looking from.
        currentCameraPosition = transformedReference + modelPosition;

        // Set up our world matrix, view matrix and projection matrix.
        UpdateCameraView(currentCameraPosition, modelPosition);
    }
</code></pre>
<h2 id="see-also">See Also</h2>
<ul>
<li><a href="../HowTo_UseViewportForSplitscreenGaming.html">How to display Multiple Screens with Viewports</a></li>
</ul>
<h3 id="concepts">Concepts</h3>
<ul>
<li><a href="../../../whatis/graphics/WhatIs_3DRendering.html">What Is 3D Rendering?</a></li>
<li><a href="../../../whatis/graphics/WhatIs_Viewport.html">What Is a Viewport?</a></li>
<li><a href="../../../whatis/graphics/WhatIs_ViewFrustum.html">What Is a View Frustum?</a></li>
<li><a href="../../../whatis/graphics/WhatIs_Render_Target.html">What Is a Render Target?</a></li>
</ul>
<h3 id="reference">Reference</h3>
<ul>
<li><a href="xref:Microsoft.Xna.Framework.Graphics.GraphicsDevice">GraphicsDevice.Viewport</a></li>
<li><a href="xref:Microsoft.Xna.Framework.Matrix">Matrix</a></li>
<li><a href="xref:Microsoft.Xna.Framework.Graphics.SpriteBatch">SpriteBatch</a></li>
</ul>

</article>
                </div>

            </main>
        </div>


        <script src="https://code.jquery.com/jquery-3.6.3.min.js" integrity="sha256-pvPw+upLPUjgMXY0G+8O0xUf+/Im1MZjXxxgOcBQBXU=" crossorigin="anonymous"></script>
        <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.1/dist/umd/popper.min.js" integrity="sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN" crossorigin="anonymous"></script>
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.min.js" integrity="sha384-+sLIOodYLS7CIrQpBjl+C7nPvqq+FbNUBDunl/OZv93DB7Ln/533i8e/mZXLi/P+" crossorigin="anonymous"></script>
        <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
        <script type="text/javascript" src="../../../../../../../styles/jquery.twbsPagination.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/mark.js@8.11.1/dist/jquery.mark.min.js"></script>
        <script type="text/javascript" src="../../../../../../../styles/url.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/anchor-js@5.0.0/anchor.min.js"></script>
        <script type="text/javascript" src="../../../../../../../styles/docfx.js"></script>
        <script type="text/javascript" src="../../../../../../../styles/main.js"></script>
        <script type="text/javascript" src="../../../../../../../styles/singulink.js"></script>    </body>
</html>
