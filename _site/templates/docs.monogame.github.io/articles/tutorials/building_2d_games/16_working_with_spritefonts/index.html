<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>

    <head>
      <meta charset="utf-8">
      <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
      <title>Chapter 16: Working with SpriteFonts | hallowed </title>
      <meta name="viewport" content="width=device-width">
      <meta name="title" content="Chapter 16: Working with SpriteFonts | hallowed ">
      <meta name="generator" content="docfx ">
  
      <link rel="shortcut icon" href="../../../../../../favicon.ico">
      <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/night-owl.min.css">
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css" integrity="sha384-EvBWSlnoFgZlXJvpzS+MAUEjvN7+gcCwH+qh7GRFOGgZO0PuwOFro7qPOJnLfe7l" crossorigin="anonymous">
      <link rel="stylesheet" href="../../../../../../styles/config.css">
      <link rel="stylesheet" href="../../../../../../styles/singulink.css">
      <link rel="stylesheet" href="../../../../../../styles/main.css">
      <meta property="docfx:navrel" content="../../../../../../toc.html">
      <meta property="docfx:tocrel" content="../../../toc.html">
  
  <meta property="docfx:rel" content="../../../../../../">
  
    </head>
    <body>
        <!-- Header required for docfx anchor scroll to work -->
        <header id="head"></header>
        <div class="top-navbar">
            <a class="burger-icon" onclick="toggleMenu()">
                <svg name="Hamburger" style="vertical-align: middle;" width="34" height="34" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" clip-rule="evenodd" d="M20 6H4V9H20V6ZM4 10.999H20V13.999H4V10.999ZM4 15.999H20V18.999H4V15.999Z"></path></svg>
            </a>


            <a class="brand" href="../../../../../../index.html">
              <img src="../../../../../../logo.svg" alt="hallowed" class="logomark">
              <span class="brand-title">hallowed</span>
            </a>        </div>

        <div class="body-content">
            <div id="blackout" class="blackout" onclick="toggleMenu()"></div>

            <nav id="sidebar" role="navigation">
                <div class="sidebar">

                    <div>
                      <div class="mobile-hide">

                        <a class="brand" href="../../../../../../index.html">
                          <img src="../../../../../../logo.svg" alt="hallowed" class="logomark">
                          <span class="brand-title">hallowed</span>
                        </a>                      </div>

                      <div class="sidesearch">
                        <form id="search" role="search" class="search">
                            <i class="bi bi-search search-icon"></i>
                            <input type="text" id="search-query" placeholder="Search" autocomplete="off">
                        </form>
                      </div>

                      <div id="navbar">
                      </div>
                    </div>                    <div class="sidebar-item-separator"></div>

                        <div id="sidetoggle">
                          <div id="sidetoc"></div>
                        </div>
                </div>
                <div class="footer">
  
  <strong><a href='https://dotnet.github.io/docfx/'>DocFX</a> + <a href='https://www.singulink.com'>Singulink</a> = â™¥</strong>
                </div>            </nav>

            <main class="main-panel">

                <div id="search-results" style="display: none;">
                  <h1 class="search-list">Search Results for <span></span></h1>
                  <div class="sr-items">
                    <p><i class="bi bi-hourglass-split index-loading"></i></p>
                  </div>
                  <ul id="pagination" data-first=First data-prev=Previous data-next=Next data-last=Last></ul>
                </div>
 

                <div role="main" class="hide-when-search">

                        <div class="subnav navbar navbar-default">
                          <div class="container hide-when-search" id="breadcrumb">
                            <ul class="breadcrumb">
                              <li></li>
                            </ul>
                          </div>
                        </div>

                         <div class="contribution">
                               <a href="https://github.com/MonoGame/docs.monogame.github.io/blob/main/articles/tutorials/building_2d_games/16_working_with_spritefonts/index.md/#L1" class="contribution-link">Edit this page</a>
                         </div>

                    <article class="content wrap" id="_content" data-uid="">


<p>In <a href="../06_working_with_textures/index.html">Chapter 06</a>, you learned how to load and render textures to display sprites in your game. While images are essential for visual elements, most games also need text for things like scores, player instructions, dialogue, and UI elements. MonoGame provides the <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteFont"><strong>SpriteFont</strong></a> class to handle text rendering, which works together with the familiar <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteBatch"><strong>SpriteBatch</strong></a> we have been using for drawing textures.</p>
<p>In this chapter, you will:</p>
<ul>
<li>Learn how MonoGame handles text rendering with SpriteFonts.</li>
<li>Create <code>SpriteFont</code> description using the MGCB Editor.</li>
<li>Load custom fonts for use in your game.</li>
<li>Render text using various parameters to control appearance.</li>
<li>Implement text rendering in our game.</li>
</ul>
<p>We will first start by understanding how text rendering works in MonoGame.</p>
<h2 id="understanding-spritefonts">Understanding SpriteFonts</h2>
<p>MonoGame processes fonts through the content pipeline to create a texture atlas of font characters.  MonoGame uses the texture atlas approach rather than directly using system fonts for several important reasons:</p>
<ul>
<li><strong>Cross-platform Compatibility</strong>: System fonts cannot be guaranteed to exist on all platforms.</li>
<li><strong>Consistency</strong>: Ensures that the text appears the same across all platforms.</li>
<li><strong>GPU Rendering</strong>: Graphics cards do not understand font formats directly; they can only render textures.</li>
<li><strong>Performance</strong>: Pre-rendering the glyphs to a texture atlas allow for faster rendering at runtime with no texture swapping.</li>
</ul>
<p>A <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteFont"><strong>SpriteFont</strong></a> in MonoGame consists of:</p>
<ol>
<li>A texture atlas containing pre-rendered glyphs (characters).</li>
<li>Data that tracks the position, size, and spacing of each character.</li>
<li>Kerning information for adjusting spacing between specific character pairs.</li>
</ol>
<p>The texture atlas approach means fonts are rendered as sprites, using the same <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteBatch"><strong>SpriteBatch</strong></a> system you learned about for drawing textures (<a href="../07_optimizing_texture_rendering/index.html">Chapter 7: Optimized Texture Rendering</a>).  When you draw text, MonoGame is actually drawing small portions of the texture atlas for each character assembled together to form complete words and sentences.</p>
<h2 id="creating-a-spritefont-description">Creating a SpriteFont Description</h2>
<p>To use text in your game, you first need to create a SpriteFont Description file and process it through the Content Pipeline, thankfully the MGCB Editor makes this process straightforward.</p>
<p>For example, in the MGCB Editor:</p>
<ol>
<li>Right-click the content project node where the SpriteFont Description will be created and choose <em>Add</em> &gt; <em>New Item...</em>.</li>
<li>Select <code>SpriteFont Description (.spritefont)</code> from the options.</li>
<li>Specify a name for the SpriteFont Description file and click <code>Create</code>.</li>
</ol>
<p>This will create a default SpriteFont Description file that look something like this:</p>
<pre><code class="lang-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;!--
This file contains an xml description of a font, and will be read by the XNA
Framework Content Pipeline. Follow the comments to customize the appearance
of the font in your game, and to change the characters which are available to draw
with.
--&gt;
&lt;XnaContent xmlns:Graphics=&quot;Microsoft.Xna.Framework.Content.Pipeline.Graphics&quot;&gt;
  &lt;Asset Type=&quot;Graphics:FontDescription&quot;&gt;

    &lt;!--
    Modify this string to change the font that will be imported.
    --&gt;
    &lt;FontName&gt;Arial&lt;/FontName&gt;

    &lt;!--
    Size is a float value, measured in points. Modify this value to change
    the size of the font.
    --&gt;
    &lt;Size&gt;12&lt;/Size&gt;

    &lt;!--
    Spacing is a float value, measured in pixels. Modify this value to change
    the amount of spacing in between characters.
    --&gt;
    &lt;Spacing&gt;0&lt;/Spacing&gt;

    &lt;!--
    UseKerning controls the layout of the font. If this value is true, kerning information
    will be used when placing characters.
    --&gt;
    &lt;UseKerning&gt;true&lt;/UseKerning&gt;

    &lt;!--
    Style controls the style of the font. Valid entries are &quot;Regular&quot;, &quot;Bold&quot;, &quot;Italic&quot;,
    and &quot;Bold, Italic&quot;, and are case sensitive.
    --&gt;
    &lt;Style&gt;Regular&lt;/Style&gt;

    &lt;!--
    If you uncomment this line, the default character will be substituted if you draw
    or measure text that contains characters which were not included in the font.
    --&gt;
    &lt;!-- &lt;DefaultCharacter&gt;*&lt;/DefaultCharacter&gt; --&gt;

    &lt;!--
    CharacterRegions control what letters are available in the font. Every
    character from Start to End will be built and made available for drawing. The
    default range is from 32, (ASCII space), to 126, ('~'), covering the basic Latin
    character set. The characters are ordered according to the Unicode standard.
    See the documentation for more information.
    --&gt;
    &lt;CharacterRegions&gt;
      &lt;CharacterRegion&gt;
        &lt;Start&gt;&amp;#32;&lt;/Start&gt;
        &lt;End&gt;&amp;#126;&lt;/End&gt;
      &lt;/CharacterRegion&gt;
    &lt;/CharacterRegions&gt;
  &lt;/Asset&gt;
&lt;/XnaContent&gt;
</code></pre>
<p>When creating a SpriteFont Description for your game, you will need to make several important decisions about font selection, size, formatting, and licensing. The following sections will guide you through customizing the SpriteFont Description using these considerations.</p>
<h3 id="customizing-the-spritefont">Customizing the SpriteFont</h3>
<p>The SpriteFont Description file allows you to customize various aspects of how the font will be processed and appear in your game. Here are the key elements you can modify:</p>
<h4 id="fontname">FontName</h4>
<p>The <code>&lt;FontName&gt;</code> element specifies which font to use. By default, it references &quot;Arial&quot;.  When a font name is specified just by name like this, it is required that the font be installed on the system where the content is built.</p>
<div class="IMPORTANT">
<h5>Important</h5>
<p>MonoGame recommends changing the default Arial font if you are targeting any platforms other than Windows. Arial is a legacy from XNA and is only guaranteed to be available in Windows builds.  As an alternative, MonoGame currently recommends using <a href="https://fonts.google.com/specimen/Roboto">Roboto</a>.</p>
</div>
<p>Alternatively, for better portability across development environments, it is recommended instead to directly reference a TrueType (.ttf) or OpenType (.otf) font file.  To do this</p>
<ol>
<li><p>Download or locate a TTF or OTF font file.</p>
</li>
<li><p>Place it in the <strong>same folder</strong> as the <code>.spritefont</code> file.</p>
<div class="IMPORTANT">
<h5>Important</h5>
<p>You place the font file in the <strong>same folder</strong> as the <code>.spritefont</code> file directly, not through the MGCB Editor.</p>
</div>
</li>
<li><p>Update the <code>&lt;FontName&gt;</code> element to include the exact filename with extension.</p>
</li>
</ol>
<div class="TIP">
<h5>Tip</h5>
<p>Use fonts with permissive licenses (like <a href="https://openfontlicense.org/">SIL Open Font License</a>) to ensure you can <strong>legally</strong> use them in your game.</p>
<p><strong>Always check the license of any font you use!</strong></p>
</div>
<h4 id="size">Size</h4>
<p>The <code>&lt;Size&gt;</code> element controls the font size in points. While it might seem straightforward, font sizing requires consideration and can be dependent on several factors.  When choosing a font size, consider:</p>
<ul>
<li><strong>Resolution impact</strong>: Fonts that look good at 1080p may appear too small at 4K or too large at 720p.</li>
<li><strong>Font style</strong>: Pixel fonts look best with small sizes to preserve crispness.</li>
<li><strong>Use case</strong>: Different UI elements may require different sizes for proper hierarchy.</li>
</ul>
<p>You may want to create multiple SpriteFont Description files for different use cases in your game such as:</p>
<ul>
<li>A larger font for headings and titles.</li>
<li>A medium-sized font for standard UI elements.</li>
<li>A smaller font for detailed information.</li>
</ul>
<div class="TIP">
<h5>Tip</h5>
<p>Creating multiple SpriteFont Description files, however, can remove some of the benefits of fonts being a texture atlas since you will now have multiple atlases for each size. You will also now have multiple assets to manage both as asset files and references in code.</p>
<p>An alternative approach is to create a single SpriteFont Description with a larger than needed size font, then scale it down during runtime in the game. This approach allows you to maintain the single SpriteFont Description file and single texture atlas, however, the size of the texture atlas will now be larger.</p>
<p>There are tradeoffs to each approach and you should choose the one that works best for your game.</p>
</div>
<h4 id="spacing">Spacing</h4>
<p>The <code>&lt;Spacing&gt;</code> element adjusts the space between characters. The default value of 0 uses the font's built-in spacing. Positive values increase spacing, while negative values (though rarely used) can decrease it.</p>
<h4 id="usekerning">UseKerning</h4>
<p>The <code>&lt;UseKerning&gt;</code> element determines whether to use kerning information from the font. Kerning adjusts the spacing between specific pairs of characters for more visually pleasing results. For most fonts, you will want to leave this as <code>true</code>.</p>
<div class="NOTE">
<h5>Note</h5>
<p>While kerning typically improves text appearance, some fonts (including Arial) may not respond optimally to kerning adjustments. If you notice unusual character spacing with a particular font, try setting this value to <code>false</code>.</p>
</div>
<h4 id="style">Style</h4>
<p>The <code>&lt;Style&gt;</code> element sets the font style. Valid options are &quot;Regular&quot;, &quot;Bold&quot;, &quot;Italic&quot;, or &quot;Bold, Italic&quot;. Note that not all fonts have all styles available, and using a style that does not exist will fall back to Regular.</p>
<h4 id="defaultcharacter">DefaultCharacter</h4>
<p>The <code>&lt;DefaultCharacter&gt;</code> element (commented out by default) specifies what character to use as a fallback when trying to render a character that is not included in the font. This is useful for handling special characters or international text.</p>
<h4 id="characterregions">CharacterRegions</h4>
<p>The <code>&lt;CharacterRegions&gt;</code> element defines which Unicode character ranges to include in the font. The default range (32-126) covers basic Latin characters, which is sufficient for English text. Including more characters increases the font texture size but allows support for more languages or special symbols.</p>
<p>For most games, the default range is sufficient.</p>
<div class="NOTE">
<h5>Note</h5>
<p>Although for fun, TRY using the Wingdings font :D</p>
</div>
<h2 id="loading-a-spritefont-description">Loading a SpriteFont Description</h2>
<p>To load a SpriteFont Description, we use the <a href="xref:Microsoft.Xna.Framework.Content.ContentManager.Load%60%601(System.String)"><strong>ContentManager.Load</strong></a> method with the <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteFont"><strong>SpriteFont</strong></a> type:</p>
<pre><code class="lang-cs">// Loading a SpriteFont Description using the content pipeline
SpriteFont font = Content.Load&lt;SpriteFont&gt;(&quot;font&quot;);
</code></pre>
<h2 id="drawing-text-with-spritebatch">Drawing Text with SpriteBatch</h2>
<p>MonoGame's <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteBatch"><strong>SpriteBatch</strong></a> class provides several overloads of the <strong>DrawString</strong> method to render text. The basic approach is similar to drawing textures, with a few unique parameters specific to text rendering.</p>
<p>The most basic DrawString overload looks like this:</p>
<pre><code class="lang-csharp">_spriteBatch.DrawString(
    font,                   // font
    &quot;Hello, MonoGame!&quot;,     // text
    Vector2.Zero,           // position
    Color.White             // color
);
</code></pre>
<p>This overload contains the following parameters:</p>
<ol>
<li><strong>font</strong>: The <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteFont"><strong>SpriteFont</strong></a> to use for rendering.</li>
<li><strong>text</strong>: The text to display (as a string or <code>StringBuilder</code>).</li>
<li><strong>position</strong>: A <a href="xref:Microsoft.Xna.Framework.Vector2"><strong>Vector2</strong></a> defining where to draw the text.</li>
<li><strong>color</strong>: The <a href="xref:Microsoft.Xna.Framework.Color"><strong>Color</strong></a> to tint the text.</li>
</ol>
<p>Just like with texture rendering, there are more advanced overloads that give you additional control:</p>
<pre><code class="lang-csharp">_spriteBatch.DrawString(
    font,                   // font
    &quot;Hello, MonoGame!&quot;,     // text
    Vector2.Zero,           // position
    Color.White,            // color
    0.0f,                   // rotation
    Vector2.Zero,           // origin
    Vector2.One,            // scale
    SpriteEffects.None,     // effects
    0.0f                    // layerDepth
);
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>Many of these parameters (<code>rotation</code>, <code>origin</code>, <code>scale</code>, <code>effects</code>, and <code>layerDepth</code>) work exactly the same way as they do for texture rendering, as explained in <a href="../06_working_with_textures/index.html">Chapter 06</a>. If you need a refresher on how these parameters affect rendering, refer back to that chapter.</p>
</div>
<h2 id="calculating-text-dimensions">Calculating Text Dimensions</h2>
<p>One common task when working with text is determining how much space it will occupy on screen. This is important for:</p>
<ul>
<li>Centering text</li>
<li>Creating UI layouts</li>
<li>Checking if text fits within a designated area</li>
<li>Implementing text wrapping</li>
</ul>
<p>MonoGame's <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteFont"><strong>SpriteFont</strong></a> class provides the <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteFont.MeasureString(System.String)"><strong>MeasureString</strong></a> method that returns the dimensions of rendered text:</p>
<pre><code class="lang-csharp">// The text to measure.
string message = &quot;Hello, MonoGame!&quot;;

// Measure the size of the message to get the text dimensions.
Vector2 textSize = font.MeasureString(message);
</code></pre>
<p>The returned <a href="xref:Microsoft.Xna.Framework.Vector2"><strong>Vector2</strong></a> contains:</p>
<ul>
<li><code>X</code>: The width of the text in pixels</li>
<li><code>Y</code>: The height of the text in pixels</li>
</ul>
<p>Below is an example of centering text on the screen by drawing the text at the center of the screen and using <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteFont.MeasureString(System.String)"><strong>MeasureString</strong></a> to calculate the center origin or the text</p>
<pre><code class="lang-csharp">// The text to draw.
string message = &quot;Hello, MonoGame!&quot;;

// Measure the size of the message to get the text dimensions.
Vector2 textSize = font.MeasureString(message);

// Set the origin to the center of the text dimensions.
Vector2 origin = textSize * 0.5f;

// Position will be the center of the screen.
Vector2 position = new Vector2(
    GraphicsDevice.PresentationParameters.BackBufferWidth,
    GraphicsDevice.PresentationParameters.BackBufferHeight
) * 0.5f;

// Draw centered text
_spriteBatch.DrawString(
    font,                   // font
    message,                // text
    position,               // position
    Color.White,            // color
    0.0f,                   // rotation
    origin,                 // origin
    1.0f,                   // scale
    SpriteEffects.None,     // effects
    0.0f                    // layerDepth
);
</code></pre><h2 id="implementing-text-in-our-game">Implementing Text in Our Game</h2>
<p>To explore implementing text, we will add text to our game to display information to the player.  We will add a score counter that increases when the slime eats the bat.</p>
<h3 id="adding-the-spritefont-description">Adding the SpriteFont Description</h3>
<p>First, we will need to create a SpriteFont Definition.  Open the <em>Content.mgcb</em> content project file in the MGCB Editor and perform the following:</p>
<ol>
<li>Create a new folder called <code>fonts</code> (right-click <em>Content</em> &gt; <em>Add</em> &gt; <em>New Folder</em>).</li>
<li>Right-click the new <code>fonts</code> folder and choose <code>Add &gt; New Item...</code>.</li>
<li>Select <code>SpriteFont Description (.spritefont)</code> from the options.</li>
<li>Name the file <code>04B_30</code> and click <code>Create</code>.</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align: center;"><img src="./images/font_added.png" alt="Figure 16-1: The 04B_30.spritefont file created in the MGCB Editor"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Figure 16-1: The 04B_30.spritefont file created in the MGCB Editor</strong></td>
</tr>
</tbody>
</table>
<div class="NOTE">
<h5>Note</h5>
<p>We have named the SpriteFont Description file with the same name as the font we will be using.  This makes it easier to remember when updating the code later.</p>
</div>
<h3 id="download-the-font-file">Download the Font File</h3>
<p>Next, right-click the following TTF font and choose &quot;Save Link as...&quot;. Save the file in the same folder where you created the <em>04B_30.spriteFont</em> file using the MGCB Editor. This ensures the font is correctly linked and available for your SpriteFont configuration.</p>
<ul>
<li><a href="./files/04B_30.ttf">04B_30.ttf</a>{download}</li>
</ul>
<h3 id="update-the-spritefont-description">Update the SpriteFont Description</h3>
<p>Next, open the <em>04B_30.spritefont</em> file in your code editor and make the following changes:</p>
<pre><code class="lang-csharp" highlight-lines="4,5">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;XnaContent xmlns:Graphics=&quot;Microsoft.Xna.Framework.Content.Pipeline.Graphics&quot;&gt;
  &lt;Asset Type=&quot;Graphics:FontDescription&quot;&gt;
    &lt;FontName&gt;04B_30.ttf&lt;/FontName&gt;
    &lt;Size&gt;17.5&lt;/Size&gt;
    &lt;Spacing&gt;0&lt;/Spacing&gt;
    &lt;UseKerning&gt;true&lt;/UseKerning&gt;
    &lt;Style&gt;Regular&lt;/Style&gt;
    &lt;CharacterRegions&gt;
      &lt;CharacterRegion&gt;
        &lt;Start&gt;&amp;#32;&lt;/Start&gt;
        &lt;End&gt;&amp;#126;&lt;/End&gt;
      &lt;/CharacterRegion&gt;
    &lt;/CharacterRegions&gt;
  &lt;/Asset&gt;
&lt;/XnaContent&gt;
</code></pre>
<p>The key changes here are:</p>
<ol>
<li>The <code>&lt;FontName&gt;</code> element was updated to <code>04B_30.ttf</code>, the exact filename with extension of the TTF font we just downloaded.</li>
<li>The <code>&lt;Size&gt;</code> element was updated to be <code>17.5</code>.</li>
</ol>
<h3 id="updating-the-game">Updating the Game</h3>
<p>Finally, open the <code>Game1.cs</code> file and make the following changes:</p>
<pre><code class="lang-csharp" highlight-lines="48-58,93-99,129-130,241-242,386-397">using System;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Audio;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;
using Microsoft.Xna.Framework.Media;
using MonoGameLibrary;
using MonoGameLibrary.Graphics;
using MonoGameLibrary.Input;

namespace DungeonSlime;

public class Game1 : Core
{
    // Defines the slime animated sprite.
    private AnimatedSprite _slime;

    // Defines the bat animated sprite.
    private AnimatedSprite _bat;

    // Tracks the position of the slime.
    private Vector2 _slimePosition;

    // Speed multiplier when moving.
    private const float MOVEMENT_SPEED = 5.0f;

    // Tracks the position of the bat.
    private Vector2 _batPosition;

    // Tracks the velocity of the bat.
    private Vector2 _batVelocity;

    // Defines the tilemap to draw.
    private Tilemap _tilemap;

    // Defines the bounds of the room that the slime and bat are contained within.
    private Rectangle _roomBounds;

    // The sound effect to play when the bat bounces off the edge of the screen.
    private SoundEffect _bounceSoundEffect;

    // The sound effect to play when the slime eats a bat.
    private SoundEffect _collectSoundEffect;

    // The background theme song.
    private Song _themeSong;

    // The SpriteFont Description used to draw text.
    private SpriteFont _font;

    // Tracks the players score.
    private int _score;

    // Defines the position to draw the score text at.
    private Vector2 _scoreTextPosition;

    // Defines the origin used when drawing the score text.
    private Vector2 _scoreTextOrigin;


    public Game1() : base(&quot;Dungeon Slime&quot;, 1280, 720, false)
    {

    }

    protected override void Initialize()
    {
        base.Initialize();

        Rectangle screenBounds = GraphicsDevice.PresentationParameters.Bounds;

        _roomBounds = new Rectangle(
            (int)_tilemap.TileWidth,
            (int)_tilemap.TileHeight,
            screenBounds.Width - (int)_tilemap.TileWidth * 2,
            screenBounds.Height - (int)_tilemap.TileHeight * 2
        );

        // Initial slime position will be the center tile of the tile map.
        int centerRow = _tilemap.Rows / 2;
        int centerColumn = _tilemap.Columns / 2;
        _slimePosition = new Vector2(centerColumn * _tilemap.TileWidth, centerRow * _tilemap.TileHeight);

        // Initial bat position will the in the top left corner of the room.
        _batPosition = new Vector2(_roomBounds.Left, _roomBounds.Top);

        // Assign the initial random velocity to the bat.
        AssignRandomBatVelocity();

        // Start playing the background music.
        Audio.PlaySong(_themeSong);

        // Set the position of the score text to align to the left edge of the
        // room bounds, and to vertically be at the center of the first tile.
        _scoreTextPosition = new Vector2(_roomBounds.Left, _tilemap.TileHeight * 0.5f);

        // Set the origin of the text so it is left-centered.
        float scoreTextYOrigin = _font.MeasureString(&quot;Score&quot;).Y * 0.5f;
        _scoreTextOrigin = new Vector2(0, scoreTextYOrigin);
    }

    protected override void LoadContent()
    {
        // Create the texture atlas from the XML configuration file.
        TextureAtlas atlas = TextureAtlas.FromFile(Content, &quot;images/atlas-definition.xml&quot;);

        // Create the slime animated sprite from the atlas.
        _slime = atlas.CreateAnimatedSprite(&quot;slime-animation&quot;);
        _slime.Scale = new Vector2(4.0f, 4.0f);

        // Create the bat animated sprite from the atlas.
        _bat = atlas.CreateAnimatedSprite(&quot;bat-animation&quot;);
        _bat.Scale = new Vector2(4.0f, 4.0f);

        // Create the tilemap from the XML configuration file.
        _tilemap = Tilemap.FromFile(Content, &quot;images/tilemap-definition.xml&quot;);
        _tilemap.Scale = new Vector2(4.0f, 4.0f);

        // Load the bounce sound effect.
        _bounceSoundEffect = Content.Load&lt;SoundEffect&gt;(&quot;audio/bounce&quot;);

        // Load the collect sound effect.
        _collectSoundEffect = Content.Load&lt;SoundEffect&gt;(&quot;audio/collect&quot;);

        // Load the background theme music.
        _themeSong = Content.Load&lt;Song&gt;(&quot;audio/theme&quot;);

        // Load the font
        _font = Content.Load&lt;SpriteFont&gt;(&quot;fonts/04B_30&quot;);
    }

    protected override void Update(GameTime gameTime)
    {
        // Update the slime animated sprite.
        _slime.Update(gameTime);

        // Update the bat animated sprite.
        _bat.Update(gameTime);

        // Check for keyboard input and handle it.
        CheckKeyboardInput();

        // Check for gamepad input and handle it.
        CheckGamePadInput();

        // Creating a bounding circle for the slime.
        Circle slimeBounds = new Circle(
            (int)(_slimePosition.X + (_slime.Width * 0.5f)),
            (int)(_slimePosition.Y + (_slime.Height * 0.5f)),
            (int)(_slime.Width * 0.5f)
        );

        // Use distance based checks to determine if the slime is within the
        // bounds of the game screen, and if it is outside that screen edge,
        // move it back inside.
        if (slimeBounds.Left &lt; _roomBounds.Left)
        {
            _slimePosition.X = _roomBounds.Left;
        }
        else if (slimeBounds.Right &gt; _roomBounds.Right)
        {
            _slimePosition.X = _roomBounds.Right - _slime.Width;
        }

        if (slimeBounds.Top &lt; _roomBounds.Top)
        {
            _slimePosition.Y = _roomBounds.Top;
        }
        else if (slimeBounds.Bottom &gt; _roomBounds.Bottom)
        {
            _slimePosition.Y = _roomBounds.Bottom - _slime.Height;
        }

        // Calculate the new position of the bat based on the velocity
        Vector2 newBatPosition = _batPosition + _batVelocity;

        // Create a bounding circle for the bat
        Circle batBounds = new Circle(
            (int)(newBatPosition.X + (_bat.Width * 0.5f)),
            (int)(newBatPosition.Y + (_bat.Height * 0.5f)),
            (int)(_bat.Width * 0.5f)
        );

        Vector2 normal = Vector2.Zero;

        // Use distance based checks to determine if the bat is within the
        // bounds of the game screen, and if it is outside that screen edge,
        // reflect it about the screen edge normal
        if (batBounds.Left &lt; _roomBounds.Left)
        {
            normal.X = Vector2.UnitX.X;
            newBatPosition.X = _roomBounds.Left;
        }
        else if (batBounds.Right &gt; _roomBounds.Right)
        {
            normal.X = -Vector2.UnitX.X;
            newBatPosition.X = _roomBounds.Right - _bat.Width;
        }

        if (batBounds.Top &lt; _roomBounds.Top)
        {
            normal.Y = Vector2.UnitY.Y;
            newBatPosition.Y = _roomBounds.Top;
        }
        else if (batBounds.Bottom &gt; _roomBounds.Bottom)
        {
            normal.Y = -Vector2.UnitY.Y;
            newBatPosition.Y = _roomBounds.Bottom - _bat.Height;
        }

        // If the normal is anything but Vector2.Zero, this means the bat had
        // moved outside the screen edge so we should reflect it about the
        // normal.
        if (normal != Vector2.Zero)
        {
            normal.Normalize();
            _batVelocity = Vector2.Reflect(_batVelocity, normal);

            // Play the bounce sound effect.
            Audio.PlaySoundEffect(_bounceSoundEffect);
        }

        _batPosition = newBatPosition;

        if (slimeBounds.Intersects(batBounds))
        {
            // Choose a random row and column based on the total number of each
            int column = Random.Shared.Next(1, _tilemap.Columns - 1);
            int row = Random.Shared.Next(1, _tilemap.Rows - 1);

            // Change the bat position by setting the x and y values equal to
            // the column and row multiplied by the width and height.
            _batPosition = new Vector2(column * _bat.Width, row * _bat.Height);

            // Assign a new random velocity to the bat.
            AssignRandomBatVelocity();

            // Play the collect sound effect.
            Audio.PlaySoundEffect(_collectSoundEffect);

            // Increase the player's score.
            _score += 100;
        }

        base.Update(gameTime);
    }

    private void AssignRandomBatVelocity()
    {
        // Generate a random angle.
        float angle = (float)(Random.Shared.NextDouble() * Math.PI * 2);

        // Convert angle to a direction vector
        float x = (float)Math.Cos(angle);
        float y = (float)Math.Sin(angle);
        Vector2 direction = new Vector2(x, y);

        // Multiply the direction vector by the movement speed
        _batVelocity = direction * MOVEMENT_SPEED;
    }

    private void CheckKeyboardInput()
    {
        // If the space key is held down, the movement speed increases by 1.5
        float speed = MOVEMENT_SPEED;
        if (Input.Keyboard.IsKeyDown(Keys.Space))
        {
            speed *= 1.5f;
        }

        // If the W or Up keys are down, move the slime up on the screen.
        if (Input.Keyboard.IsKeyDown(Keys.W) || Input.Keyboard.IsKeyDown(Keys.Up))
        {
            _slimePosition.Y -= speed;
        }

        // if the S or Down keys are down, move the slime down on the screen.
        if (Input.Keyboard.IsKeyDown(Keys.S) || Input.Keyboard.IsKeyDown(Keys.Down))
        {
            _slimePosition.Y += speed;
        }

        // If the A or Left keys are down, move the slime left on the screen.
        if (Input.Keyboard.IsKeyDown(Keys.A) || Input.Keyboard.IsKeyDown(Keys.Left))
        {
            _slimePosition.X -= speed;
        }

        // If the D or Right keys are down, move the slime right on the screen.
        if (Input.Keyboard.IsKeyDown(Keys.D) || Input.Keyboard.IsKeyDown(Keys.Right))
        {
            _slimePosition.X += speed;
        }

        // If the M key is pressed, toggle mute state for audio.
        if (Input.Keyboard.WasKeyJustPressed(Keys.M))
        {
            Audio.ToggleMute();
        }

        // If the + button is pressed, increase the volume.
        if (Input.Keyboard.WasKeyJustPressed(Keys.OemPlus))
        {
            Audio.SongVolume += 0.1f;
            Audio.SoundEffectVolume += 0.1f;
        }

        // If the - button was pressed, decrease the volume.
        if (Input.Keyboard.WasKeyJustPressed(Keys.OemMinus))
        {
            Audio.SongVolume -= 0.1f;
            Audio.SoundEffectVolume -= 0.1f;
        }
    }

    private void CheckGamePadInput()
    {
        GamePadInfo gamePadOne = Input.GamePads[(int)PlayerIndex.One];

        // If the A button is held down, the movement speed increases by 1.5
        // and the gamepad vibrates as feedback to the player.
        float speed = MOVEMENT_SPEED;
        if (gamePadOne.IsButtonDown(Buttons.A))
        {
            speed *= 1.5f;
            GamePad.SetVibration(PlayerIndex.One, 1.0f, 1.0f);
        }
        else
        {
            GamePad.SetVibration(PlayerIndex.One, 0.0f, 0.0f);
        }

        // Check thumbstick first since it has priority over which gamepad input
        // is movement.  It has priority since the thumbstick values provide a
        // more granular analog value that can be used for movement.
        if (gamePadOne.LeftThumbStick != Vector2.Zero)
        {
            _slimePosition.X += gamePadOne.LeftThumbStick.X * speed;
            _slimePosition.Y -= gamePadOne.LeftThumbStick.Y * speed;
        }
        else
        {
            // If DPadUp is down, move the slime up on the screen.
            if (gamePadOne.IsButtonDown(Buttons.DPadUp))
            {
                _slimePosition.Y -= speed;
            }

            // If DPadDown is down, move the slime down on the screen.
            if (gamePadOne.IsButtonDown(Buttons.DPadDown))
            {
                _slimePosition.Y += speed;
            }

            // If DPapLeft is down, move the slime left on the screen.
            if (gamePadOne.IsButtonDown(Buttons.DPadLeft))
            {
                _slimePosition.X -= speed;
            }

            // If DPadRight is down, move the slime right on the screen.
            if (gamePadOne.IsButtonDown(Buttons.DPadRight))
            {
                _slimePosition.X += speed;
            }
        }
    }

    protected override void Draw(GameTime gameTime)
    {
        // Clear the back buffer.
        GraphicsDevice.Clear(Color.CornflowerBlue);

        // Begin the sprite batch to prepare for rendering.
        SpriteBatch.Begin(samplerState: SamplerState.PointClamp);

        // Draw the tilemap
        _tilemap.Draw(SpriteBatch);

        // Draw the slime sprite.
        _slime.Draw(SpriteBatch, _slimePosition);

        // Draw the bat sprite.
        _bat.Draw(SpriteBatch, _batPosition);

        // Draw the score
        SpriteBatch.DrawString(
            _font,              // spriteFont
            $&quot;Score: {_score}&quot;, // text
            _scoreTextPosition, // position
            Color.White,        // color
            0.0f,               // rotation
            _scoreTextOrigin,   // origin
            1.0f,               // scale
            SpriteEffects.None, // effects
            0.0f                // layerDepth
        );

        // Always end the sprite batch when finished.
        SpriteBatch.End();

        base.Draw(gameTime);
    }
}
</code></pre>
<p>The key changes made are:</p>
<ol>
<li>The <code>_font</code> field was added to store the SpriteFont Description when loaded.</li>
<li>The <code>_score</code> field was added to track the player's score.</li>
<li>The <code>_scoreTextPosition</code> field was added to store the precalculated position to draw the score text at.</li>
<li>The <code>_scoreTextOrigin</code> field was added to store the origin to use when drawing the score text.</li>
<li>In <a href="xref:Microsoft.Xna.Framework.Game.Initialize"><strong>Initialize</strong></a>
<ol>
<li>The position to draw the score text is precalculated to align with the left side of the room bounds horizontally and to vertically be at the center of the first tile at the top.</li>
<li>The origin for the score text is precalculated by measuring the string <code>&quot;Score&quot;</code> and multiplying the <code>Y</code> component to get the vertical center of the text, then the origin is set so that it is at the left-center.</li>
</ol>
</li>
<li>In <a href="xref:Microsoft.Xna.Framework.Game.LoadContent"><strong>LoadContent</strong></a>, the font is loaded using the content manager.</li>
<li>In <a href="xref:Microsoft.Xna.Framework.Game.Update(Microsoft.Xna.Framework.GameTime)"><strong>Update</strong></a>, the player's score is increased by <code>100</code> each time the slime eats the bat.</li>
<li>In <a href="xref:Microsoft.Xna.Framework.Game.Draw(Microsoft.Xna.Framework.GameTime)"><strong>Draw</strong></a>, the score text is drawn at the precalculated position using the precalculated origin so that it aligns in the center of the tile on the blue strip using the sprite batch.</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align: center;"><video width="500" height="281" controls=""><source type="video/webm" src="./videos/gameplay.webm"></video></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Figure 16-2: The game with score displayed in the top-left corner</strong></td>
</tr>
</tbody>
</table>
<h2 id="conclusion">Conclusion</h2>
<p>In this chapter, you accomplished the following:</p>
<ul>
<li>Learned how to create SpriteFont definitions with the MGCB Editor.</li>
<li>Learned how to reference font files for better cross-platform compatibility.</li>
<li>Learned how to load SpriteFonts through the content pipeline.</li>
<li>Learned how to draw text with various parameters to control appearance.</li>
<li>Learned how to measure text dimensions.</li>
<li>Implemented a score display in our game.</li>
</ul>
<p>In the next chapter we will discuss MonoGame's service container and how we can use it to start breaking our monolithic game file into modules for better maintainability.</p>
<h2 id="test-your-knowledge">Test Your Knowledge</h2>
<ol>
<li><p>What are the key components of a SpriteFont in MonoGame?</p>
<p>:::question-answer
A SpriteFont in MonoGame consists of:</p>
<ol>
<li>A texture atlas containing pre-rendered glyphs (characters)</li>
<li>Data that tracks the position, size, and spacing of each character</li>
<li>Kerning information for adjusting spacing between specific character pairs
:::</li>
</ol>
</li>
<li><p>Why is it recommended to include the font file in your content project rather than referencing system fonts?</p>
<p>:::question-answer
Including the font file (TTF/OTF) directly in your content project and referencing it with the file extension ensures portability across different development environments. This approach does not depend on fonts being installed on the system where the content is built.
:::</p>
</li>
<li><p>What method would you use to determine how much space a text string will occupy when rendered, and what does it return?</p>
<p>:::question-answer
The <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteFont.MeasureString(System.String)"><strong>SpriteFont.MeasureString</strong></a> method is used to determine text dimensions. It returns a <a href="xref:Microsoft.Xna.Framework.Vector2"><strong>Vector2</strong></a> where the X component represents the width and the Y component represents the height of the rendered text in pixels.
:::</p>
</li>
</ol>

</article>
                </div>

            </main>
        </div>


        <script src="https://code.jquery.com/jquery-3.6.3.min.js" integrity="sha256-pvPw+upLPUjgMXY0G+8O0xUf+/Im1MZjXxxgOcBQBXU=" crossorigin="anonymous"></script>
        <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.1/dist/umd/popper.min.js" integrity="sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN" crossorigin="anonymous"></script>
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.min.js" integrity="sha384-+sLIOodYLS7CIrQpBjl+C7nPvqq+FbNUBDunl/OZv93DB7Ln/533i8e/mZXLi/P+" crossorigin="anonymous"></script>
        <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
        <script type="text/javascript" src="../../../../../../styles/jquery.twbsPagination.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/mark.js@8.11.1/dist/jquery.mark.min.js"></script>
        <script type="text/javascript" src="../../../../../../styles/url.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/anchor-js@5.0.0/anchor.min.js"></script>
        <script type="text/javascript" src="../../../../../../styles/docfx.js"></script>
        <script type="text/javascript" src="../../../../../../styles/main.js"></script>
        <script type="text/javascript" src="../../../../../../styles/singulink.js"></script>    </body>
</html>
