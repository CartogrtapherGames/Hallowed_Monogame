<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>

    <head>
      <meta charset="utf-8">
      <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
      <title>Chapter 13: Working with Tilemaps | hallowed </title>
      <meta name="viewport" content="width=device-width">
      <meta name="title" content="Chapter 13: Working with Tilemaps | hallowed ">
      <meta name="generator" content="docfx ">
  
      <link rel="shortcut icon" href="../../../../../../favicon.ico">
      <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/night-owl.min.css">
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css" integrity="sha384-EvBWSlnoFgZlXJvpzS+MAUEjvN7+gcCwH+qh7GRFOGgZO0PuwOFro7qPOJnLfe7l" crossorigin="anonymous">
      <link rel="stylesheet" href="../../../../../../styles/config.css">
      <link rel="stylesheet" href="../../../../../../styles/singulink.css">
      <link rel="stylesheet" href="../../../../../../styles/main.css">
      <meta property="docfx:navrel" content="../../../../../../toc.html">
      <meta property="docfx:tocrel" content="../../../toc.html">
  
  <meta property="docfx:rel" content="../../../../../../">
  
    </head>
    <body>
        <!-- Header required for docfx anchor scroll to work -->
        <header id="head"></header>
        <div class="top-navbar">
            <a class="burger-icon" onclick="toggleMenu()">
                <svg name="Hamburger" style="vertical-align: middle;" width="34" height="34" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" clip-rule="evenodd" d="M20 6H4V9H20V6ZM4 10.999H20V13.999H4V10.999ZM4 15.999H20V18.999H4V15.999Z"></path></svg>
            </a>


            <a class="brand" href="../../../../../../index.html">
              <img src="../../../../../../logo.svg" alt="hallowed" class="logomark">
              <span class="brand-title">hallowed</span>
            </a>        </div>

        <div class="body-content">
            <div id="blackout" class="blackout" onclick="toggleMenu()"></div>

            <nav id="sidebar" role="navigation">
                <div class="sidebar">

                    <div>
                      <div class="mobile-hide">

                        <a class="brand" href="../../../../../../index.html">
                          <img src="../../../../../../logo.svg" alt="hallowed" class="logomark">
                          <span class="brand-title">hallowed</span>
                        </a>                      </div>

                      <div class="sidesearch">
                        <form id="search" role="search" class="search">
                            <i class="bi bi-search search-icon"></i>
                            <input type="text" id="search-query" placeholder="Search" autocomplete="off">
                        </form>
                      </div>

                      <div id="navbar">
                      </div>
                    </div>                    <div class="sidebar-item-separator"></div>

                        <div id="sidetoggle">
                          <div id="sidetoc"></div>
                        </div>
                </div>
                <div class="footer">
  
  <strong><a href='https://dotnet.github.io/docfx/'>DocFX</a> + <a href='https://www.singulink.com'>Singulink</a> = â™¥</strong>
                </div>            </nav>

            <main class="main-panel">

                <div id="search-results" style="display: none;">
                  <h1 class="search-list">Search Results for <span></span></h1>
                  <div class="sr-items">
                    <p><i class="bi bi-hourglass-split index-loading"></i></p>
                  </div>
                  <ul id="pagination" data-first=First data-prev=Previous data-next=Next data-last=Last></ul>
                </div>
 

                <div role="main" class="hide-when-search">

                        <div class="subnav navbar navbar-default">
                          <div class="container hide-when-search" id="breadcrumb">
                            <ul class="breadcrumb">
                              <li></li>
                            </ul>
                          </div>
                        </div>

                         <div class="contribution">
                               <a href="https://github.com/MonoGame/docs.monogame.github.io/blob/main/articles/tutorials/building_2d_games/13_working_with_tilemaps/index.md/#L1" class="contribution-link">Edit this page</a>
                         </div>

                    <article class="content wrap" id="_content" data-uid="">


<p>In the previous chapters, you have learned how to draw individual sprites and animated sprites from a texture atlas and handle collision detection. However, the game so far is lacking an actual world or environment to exist in; it is just sprites on a cornflower blue background. Most 2D games feature game worlds built from many tiles arranged in a grid-like patten. These <em>tilemaps</em> allow you to efficiently create large game environments without managing thousands of individual sprites.</p>
<p>In this chapter you will:</p>
<ul>
<li>Learn what tilemaps are and how they are used in game development.</li>
<li>Create a <code>Tileset</code> class to manage collections of related tiles.</li>
<li>Build a <code>Tilemap</code> class to render tile-based game worlds.</li>
<li>Implement an XML-based tilemap loading system.</li>
<li>Update our game to use tilemaps for the game environment.</li>
</ul>
<h2 id="understanding-tilemaps">Understanding Tilemaps</h2>
<p>Tilemaps are a common technique used in 2D game development to create game worlds. Instead of positioning individual sprites for each element in the game world, a tilemap divides the world into a grid and places tiles from a <em>tileset</em> at each grid position.</p>
<h3 id="what-is-a-tileset">What is a Tileset?</h3>
<p>A tileset is a collection of small images (tiles) that can be combined and arranged to create game environments. Typically these are stored in a single texture atlas, similar to how we have been handing sprites and animations. Common examples of tiles might include:</p>
<ul>
<li>Floor and ground tiles.</li>
<li>Walls and obstacle tiles.</li>
<li>Decorative elements like plants and furniture.</li>
<li>Special tiles like doors, ladders, or water.</li>
</ul>
<p>Each tile in a tileset is assigned an ID number, which the tilemap uses to reference which tile goes where. For example, in <em>Figure 13-1</em> below, the tileset we will add to our game in a moment is shown on the left and on the right is the same tileset with an overlay showing how each tile is assigned an ID number.</p>
<table>
<thead>
<tr>
<th style="text-align: center;"><img src="./images/tileset-grid-comparison.png" alt="Figure 13-1: Left: Original dungeon tileset. Right: The same tileset with an overlay showing how each tile is assigned a numeric ID"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Figure 13-1: Left: Original dungeon tileset. Right: The same tileset with an overlay showing how each tile is assigned a numeric ID</strong></td>
</tr>
</tbody>
</table>
<h3 id="what-is-a-tilemap">What is a Tilemap?</h3>
<p>A tilemap is a grid-based data structure that defines which tiles from a tileset appear at each position in the game world. The tilemap stores an ID for each cell in the grid, where the ID corresponds to a specific tile in the tileset.</p>
<p>For example, a simple tilemap may look like this conceptually:</p>
<pre><code class="lang-text">00 01 02 01 03
04 05 06 05 07
08 09 10 09 11
04 09 09 09 07
12 13 14 13 15
</code></pre>
<p>If we took the above tilemap data and mapped each cell to the tile in the related tileset, it would look something similar to <em>Figure 13-2</em> below:</p>
<table>
<thead>
<tr>
<th style="text-align: center;"><img src="./images/tileset-to-tilemap-example.png" alt="Figure 13-2: From tileset to tilemap. Left: Tileset with an overlay showing the tile IDs.  Right: The tilemap created using the tiles arranged with the pattern from the code example above"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Figure 13-2: From tileset to tilemap. Left: Tileset with an overlay showing the tile IDs. Right: The tilemap created using the tiles arranged with the pattern from the code example above</strong></td>
</tr>
</tbody>
</table>
<p>This approach offers several advantage:</p>
<ol>
<li><strong>Memory efficiency</strong>: Instead of storing complete information about each tile's appearance, you only need to store a reference ID.</li>
<li><strong>Performance</strong>: Drawing a tilemap can be optimized to reduce texture swapping compared to rendering many individual sprites.</li>
<li><strong>Design flexibility</strong>: Tilemaps make it easy to create, modify, and load level designs from external files.</li>
</ol>
<p>We will now take this concept and implement it in our game by creating a <code>Tileset</code> class and a <code>Tilemap</code> class.</p>
<h2 id="the-tileset-class">The Tileset Class</h2>
<p>The <code>Tileset</code> class will manage a collection of tiles from a texture atlas. Each tile will be represented as a <code>TextureRegion</code>, building on the tools in the library we created earlier.</p>
<p>In the <code>Graphics</code> folder of the <em>MonoGameLibrary</em> project, create a new file named <code>Tileset.cs</code> with the following code as the initial structure:</p>
<pre><code class="lang-csharp">namespace MonoGameLibrary.Graphics;

public class Tileset
{

}
</code></pre><h3 id="tileset-properties-and-fields">Tileset Properties and Fields</h3>
<p>The <code>Tileset</code> class needs to store a <code>TextureRegion</code> for each of the individual tiles in the tile set and provide the dimensions (width and height) of the tiles. It should also offers additional properties that provide the total number of rows and columns in the tileset and the total number of tiles. Add the following fields and properties:</p>
<pre><code class="lang-csharp">private readonly TextureRegion[] _tiles;

/// &lt;summary&gt;
/// Gets the width, in pixels, of each tile in this tileset.
/// &lt;/summary&gt;
public int TileWidth { get; }

/// &lt;summary&gt;
/// Gets the height, in pixels, of each tile in this tileset.
/// &lt;/summary&gt;
public int TileHeight { get; }

/// &lt;summary&gt;
/// Gets the total number of columns in this tileset.
/// &lt;/summary&gt;
public int Columns { get; }

/// &lt;summary&gt;
/// Gets the total number of rows in this tileset.
/// &lt;/summary&gt;
public int Rows { get; }

/// &lt;summary&gt;
/// Gets the total number of tiles in this tileset.
/// &lt;/summary&gt;
public int Count { get; }
</code></pre><h3 id="tileset-constructor">Tileset Constructor</h3>
<p>The <code>Tileset</code> class constructor requires a source <code>TextureRegion</code> that represents the tileset and the width and height of the tiles. Based on these parameters provided, it can automatically divide the source <code>TextureRegion</code> into a grid of smaller texture regions and calculate the total number of rows, columns, and tiles.</p>
<p>Add the following constructor:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Creates a new tileset based on the given texture region with the specified
/// tile width and height.
/// &lt;/summary&gt;
/// &lt;param name=&quot;textureRegion&quot;&gt;The texture region that contains the tiles for the tileset.&lt;/param&gt;
/// &lt;param name=&quot;tileWidth&quot;&gt;The width of each tile in the tileset.&lt;/param&gt;
/// &lt;param name=&quot;tileHeight&quot;&gt;The height of each tile in the tileset.&lt;/param&gt;
public Tileset(TextureRegion textureRegion, int tileWidth, int tileHeight)
{
    TileWidth = tileWidth;
    TileHeight = tileHeight;
    Columns = textureRegion.Width / tileWidth;
    Rows = textureRegion.Height / tileHeight;
    Count = Columns * Rows;

    // Create the texture regions that make up each individual tile
    _tiles = new TextureRegion[Count];

    for (int i = 0; i &lt; Count; i++)
    {
        int x = i % Columns * tileWidth;
        int y = i / Columns * tileHeight;
        _tiles[i] = new TextureRegion(textureRegion.Texture, textureRegion.SourceRectangle.X + x, textureRegion.SourceRectangle.Y + y, tileWidth, tileHeight);
    }
}
</code></pre><h3 id="tileset-methods">Tileset Methods</h3>
<p>The <code>Tileset</code> class needs to provide methods to retrieve the <code>TextureRegion</code> of a tile based on the index (tile ID) or by the location (row and column) of the tile in the tileset. Add the following methods:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Gets the texture region for the tile from this tileset at the given index.
/// &lt;/summary&gt;
/// &lt;param name=&quot;index&quot;&gt;The index of the texture region in this tile set.&lt;/param&gt;
/// &lt;returns&gt;The texture region for the tile form this tileset at the given index.&lt;/returns&gt;
public TextureRegion GetTile(int index) =&gt; _tiles[index];

/// &lt;summary&gt;
/// Gets the texture region for the tile from this tileset at the given location.
/// &lt;/summary&gt;
/// &lt;param name=&quot;column&quot;&gt;The column in this tileset of the texture region.&lt;/param&gt;
/// &lt;param name=&quot;row&quot;&gt;The row in this tileset of the texture region.&lt;/param&gt;
/// &lt;returns&gt;The texture region for the tile from this tileset at given location.&lt;/returns&gt;
public TextureRegion GetTile(int column, int row)
{
    int index = row * Columns + column;
    return GetTile(index);
}
</code></pre><h2 id="the-tilemap-class">The Tilemap Class</h2>
<p>Now that we have a <code>Tileset</code> class to define our tile collection, we need a <code>Tilemap</code> class to arrange these tiles into a game level. The <code>Tilemap</code> class will store which tile goes where in our game world and provide methods to draw the entire map.</p>
<p>In the <code>Graphics</code> folder of the <em>MonoGameLibrary</em> project, create a new file named <code>Tilemap.cs</code> with the following code as the initial structure:</p>
<pre><code class="lang-csharp">using System;
using System.IO;
using System.Xml;
using System.Xml.Linq;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;

namespace MonoGameLibrary.Graphics;

public class Tilemap
{

}
</code></pre><h3 id="tilemap-properties-and-fields">Tilemap Properties and Fields</h3>
<p>The <code>Tilemap</code> class needs to store a reference to the tileset being used, along with an array of the tile IDs representing each tile in the map. It should also offer additional properties that provide the total number of rows and columns in the tilemap and the total number of tiles. Add the following fields and properties:</p>
<pre><code class="lang-csharp">private readonly Tileset _tileset;
private readonly int[] _tiles;

/// &lt;summary&gt;
/// Gets the total number of rows in this tilemap.
/// &lt;/summary&gt;
public int Rows { get; }

/// &lt;summary&gt;
/// Gets the total number of columns in this tilemap.
/// &lt;/summary&gt;
public int Columns { get; }

/// &lt;summary&gt;
/// Gets the total number of tiles in this tilemap.
/// &lt;/summary&gt;
public int Count { get; }

/// &lt;summary&gt;
/// Gets or Sets the scale factor to draw each tile at.
/// &lt;/summary&gt;
public Vector2 Scale { get; set; }

/// &lt;summary&gt;
/// Gets the width, in pixels, each tile is drawn at.
/// &lt;/summary&gt;
public float TileWidth =&gt; _tileset.TileWidth * Scale.X;

/// &lt;summary&gt;
/// Gets the height, in pixels, each tile is drawn at.
/// &lt;/summary&gt;
public float TileHeight =&gt; _tileset.TileHeight * Scale.Y;
</code></pre><h3 id="tilemap-constructor">Tilemap Constructor</h3>
<p>The <code>Tilemap</code> constructor requires the <code>Tilemap</code> to reference for each tile, the total number of columns and rows in the map, and the size (width and height) of each tile.</p>
<p>Add the following constructor:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Creates a new tilemap.
/// &lt;/summary&gt;
/// &lt;param name=&quot;tileset&quot;&gt;The tileset used by this tilemap.&lt;/param&gt;
/// &lt;param name=&quot;columns&quot;&gt;The total number of columns in this tilemap.&lt;/param&gt;
/// &lt;param name=&quot;rows&quot;&gt;The total number of rows in this tilemap.&lt;/param&gt;
public Tilemap(Tileset tileset, int columns, int rows)
{
    _tileset = tileset;
    Rows = rows;
    Columns = columns;
    Count = Columns * Rows;
    Scale = Vector2.One;
    _tiles = new int[Count];
}
</code></pre><h3 id="tilemap-tile-management-methods">Tilemap Tile Management Methods</h3>
<p>The <code>Tilemap</code> class should provide methods to set and retrieve tiles, either by index or location (rows and column). Add the following methods:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Sets the tile at the given index in this tilemap to use the tile from
/// the tileset at the specified tileset id.
/// &lt;/summary&gt;
/// &lt;param name=&quot;index&quot;&gt;The index of the tile in this tilemap.&lt;/param&gt;
/// &lt;param name=&quot;tilesetID&quot;&gt;The tileset id of the tile from the tileset to use.&lt;/param&gt;
public void SetTile(int index, int tilesetID)
{
    _tiles[index] = tilesetID;
}

/// &lt;summary&gt;
/// Sets the tile at the given column and row in this tilemap to use the tile
/// from the tileset at the specified tileset id.
/// &lt;/summary&gt;
/// &lt;param name=&quot;column&quot;&gt;The column of the tile in this tilemap.&lt;/param&gt;
/// &lt;param name=&quot;row&quot;&gt;The row of the tile in this tilemap.&lt;/param&gt;
/// &lt;param name=&quot;tilesetID&quot;&gt;The tileset id of the tile from the tileset to use.&lt;/param&gt;
public void SetTile(int column, int row, int tilesetID)
{
    int index = row * Columns + column;
    SetTile(index, tilesetID);
}

/// &lt;summary&gt;
/// Gets the texture region of the tile from this tilemap at the specified index.
/// &lt;/summary&gt;
/// &lt;param name=&quot;index&quot;&gt;The index of the tile in this tilemap.&lt;/param&gt;
/// &lt;returns&gt;The texture region of the tile from this tilemap at the specified index.&lt;/returns&gt;
public TextureRegion GetTile(int index)
{
    return _tileset.GetTile(_tiles[index]);
}

/// &lt;summary&gt;
/// Gets the texture region of the tile from this tilemap at the specified
/// column and row.
/// &lt;/summary&gt;
/// &lt;param name=&quot;column&quot;&gt;The column of the tile in this tilemap.&lt;/param&gt;
/// &lt;param name=&quot;row&quot;&gt;The row of the tile in this tilemap.&lt;/param&gt;
/// &lt;returns&gt;The texture region of the tile from this tilemap at the specified column and row.&lt;/returns&gt;
public TextureRegion GetTile(int column, int row)
{
    int index = row * Columns + column;
    return GetTile(index);
}
</code></pre><h3 id="tilemap-draw-method">Tilemap Draw Method</h3>
<p>The <code>Tilemap</code> class needs a method to draw the tilemap by iterating through each of the tiles and drawing the <code>TextureRegion</code> for that tile at its correct position. Add the following method:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Draws this tilemap using the given sprite batch.
/// &lt;/summary&gt;
/// &lt;param name=&quot;spriteBatch&quot;&gt;The sprite batch used to draw this tilemap.&lt;/param&gt;
public void Draw(SpriteBatch spriteBatch)
{
    for (int i = 0; i &lt; Count; i++)
    {
        int tilesetIndex = _tiles[i];
        TextureRegion tile = _tileset.GetTile(tilesetIndex);

        int x = i % Columns;
        int y = i / Columns;

        Vector2 position = new Vector2(x * TileWidth, y * TileHeight);
        tile.Draw(spriteBatch, position, Color.White, 0.0f, Vector2.Zero, Scale, SpriteEffects.None, 1.0f);
    }
}
</code></pre><h3 id="tilemap-fromfile-method">Tilemap FromFile Method</h3>
<p>The <code>Tilemap</code> class also requires a method to load and create an instance of the tilemap from an external configuration file. This allows us to separate level design from code. Add the following method:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Creates a new tilemap based on a tilemap xml configuration file.
/// &lt;/summary&gt;
/// &lt;param name=&quot;content&quot;&gt;The content manager used to load the texture for the tileset.&lt;/param&gt;
/// &lt;param name=&quot;filename&quot;&gt;The path to the xml file, relative to the content root directory.&lt;/param&gt;
/// &lt;returns&gt;The tilemap created by this method.&lt;/returns&gt;
public static Tilemap FromFile(ContentManager content, string filename)
{
    string filePath = Path.Combine(content.RootDirectory, filename);

    using (Stream stream = TitleContainer.OpenStream(filePath))
    {
        using (XmlReader reader = XmlReader.Create(stream))
        {
            XDocument doc = XDocument.Load(reader);
            XElement root = doc.Root;

            // The &lt;Tileset&gt; element contains the information about the tileset
            // used by the tilemap.
            //
            // Example
            // &lt;Tileset region=&quot;0 0 100 100&quot; tileWidth=&quot;10&quot; tileHeight=&quot;10&quot;&gt;contentPath&lt;/Tileset&gt;
            //
            // The region attribute represents the x, y, width, and height
            // components of the boundary for the texture region within the
            // texture at the contentPath specified.
            //
            // the tileWidth and tileHeight attributes specify the width and
            // height of each tile in the tileset.
            //
            // the contentPath value is the contentPath to the texture to
            // load that contains the tileset
            XElement tilesetElement = root.Element(&quot;Tileset&quot;);

            string regionAttribute = tilesetElement.Attribute(&quot;region&quot;).Value;
            string[] split = regionAttribute.Split(&quot; &quot;, StringSplitOptions.RemoveEmptyEntries);
            int x = int.Parse(split[0]);
            int y = int.Parse(split[1]);
            int width = int.Parse(split[2]);
            int height = int.Parse(split[3]);

            int tileWidth = int.Parse(tilesetElement.Attribute(&quot;tileWidth&quot;).Value);
            int tileHeight = int.Parse(tilesetElement.Attribute(&quot;tileHeight&quot;).Value);
            string contentPath = tilesetElement.Value;

            // Load the texture 2d at the content path
            Texture2D texture = content.Load&lt;Texture2D&gt;(contentPath);

            // Create the texture region from the texture
            TextureRegion textureRegion = new TextureRegion(texture, x, y, width, height);

            // Create the tileset using the texture region
            Tileset tileset = new Tileset(textureRegion, tileWidth, tileHeight);

            // The &lt;Tiles&gt; element contains lines of strings where each line
            // represents a row in the tilemap.  Each line is a space
            // separated string where each element represents a column in that
            // row.  The value of the column is the id of the tile in the
            // tileset to draw for that location.
            //
            // Example:
            // &lt;Tiles&gt;
            //      00 01 01 02
            //      03 04 04 05
            //      03 04 04 05
            //      06 07 07 08
            // &lt;/Tiles&gt;
            XElement tilesElement = root.Element(&quot;Tiles&quot;);

            // Split the value of the tiles data into rows by splitting on
            // the new line character
            string[] rows = tilesElement.Value.Trim().Split('\n', StringSplitOptions.RemoveEmptyEntries);

            // Split the value of the first row to determine the total number of columns
            int columnCount = rows[0].Split(&quot; &quot;, StringSplitOptions.RemoveEmptyEntries).Length;

            // Create the tilemap
            Tilemap tilemap = new Tilemap(tileset, columnCount, rows.Length);

            // Process each row
            for (int row = 0; row &lt; rows.Length; row++)
            {
                // Split the row into individual columns
                string[] columns = rows[row].Trim().Split(&quot; &quot;, StringSplitOptions.RemoveEmptyEntries);

                // Process each column of the current row
                for (int column = 0; column &lt; columnCount; column++)
                {
                    // Get the tileset index for this location
                    int tilesetIndex = int.Parse(columns[column]);

                    // Get the texture region of that tile from the tileset
                    TextureRegion region = tileset.GetTile(tilesetIndex);

                    // Add that region to the tilemap at the row and column location
                    tilemap.SetTile(column, row, tilesetIndex);
                }
            }

            return tilemap;
        }
    }
}
</code></pre><h2 id="updating-the-game">Updating the Game</h2>
<p>Now that we have the <code>Tilemap</code> and <code>Tileset</code> classes defined, we can update our game to use them. We will need to</p>
<ol>
<li>Update the texture atlas to include the tileset.</li>
<li>Create a tilemap xml configuration file.</li>
<li>Update the game to load the tilemap from the configuration file and draw it.</li>
</ol>
<h3 id="update-the-texture-atlas">Update the Texture Atlas</h3>
<p>Currently, the texture atlas we have been using only contains the sprites for the slime and bat animations. We need update it to a new version that contains the tileset as well.</p>
<p>Right-click the following image and save it as <code>atlas.png</code> in the <code>Content/images</code> directory of the <em>DungeonSlime</em> project (your main game project), overwriting the existing one.</p>
<div class="NOTE">
<h5>Note</h5>
<p>You do not need to do this in the MGCB editor as you are simply replacing the file and not altering any of its import properties.</p>
</div>
<table>
<thead>
<tr>
<th style="text-align: center;"><img src="./images/atlas.png" alt="Figure 13-3: The texture atlas for our game updated to include the tileset for the tilemap"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Figure 13-3: The texture atlas for our game updated to include the tileset for the tilemap</strong></td>
</tr>
</tbody>
</table>
<div class="NOTE">
<h5>Note</h5>
<p>Since the slime and bat sprites are in the same position in the new texture atlas, we do not need to update the atlas XML configuration file.</p>
</div>
<h2 id="creating-a-tilemap-xml-configuration">Creating a Tilemap XML Configuration</h2>
<p>Now that we have the texture atlas updated to include the tileset, we need to create a tilemap configuration that our game can load. The configuration will be an XML file that specifies the tileset to use and the arrangement of tiles in the tilemap.</p>
<p>We need to add this configuration file to our content project in the <em>Content/images</em> folder with the MGCB Editor, in the same way we did with the &quot;atlas-definition.xml&quot;:</p>
<ol>
<li>Open the <em>Content.mgcb</em> content project file in the MGCB Editor.</li>
<li>Right-click the <em>images</em> folder and choose <em>Add &gt; New Item...</em>.</li>
<li>Select the <em>Xml Content (.xml)</em> type and name it <code>tilemap-definition</code></li>
<li>Select the <code>tilemap-definition.xml</code> file you just created.</li>
<li>In the Properties panel, change the <em>Build Action</em> property from <em>Build</em> to <em>Copy</em>.</li>
<li>Save the changes in the MGCB Editor.</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align: center;"><img src="./images/mgcb-editor.png" alt="Figure 13-4: The Content project in the MGCB Editor with the tilemap-definition.xml file added and the Build Action property set to copy"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Figure 13-4: The Content project in the MGCB Editor with the tilemap-definition.xml file added and the Build Action property set to copy</strong></td>
</tr>
</tbody>
</table>
<ol start="7">
<li>Open the <code>tilemap-definition.xml</code> file in your code editor and replace its contents with the following and save it:</li>
</ol>
<pre><code class="lang-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;Tilemap&gt;
    &lt;Tileset region=&quot;0 40 80 80&quot; tileWidth=&quot;20&quot; tileHeight=&quot;20&quot;&gt;images/atlas&lt;/Tileset&gt;
    &lt;Tiles&gt;
        00 01 02 01 02 01 02 01 02 01 02 01 02 01 02 03
        04 05 05 06 05 05 06 05 05 06 05 05 06 05 05 07
        08 09 09 09 09 09 09 09 09 09 09 09 09 09 09 11
        04 09 09 09 09 09 09 09 10 09 09 09 09 10 09 07
        08 09 10 09 09 09 09 09 09 09 09 09 09 09 09 11
        04 09 09 09 09 09 09 09 09 09 09 09 09 09 09 07
        08 10 09 09 09 09 09 09 09 09 10 09 09 09 09 11
        04 09 09 09 09 09 10 09 09 09 09 09 09 09 09 07
        12 13 14 13 14 13 14 13 14 13 14 13 14 13 14 15
    &lt;/Tiles&gt;
&lt;/Tilemap&gt;
</code></pre>
<p>This tilemap configuration creates a simple dungeon layout with walls around the perimeter and an open floor in the middle. The tile IDs correspond to specific tiles in the tileset:</p>
<ul>
<li><code>00</code>, <code>03</code>, <code>12</code>, <code>15</code>: Corner wall tiles (top-left, top-right, bottom-left, bottom-right).</li>
<li><code>01</code>, <code>02</code>, <code>13</code>, <code>14</code>: Horizontal wall tiles (top and bottom walls).</li>
<li><code>04</code>, <code>07</code>, <code>08</code>, <code>11</code>: Vertical wall tiles (left and right walls).</li>
<li><code>05</code> and <code>06</code>: Top floor edge tiles.</li>
<li><code>09</code>: Standard floor tile.</li>
<li><code>10</code>: Decorated floor tile with a crack in it.</li>
</ul>
<h3 id="update-the-game1-class">Update the Game1 Class</h3>
<p>With all of the assets now in place and configured, we can update the <code>Game1</code> class to load the tilemap and draw it. We will also need to update the collision logic so that the boundary is no longer the edge of the screen, but instead the edges of the wall tiles of the tilemap. Open <code>Game1.cs</code> and make the following updates:</p>
<pre><code class="lang-csharp">using System;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;
using MonoGameLibrary;
using MonoGameLibrary.Graphics;
using MonoGameLibrary.Input;

namespace DungeonSlime;

public class Game1 : Core
{
    // Defines the slime animated sprite.
    private AnimatedSprite _slime;

    // Defines the bat animated sprite.
    private AnimatedSprite _bat;

    // Tracks the position of the slime.
    private Vector2 _slimePosition;

    // Speed multiplier when moving.
    private const float MOVEMENT_SPEED = 5.0f;

    // Tracks the position of the bat.
    private Vector2 _batPosition;

    // Tracks the velocity of the bat.
    private Vector2 _batVelocity;

    // Defines the tilemap to draw.
    private Tilemap _tilemap;

    // Defines the bounds of the room that the slime and bat are contained within.
    private Rectangle _roomBounds;

    public Game1() : base(&quot;Dungeon Slime&quot;, 1280, 720, false)
    {

    }

    protected override void Initialize()
    {
        base.Initialize();

        Rectangle screenBounds = GraphicsDevice.PresentationParameters.Bounds;

       _roomBounds = new Rectangle(
            (int)_tilemap.TileWidth,
            (int)_tilemap.TileHeight,
            screenBounds.Width - (int)_tilemap.TileWidth * 2,
            screenBounds.Height - (int)_tilemap.TileHeight * 2
        );

        // Initial slime position will be the center tile of the tile map.
        int centerRow = _tilemap.Rows / 2;
        int centerColumn = _tilemap.Columns / 2;
        _slimePosition = new Vector2(centerColumn * _tilemap.TileWidth, centerRow * _tilemap.TileHeight);

        // Initial bat position will be in the top left corner of the room
        _batPosition = new Vector2(_roomBounds.Left, _roomBounds.Top);

        // Assign the initial random velocity to the bat.
        AssignRandomBatVelocity();
    }

    protected override void LoadContent()
    {
        // Create the texture atlas from the XML configuration file
        TextureAtlas atlas = TextureAtlas.FromFile(Content, &quot;images/atlas-definition.xml&quot;);

        // Create the slime animated sprite from the atlas.
        _slime = atlas.CreateAnimatedSprite(&quot;slime-animation&quot;);
        _slime.Scale = new Vector2(4.0f, 4.0f);

        // Create the bat animated sprite from the atlas.
        _bat = atlas.CreateAnimatedSprite(&quot;bat-animation&quot;);
        _bat.Scale = new Vector2(4.0f, 4.0f);

        // Create the tilemap from the XML configuration file.
        _tilemap = Tilemap.FromFile(Content, &quot;images/tilemap-definition.xml&quot;);
        _tilemap.Scale = new Vector2(4.0f, 4.0f);
    }

    protected override void Update(GameTime gameTime)
    {
        // Update the slime animated sprite.
        _slime.Update(gameTime);

        // Update the bat animated sprite.
        _bat.Update(gameTime);

        // Check for keyboard input and handle it.
        CheckKeyboardInput();

        // Check for gamepad input and handle it.
        CheckGamePadInput();

        // Creating a bounding circle for the slime
        Circle slimeBounds = new Circle(
            (int)(_slimePosition.X + (_slime.Width * 0.5f)),
            (int)(_slimePosition.Y + (_slime.Height * 0.5f)),
            (int)(_slime.Width * 0.5f)
        );

        // Use distance based checks to determine if the slime is within the
        // bounds of the game screen, and if it is outside that screen edge,
        // move it back inside.
        if (slimeBounds.Left &lt; _roomBounds.Left)
        {
            _slimePosition.X = _roomBounds.Left;
        }
        else if (slimeBounds.Right &gt; _roomBounds.Right)
        {
            _slimePosition.X = _roomBounds.Right - _slime.Width;
        }

        if (slimeBounds.Top &lt; _roomBounds.Top)
        {
            _slimePosition.Y = _roomBounds.Top;
        }
        else if (slimeBounds.Bottom &gt; _roomBounds.Bottom)
        {
            _slimePosition.Y = _roomBounds.Bottom - _slime.Height;
        }

        // Calculate the new position of the bat based on the velocity
        Vector2 newBatPosition = _batPosition + _batVelocity;

        // Create a bounding circle for the bat
        Circle batBounds = new Circle(
            (int)(newBatPosition.X + (_bat.Width * 0.5f)),
            (int)(newBatPosition.Y + (_bat.Height * 0.5f)),
            (int)(_bat.Width * 0.5f)
        );

        Vector2 normal = Vector2.Zero;

        // Use distance based checks to determine if the bat is within the
        // bounds of the game screen, and if it is outside that screen edge,
        // reflect it about the screen edge normal
        if (batBounds.Left &lt; _roomBounds.Left)
        {
            normal.X = Vector2.UnitX.X;
            newBatPosition.X = _roomBounds.Left;
        }
        else if (batBounds.Right &gt; _roomBounds.Right)
        {
            normal.X = -Vector2.UnitX.X;
            newBatPosition.X = _roomBounds.Right - _bat.Width;
        }

        if (batBounds.Top &lt; _roomBounds.Top)
        {
            normal.Y = Vector2.UnitY.Y;
            newBatPosition.Y = _roomBounds.Top;
        }
        else if (batBounds.Bottom &gt; _roomBounds.Bottom)
        {
            normal.Y = -Vector2.UnitY.Y;
            newBatPosition.Y = _roomBounds.Bottom - _bat.Height;
        }

        // If the normal is anything but Vector2.Zero, this means the bat had
        // moved outside the screen edge so we should reflect it about the
        // normal.
        if (normal != Vector2.Zero)
        {
            normal.Normalize();
            _batVelocity = Vector2.Reflect(_batVelocity, normal);
        }

        _batPosition = newBatPosition;

        if (slimeBounds.Intersects(batBounds))
        {
            // Choose a random row and column based on the total number of each
            int column = Random.Shared.Next(1, _tilemap.Columns - 1);
            int row = Random.Shared.Next(1, _tilemap.Rows - 1);

            // Change the bat position by setting the x and y values equal to
            // the column and row multiplied by the width and height.
            _batPosition = new Vector2(column * _bat.Width, row * _bat.Height);

            // Assign a new random velocity to the bat
            AssignRandomBatVelocity();
        }

        base.Update(gameTime);
    }

    private void AssignRandomBatVelocity()
    {
        // Generate a random angle
        float angle = (float)(Random.Shared.NextDouble() * Math.PI * 2);

        // Convert angle to a direction vector
        float x = (float)Math.Cos(angle);
        float y = (float)Math.Sin(angle);
        Vector2 direction = new Vector2(x, y);

        // Multiply the direction vector by the movement speed
        _batVelocity = direction * MOVEMENT_SPEED;
    }

    private void CheckKeyboardInput()
    {
        // If the space key is held down, the movement speed increases by 1.5
        float speed = MOVEMENT_SPEED;
        if (Input.Keyboard.IsKeyDown(Keys.Space))
        {
            speed *= 1.5f;
        }

        // If the W or Up keys are down, move the slime up on the screen.
        if (Input.Keyboard.IsKeyDown(Keys.W) || Input.Keyboard.IsKeyDown(Keys.Up))
        {
            _slimePosition.Y -= speed;
        }

        // if the S or Down keys are down, move the slime down on the screen.
        if (Input.Keyboard.IsKeyDown(Keys.S) || Input.Keyboard.IsKeyDown(Keys.Down))
        {
            _slimePosition.Y += speed;
        }

        // If the A or Left keys are down, move the slime left on the screen.
        if (Input.Keyboard.IsKeyDown(Keys.A) || Input.Keyboard.IsKeyDown(Keys.Left))
        {
            _slimePosition.X -= speed;
        }

        // If the D or Right keys are down, move the slime right on the screen.
        if (Input.Keyboard.IsKeyDown(Keys.D) || Input.Keyboard.IsKeyDown(Keys.Right))
        {
            _slimePosition.X += speed;
        }
    }

    private void CheckGamePadInput()
    {
        GamePadInfo gamePadOne = Input.GamePads[(int)PlayerIndex.One];

        // If the A button is held down, the movement speed increases by 1.5
        // and the gamepad vibrates as feedback to the player.
        float speed = MOVEMENT_SPEED;
        if (gamePadOne.IsButtonDown(Buttons.A))
        {
            speed *= 1.5f;
            GamePad.SetVibration(PlayerIndex.One, 1.0f, 1.0f);
        }
        else
        {
            GamePad.SetVibration(PlayerIndex.One, 0.0f, 0.0f);
        }

        // Check thumbstick first since it has priority over which gamepad input
        // is movement.  It has priority since the thumbstick values provide a
        // more granular analog value that can be used for movement.
        if (gamePadOne.LeftThumbStick != Vector2.Zero)
        {
            _slimePosition.X += gamePadOne.LeftThumbStick.X * speed;
            _slimePosition.Y -= gamePadOne.LeftThumbStick.Y * speed;
        }
        else
        {
            // If DPadUp is down, move the slime up on the screen.
            if (gamePadOne.IsButtonDown(Buttons.DPadUp))
            {
                _slimePosition.Y -= speed;
            }

            // If DPadDown is down, move the slime down on the screen.
            if (gamePadOne.IsButtonDown(Buttons.DPadDown))
            {
                _slimePosition.Y += speed;
            }

            // If DPapLeft is down, move the slime left on the screen.
            if (gamePadOne.IsButtonDown(Buttons.DPadLeft))
            {
                _slimePosition.X -= speed;
            }

            // If DPadRight is down, move the slime right on the screen.
            if (gamePadOne.IsButtonDown(Buttons.DPadRight))
            {
                _slimePosition.X += speed;
            }
        }
    }

    protected override void Draw(GameTime gameTime)
    {
        // Clear the back buffer.
        GraphicsDevice.Clear(Color.CornflowerBlue);

        // Begin the sprite batch to prepare for rendering.
        SpriteBatch.Begin(samplerState: SamplerState.PointClamp);

        // Draw the tilemap.
        _tilemap.Draw(SpriteBatch);

        // Draw the slime sprite.
        _slime.Draw(SpriteBatch, _slimePosition);

        // Draw the bat sprite.
        _bat.Draw(SpriteBatch, _batPosition);

        // Always end the sprite batch when finished.
        SpriteBatch.End();

        base.Draw(gameTime);
    }
}
</code></pre>
<p>The key changes to the <code>Game1</code> class include:</p>
<ol>
<li>The <code>_tilemap</code> field was added to hold the loaded tilemap.</li>
<li>The <code>_roombounds</code> <a href="xref:Microsoft.Xna.Framework.Rectangle"><strong>Rectangle</strong></a> was added to define the playable area within the tilemap to keep the slime and bat inside the walls.</li>
<li>In <a href="xref:Microsoft.Xna.Framework.Game.Initialize"><strong>Initialize</strong></a>:
<ol>
<li>The <code>_roomBounds</code> is set based on the tilemap's tile size.</li>
<li>The starting position of the slime is now set to be in the center of the room.</li>
</ol>
</li>
<li>In <a href="xref:Microsoft.Xna.Framework.Game.LoadContent"><strong>LoadContent</strong></a>:
<ol>
<li>The tilemap is loaded from the XML configuration file.</li>
<li>The scale of the tilemap is set to a factor of 4.0.</li>
</ol>
</li>
<li>In <a href="xref:Microsoft.Xna.Framework.Game.Update(Microsoft.Xna.Framework.GameTime)"><strong>Update</strong></a>, the <code>screenBounds</code> variable was removed and the collision logic has been updated to instead use the <code>_roomBounds</code> instead.</li>
<li>In <a href="xref:Microsoft.Xna.Framework.Game.Draw(Microsoft.Xna.Framework.GameTime)"><strong>Draw</strong></a> the tilemap is drawn.</li>
</ol>
<p>Running the game now with these changes, our game now visually transforms from a simple screen with sprites to a proper game environment with walls and floors. The slime and bat are now confined within the walls of the dungeon defined by our tilemap.</p>
<table>
<thead>
<tr>
<th style="text-align: center;"><video width="500" height="281" controls=""><source type="video/webm" src="./videos/gameplay.webm"></video></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Figure 13-5: Gameplay with the tilemap rendered and the bat and slime contained within the dungeon walls</strong></td>
</tr>
</tbody>
</table>
<h2 id="additional-notes">Additional Notes</h2>
<p>While the method provided in this chapter offers a straightforward approach to loading tilemaps from external configuration files, several dedicated tools exist specifically for creating tilemaps for games. Popular options include <a href="https://www.mapeditor.org/">Tiled</a>, <a href="https://ldtk.io/">LDtk</a>, and <a href="https://ogmo-editor-3.github.io/">Ogmo</a>. These specialized tools export map configurations in various formats such as XML (similar to what we implemented) or JSON, and often include additional features like multiple layers, object placement, and custom properties for tiles.</p>
<div class="NOTE">
<h5>Note</h5>
<p>In order to utilize Tilemaps from other tools, you will need a way to import those maps as MonoGame does not natively support them, one option is to use <a href="https://www.monogameextended.net/">MonoGame.Extended</a> which provides Tilemap importers for Tiled (and more in the future) as well as a host of other features.</p>
</div>
<p>Although these tools are more robust than our implementation, the underlying concept remains the same: a tilemap is fundamentally a grid layout where each cell references a tile ID from a tileset. The principles you have learned in this chapter form the foundation for working with any tilemap system, regardless of which tool you might use.</p>
<h2 id="conclusion">Conclusion</h2>
<p>In this chapter, you accomplished the following:</p>
<ul>
<li>Learned about tilemaps and how they are used in 2D game development.</li>
<li>Created a <code>Tileset</code> class to manage collections of tiles from a texture atlas.</li>
<li>Implemented a <code>Tilemap</code> class to render grid-based game environments.</li>
<li>Created an XML-based tilemap definition system for storing level layouts.</li>
<li>Updated our game to use tilemaps for the game environment.</li>
</ul>
<p>In the next chapter, we will start exploring audio to add sound effects when a collision occurs and background music to our game.</p>
<h2 id="test-your-knowledge">Test Your Knowledge</h2>
<ol>
<li><p>What is the main advantage of using tilemaps for game environments rather than individual sprites?</p>
<p>:::question-answer
Tilemaps offer several advantages: memory efficiency (reusing tiles instead of storing complete environments), performance optimization (batched rendering), and design flexibility (easier to create and modify levels). They allow creating large game worlds by reusing a small set of tiles in different arrangements.
:::</p>
</li>
<li><p>What is the relationship between a tileset and a tilemap?</p>
<p>:::question-answer
A tileset is a collection of individual tiles stored in a texture atlas, where each tile has a unique ID. A tilemap is a grid-based structure that references tiles from the tileset by their IDs to create a complete game environment. The tileset provides the visual elements, while the tilemap defines their arrangement.
:::</p>
</li>
<li><p>Why might you use an XML definition for a tilemap instead of hardcoding the tile layout?</p>
<p>:::question-answer
Using XML definitions for tilemaps separates level design from game code, offering several benefits: easier level editing (without changing code), support for multiple levels, ability to create external level editors, and better organization of game content. It also allows non-programmers like game designers to create and modify levels.
:::</p>
</li>
<li><p>In our implementation, how does the Tilemap's Draw method work?</p>
<p>:::question-answer
The Tilemap's Draw method iterates through each position in the grid. For each position, it:</p>
<ol>
<li>Retrieves the tile ID stored at that position.</li>
<li>Gets the corresponding texture region from the tileset.</li>
<li>Calculates the screen position based on the grid coordinates and tile size.</li>
<li>Draws the texture region at that position using the sprite batch.
:::</li>
</ol>
</li>
</ol>

</article>
                </div>

            </main>
        </div>


        <script src="https://code.jquery.com/jquery-3.6.3.min.js" integrity="sha256-pvPw+upLPUjgMXY0G+8O0xUf+/Im1MZjXxxgOcBQBXU=" crossorigin="anonymous"></script>
        <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.1/dist/umd/popper.min.js" integrity="sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN" crossorigin="anonymous"></script>
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.min.js" integrity="sha384-+sLIOodYLS7CIrQpBjl+C7nPvqq+FbNUBDunl/OZv93DB7Ln/533i8e/mZXLi/P+" crossorigin="anonymous"></script>
        <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
        <script type="text/javascript" src="../../../../../../styles/jquery.twbsPagination.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/mark.js@8.11.1/dist/jquery.mark.min.js"></script>
        <script type="text/javascript" src="../../../../../../styles/url.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/anchor-js@5.0.0/anchor.min.js"></script>
        <script type="text/javascript" src="../../../../../../styles/docfx.js"></script>
        <script type="text/javascript" src="../../../../../../styles/main.js"></script>
        <script type="text/javascript" src="../../../../../../styles/singulink.js"></script>    </body>
</html>
