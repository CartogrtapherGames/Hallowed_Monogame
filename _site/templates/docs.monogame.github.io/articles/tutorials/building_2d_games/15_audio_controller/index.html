<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>

    <head>
      <meta charset="utf-8">
      <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
      <title>Chapter 15: Audio Controller | hallowed </title>
      <meta name="viewport" content="width=device-width">
      <meta name="title" content="Chapter 15: Audio Controller | hallowed ">
      <meta name="generator" content="docfx ">
  
      <link rel="shortcut icon" href="../../../../../../favicon.ico">
      <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/night-owl.min.css">
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css" integrity="sha384-EvBWSlnoFgZlXJvpzS+MAUEjvN7+gcCwH+qh7GRFOGgZO0PuwOFro7qPOJnLfe7l" crossorigin="anonymous">
      <link rel="stylesheet" href="../../../../../../styles/config.css">
      <link rel="stylesheet" href="../../../../../../styles/singulink.css">
      <link rel="stylesheet" href="../../../../../../styles/main.css">
      <meta property="docfx:navrel" content="../../../../../../toc.html">
      <meta property="docfx:tocrel" content="../../../toc.html">
  
  <meta property="docfx:rel" content="../../../../../../">
  
    </head>
    <body>
        <!-- Header required for docfx anchor scroll to work -->
        <header id="head"></header>
        <div class="top-navbar">
            <a class="burger-icon" onclick="toggleMenu()">
                <svg name="Hamburger" style="vertical-align: middle;" width="34" height="34" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" clip-rule="evenodd" d="M20 6H4V9H20V6ZM4 10.999H20V13.999H4V10.999ZM4 15.999H20V18.999H4V15.999Z"></path></svg>
            </a>


            <a class="brand" href="../../../../../../index.html">
              <img src="../../../../../../logo.svg" alt="hallowed" class="logomark">
              <span class="brand-title">hallowed</span>
            </a>        </div>

        <div class="body-content">
            <div id="blackout" class="blackout" onclick="toggleMenu()"></div>

            <nav id="sidebar" role="navigation">
                <div class="sidebar">

                    <div>
                      <div class="mobile-hide">

                        <a class="brand" href="../../../../../../index.html">
                          <img src="../../../../../../logo.svg" alt="hallowed" class="logomark">
                          <span class="brand-title">hallowed</span>
                        </a>                      </div>

                      <div class="sidesearch">
                        <form id="search" role="search" class="search">
                            <i class="bi bi-search search-icon"></i>
                            <input type="text" id="search-query" placeholder="Search" autocomplete="off">
                        </form>
                      </div>

                      <div id="navbar">
                      </div>
                    </div>                    <div class="sidebar-item-separator"></div>

                        <div id="sidetoggle">
                          <div id="sidetoc"></div>
                        </div>
                </div>
                <div class="footer">
  
  <strong><a href='https://dotnet.github.io/docfx/'>DocFX</a> + <a href='https://www.singulink.com'>Singulink</a> = â™¥</strong>
                </div>            </nav>

            <main class="main-panel">

                <div id="search-results" style="display: none;">
                  <h1 class="search-list">Search Results for <span></span></h1>
                  <div class="sr-items">
                    <p><i class="bi bi-hourglass-split index-loading"></i></p>
                  </div>
                  <ul id="pagination" data-first=First data-prev=Previous data-next=Next data-last=Last></ul>
                </div>
 

                <div role="main" class="hide-when-search">

                        <div class="subnav navbar navbar-default">
                          <div class="container hide-when-search" id="breadcrumb">
                            <ul class="breadcrumb">
                              <li></li>
                            </ul>
                          </div>
                        </div>

                         <div class="contribution">
                               <a href="https://github.com/MonoGame/docs.monogame.github.io/blob/main/articles/tutorials/building_2d_games/15_audio_controller/index.md/#L1" class="contribution-link">Edit this page</a>
                         </div>

                    <article class="content wrap" id="_content" data-uid="">


<p>While playing sounds and music using the simplified sound API is straightforward, a game needs to handle various audio states and resource cleanup including:</p>
<ul>
<li>Track and manage sound effect instances that are created.</li>
<li>Dispose of sound effect instances when they are finished.</li>
<li>Handle volume control for songs and sound effects.</li>
<li>Manage audio states (pause/resume, mute/unmute).</li>
</ul>
<p>In this chapter you will:</p>
<ul>
<li>Learn how to create a central audio management system.</li>
<li>Implement proper resource tracking and cleanup for sound effects.</li>
<li>Build methods to control audio state (play/pause, mute/unmute).</li>
<li>Add global volume control for different audio types.</li>
<li>Integrate the audio controller with your game's core systems.</li>
<li>Implement keyboard shortcuts for audio control.</li>
</ul>
<p>By the end of this chapter, you will have an audio control system that can be easily reused in future game projects.</p>
<h2 id="the-audiocontroller-class">The AudioController Class</h2>
<p>To get started, in the <em>MonoGameLibrary</em> project:</p>
<ol>
<li><p>Create a new folder named <code>Audio</code>.</p>
</li>
<li><p>Add a new class file named <code>AudioController.cs</code> to the <code>Audio</code> folder you just created.</p>
</li>
<li><p>Add the following code as the initial structure for the class</p>
<pre><code class="lang-csharp">using System;
using System.Collections.Generic;
using Microsoft.Xna.Framework.Audio;
using Microsoft.Xna.Framework.Media;

namespace MonoGameLibrary.Audio;

public class AudioController : IDisposable
{

}
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>The <code>AudioController</code> class will implement the <code>IDisposable</code> interface, This interface is part of .NET and provides a standardized implementation for an object to release resources. Implementing <code>IDisposable</code> allows other code to properly clean up the resources held by our audio controller when it is no longer needed. For more information on <code>IDisposable</code>, you can read the <a href="https://learn.microsoft.com/en-us/dotnet/standard/garbage-collection/implementing-dispose">Implement a Dispose Method</a> article on Microsoft Learn.</p>
</div>
</li>
</ol>
<h3 id="audiocontroller-properties-and-fields">AudioController Properties and Fields</h3>
<p>The <code>AudioController</code> will need to track sound effect instances created for cleanup and track the state and volume levels of songs and sound effects when toggling between mute states.</p>
<p>Add the following fields and properties:</p>
<pre><code class="lang-csharp">    // Tracks sound effect instances created so they can be paused, unpaused, and/or disposed.
    private readonly List&lt;SoundEffectInstance&gt; _activeSoundEffectInstances;

    // Tracks the volume for song playback when muting and unmuting.
    private float _previousSongVolume;

    // Tracks the volume for sound effect playback when muting and unmuting.
    private float _previousSoundEffectVolume;
    
    /// &lt;summary&gt;
    /// Gets a value that indicates if audio is muted.
    /// &lt;/summary&gt;
    public bool IsMuted { get; private set; }

/// &lt;summary&gt;
    /// Gets or Sets the global volume of songs.
    /// &lt;/summary&gt;
    /// &lt;remarks&gt;
    /// If IsMuted is true, the getter will always return back 0.0f and the
    /// setter will ignore setting the volume.
    /// &lt;/remarks&gt;
    public float SongVolume
    {
        get
        {
            if(IsMuted)
            {
                return 0.0f;
            }

            return MediaPlayer.Volume;
        }
        set
        {
            if(IsMuted)
            {
                return;
            }

            MediaPlayer.Volume = Math.Clamp(value, 0.0f, 1.0f);
        }
    }

    /// &lt;summary&gt;
    /// Gets or Sets the global volume of sound effects.
    /// &lt;/summary&gt;
    /// &lt;remarks&gt;
    /// If IsMuted is true, the getter will always return back 0.0f and the
    /// setter will ignore setting the volume.
    /// &lt;/remarks&gt;
    public float SoundEffectVolume
    {
        get
        {
            if(IsMuted)
            {
                return 0.0f;
            }

            return SoundEffect.MasterVolume;
        }
        set
        {
            if(IsMuted)
            {
                return;
            }

            SoundEffect.MasterVolume = Math.Clamp(value, 0.0f, 1.0f);
        }
    }    

    /// &lt;summary&gt;
    /// Gets a value that indicates if this audio controller has been disposed.
    /// &lt;/summary&gt;
    public bool IsDisposed { get; private set; }
</code></pre><h3 id="audiocontroller-constructor">AudioController Constructor</h3>
<p>The constructor just initializes the collection used to track the sound effect instances.</p>
<p>Add the following constructor and finalizer:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Creates a new audio controller instance.
/// &lt;/summary&gt;
public AudioController()
{
    _activeSoundEffectInstances = new List&lt;SoundEffectInstance&gt;();
}

// Finalizer called when object is collected by the garbage collector.
~AudioController() =&gt; Dispose(false);
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>The <code>AudioController</code> class implements a <a href="https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/finalizers">finalizer</a> method <code>~AudioManager()</code>. This method is called when an instance of the class is collected by the garbage collector and is here as part of the <code>IDisposable</code> implementation.</p>
</div>
<h3 id="audiocontroller-methods">AudioController Methods</h3>
<p>The <code>AudioController</code> needs methods to:</p>
<ul>
<li>Update it to check for resources to clean up.</li>
<li>Playing sound effects and songs</li>
<li>State management (play/pause, mute/unmute)</li>
<li>Volume control</li>
<li>Implement the <code>IDisposable</code> interface.</li>
</ul>
<p>So lets add them below.</p>
<h4 id="audiocontroller-update">AudioController Update</h4>
<p>The <code>Update</code> method will check for existing sound effect instances that have expired and properly dispose of them. Add the following method:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Updates this audio controller.
/// &lt;/summary&gt;
public void Update()
{
    for (int i = _activeSoundEffectInstances.Count - 1; i &gt;= 0; i--)
    {
        SoundEffectInstance instance = _activeSoundEffectInstances[i];

        if (instance.State == SoundState.Stopped)
        {
            if (!instance.IsDisposed)
            {
                instance.Dispose();
            }
            _activeSoundEffectInstances.RemoveAt(i);
        }
    }
}
</code></pre><h4 id="audiocontroller-playback">AudioController Playback</h4>
<p>While the MonoGame simplified audio API allows sound effects to be played in a fire and forget manner, doing it this way does not work if you need to pause them because the game paused. Instead, we can add playback methods through the <code>AudioController</code> that can track the sound effect instances and pause them if needed, as well as checking the media player state before playing a song.</p>
<p>Add the following methods:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Plays the given sound effect.
/// &lt;/summary&gt;
/// &lt;param name=&quot;soundEffect&quot;&gt;The sound effect to play.&lt;/param&gt;
/// &lt;returns&gt;The sound effect instance created by this method.&lt;/returns&gt;
public SoundEffectInstance PlaySoundEffect(SoundEffect soundEffect)
{
    return PlaySoundEffect(soundEffect, 1.0f, 0.0f, 0.0f, false);
}

/// &lt;summary&gt;
/// Plays the given sound effect with the specified properties.
/// &lt;/summary&gt;
/// &lt;param name=&quot;soundEffect&quot;&gt;The sound effect to play.&lt;/param&gt;
/// &lt;param name=&quot;volume&quot;&gt;The volume, ranging from 0.0 (silence) to 1.0 (full volume).&lt;/param&gt;
/// &lt;param name=&quot;pitch&quot;&gt;The pitch adjustment, ranging from -1.0 (down an octave) to 0.0 (no change) to 1.0 (up an octave).&lt;/param&gt;
/// &lt;param name=&quot;pan&quot;&gt;The panning, ranging from -1.0 (left speaker) to 0.0 (centered), 1.0 (right speaker).&lt;/param&gt;
/// &lt;param name=&quot;isLooped&quot;&gt;Whether the the sound effect should loop after playback.&lt;/param&gt;
/// &lt;returns&gt;The sound effect instance created by playing the sound effect.&lt;/returns&gt;
/// &lt;returns&gt;The sound effect instance created by this method.&lt;/returns&gt;
public SoundEffectInstance PlaySoundEffect(SoundEffect soundEffect, float volume, float pitch, float pan, bool isLooped)
{
    // Create an instance from the sound effect given.
    SoundEffectInstance soundEffectInstance = soundEffect.CreateInstance();

    // Apply the volume, pitch, pan, and loop values specified.
    soundEffectInstance.Volume = volume;
    soundEffectInstance.Pitch = pitch;
    soundEffectInstance.Pan = pan;
    soundEffectInstance.IsLooped = isLooped;

    // Tell the instance to play
    soundEffectInstance.Play();

    // Add it to the active instances for tracking
    _activeSoundEffectInstances.Add(soundEffectInstance);

    return soundEffectInstance;
}

/// &lt;summary&gt;
/// Plays the given song.
/// &lt;/summary&gt;
/// &lt;param name=&quot;song&quot;&gt;The song to play.&lt;/param&gt;
/// &lt;param name=&quot;isRepeating&quot;&gt;Optionally specify if the song should repeat.  Default is true.&lt;/param&gt;
public void PlaySong(Song song, bool isRepeating = true)
{
    // Check if the media player is already playing, if so, stop it.
    // If we do not stop it, this could cause issues on some platforms
    if (MediaPlayer.State == MediaState.Playing)
    {
        MediaPlayer.Stop();
    }

    MediaPlayer.Play(song);
    MediaPlayer.IsRepeating = isRepeating;
}
</code></pre><h4 id="audiocontroller-state-control">AudioController State Control</h4>
<p>The <code>AudioController</code> provides methods to control the state of audio playback including pausing and resuming audio as well as muting and unmuting.</p>
<p>Add the following methods:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Pauses all audio.
/// &lt;/summary&gt;
public void PauseAudio()
{
    // Pause any active songs playing.
    MediaPlayer.Pause();

    // Pause any active sound effects.
    foreach (SoundEffectInstance soundEffectInstance in _activeSoundEffectInstances)
    {
        soundEffectInstance.Pause();
    }
}

/// &lt;summary&gt;
/// Resumes play of all previous paused audio.
/// &lt;/summary&gt;
public void ResumeAudio()
{
    // Resume paused music
    MediaPlayer.Resume();

    // Resume any active sound effects.
    foreach (SoundEffectInstance soundEffectInstance in _activeSoundEffectInstances)
    {
        soundEffectInstance.Resume();
    }
}

/// &lt;summary&gt;
/// Mutes all audio.
/// &lt;/summary&gt;
public void MuteAudio()
{
    // Store the volume so they can be restored during ResumeAudio
    _previousSongVolume = MediaPlayer.Volume;
    _previousSoundEffectVolume = SoundEffect.MasterVolume;

    // Set all volumes to 0
    MediaPlayer.Volume = 0.0f;
    SoundEffect.MasterVolume = 0.0f;

    IsMuted = true;
}

/// &lt;summary&gt;
/// Unmutes all audio to the volume level prior to muting.
/// &lt;/summary&gt;
public void UnmuteAudio()
{
    // Restore the previous volume values.
    MediaPlayer.Volume = _previousSongVolume;
    SoundEffect.MasterVolume = _previousSoundEffectVolume;

    IsMuted = false;
}

/// &lt;summary&gt;
/// Toggles the current audio mute state.
/// &lt;/summary&gt;
public void ToggleMute()
{
    if (IsMuted)
    {
        UnmuteAudio();
    }
    else
    {
        MuteAudio();
    }
}
</code></pre><h4 id="audiocontroller-idisposable-implementation">AudioController IDisposable Implementation</h4>
<p>Finally, the <code>AudioController</code> is required to implement the <code>IDisposable</code> interface, to complete this add the following methods:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Disposes of this audio controller and cleans up resources.
/// &lt;/summary&gt;
public void Dispose()
{
    Dispose(true);
    GC.SuppressFinalize(this);
}

/// &lt;summary&gt;
/// Disposes this audio controller and cleans up resources.
/// &lt;/summary&gt;
/// &lt;param name=&quot;disposing&quot;&gt;Indicates whether managed resources should be disposed.&lt;/param&gt;
protected void Dispose(bool disposing)
{
    if(IsDisposed)
    {
        return;
    }

    if (disposing)
    {
        foreach (SoundEffectInstance soundEffectInstance in _activeSoundEffectInstances)
        {
            soundEffectInstance.Dispose();
        }
        _activeSoundEffectInstances.Clear();
    }

    IsDisposed = true;
}
</code></pre>
<p>Games often use limited system resources like audio channels, when we are done with these resources we need to clean them up properly. In .NET, the standard way to handle resource cleanup is through the <code>IDisposable</code> interface.</p>
<p>Think of <code>IDisposable</code> like a cleanup checklist that runs when you are finished with something:</p>
<ol>
<li>The interface provides a <code>Dispose</code> method that contains all cleanup logic.</li>
<li>When called, <code>Dispose</code> releases any resources the class was using.</li>
<li>Even if you forget to call <code>Dispose</code>, the finalizer acts as a backup cleanup mechanism.</li>
</ol>
<p>For our <code>AudioController</code>, implementing <code>IDisposable</code> means we can ensure all sound effect instances are properly stopped and disposed when our game ends, preventing resource leaks.</p>
<div class="NOTE">
<h5>Note</h5>
<p>Fore more information on <code>IDisposable</code> and the <code>Dispose</code> method, check out the <a href="https://learn.microsoft.com/en-us/dotnet/standard/garbage-collection/implementing-dispose">Implementing a Dispose Method</a> article on Microsoft Learn.</p>
</div>
<h2 id="implementing-the-audiocontroller-class">Implementing the AudioController Class</h2>
<p>Now that we have the audio controller class complete, we can update the game to use it. We will do this in two steps:</p>
<ol>
<li>First, update the <code>Core</code> class to add the <code>AudioController</code> globally.</li>
<li>Update the <code>Game1</code> class to use the global audio controller from <code>Core</code>.</li>
</ol>
<h3 id="updating-the-core-class">Updating the Core Class</h3>
<p>The <code>Core</code> class serves as our base game class, so we will update it first to add and expose the <code>AudioController</code> globally. Open the <code>Core.cs</code> file in the <em>MonoGameLibrary</em> project and update it to the following:</p>
<pre><code class="lang-csharp">using System;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;
using MonoGameLibrary.Audio;
using MonoGameLibrary.Input;

namespace MonoGameLibrary;

public class Core : Game
{
    internal static Core s_instance;

    /// &lt;summary&gt;
    /// Gets a reference to the Core instance.
    /// &lt;/summary&gt;
    public static Core Instance =&gt; s_instance;

    /// &lt;summary&gt;
    /// Gets the graphics device manager to control the presentation of graphics.
    /// &lt;/summary&gt;
    public static GraphicsDeviceManager Graphics { get; private set; }

    /// &lt;summary&gt;
    /// Gets the graphics device used to create graphical resources and perform primitive rendering.
    /// &lt;/summary&gt;
    public static new GraphicsDevice GraphicsDevice { get; private set; }

    /// &lt;summary&gt;
    /// Gets the sprite batch used for all 2D rendering.
    /// &lt;/summary&gt;
    public static SpriteBatch SpriteBatch { get; private set; }

    /// &lt;summary&gt;
    /// Gets the content manager used to load global assets.
    /// &lt;/summary&gt;
    public static new ContentManager Content { get; private set; }

    /// &lt;summary&gt;
    /// Gets a reference to to the input management system.
    /// &lt;/summary&gt;
    public static InputManager Input { get; private set; }

    /// &lt;summary&gt;
    /// Gets or Sets a value that indicates if the game should exit when the esc key on the keyboard is pressed.
    /// &lt;/summary&gt;
    public static bool ExitOnEscape { get; set; }

    /// &lt;summary&gt;
    /// Gets a reference to the audio control system.
    /// &lt;/summary&gt;
    public static AudioController Audio { get; private set; }

    /// &lt;summary&gt;
    /// Creates a new Core instance.
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;title&quot;&gt;The title to display in the title bar of the game window.&lt;/param&gt;
    /// &lt;param name=&quot;width&quot;&gt;The initial width, in pixels, of the game window.&lt;/param&gt;
    /// &lt;param name=&quot;height&quot;&gt;The initial height, in pixels, of the game window.&lt;/param&gt;
    /// &lt;param name=&quot;fullScreen&quot;&gt;Indicates if the game should start in fullscreen mode.&lt;/param&gt;
    public Core(string title, int width, int height, bool fullScreen)
    {
        // Ensure that multiple cores are not created.
        if (s_instance != null)
        {
            throw new InvalidOperationException($&quot;Only a single Core instance can be created&quot;);
        }

        // Store reference to engine for global member access.
        s_instance = this;

        // Create a new graphics device manager.
        Graphics = new GraphicsDeviceManager(this);

        // Set the graphics defaults.
        Graphics.PreferredBackBufferWidth = width;
        Graphics.PreferredBackBufferHeight = height;
        Graphics.IsFullScreen = fullScreen;

        // Apply the graphic presentation changes.
        Graphics.ApplyChanges();

        // Set the window title.
        Window.Title = title;

        // Set the core's content manager to a reference of the base Game's
        // content manager.
        Content = base.Content;

        // Set the root directory for content.
        Content.RootDirectory = &quot;Content&quot;;

        // Mouse is visible by default.
        IsMouseVisible = true;

        // Exit on escape is true by default
        ExitOnEscape = true;        
    }

    protected override void Initialize()
    {
        base.Initialize();

        // Set the core's graphics device to a reference of the base Game's
        // graphics device.
        GraphicsDevice = base.GraphicsDevice;

        // Create the sprite batch instance.
        SpriteBatch = new SpriteBatch(GraphicsDevice);

        // Create a new input manager.
        Input = new InputManager();

        // Create a new audio controller.
        Audio = new AudioController();
    }

    protected override void UnloadContent()
    {
        // Dispose of the audio controller.
        Audio.Dispose();

        base.UnloadContent();
    }

    protected override void Update(GameTime gameTime)
    {
        // Update the input manager.
        Input.Update(gameTime);

        // Update the audio controller.
        Audio.Update();

        if (ExitOnEscape &amp;&amp; Input.Keyboard.IsKeyDown(Keys.Escape))
        {
            Exit();
        }

        base.Update(gameTime);
    }
}
</code></pre>
<p>The key changes made here are:</p>
<ol>
<li>Added the <code>using MonoGameLibrary.Audio;</code> directive to access the <code>AudioController</code> class.</li>
<li>Added a static <code>Audio</code> property to provide global access to the audio controller.</li>
<li>Created the new audio controller instance in the <code>Initialize</code> method.</li>
<li>Added an override for the <code>UnloadContent</code> method where we dispose of the audio controller.</li>
<li>The audio controller is updated in the <code>Update</code> method.</li>
</ol>
<h3 id="updating-the-game1-class">Updating the Game1 Class</h3>
<p>Next, update the <code>Game1</code> class to use the audio controller for audio playback. Open <code>Game1.cs</code> and make the following updates:</p>
<pre><code class="lang-csharp">using System;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Audio;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;
using Microsoft.Xna.Framework.Media;
using MonoGameLibrary;
using MonoGameLibrary.Graphics;
using MonoGameLibrary.Input;

namespace DungeonSlime;

public class Game1 : Core
{
    // Defines the slime animated sprite.
    private AnimatedSprite _slime;

    // Defines the bat animated sprite.
    private AnimatedSprite _bat;

    // Tracks the position of the slime.
    private Vector2 _slimePosition;

    // Speed multiplier when moving.
    private const float MOVEMENT_SPEED = 5.0f;

    // Tracks the position of the bat.
    private Vector2 _batPosition;

    // Tracks the velocity of the bat.
    private Vector2 _batVelocity;

    // Defines the tilemap to draw.
    private Tilemap _tilemap;

    // Defines the bounds of the room that the slime and bat are contained within.
    private Rectangle _roomBounds;

    // The sound effect to play when the bat bounces off the edge of the screen.
    private SoundEffect _bounceSoundEffect;

    // The sound effect to play when the slime eats a bat.
    private SoundEffect _collectSoundEffect;

    // The background theme song
    private Song _themeSong;

    public Game1() : base(&quot;Dungeon Slime&quot;, 1280, 720, false)
    {

    }

    protected override void Initialize()
    {
        base.Initialize();

        Rectangle screenBounds = GraphicsDevice.PresentationParameters.Bounds;

        _roomBounds = new Rectangle(
            (int)_tilemap.TileWidth,
            (int)_tilemap.TileHeight,
            screenBounds.Width - (int)_tilemap.TileWidth * 2,
            screenBounds.Height - (int)_tilemap.TileHeight * 2
        );

        // Initial slime position will be the center tile of the tile map.
        int centerRow = _tilemap.Rows / 2;
        int centerColumn = _tilemap.Columns / 2;
        _slimePosition = new Vector2(centerColumn * _tilemap.TileWidth, centerRow * _tilemap.TileHeight);

        // Initial bat position will the in the top left corner of the room.
        _batPosition = new Vector2(_roomBounds.Left, _roomBounds.Top);

        // Assign the initial random velocity to the bat.
        AssignRandomBatVelocity();

        // Start playing the background music.
        Audio.PlaySong(_themeSong);
    }

    protected override void LoadContent()
    {
        // Create the texture atlas from the XML configuration file.
        TextureAtlas atlas = TextureAtlas.FromFile(Content, &quot;images/atlas-definition.xml&quot;);

        // Create the slime animated sprite from the atlas.
        _slime = atlas.CreateAnimatedSprite(&quot;slime-animation&quot;);
        _slime.Scale = new Vector2(4.0f, 4.0f);

        // Create the bat animated sprite from the atlas.
        _bat = atlas.CreateAnimatedSprite(&quot;bat-animation&quot;);
        _bat.Scale = new Vector2(4.0f, 4.0f);

        // Create the tilemap from the XML configuration file.
        _tilemap = Tilemap.FromFile(Content, &quot;images/tilemap-definition.xml&quot;);
        _tilemap.Scale = new Vector2(4.0f, 4.0f);

        // Load the bounce sound effect.
        _bounceSoundEffect = Content.Load&lt;SoundEffect&gt;(&quot;audio/bounce&quot;);

        // Load the collect sound effect.
        _collectSoundEffect = Content.Load&lt;SoundEffect&gt;(&quot;audio/collect&quot;);

        // Load the background theme music.
        _themeSong = Content.Load&lt;Song&gt;(&quot;audio/theme&quot;);
    }

    protected override void Update(GameTime gameTime)
    {
        // Update the slime animated sprite.
        _slime.Update(gameTime);

        // Update the bat animated sprite.
        _bat.Update(gameTime);

        // Check for keyboard input and handle it.
        CheckKeyboardInput();

        // Check for gamepad input and handle it.
        CheckGamePadInput();

        // Creating a bounding circle for the slime.
        Circle slimeBounds = new Circle(
            (int)(_slimePosition.X + (_slime.Width * 0.5f)),
            (int)(_slimePosition.Y + (_slime.Height * 0.5f)),
            (int)(_slime.Width * 0.5f)
        );

        // Use distance based checks to determine if the slime is within the
        // bounds of the game screen, and if it is outside that screen edge,
        // move it back inside.
        if (slimeBounds.Left &lt; _roomBounds.Left)
        {
            _slimePosition.X = _roomBounds.Left;
        }
        else if (slimeBounds.Right &gt; _roomBounds.Right)
        {
            _slimePosition.X = _roomBounds.Right - _slime.Width;
        }

        if (slimeBounds.Top &lt; _roomBounds.Top)
        {
            _slimePosition.Y = _roomBounds.Top;
        }
        else if (slimeBounds.Bottom &gt; _roomBounds.Bottom)
        {
            _slimePosition.Y = _roomBounds.Bottom - _slime.Height;
        }

        // Calculate the new position of the bat based on the velocity.
        Vector2 newBatPosition = _batPosition + _batVelocity;

        // Create a bounding circle for the bat.
        Circle batBounds = new Circle(
            (int)(newBatPosition.X + (_bat.Width * 0.5f)),
            (int)(newBatPosition.Y + (_bat.Height * 0.5f)),
            (int)(_bat.Width * 0.5f)
        );

        Vector2 normal = Vector2.Zero;

        // Use distance based checks to determine if the bat is within the
        // bounds of the game screen, and if it is outside that screen edge,
        // reflect it about the screen edge normal
        if (batBounds.Left &lt; _roomBounds.Left)
        {
            normal.X = Vector2.UnitX.X;
            newBatPosition.X = _roomBounds.Left;
        }
        else if (batBounds.Right &gt; _roomBounds.Right)
        {
            normal.X = -Vector2.UnitX.X;
            newBatPosition.X = _roomBounds.Right - _bat.Width;
        }

        if (batBounds.Top &lt; _roomBounds.Top)
        {
            normal.Y = Vector2.UnitY.Y;
            newBatPosition.Y = _roomBounds.Top;
        }
        else if (batBounds.Bottom &gt; _roomBounds.Bottom)
        {
            normal.Y = -Vector2.UnitY.Y;
            newBatPosition.Y = _roomBounds.Bottom - _bat.Height;
        }

        // If the normal is anything but Vector2.Zero, this means the bat had
        // moved outside the screen edge so we should reflect it about the
        // normal.
        if (normal != Vector2.Zero)
        {
            normal.Normalize();
            _batVelocity = Vector2.Reflect(_batVelocity, normal);

            // Play the bounce sound effect.
            Audio.PlaySoundEffect(_bounceSoundEffect);
        }

        _batPosition = newBatPosition;

        if (slimeBounds.Intersects(batBounds))
        {
            // Choose a random row and column based on the total number of each
            int column = Random.Shared.Next(1, _tilemap.Columns - 1);
            int row = Random.Shared.Next(1, _tilemap.Rows - 1);

            // Change the bat position by setting the x and y values equal to
            // the column and row multiplied by the width and height.
            _batPosition = new Vector2(column * _bat.Width, row * _bat.Height);

            // Assign a new random velocity to the bat.
            AssignRandomBatVelocity();

            // Play the collect sound effect.
            Audio.PlaySoundEffect(_collectSoundEffect);
        }

        base.Update(gameTime);
    }

    private void AssignRandomBatVelocity()
    {
        // Generate a random angle.
        float angle = (float)(Random.Shared.NextDouble() * Math.PI * 2);

        // Convert angle to a direction vector.
        float x = (float)Math.Cos(angle);
        float y = (float)Math.Sin(angle);
        Vector2 direction = new Vector2(x, y);

        // Multiply the direction vector by the movement speed.
        _batVelocity = direction * MOVEMENT_SPEED;
    }

    private void CheckKeyboardInput()
    {
        // If the space key is held down, the movement speed increases by 1.5
        float speed = MOVEMENT_SPEED;
        if (Input.Keyboard.IsKeyDown(Keys.Space))
        {
            speed *= 1.5f;
        }

        // If the W or Up keys are down, move the slime up on the screen.
        if (Input.Keyboard.IsKeyDown(Keys.W) || Input.Keyboard.IsKeyDown(Keys.Up))
        {
            _slimePosition.Y -= speed;
        }

        // if the S or Down keys are down, move the slime down on the screen.
        if (Input.Keyboard.IsKeyDown(Keys.S) || Input.Keyboard.IsKeyDown(Keys.Down))
        {
            _slimePosition.Y += speed;
        }

        // If the A or Left keys are down, move the slime left on the screen.
        if (Input.Keyboard.IsKeyDown(Keys.A) || Input.Keyboard.IsKeyDown(Keys.Left))
        {
            _slimePosition.X -= speed;
        }

        // If the D or Right keys are down, move the slime right on the screen.
        if (Input.Keyboard.IsKeyDown(Keys.D) || Input.Keyboard.IsKeyDown(Keys.Right))
        {
            _slimePosition.X += speed;
        }

        // If the M key is pressed, toggle mute state for audio.
        if (Input.Keyboard.WasKeyJustPressed(Keys.M))
        {
            Audio.ToggleMute();
        }

        // If the + button is pressed, increase the volume.
        if (Input.Keyboard.WasKeyJustPressed(Keys.OemPlus))
        {
            Audio.SongVolume += 0.1f;
            Audio.SoundEffectVolume += 0.1f;
        }

        // If the - button was pressed, decrease the volume.
        if (Input.Keyboard.WasKeyJustPressed(Keys.OemMinus))
        {
            Audio.SongVolume -= 0.1f;
            Audio.SoundEffectVolume -= 0.1f;
        }
    }

    private void CheckGamePadInput()
    {
        GamePadInfo gamePadOne = Input.GamePads[(int)PlayerIndex.One];

        // If the A button is held down, the movement speed increases by 1.5
        // and the gamepad vibrates as feedback to the player.
        float speed = MOVEMENT_SPEED;
        if (gamePadOne.IsButtonDown(Buttons.A))
        {
            speed *= 1.5f;
            GamePad.SetVibration(PlayerIndex.One, 1.0f, 1.0f);
        }
        else
        {
            GamePad.SetVibration(PlayerIndex.One, 0.0f, 0.0f);
        }

        // Check thumbstick first since it has priority over which gamepad input
        // is movement.  It has priority since the thumbstick values provide a
        // more granular analog value that can be used for movement.
        if (gamePadOne.LeftThumbStick != Vector2.Zero)
        {
            _slimePosition.X += gamePadOne.LeftThumbStick.X * speed;
            _slimePosition.Y -= gamePadOne.LeftThumbStick.Y * speed;
        }
        else
        {
            // If DPadUp is down, move the slime up on the screen.
            if (gamePadOne.IsButtonDown(Buttons.DPadUp))
            {
                _slimePosition.Y -= speed;
            }

            // If DPadDown is down, move the slime down on the screen.
            if (gamePadOne.IsButtonDown(Buttons.DPadDown))
            {
                _slimePosition.Y += speed;
            }

            // If DPapLeft is down, move the slime left on the screen.
            if (gamePadOne.IsButtonDown(Buttons.DPadLeft))
            {
                _slimePosition.X -= speed;
            }

            // If DPadRight is down, move the slime right on the screen.
            if (gamePadOne.IsButtonDown(Buttons.DPadRight))
            {
                _slimePosition.X += speed;
            }
        }
    }

    protected override void Draw(GameTime gameTime)
    {
        // Clear the back buffer.
        GraphicsDevice.Clear(Color.CornflowerBlue);

        // Begin the sprite batch to prepare for rendering.
        SpriteBatch.Begin(samplerState: SamplerState.PointClamp);

        // Draw the tilemap
        _tilemap.Draw(SpriteBatch);

        // Draw the slime sprite.
        _slime.Draw(SpriteBatch, _slimePosition);

        // Draw the bat sprite.
        _bat.Draw(SpriteBatch, _batPosition);

        // Always end the sprite batch when finished.
        SpriteBatch.End();

        base.Draw(gameTime);
    }
}
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>Note there were a lot of replacements in the <code>LoadContent</code> method, switching from loading and initializing the background Song and replacing it with a call to the new <code>AudioController</code> to do all the work managing the Song reference. Much cleaner.</p>
</div>
<p>The key changes made here are:</p>
<ol>
<li>The <code>_themeSong</code> field is added to store a reference to the background song to play.</li>
<li>In <a href="xref:Microsoft.Xna.Framework.Game.LoadContent"><strong>LoadContent</strong></a>, the background theme song is loaded using the content manager.</li>
<li>In <a href="xref:Microsoft.Xna.Framework.Game.Initialize"><strong>Initialize</strong></a>, the audio manager is used to play the background theme song.</li>
<li>In <a href="xref:Microsoft.Xna.Framework.Game.Update(Microsoft.Xna.Framework.GameTime)"><strong>Update</strong></a> the audio manager is used to play the bounce and collect sound effects.</li>
<li>In <code>CheckKeyboardInput</code> the following checks were added
<ol>
<li>If the M key on the keyboard is pressed, it will toggle mute for all audio.</li>
<li>If the + key is pressed, the song and sound effect volumes are increased by <code>0.1f</code>.</li>
<li>If the - key is pressed, the song and sound effect volumes are decreased by <code>0.1f</code>.</li>
</ol>
</li>
</ol>
<p>Running the game now will produce the same result as the previous chapter, only now the lifetime of sound effects and the state management of audio is done through the new audio controller. You can also mute and unumte the audio with the M key and increase and decrease the volume using the + and - keys.</p>
<table>
<thead>
<tr>
<th style="text-align: center;"><video width="500" height="281" controls=""><source type="video/webm" src="./videos/gameplay.webm"></video></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Figure 15-1: Gameplay with audio.</strong></td>
</tr>
</tbody>
</table>
<div class="NOTE">
<h5>Note</h5>
<p>You may note that while we added keybindings to change the audio settings, we did not add any bindings for the GamePad. This is simply because this is not normally how you would adjust these values on a console, on consoles you would have a settings/options screen to update them.</p>
<p>Later in <a href="../20_implementing_ui_with_gum/index.html">Chapter 20: Implementing UI with GUM</a> we will add an Options screen to adjust all the audio values for the game.</p>
</div>
<h2 id="conclusion">Conclusion</h2>
<p>In this chapter, you accomplished the following:</p>
<ul>
<li>Created a reusable <code>AudioController</code> class to centralize audio management.</li>
<li>Learned about proper resource management for audio using the <code>IDisposable</code> pattern.</li>
<li>Implemented tracking and cleanup of sound effect instances.</li>
<li>Added global volume control for both sound effects and music.</li>
<li>Created methods to toggle audio states (play/pause, mute/unmute).</li>
<li>Updated the <code>Core</code> class to provide global access to the audio controller.</li>
<li>Added keyboard controls to adjust volume and toggle mute state.</li>
</ul>
<p>The <code>AudioController</code> class you created is a significant improvement over directly using MonoGame's audio APIs. It handles common audio management tasks that would otherwise need to be implemented repeatedly in different parts of your game. By centralizing these functions, you make your code more maintainable and provide a consistent audio experience across your game.</p>
<p>In the next chapter, we will start exploring fonts and adding text to the game.</p>

</article>
                </div>

            </main>
        </div>


        <script src="https://code.jquery.com/jquery-3.6.3.min.js" integrity="sha256-pvPw+upLPUjgMXY0G+8O0xUf+/Im1MZjXxxgOcBQBXU=" crossorigin="anonymous"></script>
        <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.1/dist/umd/popper.min.js" integrity="sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN" crossorigin="anonymous"></script>
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.min.js" integrity="sha384-+sLIOodYLS7CIrQpBjl+C7nPvqq+FbNUBDunl/OZv93DB7Ln/533i8e/mZXLi/P+" crossorigin="anonymous"></script>
        <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
        <script type="text/javascript" src="../../../../../../styles/jquery.twbsPagination.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/mark.js@8.11.1/dist/jquery.mark.min.js"></script>
        <script type="text/javascript" src="../../../../../../styles/url.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/anchor-js@5.0.0/anchor.min.js"></script>
        <script type="text/javascript" src="../../../../../../styles/docfx.js"></script>
        <script type="text/javascript" src="../../../../../../styles/main.js"></script>
        <script type="text/javascript" src="../../../../../../styles/singulink.js"></script>    </body>
</html>
