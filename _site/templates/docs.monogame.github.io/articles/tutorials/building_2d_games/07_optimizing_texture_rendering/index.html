<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>

    <head>
      <meta charset="utf-8">
      <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
      <title>Chapter 07: Optimizing Texture Rendering | hallowed </title>
      <meta name="viewport" content="width=device-width">
      <meta name="title" content="Chapter 07: Optimizing Texture Rendering | hallowed ">
      <meta name="generator" content="docfx ">
  
      <link rel="shortcut icon" href="../../../../../../favicon.ico">
      <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/night-owl.min.css">
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css" integrity="sha384-EvBWSlnoFgZlXJvpzS+MAUEjvN7+gcCwH+qh7GRFOGgZO0PuwOFro7qPOJnLfe7l" crossorigin="anonymous">
      <link rel="stylesheet" href="../../../../../../styles/config.css">
      <link rel="stylesheet" href="../../../../../../styles/singulink.css">
      <link rel="stylesheet" href="../../../../../../styles/main.css">
      <meta property="docfx:navrel" content="../../../../../../toc.html">
      <meta property="docfx:tocrel" content="../../../toc.html">
  
  <meta property="docfx:rel" content="../../../../../../">
  
    </head>
    <body>
        <!-- Header required for docfx anchor scroll to work -->
        <header id="head"></header>
        <div class="top-navbar">
            <a class="burger-icon" onclick="toggleMenu()">
                <svg name="Hamburger" style="vertical-align: middle;" width="34" height="34" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" clip-rule="evenodd" d="M20 6H4V9H20V6ZM4 10.999H20V13.999H4V10.999ZM4 15.999H20V18.999H4V15.999Z"></path></svg>
            </a>


            <a class="brand" href="../../../../../../index.html">
              <img src="../../../../../../logo.svg" alt="hallowed" class="logomark">
              <span class="brand-title">hallowed</span>
            </a>        </div>

        <div class="body-content">
            <div id="blackout" class="blackout" onclick="toggleMenu()"></div>

            <nav id="sidebar" role="navigation">
                <div class="sidebar">

                    <div>
                      <div class="mobile-hide">

                        <a class="brand" href="../../../../../../index.html">
                          <img src="../../../../../../logo.svg" alt="hallowed" class="logomark">
                          <span class="brand-title">hallowed</span>
                        </a>                      </div>

                      <div class="sidesearch">
                        <form id="search" role="search" class="search">
                            <i class="bi bi-search search-icon"></i>
                            <input type="text" id="search-query" placeholder="Search" autocomplete="off">
                        </form>
                      </div>

                      <div id="navbar">
                      </div>
                    </div>                    <div class="sidebar-item-separator"></div>

                        <div id="sidetoggle">
                          <div id="sidetoc"></div>
                        </div>
                </div>
                <div class="footer">
  
  <strong><a href='https://dotnet.github.io/docfx/'>DocFX</a> + <a href='https://www.singulink.com'>Singulink</a> = â™¥</strong>
                </div>            </nav>

            <main class="main-panel">

                <div id="search-results" style="display: none;">
                  <h1 class="search-list">Search Results for <span></span></h1>
                  <div class="sr-items">
                    <p><i class="bi bi-hourglass-split index-loading"></i></p>
                  </div>
                  <ul id="pagination" data-first=First data-prev=Previous data-next=Next data-last=Last></ul>
                </div>
 

                <div role="main" class="hide-when-search">

                        <div class="subnav navbar navbar-default">
                          <div class="container hide-when-search" id="breadcrumb">
                            <ul class="breadcrumb">
                              <li></li>
                            </ul>
                          </div>
                        </div>

                         <div class="contribution">
                               <a href="https://github.com/MonoGame/docs.monogame.github.io/blob/main/articles/tutorials/building_2d_games/07_optimizing_texture_rendering/index.md/#L1" class="contribution-link">Edit this page</a>
                         </div>

                    <article class="content wrap" id="_content" data-uid="">


<p>In <a href="../06_working_with_textures/index.html">Chapter 06</a>, you learned how to load and render textures using <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteBatch"><strong>SpriteBatch</strong></a>. While rendering individual textures works well for simple games, it can lead to performance issues as your game grows more complex. In this chapter, we will explore how to optimize texture rendering by reducing texture swaps and creating reusable components for better organization.</p>
<p>In this chapter, you will:</p>
<ul>
<li>Learn about texture swapping and its impact on performance.</li>
<li>Explore texture atlases as a solution for optimizing texture rendering.</li>
<li>Create reusable classes to optimize and simplify texture management and rendering.</li>
</ul>
<p>By the end of this chapter, you will understand how to organize your game's textures for optimal performance and have a flexible texture atlas management system for your future game projects.</p>
<h2 id="texture-swapping">Texture Swapping</h2>
<p>Every time the <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteBatch.Draw(Microsoft.Xna.Framework.Graphics.Texture2D,Microsoft.Xna.Framework.Vector2,System.Nullable%7BMicrosoft.Xna.Framework.Rectangle%7D,Microsoft.Xna.Framework.Color,System.Single,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Graphics.SpriteEffects,System.Single)"><strong>SpriteBatch.Draw</strong></a> method is executed with a different <em>texture</em> parameter than the previous <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteBatch.Draw(Microsoft.Xna.Framework.Graphics.Texture2D,Microsoft.Xna.Framework.Vector2,System.Nullable%7BMicrosoft.Xna.Framework.Rectangle%7D,Microsoft.Xna.Framework.Color,System.Single,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Graphics.SpriteEffects,System.Single)"><strong>SpriteBatch.Draw</strong></a> method call, a <em>texture swap</em> occurs, unbinding the current texture on the GPU and binding the new texture.</p>
<div class="NOTE">
<h5>Note</h5>
<p>A texture swap occurs when the GPU needs to switch between different textures during rendering. While each individual swap may seem trivial, the cumulative effect in a complex game can significantly impact performance.</p>
</div>
<p>For example, here are the simplified draw calls for an example Pong game:</p>
<pre><code class="lang-csharp">// Using the paddle texture to render the left player paddle.
// The paddle texture is bound to the GPU.
_spriteBatch.Draw(paddleTexture, leftPaddlePosition, Color.White);

// Using the ball texture to render the ball
// A texture swap occurs, unbinding the paddle texture to bind the ball texture.
_spriteBatch.Draw(ballTexture, ballPosition, Color.White);

// Reusing the paddle texture to draw the right player paddle.
// A texture swap occurs again, unbinding the ball texture to bind the paddle texture.
_spriteBatch.Draw(paddleTexture, rightPaddlePosition, Color.White);
</code></pre>
<p>In the above example:</p>
<ol>
<li>The paddle texture is bound to the GPU so the left player paddle can be drawn.</li>
<li>The paddle texture is unbound from the GPU and the ball texture is bound so that the ball can be drawn (Texture Swap #1).</li>
<li>The ball texture is unbound from the GPU and the paddle texture is bound again so the right player paddle can be drawn (Texture Swap #2).</li>
</ol>
<p>These texture swaps, while negligible in this example, can become a performance issue in a full game where you might be drawing hundreds or thousands of sprites per frame.</p>
<h3 id="attempting-to-optimize-draw-order">Attempting to Optimize Draw Order</h3>
<p>One approach to get around this could be to optimize the order of the draw calls to minimize texture swaps.  For example, if we reorder the draw calls from the previous example so that both paddles are drawn first and then the ball, the number of texture swaps is reduced from two to one:</p>
<pre><code class="lang-csharp">// Render the left and right paddles first.
// This reduces the number of texture swaps needed from two to one.
_spriteBatch.Draw(paddleTexture, _leftPaddlePosition, Color.White);
_spriteBatch.Draw(paddleTexture, _rightPaddlePosition, Color.White);
_spriteBatch.Draw(ballTexture, _ballPosition, Color.White);
</code></pre>
<p>However this is not a scalable solution. In a real game with dozens of different textures and complex draw orders for layered sprites, UI elements, particles, etc., managing draw order by texture becomes impractical and will conflict with desired visual layering.</p>
<h2 id="what-is-a-texture-atlas">What is a Texture Atlas</h2>
<p>A texture atlas (also known as a sprite sheet) is a large image file that contains multiple smaller images packed together. Instead of loading separate textures for each sprite, you load the single texture file with all the images combined like a scrapbook where all your photos are arranged on the same page.</p>
<div class="NOTE">
<h5>Note</h5>
<p>Using a texture atlas not only eliminates texture swaps but also reduces memory usage and simplifies asset management since you are loading and tracking a single texture instead of many individual ones.</p>
</div>
<p>In the Pong example, imagine taking the paddle and ball image and combining them into a single image file like in <em>Figure 7-1</em> below:</p>
<table>
<thead>
<tr>
<th style="text-align: center;"><img src="./images/pong-atlas.png" alt="Figure 7-1: Pong Texture Atlas Example"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Figure 7-1: Pong Texture Atlas Example</strong></td>
</tr>
</tbody>
</table>
<p>Now when we draw these images, we would be using the same texture and just specify the source rectangles for the paddle or ball when needed, completely eliminating texture swaps.</p>
<pre><code class="lang-csharp">private Texture2D _textureAtlas;
private Rectangle _paddleSourceRect;
private Rectangle _ballSourceRect;

protected override void LoadContent()
{
    _textureAtlas = Content.Load&lt;Texture2D&gt;(&quot;pong-atlas&quot;);
    _paddleSourceRect = new Rectangle(0, 0, 32, 32);
    _ballSourceRect = new Rectangle(32, 0, 32, 32);
}

protected override void Draw(GameTime gameTime)
{
    GraphicsDevice.Clear(Color.CornflowerBlue);

    _spriteBatch.Begin();
    
    // All draw calls use the same texture, so there is no texture swapping!
    _spriteBatch.Draw(_textureAtlas, _leftPaddlePosition, _paddleSourceRect, Color.White);
    _spriteBatch.Draw(_textureAtlas, _rightPaddlePosition, _paddleSourceRect, Color.White);
    _spriteBatch.Draw(_textureAtlas, _ballPosition, _ballSourceRect, Color.White);
    
    _spriteBatch.End();
}
</code></pre>
<p>While using the single texture with source rectangles solves the potential performance issues, managing multiple source rectangles in variables can become complex as your game grows.  In the Pong example above, we are already tracking the source rectangles for both the paddle and ball sprites. Imagine scaling this up to a game with dozens of different images, each potentially needing their own position, rotation, scale, and other rendering properties.</p>
<p>To better organize this complexity, we can apply object-oriented design principles to create classes that encapsulates the information needed.</p>
<h2 id="the-textureregion-class">The TextureRegion Class</h2>
<p>In <a href="../06_working_with_textures/index.html#source-rectangle">Chapter 06</a>, we learned about using the <code>sourceRectangle</code> parameter to reuse the same texture when rendering sprites but specifying different regions within the texture to render.  For our next step, we will build on this and create a class called <code>TextureRegion</code>.</p>
<p>We are going to add this class to the class library we created in <a href="../04_creating_a_class_library/index.html">Chapter 04</a>.  Perform the following:</p>
<ol>
<li>Add new folder in the <em>MonoGameLibrary</em> project named <code>Graphics</code></li>
<li>Create a new file named <code>TextureRegion.cs</code> inside the <em>Graphics</em> folder you just created.</li>
<li>Add the following code for the foundation of the <code>TextureRegion</code> class to the file:</li>
</ol>
<pre><code class="lang-csharp">using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;

namespace MonoGameLibrary.Graphics;

/// &lt;summary&gt;
/// Represents a rectangular region within a texture.
/// &lt;/summary&gt;
public class TextureRegion 
{

}
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>The <code>TextureRegion.cs</code> class file is placed in the <em>MonoGame/Graphics</em> folder and the class uses the <code>MonoGameLibrary.Graphics</code> <a href="https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/types/namespaces#namespaces-overview">namespace</a> to keep graphics-related classes organized together.  As we add more functionality to the library, we will continue to use directories and namespaces to maintain a clean structure.</p>
</div>
<p>We will add several components to this class in sequence. Each section below should be added to the <code>TextureRegion</code> class in the order presented between the brackets <code>{ }</code> of the class definition. As we go through each part, the class will gradually take shape to handle all the texture handling behavior we need.</p>
<h3 id="textureregion-members">TextureRegion Members</h3>
<p>The <code>TextureRegion</code> class will utilize four properties to define and manage a region within a texture.  Add the following properties:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Gets or Sets the source texture this texture region is part of.
/// &lt;/summary&gt;
public Texture2D Texture { get; set; }

/// &lt;summary&gt;
/// Gets or Sets the source rectangle boundary of this texture region within the source texture.
/// &lt;/summary&gt;
public Rectangle SourceRectangle { get; set; }

/// &lt;summary&gt;
/// Gets the width, in pixels, of this texture region.
/// &lt;/summary&gt;
public int Width =&gt; SourceRectangle.Width;

/// &lt;summary&gt;
/// Gets the height, in pixels, of this texture region.
/// &lt;/summary&gt;
public int Height =&gt; SourceRectangle.Height;
</code></pre>
<p>The <code>Texture</code> and <code>SourceRectangle</code> properties work together to define where the region is located: <code>Texture</code> specifies which texture contains the region, while <code>SourceRectangle</code> defines its exact location and size within that texture. The <code>Width</code> and <code>Height</code> properties provide convenient access to the region's dimensions without having to access the SourceRectangle property directly.</p>
<h3 id="textureregion-constructor">TextureRegion Constructor</h3>
<p>The <code>TextureRegion</code> class provides two ways to create a new texture region.</p>
<p>Add the following constructors:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Creates a new texture region.
/// &lt;/summary&gt;
public TextureRegion() { }

/// &lt;summary&gt;
/// Creates a new texture region using the specified source texture.
/// &lt;/summary&gt;
/// &lt;param name=&quot;texture&quot;&gt;The texture to use as the source texture for this texture region.&lt;/param&gt;
/// &lt;param name=&quot;x&quot;&gt;The x-coordinate position of the upper-left corner of this texture region relative to the upper-left corner of the source texture.&lt;/param&gt;
/// &lt;param name=&quot;y&quot;&gt;The y-coordinate position of the upper-left corner of this texture region relative to the upper-left corner of the source texture.&lt;/param&gt;
/// &lt;param name=&quot;width&quot;&gt;The width, in pixels, of this texture region.&lt;/param&gt;
/// &lt;param name=&quot;height&quot;&gt;The height, in pixels, of this texture region.&lt;/param&gt;
public TextureRegion(Texture2D texture, int x, int y, int width, int height)
{
    Texture = texture;
    SourceRectangle = new Rectangle(x, y, width, height);
}
</code></pre>
<ul>
<li>The default constructor creates an empty texture region that can be configured later.</li>
<li>The parameterized constructor allows you to define the region's source texture and boundary in a single step.</li>
</ul>
<p>The second constructor provides a convenient way to create texture regions when you know the exact location and dimensions within the source texture upfront.</p>
<h3 id="textureregion-methods">TextureRegion Methods</h3>
<p>Finally, the <code>TextureRegion</code> class will provide three overloaded Draw methods to render the texture region. Add the following methods:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Submit this texture region for drawing in the current batch.
/// &lt;/summary&gt;
/// &lt;param name=&quot;spriteBatch&quot;&gt;The spritebatch instance used for batching draw calls.&lt;/param&gt;
/// &lt;param name=&quot;position&quot;&gt;The xy-coordinate location to draw this texture region on the screen.&lt;/param&gt;
/// &lt;param name=&quot;color&quot;&gt;The color mask to apply when drawing this texture region on screen.&lt;/param&gt;
public void Draw(SpriteBatch spriteBatch, Vector2 position, Color color)
{
    Draw(spriteBatch, position, color, 0.0f, Vector2.Zero, Vector2.One, SpriteEffects.None, 0.0f);
}

/// &lt;summary&gt;
/// Submit this texture region for drawing in the current batch.
/// &lt;/summary&gt;
/// &lt;param name=&quot;spriteBatch&quot;&gt;The spritebatch instance used for batching draw calls.&lt;/param&gt;
/// &lt;param name=&quot;position&quot;&gt;The xy-coordinate location to draw this texture region on the screen.&lt;/param&gt;
/// &lt;param name=&quot;color&quot;&gt;The color mask to apply when drawing this texture region on screen.&lt;/param&gt;
/// &lt;param name=&quot;rotation&quot;&gt;The amount of rotation, in radians, to apply when drawing this texture region on screen.&lt;/param&gt;
/// &lt;param name=&quot;origin&quot;&gt;The center of rotation, scaling, and position when drawing this texture region on screen.&lt;/param&gt;
/// &lt;param name=&quot;scale&quot;&gt;The scale factor to apply when drawing this texture region on screen.&lt;/param&gt;
/// &lt;param name=&quot;effects&quot;&gt;Specifies if this texture region should be flipped horizontally, vertically, or both when drawing on screen.&lt;/param&gt;
/// &lt;param name=&quot;layerDepth&quot;&gt;The depth of the layer to use when drawing this texture region on screen.&lt;/param&gt;
public void Draw(SpriteBatch spriteBatch, Vector2 position, Color color, float rotation, Vector2 origin, float scale, SpriteEffects effects, float layerDepth)
{
    Draw(
        spriteBatch,
        position,
        color,
        rotation,
        origin,
        new Vector2(scale, scale),
        effects,
        layerDepth
    );
}

/// &lt;summary&gt;
/// Submit this texture region for drawing in the current batch.
/// &lt;/summary&gt;
/// &lt;param name=&quot;spriteBatch&quot;&gt;The spritebatch instance used for batching draw calls.&lt;/param&gt;
/// &lt;param name=&quot;position&quot;&gt;The xy-coordinate location to draw this texture region on the screen.&lt;/param&gt;
/// &lt;param name=&quot;color&quot;&gt;The color mask to apply when drawing this texture region on screen.&lt;/param&gt;
/// &lt;param name=&quot;rotation&quot;&gt;The amount of rotation, in radians, to apply when drawing this texture region on screen.&lt;/param&gt;
/// &lt;param name=&quot;origin&quot;&gt;The center of rotation, scaling, and position when drawing this texture region on screen.&lt;/param&gt;
/// &lt;param name=&quot;scale&quot;&gt;The amount of scaling to apply to the x- and y-axes when drawing this texture region on screen.&lt;/param&gt;
/// &lt;param name=&quot;effects&quot;&gt;Specifies if this texture region should be flipped horizontally, vertically, or both when drawing on screen.&lt;/param&gt;
/// &lt;param name=&quot;layerDepth&quot;&gt;The depth of the layer to use when drawing this texture region on screen.&lt;/param&gt;
public void Draw(SpriteBatch spriteBatch, Vector2 position, Color color, float rotation, Vector2 origin, Vector2 scale, SpriteEffects effects, float layerDepth)
{
    spriteBatch.Draw(
        Texture,
        position,
        SourceRectangle,
        color,
        rotation,
        origin,
        scale,
        effects,
        layerDepth
    );
}
</code></pre>
<p>These methods provide flexible options for rendering the texture region, similar to what the <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteBatch.Draw(Microsoft.Xna.Framework.Graphics.Texture2D,Microsoft.Xna.Framework.Vector2,System.Nullable%7BMicrosoft.Xna.Framework.Rectangle%7D,Microsoft.Xna.Framework.Color,System.Single,Microsoft.Xna.Framework.Vector2,System.Single,Microsoft.Xna.Framework.Graphics.SpriteEffects,System.Single)"><strong>SpriteBatch.Draw</strong></a> method does:</p>
<ul>
<li>The simplest overload requires only position and color.</li>
<li>A second overload exposes all rendering parameters while allowing for a single float value to be applied to both axes for scaling.</li>
<li>The third overload is the most flexible, offering all rendering parameters and independent x- and y-axis scaling.</li>
</ul>
<p>Only the last <code>Draw</code> method actually uses the <code>Texture</code> specified in the class, as the other two methods both depend on this final implementation, simplifying the code needed to actually do the drawing.</p>
<h2 id="the-textureatlas-class">The TextureAtlas Class</h2>
<p>In the <a href="#what-is-a-texture-atlas">What is a Texture Atlas</a> section above, a texture atlas was described as a scrap book that holds all of the individual sprites for the game.  These individual sprites can now be represented by the <code>TextureRegion</code> class we just created.  Now, we will create the <code>TextureAtlas</code> class to represent the collection of the regions that make up all of our sprites.</p>
<p>Just like the <code>TextureRegion</code> class, we are going to add this to the class library.  In the <em>Graphics</em> folder within the <em>MonoGameLibrary</em> project, add a new file named <code>TextureAtlas.cs</code>, then add the following code for the foundation of the <code>TextureAtlas</code> class:</p>
<pre><code class="lang-csharp">using System.Collections.Generic;
using System.IO;
using System.Xml;
using System.Xml.Linq;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;

namespace MonoGameLibrary.Graphics;

public class TextureAtlas 
{

}
</code></pre>
<p>As before, each section below adds more functionality to this class, one after the other within the <code>TextureAtlas</code> class.</p>
<h3 id="textureatlas-members">TextureAtlas Members</h3>
<p>The <code>TextureAtlas</code> class needs two key members to manage texture regions. Add the following:</p>
<pre><code class="lang-csharp">private Dictionary&lt;string, TextureRegion&gt; _regions;

/// &lt;summary&gt;
/// Gets or Sets the source texture represented by this texture atlas.
/// &lt;/summary&gt;
public Texture2D Texture { get; set; }
</code></pre>
<p>The private <code>_regions</code> dictionary stores named texture regions, allowing us to retrieve specific regions by name, while the <code>Texture</code> property holds the source texture that contains all the regions. Together, these members enable the atlas to manage multiple texture regions from a single source texture.</p>
<h3 id="textureatlas-constructors">TextureAtlas Constructors</h3>
<p>The <code>TextureAtlas</code> class provides two ways to create a new atlas.</p>
<p>Add the following constructors:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Creates a new texture atlas.
/// &lt;/summary&gt;
public TextureAtlas()
{
    _regions = new Dictionary&lt;string, TextureRegion&gt;();
}

/// &lt;summary&gt;
/// Creates a new texture atlas instance using the given texture.
/// &lt;/summary&gt;
/// &lt;param name=&quot;texture&quot;&gt;The source texture represented by the texture atlas.&lt;/param&gt;
public TextureAtlas(Texture2D texture)
{
    Texture = texture;
    _regions = new Dictionary&lt;string, TextureRegion&gt;();
}
</code></pre>
<ul>
<li>The default constructor creates an empty atlas that can be configured later.</li>
<li>The parameterized constructor allows you to specify the source texture immediately.</li>
</ul>
<p>Both constructors initialize the <code>_regions</code> dictionary so that it is ready to be used either way.</p>
<h3 id="textureatlas-methods">TextureAtlas Methods</h3>
<p>Finally, The <code>TextureAtlas</code> class will provide methods for managing texture regions and creating atlases from configuration files. Add the following methods:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Creates a new region and adds it to this texture atlas.
/// &lt;/summary&gt;
/// &lt;param name=&quot;name&quot;&gt;The name to give the texture region.&lt;/param&gt;
/// &lt;param name=&quot;x&quot;&gt;The top-left x-coordinate position of the region boundary relative to the top-left corner of the source texture boundary.&lt;/param&gt;
/// &lt;param name=&quot;y&quot;&gt;The top-left y-coordinate position of the region boundary relative to the top-left corner of the source texture boundary.&lt;/param&gt;
/// &lt;param name=&quot;width&quot;&gt;The width, in pixels, of the region.&lt;/param&gt;
/// &lt;param name=&quot;height&quot;&gt;The height, in pixels, of the region.&lt;/param&gt;
public void AddRegion(string name, int x, int y, int width, int height)
{
    TextureRegion region = new TextureRegion(Texture, x, y, width, height);
    _regions.Add(name, region);
}

/// &lt;summary&gt;
/// Gets the region from this texture atlas with the specified name.
/// &lt;/summary&gt;
/// &lt;param name=&quot;name&quot;&gt;The name of the region to retrieve.&lt;/param&gt;
/// &lt;returns&gt;The TextureRegion with the specified name.&lt;/returns&gt;
public TextureRegion GetRegion(string name)
{
    return _regions[name];
}

/// &lt;summary&gt;
/// Removes the region from this texture atlas with the specified name.
/// &lt;/summary&gt;
/// &lt;param name=&quot;name&quot;&gt;The name of the region to remove.&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
public bool RemoveRegion(string name)
{
    return _regions.Remove(name);
}

/// &lt;summary&gt;
/// Removes all regions from this texture atlas.
/// &lt;/summary&gt;
public void Clear()
{
    _regions.Clear();
}

/// &lt;summary&gt;
/// Creates a new texture atlas based on a texture atlas xml configuration file.
/// &lt;/summary&gt;
/// &lt;param name=&quot;content&quot;&gt;The content manager used to load the texture for the atlas.&lt;/param&gt;
/// &lt;param name=&quot;fileName&quot;&gt;The path to the xml file, relative to the content root directory.&lt;/param&gt;
/// &lt;returns&gt;The texture atlas created by this method.&lt;/returns&gt;
public static TextureAtlas FromFile(ContentManager content, string fileName)
{
    TextureAtlas atlas = new TextureAtlas();

    string filePath = Path.Combine(content.RootDirectory, fileName);

    using (Stream stream = TitleContainer.OpenStream(filePath))
    {
        using (XmlReader reader = XmlReader.Create(stream))
        {
            XDocument doc = XDocument.Load(reader);
            XElement root = doc.Root;

            // The &lt;Texture&gt; element contains the content path for the Texture2D to load.
            // So we will retrieve that value then use the content manager to load the texture.
            string texturePath = root.Element(&quot;Texture&quot;).Value;
            atlas.Texture = content.Load&lt;Texture2D&gt;(texturePath);

            // The &lt;Regions&gt; element contains individual &lt;Region&gt; elements, each one describing
            // a different texture region within the atlas.  
            //
            // Example:
            // &lt;Regions&gt;
            //      &lt;Region name=&quot;spriteOne&quot; x=&quot;0&quot; y=&quot;0&quot; width=&quot;32&quot; height=&quot;32&quot; /&gt;
            //      &lt;Region name=&quot;spriteTwo&quot; x=&quot;32&quot; y=&quot;0&quot; width=&quot;32&quot; height=&quot;32&quot; /&gt;
            // &lt;/Regions&gt;
            //
            // So we retrieve all of the &lt;Region&gt; elements then loop through each one
            // and generate a new TextureRegion instance from it and add it to this atlas.
            var regions = root.Element(&quot;Regions&quot;)?.Elements(&quot;Region&quot;);

            if (regions != null)
            {
                foreach (var region in regions)
                {
                    string name = region.Attribute(&quot;name&quot;)?.Value;
                    int x = int.Parse(region.Attribute(&quot;x&quot;)?.Value ?? &quot;0&quot;);
                    int y = int.Parse(region.Attribute(&quot;y&quot;)?.Value ?? &quot;0&quot;);
                    int width = int.Parse(region.Attribute(&quot;width&quot;)?.Value ?? &quot;0&quot;);
                    int height = int.Parse(region.Attribute(&quot;height&quot;)?.Value ?? &quot;0&quot;);

                    if (!string.IsNullOrEmpty(name))
                    {
                        atlas.AddRegion(name, x, y, width, height);
                    }
                }
            }

            return atlas;
        }
    }
}
</code></pre>
<p>These methods serve different purposes in managing the texture atlas:</p>
<ol>
<li>Region Management
<ul>
<li><code>AddRegion</code>: Creates a new <code>TextureRegion</code> at the specified location in the atlas.</li>
<li><code>GetRegion</code>: Retrieves a previously added region by its name.</li>
<li><code>RemoveRegion</code>: Removes a specific region by its name.</li>
<li><code>Clear</code>: Removes all regions from the atlas.</li>
</ul>
</li>
<li>Atlas Creation
<ul>
<li><code>FromFile</code>: creates a new <code>TextureAtlas</code> from an XML configuration file. This method will load the source texture then create and add the regions based on the XML configuration.  We will look more into using the XML configuration in a moment.</li>
</ul>
</li>
</ol>
<h2 id="using-the-textureatlas-class">Using the TextureAtlas Class</h2>
<p>Now we can put our new <code>TextureAtlas</code> class to use by exploring two approaches; creating an atlas manually and using XML configuration.  So far, we have been practicing using textures with the MonoGame logo. Now we will use a new texture atlas that contains various sprites we will need for our game.</p>
<p>Download the texture atlas by right-clicking the following image and saving it as atlas.png:</p>
<table>
<thead>
<tr>
<th style="text-align: center;"><img src="./images/atlas.png" alt="Figure 7-2: The texture atlas for our game"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Figure 7-2: The texture atlas for our game</strong></td>
</tr>
</tbody>
</table>
<div class="TIP">
<h5>Tip</h5>
<p>You may notice that our texture atlas image has some empty areas, which seems like a waste.  Its dimensions are 256x256 pixels when it could have just been 240x160 pixels.</p>
<p><strong>This is intentional.</strong></p>
<p>Game graphics often use texture dimensions that are powers of 2 (128, 256, 512, 1024, etc.) for technical reasons. While modern graphics hardware can handle any texture size, power-of-2 dimensions provide better memory efficiency and more precise rendering. When pixel coordinates are converted to texture coordinates during rendering, powers of 2 can be represented more precisely in floating-point calculations, helping prevent visual artifacts like texture seams.</p>
<p>This is not critical for simple 2D games, but adopting this practice early will serve you well as your games become more complex.</p>
</div>
<p>Add this texture atlas to your content project using the MGCB Editor:</p>
<ol>
<li>Open the <em>Content.mgcb</em> file in the MGCB Editor</li>
<li>In the editor, right-click the <em>images</em> folder and choose <em>Add &gt; Existing item...</em>.</li>
<li>Navigate to and choose the <em>atlas.png</em> file you downloaded to add it.</li>
<li>Save the changes and close the MGCB Editor.</li>
</ol>
<div class="TIP">
<h5>Tip</h5>
<p>If you need a refresher on adding content using the MGCB Editor, you can revisit the <a href="../05_content_pipeline/index.html">Chapter 05: The Content Pipeline</a>.</p>
</div>
<p>First, we will explore creating the texture atlas and defining the texture regions directly in code.  Replace the contents of <code>Game1.cs</code> with the following:</p>
<pre><code class="lang-csharp" highlight-lines="5,11-15,31-47,65-75">using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;
using MonoGameLibrary;
using MonoGameLibrary.Graphics;

namespace DungeonSlime;

public class Game1 : Core
{
    // texture region that defines the slime sprite in the atlas.
    private TextureRegion _slime;

    // texture region that defines the bat sprite in the atlas.
    private TextureRegion _bat;

    public Game1() : base(&quot;Dungeon Slime&quot;, 1280, 720, false)
    {

    }

    protected override void Initialize()
    {
        // TODO: Add your initialization logic here

        base.Initialize();
    }

    protected override void LoadContent()
    {
        // Load the atlas texture using the content manager
        Texture2D atlasTexture = Content.Load&lt;Texture2D&gt;(&quot;images/atlas&quot;);

        //  Create a TextureAtlas instance from the atlas
        TextureAtlas atlas = new TextureAtlas(atlasTexture);

        // add the slime region to the atlas.
        atlas.AddRegion(&quot;slime&quot;, 0, 0, 20, 20);

        // add the bat region to the atlas.
        atlas.AddRegion(&quot;bat&quot;, 20, 0, 20, 20);

        // retrieve the slime region from the atlas.
        _slime = atlas.GetRegion(&quot;slime&quot;);

        // retrieve the bat region from the atlas.
        _bat = atlas.GetRegion(&quot;bat&quot;);
    }

    protected override void Update(GameTime gameTime)
    {
        if (GamePad.GetState(PlayerIndex.One).Buttons.Back == ButtonState.Pressed || Keyboard.GetState().IsKeyDown(Keys.Escape))
            Exit();

        // TODO: Add your update logic here

        base.Update(gameTime);
    }

    protected override void Draw(GameTime gameTime)
    {
        // Clear the back buffer.
        GraphicsDevice.Clear(Color.CornflowerBlue);

        // Begin the sprite batch to prepare for rendering.
        SpriteBatch.Begin(samplerState: SamplerState.PointClamp);

        // Draw the slime texture region at a scale of 4.0
        _slime.Draw(SpriteBatch, Vector2.Zero, Color.White, 0.0f, Vector2.One, 4.0f, SpriteEffects.None, 0.0f);

        // Draw the bat texture region 10px to the right of the slime at a scale of 4.0
        _bat.Draw(SpriteBatch, new Vector2(_slime.Width * 4.0f + 10, 0), Color.White, 0.0f, Vector2.One, 4.0f, SpriteEffects.None, 1.0f);

        // Always end the sprite batch when finished.
        SpriteBatch.End();

        base.Draw(gameTime);
    }
}
</code></pre>
<p>The key changes in this implementation are:</p>
<ol>
<li>The <code>_logo</code> field was removed.</li>
<li>Added  <code>TextureRegion</code> members for the slime and bat sprites.</li>
<li>In <a href="xref:Microsoft.Xna.Framework.Game.LoadContent"><strong>LoadContent</strong></a>:
<ul>
<li>Removed loading the logo texture.</li>
<li>Created a <code>TextureAtlas</code> with the atlas texture.</li>
<li>Added regions for both the slime and the bat.</li>
<li>Retrieved the regions using their names.</li>
</ul>
</li>
<li>Updated <a href="xref:Microsoft.Xna.Framework.Game.Draw(Microsoft.Xna.Framework.GameTime)"><strong>Draw</strong></a> to:
<ul>
<li>Draw the slime at a scale factor of 4.</li>
<li>Draw the bat 10 pixels to the right of the slime based on the slime's <code>Width</code> property, at a scale of 4.</li>
</ul>
</li>
</ol>
<p>Running the game now shows both sprites in the upper-left corner:</p>
<table>
<thead>
<tr>
<th style="text-align: center;"><img src="./images/slime-and-bat-rendered.png" alt="Figure 7-3: The slime and bat texture regions being rendered in the upper-left corner of the game window"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Figure 7-3: The slime and bat texture regions being rendered in the upper-left corner of the game window</strong></td>
</tr>
</tbody>
</table>
<p>While manual creation works for a few sprites, managing many regions becomes cumbersome. Now we will explore the <code>TextureAtlas.FromFile</code> method to load our atlas configuration from XML instead. Perform the following:</p>
<ol>
<li><p>Open the <em>Content.mgcb</em> file in the MGCB Editor</p>
</li>
<li><p>Create a new file named <code>atlas-definition</code> in the <em>Content/images</em> folder using &quot;Add -&gt; New Item -&gt; XML Content&quot;.</p>
</li>
<li><p>In the properties panel at the bottom for the <code>atlas-definition.xml</code> file, change the <em><code>Build Action</code></em> property from <code>Build</code> to <em><code>Copy</code></em>.</p>
</li>
<li><p>Save the changes and close the MGCB Editor</p>
</li>
<li><p>Open the new <code>atlas-definition.xml</code> file in your code editor (The MGCB editor cannot edit files, only manage the what content it builds)</p>
</li>
<li><p>Replace the contents of the XML file with the following:</p>
<pre><code class="lang-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;TextureAtlas&gt;
    &lt;Texture&gt;images/atlas&lt;/Texture&gt;
    &lt;Regions&gt;
        &lt;Region name=&quot;slime&quot; x=&quot;0&quot; y=&quot;0&quot; width=&quot;20&quot; height=&quot;20&quot; /&gt;
        &lt;Region name=&quot;bat&quot; x=&quot;20&quot; y=&quot;0&quot; width=&quot;20&quot; height=&quot;20&quot; /&gt;
    &lt;/Regions&gt;
&lt;/TextureAtlas&gt;
</code></pre>
<table>
<thead>
<tr>
<th style="text-align: center;"><img src="./images/mgcb-editor-copy.png" alt="Figure 7-4: The atlas-definition.xml file added to the content project with the Build Action property set to Copy"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Figure 7-4: The atlas-definition.xml file added to the content project with the Build Action property set to Copy</strong></td>
</tr>
</tbody>
</table>
<div class="TIP">
<h5>Tip</h5>
<p>Using the content pipeline to copy files ensures they are placed in the correct location alongside other game content. While there are other methods (like editing the .csproj), this approach keeps asset management centralized</p>
</div>
</li>
<li><p>Update the contents of <code>Game1.cs</code> with the following code:</p>
<pre><code class="lang-csharp" highlight-lines="31-32">using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;
using MonoGameLibrary;
using MonoGameLibrary.Graphics;

namespace DungeonSlime;

public class Game1 : Core
{
    // texture region that defines the slime sprite in the atlas.
    private TextureRegion _slime;

    // texture region that defines the bat sprite in the atlas.
    private TextureRegion _bat;

    public Game1() : base(&quot;Dungeon Slime&quot;, 1280, 720, false)
    {

    }

    protected override void Initialize()
    {
        // TODO: Add your initialization logic here

        base.Initialize();
    }

    protected override void LoadContent()
    {
        // Create the texture atlas from the XML configuration file
        TextureAtlas atlas = TextureAtlas.FromFile(Content, &quot;images/atlas-definition.xml&quot;);

        // retrieve the slime region from the atlas.
        _slime = atlas.GetRegion(&quot;slime&quot;);

        // retrieve the bat region from the atlas.
        _bat = atlas.GetRegion(&quot;bat&quot;);
    }

    protected override void Update(GameTime gameTime)
    {
        if (GamePad.GetState(PlayerIndex.One).Buttons.Back == ButtonState.Pressed || Keyboard.GetState().IsKeyDown(Keys.Escape))
            Exit();

        // TODO: Add your update logic here

        base.Update(gameTime);
    }

    protected override void Draw(GameTime gameTime)
    {
        // Clear the back buffer.
        GraphicsDevice.Clear(Color.CornflowerBlue);

        // Begin the sprite batch to prepare for rendering.
        SpriteBatch.Begin(samplerState: SamplerState.PointClamp);

        // Draw the slime texture region at a scale of 4.0
        _slime.Draw(SpriteBatch, Vector2.Zero, Color.White, 0.0f, Vector2.One, 4.0f, SpriteEffects.None, 0.0f);

        // Draw the bat texture region 10px to the right of the slime at a scale of 4.0
        _bat.Draw(SpriteBatch, new Vector2(_slime.Width * 4.0f + 10, 0), Color.White, 0.0f, Vector2.One, 4.0f, SpriteEffects.None, 1.0f);

        // Always end the sprite batch when finished.
        SpriteBatch.End();

        base.Draw(gameTime);
    }
}
</code></pre></li>
</ol>
<p>The key improvements here is in <a href="xref:Microsoft.Xna.Framework.Game.LoadContent"><strong>LoadContent</strong></a>, where we now:</p>
<ul>
<li>Create an atlas from the XML configuration file.</li>
<li>Let the <code>TextureAtlas.FromFile</code> method handle texture loading and region creation.</li>
<li>Removed the manual creation of regions in code.</li>
</ul>
<p>This configuration based approached is advantageous because we can now add new and modify existing regions within the atlas without having to change code and/or recompile.  This also keeps the sprite definitions separate from the game logic.</p>
<p>Running the game now will show the same results as <em>Figure 7-4</em> above, with the slime and bat texture regions rendered in the upper-left corner of the game window.</p>
<h2 id="conclusion">Conclusion</h2>
<p>In this chapter, you accomplished the following:</p>
<ul>
<li>Learned about texture swapping and its impact on performance</li>
<li>Explored texture atlases as a solution for optimizing texture rendering</li>
<li>Learned what a class library is and the benefits of using one.</li>
<li>Created reusable <code>TextureRegion</code> and <code>TextureAtlas</code> classes to optimize and simplify texture management.</li>
<li>Learned how to include assets in the content pipeline that should only be copied and not processed.</li>
</ul>
<p>In the next chapter, we will build on the concepts of the <code>TextureAtlas</code> and explore creating the <code>Sprite</code> and <code>AnimatedSprite</code> classes to further simplify managing and rendering sprites.</p>
<h2 id="test-your-knowledge">Test Your Knowledge</h2>
<ol>
<li><p>What is a texture swap and why can it impact performance?</p>
<p>:::question-answer
A texture swap occurs when the GPU needs to unbind one texture and bind another between draw calls. While individual swaps may seem trivial, they can significantly impact performance in games with many sprites as each swap is an expensive GPU operation.
:::</p>
</li>
<li><p>Name a benefit of using a texture atlas.</p>
<p>:::question-answer
Any of the following are benefits of using a texture atlas:</p>
<ul>
<li>Eliminates texture swaps by using a single texture</li>
<li>Reduces memory usage</li>
<li>Simplifies asset management</li>
<li>Improves rendering performance</li>
</ul>
<p>:::</p>
</li>
</ol>

</article>
                </div>

            </main>
        </div>


        <script src="https://code.jquery.com/jquery-3.6.3.min.js" integrity="sha256-pvPw+upLPUjgMXY0G+8O0xUf+/Im1MZjXxxgOcBQBXU=" crossorigin="anonymous"></script>
        <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.1/dist/umd/popper.min.js" integrity="sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN" crossorigin="anonymous"></script>
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.min.js" integrity="sha384-+sLIOodYLS7CIrQpBjl+C7nPvqq+FbNUBDunl/OZv93DB7Ln/533i8e/mZXLi/P+" crossorigin="anonymous"></script>
        <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
        <script type="text/javascript" src="../../../../../../styles/jquery.twbsPagination.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/mark.js@8.11.1/dist/jquery.mark.min.js"></script>
        <script type="text/javascript" src="../../../../../../styles/url.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/anchor-js@5.0.0/anchor.min.js"></script>
        <script type="text/javascript" src="../../../../../../styles/docfx.js"></script>
        <script type="text/javascript" src="../../../../../../styles/main.js"></script>
        <script type="text/javascript" src="../../../../../../styles/singulink.js"></script>    </body>
</html>
