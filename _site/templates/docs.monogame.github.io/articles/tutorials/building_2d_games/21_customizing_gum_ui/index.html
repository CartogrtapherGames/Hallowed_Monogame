<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>

    <head>
      <meta charset="utf-8">
      <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
      <title>Chapter 21: Customizing Gum UI | hallowed </title>
      <meta name="viewport" content="width=device-width">
      <meta name="title" content="Chapter 21: Customizing Gum UI | hallowed ">
      <meta name="generator" content="docfx ">
  
      <link rel="shortcut icon" href="../../../../../../favicon.ico">
      <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/night-owl.min.css">
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css" integrity="sha384-EvBWSlnoFgZlXJvpzS+MAUEjvN7+gcCwH+qh7GRFOGgZO0PuwOFro7qPOJnLfe7l" crossorigin="anonymous">
      <link rel="stylesheet" href="../../../../../../styles/config.css">
      <link rel="stylesheet" href="../../../../../../styles/singulink.css">
      <link rel="stylesheet" href="../../../../../../styles/main.css">
      <meta property="docfx:navrel" content="../../../../../../toc.html">
      <meta property="docfx:tocrel" content="../../../toc.html">
  
  <meta property="docfx:rel" content="../../../../../../">
  
    </head>
    <body>
        <!-- Header required for docfx anchor scroll to work -->
        <header id="head"></header>
        <div class="top-navbar">
            <a class="burger-icon" onclick="toggleMenu()">
                <svg name="Hamburger" style="vertical-align: middle;" width="34" height="34" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" clip-rule="evenodd" d="M20 6H4V9H20V6ZM4 10.999H20V13.999H4V10.999ZM4 15.999H20V18.999H4V15.999Z"></path></svg>
            </a>


            <a class="brand" href="../../../../../../index.html">
              <img src="../../../../../../logo.svg" alt="hallowed" class="logomark">
              <span class="brand-title">hallowed</span>
            </a>        </div>

        <div class="body-content">
            <div id="blackout" class="blackout" onclick="toggleMenu()"></div>

            <nav id="sidebar" role="navigation">
                <div class="sidebar">

                    <div>
                      <div class="mobile-hide">

                        <a class="brand" href="../../../../../../index.html">
                          <img src="../../../../../../logo.svg" alt="hallowed" class="logomark">
                          <span class="brand-title">hallowed</span>
                        </a>                      </div>

                      <div class="sidesearch">
                        <form id="search" role="search" class="search">
                            <i class="bi bi-search search-icon"></i>
                            <input type="text" id="search-query" placeholder="Search" autocomplete="off">
                        </form>
                      </div>

                      <div id="navbar">
                      </div>
                    </div>                    <div class="sidebar-item-separator"></div>

                        <div id="sidetoggle">
                          <div id="sidetoc"></div>
                        </div>
                </div>
                <div class="footer">
  
  <strong><a href='https://dotnet.github.io/docfx/'>DocFX</a> + <a href='https://www.singulink.com'>Singulink</a> = â™¥</strong>
                </div>            </nav>

            <main class="main-panel">

                <div id="search-results" style="display: none;">
                  <h1 class="search-list">Search Results for <span></span></h1>
                  <div class="sr-items">
                    <p><i class="bi bi-hourglass-split index-loading"></i></p>
                  </div>
                  <ul id="pagination" data-first=First data-prev=Previous data-next=Next data-last=Last></ul>
                </div>
 

                <div role="main" class="hide-when-search">

                        <div class="subnav navbar navbar-default">
                          <div class="container hide-when-search" id="breadcrumb">
                            <ul class="breadcrumb">
                              <li></li>
                            </ul>
                          </div>
                        </div>

                         <div class="contribution">
                               <a href="https://github.com/MonoGame/docs.monogame.github.io/blob/main/articles/tutorials/building_2d_games/21_customizing_gum_ui/index.md/#L1" class="contribution-link">Edit this page</a>
                         </div>

                    <article class="content wrap" id="_content" data-uid="">


<p>In the <a href="../20_implementing_ui_with_gum/index.html">previous chapter</a>, we implemented a functional UI system for our game using the Gum framework. While the UI is now fully operational, it uses Gum's default styling.  This default styling is good for quickly iterating when building the UI, but it does not match the game's visuals.  A well designed UI should not only be functional but also complement the game's overall visual style to create a cohesive experience.</p>
<p>In this chapter you will:</p>
<ul>
<li>Learn about Gum's visual customization system and component hierarchy.</li>
<li>Understand how animation chains and visual states work in Gum.</li>
<li>Create custom styled button and slider components.</li>
<li>Update the game's texture atlas to include UI graphics.</li>
<li>Implement responsive visual feedback for player interactions.</li>
<li>Apply your custom components to the game's UI screens.</li>
</ul>
<h2 id="understanding-gums-customization-system">Understanding Gum's Customization System</h2>
<p>Gum provides a powerful customization system that separates a UI element's functionality from its appearance.  This allows you to maintain the built-in behavior of standard controls while completely changing their visual representation.</p>
<h3 id="container-hierarchy">Container Hierarchy</h3>
<p>Every customized UI component in Gum starts with a top-level container that holds all other visual elements. This container is typically of type <code>ContainerRuntime</code>, which is similar to the <code>Panel</code> type we used earlier, but specifically designed for building custom visuals.</p>
<p>The container hierarchy follows a parent-child relationship:</p>
<ul>
<li>The top-level container manages the overall size and positioning of the component.</li>
<li>Visual elements like backgrounds, text, and icons are added as children.</li>
<li>Child elements can be positioned relative to their parent container.</li>
<li>Child elements can also be nested within other children, creating deeper hierarchies.</li>
</ul>
<p>This hierarchical structure allows you to build complex UI components from simpler parts, with each part playing a specific role in the overall design.</p>
<h3 id="size-relationships-with-width-and-widthunits">Size Relationships with Width and WidthUnits</h3>
<p>One powerful feature of Gum is how it handles size relationships between parent and child elements. By using different <code>WidthUnits</code> values, you can create dependencies that flow in different directions:</p>
<ul>
<li><strong>RelativeToChildren</strong>: A parent container can size itself based on its children.</li>
<li><strong>PercentageOfParent</strong>: A child element can size itself as a percentage of its parent.</li>
<li><strong>Absolute</strong>: An element can have a fixed pixel size.</li>
<li><strong>RelativeToParent</strong>: An element can size itself relative to a specific container.</li>
</ul>
<p>For example:</p>
<ul>
<li>A button might use a text element with <code>WidthUnits</code> set to <code>RelativeToChildren</code>, which means the text will be exactly the size needed to display its content.</li>
<li>The button's container might use <code>RelativeToChildren</code> with some additional padding, allowing the button to automatically resize based on its text content.</li>
</ul>
<p>Although we have not explicitly assigned WidthUnits and HeightUnits in our code, we have indirectly set these values by calling the Visual's <code>Dock</code> method. Specifically, by passing <code>Dock.Fill</code> as the parameter, <code>WidthUnits</code> and <code>HeightUnits</code> are both set to <code>RelativeToParent</code>.</p>
<div class="NOTE">
<h5>Note</h5>
<p>These size relationships can create circular dependencies when a child depends on its parent and the parent depends on the child. In such cases, Gum resolves the conflict by making the child depend on the parent, and the parent ignores that particular child when calculating its size.</p>
</div>
<h3 id="visual-elements">Visual Elements</h3>
<p>Gum provides several visual element types that we can use to build our custom components:</p>
<ul>
<li><strong>ContainerRuntime</strong>: An invisible container for organizing other elements.</li>
<li><strong>NineSliceRuntime</strong>: A special graphic that can stretch while preserving its corners and edges.</li>
<li><strong>TextRuntime</strong>: An element for displaying text with custom fonts.</li>
<li><strong>ColoredRectangleRuntime</strong>: A simple colored rectangle for backgrounds or fills.</li>
</ul>
<p>The <code>NineSliceRuntime</code> is particularly useful for UI elements that need to resize dynamically. It divides a graphic into nine sections (four corners, four edges, and a center), allowing the element to stretch without distorting its borders.</p>
<div class="NOTE">
<h5>Note</h5>
<p>A MonoGame and Gum community member Kaltinril also has a video series discussing Gum.  With permission, the following video segment is included to demonstrate the advantages of using a <em>Nineslice</em> when creating UI elements.</p>
<div class="embeddedvideo">
<iframe width="560" height="315" src="https://www.youtube.com/embed/pI8yxdaGSVU?si=1wKj6EPkryepxVmg&amp;start=1114&amp;end=1209" title="Nineslice Overview" frameborder="0" allowfullscreen></iframe>
</div>
</div>
<h4 id="animation-chains">Animation Chains</h4>
<p>An <code>AnimationChain</code> is a sequence of animation frames that play in order, typically looping after the last frame. Each frame in the chain defines:</p>
<ul>
<li>Which part of a texture to display (using texture coordinates).</li>
<li>How long to display that frame (using a frame length value).</li>
<li>Which texture to use for the frame.</li>
</ul>
<p>Texture coordinates in Gum use normalized values (0.0 to 1.0) rather than pixel coordinates, where:</p>
<ul>
<li>0.0 represents the left or top edge of the texture.</li>
<li>1.0 represents the right or bottom edge of the texture.</li>
</ul>
<p>To convert from pixel coordinates to normalized values, you divide the pixel position by the texture's width or height.</p>
<h4 id="visual-states">Visual States</h4>
<p>Rather than directly modifying properties when UI elements change state (like when a button is focused), Gum uses a state-based system. Each control type has a specific category name that identifies its collection of states:</p>
<ul>
<li>Buttons use <code>Button.ButtonCategoryName</code>.</li>
<li>Sliders use <code>Slider.SliderCategoryName</code>.</li>
<li>Other control types have their own category names.</li>
</ul>
<p>Within each category, you define named states that correspond to the control's possible conditions:</p>
<ul>
<li>&quot;Enabled&quot; (the normal, unfocused state).</li>
<li>&quot;Focused&quot; (when the control has focus).</li>
<li>&quot;Highlighted&quot; (when the mouse hovers over the control).</li>
<li>&quot;Disabled&quot; (when the control cannot be interacted with).</li>
</ul>
<p>Each state contains an <code>Apply</code> action that defines what visual changes occur when that state becomes active. For example, when a button becomes focused, its state might change the background color or switch to an animated version.</p>
<h3 id="input-and-focus-handling">Input and Focus Handling</h3>
<p>Custom UI components can enhance their interactivity by handling specific input events:</p>
<ul>
<li>The <code>KeyDown</code> event can be used to add custom keyboard navigation.</li>
<li>The <code>RollOn</code> event can detect when the mouse moves over the component.</li>
<li>The <code>Click</code> event can respond to mouse clicks or gamepad button presses.</li>
</ul>
<p>Gum distinguishes between highlighting (visual response to mouse hover) and focus (ability to receive keyboard/gamepad input). For a seamless experience across input devices, a common pattern is to automatically focus elements when the mouse hovers over them, ensuring that visual highlighting and input focus remain synchronized.</p>
<p>Now that we understand the key concepts behind Gum's customization system, we can apply them to create custom UI components for our game.</p>
<h2 id="updating-the-game-resources">Updating the Game Resources</h2>
<p>Before we create our custom components, we need to update the game's resources to include UI graphics and fonts.</p>
<h3 id="update-the-texture-atlas">Update the Texture Atlas</h3>
<p>First need to update the <em>atlas.png</em> texture atlas file for the game. This new version of the texture atlas includes:</p>
<ul>
<li>The characters for the font, generated using Bitmap Font Generator (BMFont)</li>
<li>The sprites for the UI components we will create</li>
</ul>
<p>Download the new texture atlas below by right-clicking the following image and saving it as <em>atlas.png</em> in the <em>Content/images</em> folder of the game project, overwriting the existing one.</p>
<table>
<thead>
<tr>
<th style="text-align: center;"><img src="./images/atlas.png" alt="Figure 21-1: The texture atlas for the game updated to include the UI sprites"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Figure 21-1: The texture atlas for the game updated to include the UI sprites</strong></td>
</tr>
</tbody>
</table>
<p>The slime and bat sprites are no longer in the same position, and we have some new regions to define for our UI sprites. This means we need to update the texture atlas XML configuration file as well. Open the <em>atlas-definition.xml</em> configuration file and update it to the following:</p>
<pre><code class="lang-csharp" highlight-lines="5-16,29-32">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;TextureAtlas&gt;
    &lt;Texture&gt;images/atlas&lt;/Texture&gt;
    &lt;Regions&gt;
        &lt;Region name=&quot;slime-1&quot; x=&quot;340&quot; y=&quot;0&quot; width=&quot;20&quot; height=&quot;20&quot; /&gt;
        &lt;Region name=&quot;slime-2&quot; x=&quot;340&quot; y=&quot;20&quot; width=&quot;20&quot; height=&quot;20&quot; /&gt;
        &lt;Region name=&quot;bat-1&quot; x=&quot;340&quot; y=&quot;40&quot; width=&quot;20&quot; height=&quot;20&quot; /&gt;
        &lt;Region name=&quot;bat-2&quot; x=&quot;340&quot; y=&quot;60&quot; width=&quot;20&quot; height=&quot;20&quot; /&gt;
        &lt;Region name=&quot;bat-3&quot; x=&quot;360&quot; y=&quot;0&quot; width=&quot;20&quot; height=&quot;20&quot; /&gt;
        &lt;Region name=&quot;unfocused-button&quot; x=&quot;259&quot; y=&quot;80&quot; width=&quot;65&quot; height=&quot;14&quot; /&gt;
        &lt;Region name=&quot;focused-button-1&quot; x=&quot;259&quot; y=&quot;94&quot; width=&quot;65&quot; height=&quot;14&quot; /&gt;
        &lt;Region name=&quot;focused-button-2&quot; x=&quot;259&quot; y=&quot;109&quot; width=&quot;65&quot; height=&quot;14&quot; /&gt;
        &lt;Region name=&quot;panel-background&quot; x=&quot;324&quot; y=&quot;97&quot; width=&quot;15&quot; height=&quot;15&quot; /&gt;
        &lt;Region name=&quot;slider-off-background&quot; x=&quot;341&quot; y=&quot;96&quot; width=&quot;11&quot; height=&quot;10&quot; /&gt;
        &lt;Region name=&quot;slider-middle-background&quot; x=&quot;345&quot; y=&quot;81&quot; width=&quot;3&quot; height=&quot;3&quot; /&gt;
        &lt;Region name=&quot;slider-max-background&quot; x=&quot;354&quot; y=&quot;96&quot; width=&quot;11&quot; height=&quot;10&quot; /&gt;
    &lt;/Regions&gt;
    &lt;Animations&gt;
        &lt;Animation name=&quot;slime-animation&quot; delay=&quot;200&quot;&gt;
            &lt;Frame region=&quot;slime-1&quot; /&gt;
            &lt;Frame region=&quot;slime-2&quot; /&gt;
        &lt;/Animation&gt;
        &lt;Animation name=&quot;bat-animation&quot; delay=&quot;200&quot;&gt;
            &lt;Frame region=&quot;bat-1&quot; /&gt;
            &lt;Frame region=&quot;bat-2&quot; /&gt;
            &lt;Frame region=&quot;bat-1&quot; /&gt;
            &lt;Frame region=&quot;bat-3&quot; /&gt;
        &lt;/Animation&gt;
        &lt;Animation name=&quot;focused-button-animation&quot; delay=&quot;300&quot;&gt;
            &lt;Frame region=&quot;focused-button-1&quot; /&gt;
            &lt;Frame region=&quot;focused-button-2&quot; /&gt;
        &lt;/Animation&gt;
    &lt;/Animations&gt;
&lt;/TextureAtlas&gt;
</code></pre>
<p>The same is now true for the tiles in the texture atlas.  Since they have been repositioned in the new texture atlas, we need to update the <code>region</code> attribute for the tilemap XML configuration file.  Open the <code>tilemap-definition.xml</code> configuration file and update it to the following:</p>
<pre><code class="lang-csharp" highlight-lines="3">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;Tilemap&gt;
    &lt;Tileset region=&quot;260 0 80 80&quot; tileWidth=&quot;20&quot; tileHeight=&quot;20&quot;&gt;images/atlas&lt;/Tileset&gt;
    &lt;Tiles&gt;
        00 01 02 01 02 01 02 01 02 01 02 01 02 01 02 03
        04 05 05 06 05 05 06 05 05 06 05 05 06 05 05 07
        08 09 09 09 09 09 09 09 09 09 09 09 09 09 09 11
        04 09 09 09 09 09 09 09 10 09 09 09 09 10 09 07
        08 09 10 09 09 09 09 09 09 09 09 09 09 09 09 11
        04 09 09 09 09 09 09 09 09 09 09 09 09 09 09 07
        08 10 09 09 09 09 09 09 09 09 10 09 09 09 09 11
        04 09 09 09 09 09 10 09 09 09 09 09 09 09 09 07
        12 13 14 13 14 13 14 13 14 13 14 13 14 13 14 15
    &lt;/Tiles&gt;
&lt;/Tilemap&gt;
</code></pre><h3 id="adding-bitmap-fonts">Adding Bitmap Fonts</h3>
<p>While MonoGame natively uses <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteFont"><strong>SpriteFont</strong></a> to draw text, Gum uses the <a href="https://www.angelcode.com/products/bmfont/">AngelCode Bitmap Font (.fnt)</a> font file format. This means we will need to supply Gum with the <em>.fnt</em> file that defines our font.</p>
<div class="NOTE">
<h5>Note</h5>
<p>For this tutorial, a pregenerated <em>.fnt</em> file is supplied below.  For more information on creating <em>.fnt</em> files for Gum, see the <a href="https://docs.flatredball.com/gum/gum-tool/gum-elements/text/use-custom-font#creating-fonts-with-bitmapfontgenerator">Create Fonts with BitmapFontGenerator</a> section of the Gum documentation.</p>
</div>
<p>Download the <em>.fnt</em> file below by right-clicking the following link and saving it as <em>04b_30.fnt</em> in the game project's <em>Content/fonts</em> folder:</p>
<ul>
<li><a href="./files/04b_30.fnt">04b_30.fnt</a>{download}</li>
</ul>
<p>Next, add this font file to your content project using the MGCB Editor:</p>
<ol>
<li>Open the <code>Content.mgcb</code> content project file in the MGCB Editor.</li>
<li>Right-click the <code>fonts</code> folder and choose <code>Add &gt; Existing Item...</code>.</li>
<li>Navigate to and select the <code>04b_30.fnt</code> file you just downloaded.</li>
<li>In the Properties panel, change the <code>Build Action</code> to <code>Copy</code>. The MonoGame Content Pipeline cannot process <em>.fnt</em> files; we just need it to copy it so we can give it to Gum.</li>
<li><strong>Save the changes and close the MGCB Editor.</strong></li>
</ol>
<table>
<thead>
<tr>
<th style="text-align: center;"><img src="./images/mgcb-editor.png" alt="Figure 21-2: The MGCB Editor with the 04b_30.fnt added to the fonts folder and the Build property set to Copy"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Figure 21-2: The MGCB Editor with the 04b_30.fnt added to the fonts folder and the Build property set to Copy</strong></td>
</tr>
</tbody>
</table>
<div class="NOTE">
<h5>Note</h5>
<p>When the <em>.fnt</em> font file was generated using the <a href="https://www.angelcode.com/products/bmfont/">AngelCode Bitmap Font Generator</a>, the graphics from the <em>.png</em> file that it produces was copied over into our existing texture atlas. By doing this, it allows Gum to render the visuals for elements and the text from the same atlas, reducing texture swapping.</p>
<p>The font file references our existing texture atlas using a relative path that points to the atlas image.</p>
<p>The best practice when using this method is to ensure that when you copy the graphics from the generated <em>.png</em> file to your texture atlas, you place the generated character glyph graphics in the top-left of your texture atlas. This means all of the coordinates in the <em>.fnt</em> file will correctly reference the character glyphs without additional manual changes.</p>
</div>
<h2 id="updating-the-textureregion-class">Updating the TextureRegion Class</h2>
<p>In <a href="../18_texture_sampling/index.html#texture-coordinates">Chapter 18</a> we discussed texture coordinates and that graphic devices use a normalized coordinate system between 0.0 and 1.0.</p>
<p>Since <a href="#animation-chains">Gum also uses this coordinate system</a>, we will update the <code>TextureRegion</code> class to easily provide these values for any given region.</p>
<p>Open the <code>TextureRegion.cs</code> file in the <em>MonoGameLibrary</em> project and add the following properties to the <code>TextureRegion</code> class:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Gets the top normalized texture coordinate of this region.
/// &lt;/summary&gt;
public float TopTextureCoordinate =&gt; SourceRectangle.Top / (float)Texture.Height;

/// &lt;summary&gt;
/// Gets the bottom normalized texture coordinate of this region.
/// &lt;/summary&gt;
public float BottomTextureCoordinate =&gt; SourceRectangle.Bottom / (float)Texture.Height;

/// &lt;summary&gt;
///  Gets the left normalized texture coordinate of this region.
/// &lt;/summary&gt;
public float LeftTextureCoordinate =&gt; SourceRectangle.Left / (float)Texture.Width;

/// &lt;summary&gt;
/// Gets the right normalized texture coordinate of this region.
/// &lt;/summary&gt;
public float RightTextureCoordinate =&gt; SourceRectangle.Right / (float)Texture.Width;
</code></pre><h2 id="creating-custom-ui-components">Creating Custom UI Components</h2>
<p>Now that we have all our resources prepared, we can create custom versions of the UI controls we are using in our game. We will start with an animated button that uses our game's visual style, then move on to creating a custom slider.</p>
<h3 id="the-animatedbutton-class">The AnimatedButton Class</h3>
<p>Our first custom component is an <code>AnimatedButton</code> that inherits from Gum's base <code>Button</code> class. This button uses the game's existing texture atlas for its visual appearance and animates when focused.</p>
<p>By default all Gum components provide a Visual property which can be cast to a type specific to the particular control. By convention the visual type is named the same as the component with the word <code>Visual</code> appened. For example, we will be casting the AnimatedButton's Visual property to <code>ButtonVisual</code> to access button-specific properties.</p>
<p>This new <code>AnimatedButton</code> class casts the Visual property to <code>ButtonVisual</code> and modifies the button-specific properties such as background and text.</p>
<p>First, in the <em>DungeonSlime</em> project (your main game project), create a new folder named <code>UI</code> to store our custom UI components.  Next, in that <code>UI</code> folder, create a new file called <code>AnimatedButton.cs</code> and add the following code to it:</p>
<pre><code class="lang-csharp">using System;
using Gum.DataTypes;
using Gum.DataTypes.Variables;
using Gum.Forms.Controls;
using Gum.Forms.DefaultVisuals;
using Gum.Graphics.Animation;
using Gum.Managers;
using Microsoft.Xna.Framework.Input;
using MonoGameGum.GueDeriving;
using MonoGameLibrary.Graphics;

namespace DungeonSlime.UI;

/// &lt;summary&gt;
/// A custom button implementation that inherits from Gum's Button class to provide
/// animated visual feedback when focused.
/// &lt;/summary&gt;
internal class AnimatedButton : Button
{
    /// &lt;summary&gt;
    /// Creates a new AnimatedButton instance using graphics from the specified texture atlas.
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;atlas&quot;&gt;The texture atlas containing button graphics and animations&lt;/param&gt;
    public AnimatedButton(TextureAtlas atlas)
    {
        // Each Forms conrol has a general Visual property that
        // has properties shared by all control types. This Visual
        // type matches the Forms type. It can be casted to access
        // controls-specific properties.
        ButtonVisual buttonVisual = (ButtonVisual)Visual;
        // Width is relative to children with extra padding, height is fixed
        buttonVisual.Height = 14f;
        buttonVisual.HeightUnits = DimensionUnitType.Absolute;
        buttonVisual.Width = 21f;
        buttonVisual.WidthUnits = DimensionUnitType.RelativeToChildren;

        // Get a reference to the nine-slice background to display the button graphics
        // A nine-slice allows the button to stretch while preserving corner appearance
        NineSliceRuntime background = buttonVisual.Background;
        background.Texture = atlas.Texture;
        background.TextureAddress = TextureAddress.Custom;
        background.Color = Microsoft.Xna.Framework.Color.White;
        // texture coordinates for the background are set down below

        TextRuntime textInstance = buttonVisual.TextInstance;
        textInstance.Text = &quot;START&quot;;
        textInstance.Blue = 130;
        textInstance.Green = 86;
        textInstance.Red = 70;
        textInstance.UseCustomFont = true;
        textInstance.CustomFontFile = &quot;fonts/04b_30.fnt&quot;;
        textInstance.FontScale = 0.25f;
        textInstance.Anchor(Gum.Wireframe.Anchor.Center);
        textInstance.Width = 0;
        textInstance.WidthUnits = DimensionUnitType.RelativeToChildren;

        // Get the texture region for the unfocused button state from the atlas
        TextureRegion unfocusedTextureRegion = atlas.GetRegion(&quot;unfocused-button&quot;);

        // Create an animation chain for the unfocused state with a single frame
        AnimationChain unfocusedAnimation = new AnimationChain();
        unfocusedAnimation.Name = nameof(unfocusedAnimation);
        AnimationFrame unfocusedFrame = new AnimationFrame
        {
            TopCoordinate = unfocusedTextureRegion.TopTextureCoordinate,
            BottomCoordinate = unfocusedTextureRegion.BottomTextureCoordinate,
            LeftCoordinate = unfocusedTextureRegion.LeftTextureCoordinate,
            RightCoordinate = unfocusedTextureRegion.RightTextureCoordinate,
            FrameLength = 0.3f,
            Texture = unfocusedTextureRegion.Texture
        };
        unfocusedAnimation.Add(unfocusedFrame);

        // Get the multi-frame animation for the focused button state from the atlas
        Animation focusedAtlasAnimation = atlas.GetAnimation(&quot;focused-button-animation&quot;);

        // Create an animation chain for the focused state using all frames from the atlas animation
        AnimationChain focusedAnimation = new AnimationChain();
        focusedAnimation.Name = nameof(focusedAnimation);
        foreach (TextureRegion region in focusedAtlasAnimation.Frames)
        {
            AnimationFrame frame = new AnimationFrame
            {
                TopCoordinate = region.TopTextureCoordinate,
                BottomCoordinate = region.BottomTextureCoordinate,
                LeftCoordinate = region.LeftTextureCoordinate,
                RightCoordinate = region.RightTextureCoordinate,
                FrameLength = (float)focusedAtlasAnimation.Delay.TotalSeconds,
                Texture = region.Texture
            };

            focusedAnimation.Add(frame);
        }

        // Assign both animation chains to the nine-slice background
        background.AnimationChains = new AnimationChainList
        {
            unfocusedAnimation,
            focusedAnimation
        };


        // Reset all state to default so we don't have unexpected variable assignments:
        buttonVisual.ButtonCategory.ResetAllStates();

        // Get the enabled (default/unfocused) state
        StateSave enabledState = buttonVisual.States.Enabled;
        enabledState.Apply = () =&gt;
        {
            // When enabled but not focused, use the unfocused animation
            background.CurrentChainName = unfocusedAnimation.Name;
        };

        // Create the focused state
        StateSave focusedState = buttonVisual.States.Focused;
        focusedState.Apply = () =&gt;
        {
            // When focused, use the focused animation and enable animation playback
            background.CurrentChainName = focusedAnimation.Name;
            background.Animate = true;
        };

        // Create the highlighted+focused state (for mouse hover while focused)
        StateSave highlightedFocused = buttonVisual.States.HighlightedFocused;
        highlightedFocused.Apply = focusedState.Apply;

        // Create the highlighted state (for mouse hover)
        // by cloning the enabled state since they appear the same
        StateSave highlighted = buttonVisual.States.Highlighted;
        highlighted.Apply = enabledState.Apply;

        // Add event handlers for keyboard input.
        KeyDown += HandleKeyDown;

        // Add event handler for mouse hover focus.
        buttonVisual.RollOn += HandleRollOn;
    }

    /// &lt;summary&gt;
    /// Handles keyboard input for navigation between buttons using left/right keys.
    /// &lt;/summary&gt;
    private void HandleKeyDown(object sender, KeyEventArgs e)
    {
        if (e.Key == Keys.Left)
        {
            // Left arrow navigates to previous control
            HandleTab(TabDirection.Up, loop: true);
        }
        if (e.Key == Keys.Right)
        {
            // Right arrow navigates to next control
            HandleTab(TabDirection.Down, loop: true);
        }
    }

    /// &lt;summary&gt;
    /// Automatically focuses the button when the mouse hovers over it.
    /// &lt;/summary&gt;
    private void HandleRollOn(object sender, EventArgs e)
    {
        IsFocused = true;
    }
}
</code></pre>
<p>Next, we will examine the key aspects of this new <code>AnimatedButton</code> implementation:</p>
<h4 id="buttonvisual">ButtonVisual</h4>
<p>As mentioned earlier, we first access the <code>Visual</code> object and cast it to a <code>ButtonVisual</code>. Doing so gives us access to button-specific properties including individual elements (such as the text and background visuals) as well as the states that are applied when the button is hovered or pressed.</p>
<p>We can modify the Visual to give it the appropriate size.</p>
<pre><code class="lang-csharp">ButtonVisual buttonVisual = (ButtonVisual)Visual;
// Width is relative to children with extra padding, height is fixed
buttonVisual.Height = 14f;
buttonVisual.HeightUnits = DimensionUnitType.Absolute;
buttonVisual.Width = 21f;
buttonVisual.WidthUnits = DimensionUnitType.RelativeToChildren;
</code></pre>
<p>The <code>WidthUnits</code> property set to <code>RelativeToChildren</code> means the container  automatically sizes itself based on its child elements, with 21 pixels of additional space.  This allows the button to adapt its size depending on the text content.</p>
<h4 id="nine-slice-background">Nine-slice Background</h4>
<p><code>ButtonVisual</code> provides a <code>Background</code> which we can modify. This is of type <code>NineSliceRuntime</code> which is a special graphic that can be stretch while preserving its corners and edges:</p>
<pre><code class="lang-csharp">NineSliceRuntime background = buttonVisual.Background;
background.Texture = atlas.Texture;
background.TextureAddress = TextureAddress.Custom;
background.Color = Microsoft.Xna.Framework.Color.White;
</code></pre>
<p>The <code>TextureAddress</code> property is set to <code>Custom</code> so we can specify exactly which portion of the atlas texture to use, while <code>Dock(Dock.Fill)</code> ensure the background fills the entire button area. The portion of the atlas is assigned using AnimationChains, which are discussed later in this tutorial.</p>
<h4 id="text">Text</h4>
<p><code>ButtonVisual</code> also provides a customizable <code>Text</code> property. In this case we assign the font, color, and size.</p>
<pre><code class="lang-csharp">TextRuntime textInstance = buttonVisual.TextInstance;
textInstance.Text = &quot;START&quot;;
textInstance.Blue = 130;
textInstance.Green = 86;
textInstance.Red = 70;
textInstance.UseCustomFont = true;
textInstance.CustomFontFile = &quot;fonts/04b_30.fnt&quot;;
textInstance.FontScale = 0.25f;
textInstance.Anchor(Gum.Wireframe.Anchor.Center);
textInstance.Width = 0;
textInstance.WidthUnits = DimensionUnitType.RelativeToChildren;
</code></pre><h4 id="animated-chains">Animated Chains</h4>
<p>The most distinctive feature of our animated button is its ability to change appearance when focused.  We achieve this by creating two animation chains:</p>
<ol>
<li>An &quot;unfocused&quot; animation with a single static frame.</li>
<li>A &quot;focused&quot; animation with two alternating frames that create a visual effect.</li>
</ol>
<p>Each animation frame specifies the coordinates within our texture atlas to display:</p>
<pre><code class="lang-csharp">TextureRegion unfocusedTextureRegion = atlas.GetRegion(&quot;unfocused-button&quot;);

// Create an animation chain for the unfocused state with a single frame
AnimationChain unfocusedAnimation = new AnimationChain();
unfocusedAnimation.Name = nameof(unfocusedAnimation);
AnimationFrame unfocusedFrame = new AnimationFrame
{
    TopCoordinate = unfocusedTextureRegion.TopTextureCoordinate,
    BottomCoordinate = unfocusedTextureRegion.BottomTextureCoordinate,
    LeftCoordinate = unfocusedTextureRegion.LeftTextureCoordinate,
    RightCoordinate = unfocusedTextureRegion.RightTextureCoordinate,
    FrameLength = 0.3f,
    Texture = unfocusedTextureRegion.Texture
};
unfocusedAnimation.Add(unfocusedFrame);

// Get the multi-frame animation for the focused button state from the atlas
Animation focusedAtlasAnimation = atlas.GetAnimation(&quot;focused-button-animation&quot;);

// Create an animation chain for the focused state using all frames from the atlas animation
AnimationChain focusedAnimation = new AnimationChain();
focusedAnimation.Name = nameof(focusedAnimation);
foreach (TextureRegion region in focusedAtlasAnimation.Frames)
{
    AnimationFrame frame = new AnimationFrame
    {
        TopCoordinate = region.TopTextureCoordinate,
        BottomCoordinate = region.BottomTextureCoordinate,
        LeftCoordinate = region.LeftTextureCoordinate,
        RightCoordinate = region.RightTextureCoordinate,
        FrameLength = (float)focusedAtlasAnimation.Delay.TotalSeconds,
        Texture = region.Texture
    };

    focusedAnimation.Add(frame);
}
</code></pre><h4 id="states-and-categories">States and Categories</h4>
<p>In Gum, each control type has a specific category name that identifies its state collection. <code>ButtonVisual</code> provides access to ready-made states and catgories which we can modify. Before we speicfy how a state should modify the button's appearance, we clear out all existing functionality so that we can fully control the states:</p>
<pre><code class="lang-csharp">buttonVisual.ButtonCategory.ResetAllStates();
</code></pre>
<p>Each of the button's states can be accessed through <code>ButtonVisual</code>. Since the states were cleared previously, the code assigns only the necessary property assignments in the <code>Apply</code> delegate. In our case, we switch between animation chains to create the desired visual effect.</p>
<pre><code class="lang-csharp">StateSave enabledState = buttonVisual.States.Enabled;
enabledState.Apply = () =&gt;
{
    // When enabled but not focused, use the unfocused animation
    background.CurrentChainName = unfocusedAnimation.Name;
};

// Create the focused state
StateSave focusedState = buttonVisual.States.Focused;
focusedState.Apply = () =&gt;
{
    // When focused, use the focused animation and enable animation playback
    background.CurrentChainName = focusedAnimation.Name;
    background.Animate = true;
};

// Create the highlighted+focused state (for mouse hover while focused)
StateSave highlightedFocused = buttonVisual.States.HighlightedFocused;
highlightedFocused.Apply = focusedState.Apply;

// Create the highlighted state (for mouse hover)
// by cloning the enabled state since they appear the same
StateSave highlighted = buttonVisual.States.Highlighted;
highlighted.Apply = enabledState.Apply;
</code></pre><h4 id="custom-input-handling">Custom Input Handling</h4>
<p>We add custom keyboard navigation to our button by handling the <code>KeyDown</code> event:</p>
<pre><code class="lang-csharp">KeyDown += HandleKeyDown;
</code></pre><pre><code class="lang-csharp">private void HandleKeyDown(object sender, KeyEventArgs e)
{
    if (e.Key == Keys.Left)
    {
        // Left arrow navigates to previous control
        HandleTab(TabDirection.Up, loop: true);
    }
    if (e.Key == Keys.Right)
    {
        // Right arrow navigates to next control
        HandleTab(TabDirection.Down, loop: true);
    }
}
</code></pre>
<p>This allows players to navigate between buttons using the left and right arrow keys, providing additional control options beyond the default tab navigation.</p>
<h4 id="focus-management">Focus Management</h4>
<p>We also add a <code>RollOn</code> event handler to ensure the button gets focus when the mouse hovers over it:</p>
<pre><code class="lang-csharp">buttonVisual.RollOn += HandleRollOn;
</code></pre><pre><code class="lang-csharp">private void HandleRollOn(object sender, EventArgs e)
{
    IsFocused = true;
}
</code></pre>
<p>This creates a more responsive interface by immediately focusing elements that the player interacts with using the mouse.</p>
<h3 id="the-optionsslider-class">The OptionsSlider Class</h3>
<p>Now we will create a custom <code>OptionsSlider</code> class to style the volume sliders.  This class inherits from Gum's base <code>Slider</code> class and provides a styled appearance consistent with the game's visual theme.</p>
<p>Unlike <code>AnimatedButton</code>, the <code>OptionsSlider</code> creates a Visual completely from scratch. This class provides an example for how to completely customize a Forms control by recreating its Visual object entirely. We do this because the desired appearance and behavior of our <code>OptionsSlider</code> is differs enough from the existing Slider that it is easier to replace its <code>Visual</code> entirely.</p>
<p>In the <code>UI</code> folder of the <em>DungeonSlime</em> project (your main game project), create a new file called <code>OptionsSlider.cs</code> and add the following code to it:</p>
<pre><code class="lang-csharp">using System;
using Gum.DataTypes;
using Gum.DataTypes.Variables;
using Gum.Managers;
using Microsoft.Xna.Framework;
using Gum.Forms.Controls;
using MonoGameGum.GueDeriving;
using MonoGameLibrary.Graphics;

namespace DungeonSlime.UI;

/// &lt;summary&gt;
/// A custom slider control that inherits from Gum's Slider class.
/// &lt;/summary&gt;
public class OptionsSlider : Slider
{
    // Reference to the text label that displays the slider's title
    private TextRuntime _textInstance;

    // Reference to the rectangle that visually represents the current value
    private ColoredRectangleRuntime _fillRectangle;

    /// &lt;summary&gt;
    /// Gets or sets the text label for this slider.
    /// &lt;/summary&gt;
    public string Text
    {
        get =&gt; _textInstance.Text;
        set =&gt; _textInstance.Text = value;
    }

    /// &lt;summary&gt;
    /// Creates a new OptionsSlider instance using graphics from the specified texture atlas.
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;atlas&quot;&gt;The texture atlas containing slider graphics.&lt;/param&gt;
    public OptionsSlider(TextureAtlas atlas)
    {
        // Create the top-level container for all visual elements
        ContainerRuntime topLevelContainer = new ContainerRuntime();
        topLevelContainer.Height = 55f;
        topLevelContainer.Width = 264f;

        TextureRegion backgroundRegion = atlas.GetRegion(&quot;panel-background&quot;);

        // Create the background panel that contains everything
        NineSliceRuntime background = new NineSliceRuntime();
        background.Texture = atlas.Texture;
        background.TextureAddress = TextureAddress.Custom;
        background.TextureHeight = backgroundRegion.Height;
        background.TextureLeft = backgroundRegion.SourceRectangle.Left;
        background.TextureTop = backgroundRegion.SourceRectangle.Top;
        background.TextureWidth = backgroundRegion.Width;
        background.Dock(Gum.Wireframe.Dock.Fill);
        topLevelContainer.AddChild(background);

        // Create the title text element
        _textInstance = new TextRuntime();
        _textInstance.CustomFontFile = @&quot;fonts/04b_30.fnt&quot;;
        _textInstance.UseCustomFont = true;
        _textInstance.FontScale = 0.5f;
        _textInstance.Text = &quot;Replace Me&quot;;
        _textInstance.X = 10f;
        _textInstance.Y = 10f;
        _textInstance.WidthUnits = DimensionUnitType.RelativeToChildren;
        topLevelContainer.AddChild(_textInstance);

        // Create the container for the slider track and decorative elements
        ContainerRuntime innerContainer = new ContainerRuntime();
        innerContainer.Height = 13f;
        innerContainer.Width = 241f;
        innerContainer.X = 10f;
        innerContainer.Y = 33f;
        topLevelContainer.AddChild(innerContainer);

        TextureRegion offBackgroundRegion = atlas.GetRegion(&quot;slider-off-background&quot;);

        // Create the &quot;OFF&quot; side of the slider (left end)
        NineSliceRuntime offBackground = new NineSliceRuntime();
        offBackground.Dock(Gum.Wireframe.Dock.Left);
        offBackground.Texture = atlas.Texture;
        offBackground.TextureAddress = TextureAddress.Custom;
        offBackground.TextureHeight = offBackgroundRegion.Height;
        offBackground.TextureLeft = offBackgroundRegion.SourceRectangle.Left;
        offBackground.TextureTop = offBackgroundRegion.SourceRectangle.Top;
        offBackground.TextureWidth = offBackgroundRegion.Width;
        offBackground.Width = 28f;
        offBackground.WidthUnits = DimensionUnitType.Absolute;
        offBackground.Dock(Gum.Wireframe.Dock.Left);
        innerContainer.AddChild(offBackground);

        TextureRegion middleBackgroundRegion = atlas.GetRegion(&quot;slider-middle-background&quot;);

        // Create the middle track portion of the slider
        NineSliceRuntime middleBackground = new NineSliceRuntime();
        middleBackground.Dock(Gum.Wireframe.Dock.FillVertically);
        middleBackground.Texture = middleBackgroundRegion.Texture;
        middleBackground.TextureAddress = TextureAddress.Custom;
        middleBackground.TextureHeight = middleBackgroundRegion.Height;
        middleBackground.TextureLeft = middleBackgroundRegion.SourceRectangle.Left;
        middleBackground.TextureTop = middleBackgroundRegion.SourceRectangle.Top;
        middleBackground.TextureWidth = middleBackgroundRegion.Width;
        middleBackground.Width = 179f;
        middleBackground.WidthUnits = DimensionUnitType.Absolute;
        middleBackground.Dock(Gum.Wireframe.Dock.Left);
        middleBackground.X = 27f;
        innerContainer.AddChild(middleBackground);

        TextureRegion maxBackgroundRegion = atlas.GetRegion(&quot;slider-max-background&quot;);

        // Create the &quot;MAX&quot; side of the slider (right end)
        NineSliceRuntime maxBackground = new NineSliceRuntime();
        maxBackground.Texture = maxBackgroundRegion.Texture;
        maxBackground.TextureAddress = TextureAddress.Custom;
        maxBackground.TextureHeight = maxBackgroundRegion.Height;
        maxBackground.TextureLeft = maxBackgroundRegion.SourceRectangle.Left;
        maxBackground.TextureTop = maxBackgroundRegion.SourceRectangle.Top;
        maxBackground.TextureWidth = maxBackgroundRegion.Width;
        maxBackground.Width = 36f;
        maxBackground.WidthUnits = DimensionUnitType.Absolute;
        maxBackground.Dock(Gum.Wireframe.Dock.Right);
        innerContainer.AddChild(maxBackground);

        // Create the interactive track that responds to clicks
        // The special name &quot;TrackInstance&quot; is required for Slider functionality
        ContainerRuntime trackInstance = new ContainerRuntime();
        trackInstance.Name = &quot;TrackInstance&quot;;
        trackInstance.Dock(Gum.Wireframe.Dock.Fill);
        trackInstance.Height = -2f;
        trackInstance.Width = -2f;
        middleBackground.AddChild(trackInstance);

        // Create the fill rectangle that visually displays the current value
        _fillRectangle = new ColoredRectangleRuntime();
        _fillRectangle.Dock(Gum.Wireframe.Dock.Left);
        _fillRectangle.Width = 90f; // Default to 90% - will be updated by value changes
        _fillRectangle.WidthUnits = DimensionUnitType.PercentageOfParent;
        trackInstance.AddChild(_fillRectangle);

        // Add &quot;OFF&quot; text to the left end
        TextRuntime offText = new TextRuntime();
        offText.Red = 70;
        offText.Green = 86;
        offText.Blue = 130;
        offText.CustomFontFile = @&quot;fonts/04b_30.fnt&quot;;
        offText.FontScale = 0.25f;
        offText.UseCustomFont = true;
        offText.Text = &quot;OFF&quot;;
        offText.Anchor(Gum.Wireframe.Anchor.Center);
        offBackground.AddChild(offText);

        // Add &quot;MAX&quot; text to the right end
        TextRuntime maxText = new TextRuntime();
        maxText.Red = 70;
        maxText.Green = 86;
        maxText.Blue = 130;
        maxText.CustomFontFile = @&quot;fonts/04b_30.fnt&quot;;
        maxText.FontScale = 0.25f;
        maxText.UseCustomFont = true;
        maxText.Text = &quot;MAX&quot;;
        maxText.Anchor(Gum.Wireframe.Anchor.Center);
        maxBackground.AddChild(maxText);

        // Define colors for focused and unfocused states
        Color focusedColor = Color.White;
        Color unfocusedColor = Color.Gray;

        // Create slider state category - Slider.SliderCategoryName is the required name
        StateSaveCategory sliderCategory = new StateSaveCategory();
        sliderCategory.Name = Slider.SliderCategoryName;
        topLevelContainer.AddCategory(sliderCategory);

        // Create the enabled (default/unfocused) state
        StateSave enabled = new StateSave();
        enabled.Name = FrameworkElement.EnabledStateName;
        enabled.Apply = () =&gt;
        {
            // When enabled but not focused, use gray coloring for all elements
            background.Color = unfocusedColor;
            _textInstance.Color = unfocusedColor;
            offBackground.Color = unfocusedColor;
            middleBackground.Color = unfocusedColor;
            maxBackground.Color = unfocusedColor;
            _fillRectangle.Color = unfocusedColor;
        };
        sliderCategory.States.Add(enabled);

        // Create the focused state
        StateSave focused = new StateSave();
        focused.Name = FrameworkElement.FocusedStateName;
        focused.Apply = () =&gt;
        {
            // When focused, use white coloring for all elements
            background.Color = focusedColor;
            _textInstance.Color = focusedColor;
            offBackground.Color = focusedColor;
            middleBackground.Color = focusedColor;
            maxBackground.Color = focusedColor;
            _fillRectangle.Color = focusedColor;
        };
        sliderCategory.States.Add(focused);

        // Create the highlighted+focused state by cloning the focused state
        StateSave highlightedFocused = focused.Clone();
        highlightedFocused.Name = FrameworkElement.HighlightedFocusedStateName;
        sliderCategory.States.Add(highlightedFocused);

        // Create the highlighted state by cloning the enabled state
        StateSave highlighted = enabled.Clone();
        highlighted.Name = FrameworkElement.HighlightedStateName;
        sliderCategory.States.Add(highlighted);

        // Assign the configured container as this slider's visual
        Visual = topLevelContainer;

        // Enable click-to-point functionality for the slider
        // This allows users to click anywhere on the track to jump to that value
        IsMoveToPointEnabled = true;

        // Add event handlers
        Visual.RollOn += HandleRollOn;
        ValueChanged += HandleValueChanged;
        ValueChangedByUi += HandleValueChangedByUi;
    }

    /// &lt;summary&gt;
    /// Automatically focuses the slider when the user interacts with it
    /// &lt;/summary&gt;
    private void HandleValueChangedByUi(object sender, EventArgs e)
    {
        IsFocused = true;
    }

    /// &lt;summary&gt;
    /// Automatically focuses the slider when the mouse hovers over it
    /// &lt;/summary&gt;
    private void HandleRollOn(object sender, EventArgs e)
    {
        IsFocused = true;
    }

    /// &lt;summary&gt;
    /// Updates the fill rectangle width to visually represent the current value
    /// &lt;/summary&gt;
    private void HandleValueChanged(object sender, EventArgs e)
    {
        // Calculate the ratio of the current value within its range
        double ratio = (Value - Minimum) / (Maximum - Minimum);

        // Update the fill rectangle width as a percentage
        // _fillRectangle uses percentage width units, so we multiply by 100
        _fillRectangle.Width = 100 * (float)ratio;
    }
}
</code></pre>
<p>The <code>OptionsSlider</code> is more complex than then <a href="#the-animatedbutton-class"><code>AnimatedButton</code></a> because it contains more visual elements.  Below are the key aspects of this implementation:</p>
<h4 id="slider-components">Slider Components</h4>
<p>Walking through the <code>OptionsSlider</code> implementation, it consists of several components</p>
<ol>
<li>A background container with a label for the slider.</li>
<li>An inner container that holds the slider track.</li>
<li>&quot;OFF&quot; and &quot;MAX&quot; section at each end of the slider.</li>
<li>A track where the thumb moves.</li>
<li>A fill rectangle that shows the current value visually.</li>
</ol>
<p>Each of these elements is styled to match the game's visual theme using sprites from our atlas.</p>
<h4 id="custom-text-property">Custom Text Property</h4>
<p>We add a custom <code>Text</code> property to set the slider's label:</p>
<pre><code class="lang-csharp">/// Gets or sets the text label for this slider.
/// &lt;/summary&gt;
public string Text
{
    get =&gt; _textInstance.Text;
    set =&gt; _textInstance.Text = value;
}

</code></pre>
<p>This allows us to easily customize the label for each slider instance we create.</p>
<h4 id="visual-feedback">Visual Feedback</h4>
<p>The slider uses color changes to provide visual feedback:</p>
<pre><code class="lang-csharp">StateSave enabled = new StateSave();
enabled.Name = FrameworkElement.EnabledStateName;
enabled.Apply = () =&gt;
{
    // When enabled but not focused, use gray coloring for all elements
    background.Color = unfocusedColor;
    _textInstance.Color = unfocusedColor;
    offBackground.Color = unfocusedColor;
    middleBackground.Color = unfocusedColor;
    maxBackground.Color = unfocusedColor;
    _fillRectangle.Color = unfocusedColor;
};
sliderCategory.States.Add(enabled);

</code></pre><pre><code class="lang-csharp">StateSave focused = new StateSave();
focused.Name = FrameworkElement.FocusedStateName;
focused.Apply = () =&gt;
{
    // When focused, use white coloring for all elements
    background.Color = focusedColor;
    _textInstance.Color = focusedColor;
    offBackground.Color = focusedColor;
    middleBackground.Color = focusedColor;
    maxBackground.Color = focusedColor;
    _fillRectangle.Color = focusedColor;
};
sliderCategory.States.Add(focused);

</code></pre>
<p>When the slider is focused, all its elements change from gray to white, making it clear to the player which UI element currently has focus.</p>
<h4 id="fill-visualization">Fill Visualization</h4>
<p>One of the most important aspects of a slider is the visual representation of its value.  We achieve this by updating the width of the <code>_fillRectangle</code> element:</p>
<pre><code class="lang-csharp">    /// Updates the fill rectangle width to visually represent the current value
    /// &lt;/summary&gt;
    private void HandleValueChanged(object sender, EventArgs e)
    {
        // Calculate the ratio of the current value within its range
        double ratio = (Value - Minimum) / (Maximum - Minimum);

        // Update the fill rectangle width as a percentage
        // _fillRectangle uses percentage width units, so we multiply by 100
        _fillRectangle.Width = 100 * (float)ratio;
    }
}
</code></pre>
<p>This method converts the slider's current value to a percentage and applies it to the fill rectangle's width, creating a visual indicator of the current setting.</p>
<h2 id="updating-the-scenes-to-use-custom-controls">Updating the Scenes to Use Custom Controls</h2>
<p>Now that we have created our custom controls, we need to update our game scenes to use them instead of the default Gum controls.</p>
<h3 id="updating-the-titlescene">Updating the TitleScene</h3>
<p>First, open the <code>TitleScene.cs</code> file in the game project and add the following using declaration to the top of the <code>TitleScene</code> class:</p>
<pre><code class="lang-csharp" highlight-lines="2,11">using System;
using DungeonSlime.UI;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Audio;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;
using MonoGameGum;
using MonoGameGum.Forms.Controls;
using MonoGameGum.GueDeriving;
using MonoGameLibrary;
using MonoGameLibrary.Graphics;
using MonoGameLibrary.Scenes;
</code></pre>
<p>Next, update both the <code>_optionsButton</code> and the <code>_optionsBackButton</code> fields to be of our new <a href="#the-animatedbutton-class"><code>AnimatedButton</code></a> type, and add a new field to store a reference to the texture atlas in.</p>
<pre><code class="lang-csharp" highlight-lines="3-11">// Existing fields...

// The options button used to open the options menu.
private AnimatedButton _optionsButton;

// The back button used to exit the options menu back to the title menu.
private AnimatedButton _optionsBackButton;

// Reference to the texture atlas that we can pass to UI elements when they
// are created.
private TextureAtlas _atlas;
</code></pre>
<p>Next, in the <code>LoadContent</code> method, we need to update it so that it loads the texture atlas from the XML configuration file and stores it in the new <code>_atlas</code> field:</p>
<pre><code class="lang-csharp" highlight-lines="15-16">public override void LoadContent()
{
    // Load the font for the standard text.
    _font = Core.Content.Load&lt;SpriteFont&gt;(&quot;fonts/04B_30&quot;);

    // Load the font for the title text
    _font5x = Content.Load&lt;SpriteFont&gt;(&quot;fonts/04B_30_5x&quot;);

    // Load the background pattern texture.
    _backgroundPattern = Content.Load&lt;Texture2D&gt;(&quot;images/background-pattern&quot;);

    // Load the sound effect to play when ui actions occur.
    _uiSoundEffect = Core.Content.Load&lt;SoundEffect&gt;(&quot;audio/ui&quot;);

    // Load the texture atlas from the xml configuration file.
    _atlas = TextureAtlas.FromFile(Core.Content, &quot;images/atlas-definition.xml&quot;);
}
</code></pre>
<p>Next, update the <code>CreateTitlePanel</code> method so that instead of using the default Gum <code>Button</code> Forms controls it now uses our custom <a href="#the-animatedbutton-class"><code>AnimatedButton</code></a> control and remove the explicit setting of the <code>Visual.Width</code> property since this is managed by the <a href="#the-animatedbutton-class"><code>AnimatedButton</code></a> now:</p>
<pre><code class="lang-csharp" highlight-lines="8,16">private void CreateTitlePanel()
{
    // Create a container to hold all of our buttons
    _titleScreenButtonsPanel = new Panel();
    _titleScreenButtonsPanel.Dock(Gum.Wireframe.Dock.Fill);
    _titleScreenButtonsPanel.AddToRoot();

    AnimatedButton startButton = new AnimatedButton(_atlas);
    startButton.Anchor(Gum.Wireframe.Anchor.BottomLeft);
    startButton.Visual.X = 50;
    startButton.Visual.Y = -12;
    startButton.Text = &quot;Start&quot;;
    startButton.Click += HandleStartClicked;
    _titleScreenButtonsPanel.AddChild(startButton);

    _optionsButton = new AnimatedButton(_atlas);
    _optionsButton.Anchor(Gum.Wireframe.Anchor.BottomRight);
    _optionsButton.Visual.X = -50;
    _optionsButton.Visual.Y = -12;
    _optionsButton.Text = &quot;Options&quot;;
    _optionsButton.Click += HandleOptionsClicked;
    _titleScreenButtonsPanel.AddChild(_optionsButton);

    startButton.IsFocused = true;
}
</code></pre>
<p>Finally, update the <code>CreateOptionsPanel</code> method so that:</p>
<ul>
<li>It uses a <code>TextRuntime</code> to display the text &quot;OPTIONS&quot; using the bitmap font</li>
<li>Instead of using the default Gum <code>Button</code> and <code>Slider</code> Forms controls, it now uses our custom <a href="#the-animatedbutton-class"><code>AnimatedButton</code></a> and <a href="#the-optionsslider-class"><code>OptionsSlider</code></a> controls.</li>
<li>Both the <code>musicSlider</code> and <code>sfxSlider</code> have been given <code>Name</code> and <code>Text</code> properties.</li>
</ul>
<pre><code class="lang-csharp" highlight-lines="8-15,17-19,31-33,45">private void CreateOptionsPanel()
{
    _optionsPanel = new Panel();
    _optionsPanel.Dock(Gum.Wireframe.Dock.Fill);
    _optionsPanel.IsVisible = false;
    _optionsPanel.AddToRoot();

    TextRuntime optionsText = new TextRuntime();
    optionsText.X = 10;
    optionsText.Y = 10;
    optionsText.Text = &quot;OPTIONS&quot;;
    optionsText.UseCustomFont = true;
    optionsText.FontScale = 0.5f;
    optionsText.CustomFontFile = @&quot;fonts/04b_30.fnt&quot;;
    _optionsPanel.AddChild(optionsText);

    OptionsSlider musicSlider = new OptionsSlider(_atlas);
    musicSlider.Name = &quot;MusicSlider&quot;;
    musicSlider.Text = &quot;MUSIC&quot;;
    musicSlider.Anchor(Gum.Wireframe.Anchor.Top);
    musicSlider.Visual.Y = 30f;
    musicSlider.Minimum = 0;
    musicSlider.Maximum = 1;
    musicSlider.Value = Core.Audio.SongVolume;
    musicSlider.SmallChange = .1;
    musicSlider.LargeChange = .2;
    musicSlider.ValueChanged += HandleMusicSliderValueChanged;
    musicSlider.ValueChangeCompleted += HandleMusicSliderValueChangeCompleted;
    _optionsPanel.AddChild(musicSlider);

    OptionsSlider sfxSlider = new OptionsSlider(_atlas);
    sfxSlider.Name = &quot;SfxSlider&quot;;
    sfxSlider.Text = &quot;SFX&quot;;
    sfxSlider.Anchor(Gum.Wireframe.Anchor.Top);
    sfxSlider.Visual.Y = 93;
    sfxSlider.Minimum = 0;
    sfxSlider.Maximum = 1;
    sfxSlider.Value = Core.Audio.SoundEffectVolume;
    sfxSlider.SmallChange = .1;
    sfxSlider.LargeChange = .2;
    sfxSlider.ValueChanged += HandleSfxSliderChanged;
    sfxSlider.ValueChangeCompleted += HandleSfxSliderChangeCompleted;
    _optionsPanel.AddChild(sfxSlider);

    _optionsBackButton = new AnimatedButton(_atlas);
    _optionsBackButton.Text = &quot;BACK&quot;;
    _optionsBackButton.Anchor(Gum.Wireframe.Anchor.BottomRight);
    _optionsBackButton.X = -28f;
    _optionsBackButton.Y = -10f;
    _optionsBackButton.Click += HandleOptionsButtonBack;
    _optionsPanel.AddChild(_optionsBackButton);
}
</code></pre><h3 id="updating-the-gamescene">Updating the GameScene</h3>
<p>Next, open the <code>GameScene.cs</code> file in the game project and add the following using declaration to the top of the <code>GameScene</code> class:</p>
<pre><code class="lang-csharp" highlight-lines="2,4">using System;
using DungeonSlime.UI;
using Gum.DataTypes;
using Gum.Managers;
using Gum.Wireframe;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Audio;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;
using MonoGameGum;
using Gum.Forms.Controls;
using MonoGameGum.GueDeriving;
using MonoGameLibrary;
using MonoGameLibrary.Graphics;
using MonoGameLibrary.Input;
using MonoGameLibrary.Scenes;
</code></pre>
<p>Next, update the <code>_resumeButton</code> field to be of our new <a href="#the-animatedbutton-class"><code>AnimatedButton</code></a> type and add a field to store a reference to the texture atlas in.</p>
<pre><code class="lang-csharp" highlight-lines="5,10-12">// Existing fields...

// A reference to the resume button UI element so we can focus it
// when the game is paused.
private AnimatedButton _resumeButton;

// The UI sound effect to play when a UI event is triggered.
private SoundEffect _uiSoundEffect;

// Reference to the texture atlas that we can pass to UI elements when they
// are created.
private TextureAtlas _atlas;
</code></pre>
<p>Next, in the <code>LoadContent</code> method, we need to update it so that it stores the texture atlas once loaded in the new <code>_atlas</code> field.</p>
<pre><code class="lang-csharp" highlight-lines="4,7,11">public override void LoadContent()
{
    // Create the texture atlas from the XML configuration file
    _atlas = TextureAtlas.FromFile(Core.Content, &quot;images/atlas-definition.xml&quot;);

    // Create the slime animated sprite from the atlas.
    _slime = _atlas.CreateAnimatedSprite(&quot;slime-animation&quot;);
    _slime.Scale = new Vector2(4.0f, 4.0f);

    // Create the bat animated sprite from the atlas.
    _bat = _atlas.CreateAnimatedSprite(&quot;bat-animation&quot;);
    _bat.Scale = new Vector2(4.0f, 4.0f);

    // Create the tilemap from the XML configuration file.
    _tilemap = Tilemap.FromFile(Content, &quot;images/tilemap-definition.xml&quot;);
    _tilemap.Scale = new Vector2(4.0f, 4.0f);

    // Load the bounce sound effect
    _bounceSoundEffect = Content.Load&lt;SoundEffect&gt;(&quot;audio/bounce&quot;);

    // Load the collect sound effect
    _collectSoundEffect = Content.Load&lt;SoundEffect&gt;(&quot;audio/collect&quot;);

    // Load the font
    _font = Core.Content.Load&lt;SpriteFont&gt;(&quot;fonts/04B_30&quot;);

    // Load the sound effect to play when ui actions occur.
    _uiSoundEffect = Core.Content.Load&lt;SoundEffect&gt;(&quot;audio/ui&quot;);
}
</code></pre>
<p>Finally, update the <code>CreatePausePanel</code> method so that</p>
<ol>
<li>Instead of using a <a href="#visual-elements"><code>ColoredRectangleRuntime</code></a> for the background of the pause panel, it now uses a <a href="#visual-elements"><code>NineSliceRuntime</code></a> that uses the sprite from the texture atlas.</li>
<li>The <code>textInstance</code> is updated so that it uses the custom bitmap font file.</li>
<li>The <code>_resumeButton</code> and <code>quiteButton</code> are updated to use our custom <a href="#the-animatedbutton-class"><code>AnimatedButton</code></a> control instead of the default Gum <code>Button</code> Forms control.</li>
</ol>
<pre><code class="lang-csharp" highlight-lines="12-22,26-28,33,41">private void CreatePausePanel()
{
    _pausePanel = new Panel();
    _pausePanel.Anchor(Anchor.Center);
    _pausePanel.Visual.WidthUnits = DimensionUnitType.Absolute;
    _pausePanel.Visual.HeightUnits = DimensionUnitType.Absolute;
    _pausePanel.Visual.Height = 70;
    _pausePanel.Visual.Width = 264;
    _pausePanel.IsVisible = false;
    _pausePanel.AddToRoot();

    TextureRegion backgroundRegion = _atlas.GetRegion(&quot;panel-background&quot;);

    NineSliceRuntime background = new NineSliceRuntime();
    background.Dock(Dock.Fill);
    background.Texture = backgroundRegion.Texture;
    background.TextureAddress = TextureAddress.Custom;
    background.TextureHeight = backgroundRegion.Height;
    background.TextureLeft = backgroundRegion.SourceRectangle.Left;
    background.TextureTop = backgroundRegion.SourceRectangle.Top;
    background.TextureWidth = backgroundRegion.Width;
    _pausePanel.AddChild(background);

    TextRuntime textInstance = new TextRuntime();
    textInstance.Text = &quot;PAUSED&quot;;
    textInstance.CustomFontFile = @&quot;fonts/04b_30.fnt&quot;;
    textInstance.UseCustomFont = true;
    textInstance.FontScale = 0.5f;
    textInstance.X = 10f;
    textInstance.Y = 10f;
    _pausePanel.AddChild(textInstance);

    _resumeButton = new AnimatedButton(_atlas);
    _resumeButton.Text = &quot;RESUME&quot;;
    _resumeButton.Anchor(Anchor.BottomLeft);
    _resumeButton.Visual.X = 9f;
    _resumeButton.Visual.Y = -9f;
    _resumeButton.Click += HandleResumeButtonClicked;
    _pausePanel.AddChild(_resumeButton);

    AnimatedButton quitButton = new AnimatedButton(_atlas);
    quitButton.Text = &quot;QUIT&quot;;
    quitButton.Anchor(Anchor.BottomRight);
    quitButton.Visual.X = -9f;
    quitButton.Visual.Y = -9f;
    quitButton.Click += HandleQuitButtonClicked;

    _pausePanel.AddChild(quitButton);
}
</code></pre><h2 id="testing-the-styled-ui">Testing the Styled UI</h2>
<p>When you run the game now, you will see a dramatic improvement in the visual appearance of the UI:</p>
<ol>
<li>The buttons now use our custom animated background that pulses when focused.</li>
<li>The sliders have a cleaner, mores stylized appearance with the OFF and MAX labels.</li>
<li>All text uses our custom bitmap font.</li>
<li>Visual feedback clearly indicates which element has focus.</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align: center;"><video width="500" height="281" controls=""><source type="video/webm" src="./videos/gameplay.webm"></video></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Figure 21-3: The game using Gum now with custom styled UI components</strong></td>
</tr>
</tbody>
</table>
<p>The entire UI now has a cohesive style that matches the rest of the game.</p>
<h2 id="conclusion">Conclusion</h2>
<p>In this chapter, you learned how to transform basic UI components into custom, styled elements that match the game's visual theme. You explored several key aspects of UI customization:</p>
<ul>
<li>How container hierarchies and size relationships work in Gum.</li>
<li>Creating animation chains for visual feedback.</li>
<li>Using the state system to respond to user interactions.</li>
<li>Building complex custom controls by extending base classes.</li>
<li>Integrating custom fonts and graphics from a texture atlas.</li>
</ul>
<p>By creating reusable custom controls, you have not only improved the look of your game, but you have also developed components that can be used in future projects. This approach of separating functionality from appearance allows you to maintain consistent behavior while completely changing the visual style to match different games.</p>
<p>The principles you have learned in this chapter extend beyond the specific components we created. You can apply the same techniques to create other custom UI elements like checkboxes, radio buttons, scroll panels, and more. By understanding how to build on Gum's foundation, you have the tools to create any UI component your game might need.</p>
<h2 id="test-your-knowledge">Test Your Knowledge</h2>
<ol>
<li><p>What are the two main approaches to customizing visuals in Gum, and when would you use each one?</p>
<p>:::question-answer
The two main approaches are:</p>
<ul>
<li><strong>Direct property assignment</strong>: Setting properties directly in code (like <code>button.Visual.Width = 100</code>). This approach is best for initial setup of UI elements and static properties that do not change during gameplay.</li>
<li><strong>States (StateSave objects)</strong>: Defining different visual states that are applied automatically in response to interactions. This approach is best for dynamic changes that happen during gameplay, like highlighting a button when it is focused or changing colors when a slider is adjusted.</li>
</ul>
<p>:::</p>
</li>
<li><p>What is the purpose of using a top-level container in a custom Gum control?</p>
<p>:::question-answer
A top-level container in a custom Gum control serves several purposes:</p>
<ul>
<li>It provides a single parent element that holds all visual components of the control.</li>
<li>It establishes the coordinate system for positioning child elements.</li>
<li>It can manage the overall size of the control (often using <code>RelativeToChildren</code> sizing).</li>
<li>It serves as the attachment point for states and categories.</li>
<li>It creates a clear separation between the control's visuals and its functionality.</li>
</ul>
<p>:::</p>
</li>
<li><p>How do animation chains work in Gum, and what are the key components needed to create one?</p>
<p>:::question-answer
Animation chains in Gum work by displaying a sequence of frames in order, typically looping after the last frame. The key components needed to create an animation chain are:</p>
<ol>
<li>An <code>AnimationChain</code> object to hold the sequence of frames</li>
<li>Multiple <code>AnimationFrame</code> objects, each with:
<ul>
<li>Texture coordinates (left, right, top, bottom) defining which part of the texture to display</li>
<li>A frame length value determining how long to display the frame</li>
<li>A reference to the texture where the frame appears</li>
</ul>
</li>
<li>A method to add the animation to a visual element (like assigning to a NineSliceRuntime's CurrentChainName)</li>
</ol>
<p>The animation system uses normalized texture coordinates (0.0 to 1.0) rather than pixel coordinates.
:::</p>
</li>
<li><p>What is the relationship between Gum's state system and Forms controls, and why is it important?</p>
<p>:::question-answer
Gum's state system links with Forms controls through specifically named categories and states:</p>
<ul>
<li>Each Forms control type has a reserved category name (e.g., Button.ButtonCategoryName)</li>
<li>Within that category, the control looks for states with specific names (Enabled, Focused, Highlighted, etc.)</li>
<li>When the control's state changes (like gaining focus), it automatically applies the corresponding visual state</li>
</ul>
<p>This relationship is important because it:</p>
<ul>
<li>Separates the control's functionality from its appearance</li>
<li>Enables consistent behavior while allowing complete visual customization</li>
<li>Provides automatic visual feedback in response to user interactions without requiring manual state management</li>
<li>Makes it easier to create controls that work with mouse, keyboard, and gamepad input.</li>
</ul>
<p>:::</p>
</li>
</ol>

</article>
                </div>

            </main>
        </div>


        <script src="https://code.jquery.com/jquery-3.6.3.min.js" integrity="sha256-pvPw+upLPUjgMXY0G+8O0xUf+/Im1MZjXxxgOcBQBXU=" crossorigin="anonymous"></script>
        <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.1/dist/umd/popper.min.js" integrity="sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN" crossorigin="anonymous"></script>
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.min.js" integrity="sha384-+sLIOodYLS7CIrQpBjl+C7nPvqq+FbNUBDunl/OZv93DB7Ln/533i8e/mZXLi/P+" crossorigin="anonymous"></script>
        <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
        <script type="text/javascript" src="../../../../../../styles/jquery.twbsPagination.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/mark.js@8.11.1/dist/jquery.mark.min.js"></script>
        <script type="text/javascript" src="../../../../../../styles/url.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/anchor-js@5.0.0/anchor.min.js"></script>
        <script type="text/javascript" src="../../../../../../styles/docfx.js"></script>
        <script type="text/javascript" src="../../../../../../styles/main.js"></script>
        <script type="text/javascript" src="../../../../../../styles/singulink.js"></script>    </body>
</html>
