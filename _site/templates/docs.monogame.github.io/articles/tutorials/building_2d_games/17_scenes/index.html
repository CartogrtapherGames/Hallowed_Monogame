<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>

    <head>
      <meta charset="utf-8">
      <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
      <title>Chapter 17: Scene Management | hallowed </title>
      <meta name="viewport" content="width=device-width">
      <meta name="title" content="Chapter 17: Scene Management | hallowed ">
      <meta name="generator" content="docfx ">
  
      <link rel="shortcut icon" href="../../../../../../favicon.ico">
      <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/night-owl.min.css">
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css" integrity="sha384-EvBWSlnoFgZlXJvpzS+MAUEjvN7+gcCwH+qh7GRFOGgZO0PuwOFro7qPOJnLfe7l" crossorigin="anonymous">
      <link rel="stylesheet" href="../../../../../../styles/config.css">
      <link rel="stylesheet" href="../../../../../../styles/singulink.css">
      <link rel="stylesheet" href="../../../../../../styles/main.css">
      <meta property="docfx:navrel" content="../../../../../../toc.html">
      <meta property="docfx:tocrel" content="../../../toc.html">
  
  <meta property="docfx:rel" content="../../../../../../">
  
    </head>
    <body>
        <!-- Header required for docfx anchor scroll to work -->
        <header id="head"></header>
        <div class="top-navbar">
            <a class="burger-icon" onclick="toggleMenu()">
                <svg name="Hamburger" style="vertical-align: middle;" width="34" height="34" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" clip-rule="evenodd" d="M20 6H4V9H20V6ZM4 10.999H20V13.999H4V10.999ZM4 15.999H20V18.999H4V15.999Z"></path></svg>
            </a>


            <a class="brand" href="../../../../../../index.html">
              <img src="../../../../../../logo.svg" alt="hallowed" class="logomark">
              <span class="brand-title">hallowed</span>
            </a>        </div>

        <div class="body-content">
            <div id="blackout" class="blackout" onclick="toggleMenu()"></div>

            <nav id="sidebar" role="navigation">
                <div class="sidebar">

                    <div>
                      <div class="mobile-hide">

                        <a class="brand" href="../../../../../../index.html">
                          <img src="../../../../../../logo.svg" alt="hallowed" class="logomark">
                          <span class="brand-title">hallowed</span>
                        </a>                      </div>

                      <div class="sidesearch">
                        <form id="search" role="search" class="search">
                            <i class="bi bi-search search-icon"></i>
                            <input type="text" id="search-query" placeholder="Search" autocomplete="off">
                        </form>
                      </div>

                      <div id="navbar">
                      </div>
                    </div>                    <div class="sidebar-item-separator"></div>

                        <div id="sidetoggle">
                          <div id="sidetoc"></div>
                        </div>
                </div>
                <div class="footer">
  
  <strong><a href='https://dotnet.github.io/docfx/'>DocFX</a> + <a href='https://www.singulink.com'>Singulink</a> = â™¥</strong>
                </div>            </nav>

            <main class="main-panel">

                <div id="search-results" style="display: none;">
                  <h1 class="search-list">Search Results for <span></span></h1>
                  <div class="sr-items">
                    <p><i class="bi bi-hourglass-split index-loading"></i></p>
                  </div>
                  <ul id="pagination" data-first=First data-prev=Previous data-next=Next data-last=Last></ul>
                </div>
 

                <div role="main" class="hide-when-search">

                        <div class="subnav navbar navbar-default">
                          <div class="container hide-when-search" id="breadcrumb">
                            <ul class="breadcrumb">
                              <li></li>
                            </ul>
                          </div>
                        </div>

                         <div class="contribution">
                               <a href="https://github.com/MonoGame/docs.monogame.github.io/blob/main/articles/tutorials/building_2d_games/17_scenes/index.md/#L1" class="contribution-link">Edit this page</a>
                         </div>

                    <article class="content wrap" id="_content" data-uid="">


<p>In game development, a scene (sometimes called a screen or state) represents a distinct section of the game.  Each scene typically has its own update and draw logic, as well as its own set of game objects.  Common examples of scenes include title screens, menus, gameplay screens, game over screens, and more.  Scenes help organize the game's code by separating different parts of the game into self-contained modules.  This makes the code more manageable as the game grows in complexity and offers several advantages:</p>
<ol>
<li><strong>Improved organization</strong>: Each scene contains only the code and assets relevant to that part of the game.</li>
<li><strong>Memory management</strong>: Load assets only when needed and unload them when leaving a scene.</li>
<li><strong>Simplified state handling</strong>: Each scene maintains its own state without affecting others.</li>
<li><strong>Code reusability</strong>: Create reusable scene templates for common game screens.</li>
</ol>
<p>Our game logic is currently contained within the single <code>Game1</code> class.  Adding more screens to it would make the code harder to manage, so instead we need to start thinking about breaking it down into scenes.</p>
<p>In this chapter, you will:</p>
<ul>
<li>Learn the concept of scene management and its benefits</li>
<li>Create a base Scene class with a consistent lifecycle</li>
<li>Implement scene transitions using a manager</li>
<li>Create a title scene and gameplay scene for our game</li>
<li>Refactor our existing game to use the scene system</li>
</ul>
<p>We will begin by first defining the lifecycle of a scene that will be followed.</p>
<h2 id="scene-lifecycle">Scene Lifecycle</h2>
<p>In Chapter 03, you learned the basic <a href="../03_the_game1_file/index.html#exploring-the-game1-class">lifecycle of the <code>Game</code> class</a>.  To be consistent, we can borrow from this lifecycle and adapt it for our scenes. The order of operations for this lifecycle will be:</p>
<ol>
<li>A scene is created and set as the active scene.</li>
<li>The first screen is made active and is initialized and content loaded.</li>
<li>The active scene is updated and drawn each cycle.</li>
<li>When transitioning to a new scene, or when the scene ends:
<ol>
<li>The current scene is unloaded and disposed of.</li>
<li>The new scene is initialized and content loaded.</li>
<li>The new scene becomes the active scene and the cycle begins again until the game is told to exit.</li>
</ol>
</li>
</ol>
<h2 id="the-scene-base-class">The Scene Base Class</h2>
<p>The base <code>Scene</code> class is an abstract class for scenes that provides common functionality for all scenes.  In our actual game, we will create concrete implementations of this, like a title scene.</p>
<p>To get started, in the <em>MonoGameLibrary</em> project:</p>
<ol>
<li><p>Create a new folder named <code>Scenes</code>.</p>
</li>
<li><p>Add a new class file named <code>Scene.cs</code> to the <code>Scenes</code> folder you just created.</p>
</li>
<li><p>Add the following code as the initial structure for the class:</p>
<pre><code class="lang-csharp">using System;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Content;

namespace MonoGameLibrary.Scenes;

public abstract class Scene : IDisposable
{

}
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>Just like with the <code>AudioController</code> in <a href="../15_audio_controller/index.html#audiocontroller-idisposable-implementation">Chapter 15</a>, each <code>Scene</code> implements the <code>IDisposable</code> interface.  This provides a standardized in method to release the resources held by a scene when it is no longer needed.</p>
</div>
</li>
</ol>
<h3 id="scene-properties">Scene Properties</h3>
<p>Add the following properties to the <code>Scene</code> class:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Gets the ContentManager used for loading scene-specific assets.
/// &lt;/summary&gt;
/// &lt;remarks&gt;
/// Assets loaded through this ContentManager will be automatically unloaded when this scene ends.
/// &lt;/remarks&gt;
protected ContentManager Content { get; }

/// &lt;summary&gt;
/// Gets a value that indicates if the scene has been disposed of.
/// &lt;/summary&gt;
public bool IsDisposed { get; private set; }
</code></pre>
<ul>
<li>The <code>Content</code> property is the scene's personal <a href="xref:Microsoft.Xna.Framework.Content.ContentManager"><strong>ContentManager</strong></a> that can be used to load scene specific content that will be unloaded when the scene ends.  This helps manage memory usage by only loading what is needed for a specific scene.</li>
<li>The <code>IsDisposed</code> property is used to track if the scene has been disposed of since it implements the <code>IDisposable</code> interface.</li>
</ul>
<h3 id="scene-constructor">Scene Constructor</h3>
<p>Add the following constructor and finalizer to the <code>Scene</code> class:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Creates a new scene instance.
/// &lt;/summary&gt;
public Scene()
{
    // Create a content manager for the scene
    Content = new ContentManager(Core.Content.ServiceProvider);

    // Set the root directory for content to the same as the root directory
    // for the game's content.
    Content.RootDirectory = Core.Content.RootDirectory;
}

// Finalizer, called when object is cleaned up by garbage collector.
~Scene() =&gt; Dispose(false);
</code></pre>
<ul>
<li>The constructor initializes the scene's content manager and sets the root folder to match that of the base game's content manager.</li>
<li>The finalizer is called by the garbage collector automatically when a scene object is collected which just calls the <code>Dispose</code> method to ensure resources are disposed of properly.</li>
</ul>
<h3 id="scene-methods">Scene Methods</h3>
<p>Add the following methods to the <code>Scene</code> class:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Initializes the scene.
/// &lt;/summary&gt;
/// &lt;remarks&gt;
/// When overriding this in a derived class, ensure that base.Initialize()
/// still called as this is when LoadContent is called.
/// &lt;/remarks&gt;
public virtual void Initialize()
{
    LoadContent();
}

/// &lt;summary&gt;
/// Override to provide logic to load content for the scene.
/// &lt;/summary&gt;
public virtual void LoadContent() { }

/// &lt;summary&gt;
/// Unloads scene-specific content.
/// &lt;/summary&gt;
public virtual void UnloadContent()
{
    Content.Unload();
}

/// &lt;summary&gt;
/// Updates this scene.
/// &lt;/summary&gt;
/// &lt;param name=&quot;gameTime&quot;&gt;A snapshot of the timing values for the current frame.&lt;/param&gt;
public virtual void Update(GameTime gameTime) { }

/// &lt;summary&gt;
/// Draws this scene.
/// &lt;/summary&gt;
/// &lt;param name=&quot;gameTime&quot;&gt;A snapshot of the timing values for the current frame.&lt;/param&gt;
public virtual void Draw(GameTime gameTime) { }
</code></pre>
<p>These methods are setup similar to how the <code>Game</code> class works to keep the workflow consistent:</p>
<ul>
<li><code>Initialize</code> is called only once when the scene becomes the active scene.  It can be overridden by the derived class to provide scene specific initialization logic.  It also calls the <code>LoadContent</code> method the same way the <code>Game</code> class is done for consistency.</li>
<li><code>LoadContent</code> is called only once, at the end of the <code>Initialize</code> method.  It can be overridden by the derived class to load scene specific content.</li>
<li><code>UnloadContent</code> is called only once when a scene is ending due to a transition to a new scene.  It can be overridden by the derived class to perform unloading of any scene specific content.</li>
<li><code>Update</code> is called once at the start of every game cycle. It can be overridden to provide the update logic for the scene.</li>
<li><code>Draw</code> is called once every game cycle, directly after <code>Update</code>.  It can be overridden to provide the draw logic for the scene.</li>
</ul>
<h4 id="idisposable-implementation">IDisposable Implementation</h4>
<p>Add the following methods to the <code>Scene</code> class to complete the implementation of the <code>IDisposable</code> interface:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Disposes of this scene.
/// &lt;/summary&gt;
public void Dispose()
{
    Dispose(true);
    GC.SuppressFinalize(this);
}

/// &lt;summary&gt;
/// Disposes of this scene.
/// &lt;/summary&gt;
/// &lt;param name=&quot;disposing&quot;&gt;'
/// Indicates whether managed resources should be disposed.  This value is only true when called from the main
/// Dispose method.  When called from the finalizer, this will be false.
/// &lt;/param&gt;
protected virtual void Dispose(bool disposing)
{
    if (IsDisposed)
    {
        return;
    }

    if (disposing)
    {
        UnloadContent();
        Content.Dispose();
    }
}
</code></pre>
<p>With the Base scene implementation complete, we can now use it to create actual scenes for our project. The next step is to implement a manager that organizes and coordinates these scenes within the game.</p>
<h2 id="scene-management">Scene Management</h2>
<p>With the base <code>Scene</code> class defined, the <code>Core</code> class needs to be updated to handle management of the scenes, including update, drawing, and changing scenes.  Open the <code>Core.cs</code> file in the <em>MonoGameLibrary</em> project and make the following changes:</p>
<pre><code class="lang-csharp">using System;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;
using MonoGameLibrary.Audio;
using MonoGameLibrary.Input;
using MonoGameLibrary.Scenes;

namespace MonoGameLibrary;

public class Core : Game
{
    internal static Core s_instance;

    /// &lt;summary&gt;
    /// Gets a reference to the Core instance.
    /// &lt;/summary&gt;
    public static Core Instance =&gt; s_instance;

    // The scene that is currently active.
    private static Scene s_activeScene;

    // The next scene to switch to, if there is one.
    private static Scene s_nextScene;

    /// &lt;summary&gt;
    /// Gets the graphics device manager to control the presentation of graphics.
    /// &lt;/summary&gt;
    public static GraphicsDeviceManager Graphics { get; private set; }

    /// &lt;summary&gt;
    /// Gets the graphics device used to create graphical resources and perform primitive rendering.
    /// &lt;/summary&gt;
    public static new GraphicsDevice GraphicsDevice { get; private set; }

    /// &lt;summary&gt;
    /// Gets the sprite batch used for all 2D rendering.
    /// &lt;/summary&gt;
    public static SpriteBatch SpriteBatch { get; private set; }

    /// &lt;summary&gt;
    /// Gets the content manager used to load global assets.
    /// &lt;/summary&gt;
    public static new ContentManager Content { get; private set; }

    /// &lt;summary&gt;
    /// Gets a reference to to the input management system.
    /// &lt;/summary&gt;
    public static InputManager Input { get; private set; }

    /// &lt;summary&gt;
    /// Gets or Sets a value that indicates if the game should exit when the esc key on the keyboard is pressed.
    /// &lt;/summary&gt;
    public static bool ExitOnEscape { get; set; }

    /// &lt;summary&gt;
    /// Gets a reference to the audio control system.
    /// &lt;/summary&gt;
    public static AudioController Audio { get; private set; }

    /// &lt;summary&gt;
    /// Creates a new Core instance.
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;title&quot;&gt;The title to display in the title bar of the game window.&lt;/param&gt;
    /// &lt;param name=&quot;width&quot;&gt;The initial width, in pixels, of the game window.&lt;/param&gt;
    /// &lt;param name=&quot;height&quot;&gt;The initial height, in pixels, of the game window.&lt;/param&gt;
    /// &lt;param name=&quot;fullScreen&quot;&gt;Indicates if the game should start in fullscreen mode.&lt;/param&gt;
    public Core(string title, int width, int height, bool fullScreen)
    {
        // Ensure that multiple cores are not created.
        if (s_instance != null)
        {
            throw new InvalidOperationException($&quot;Only a single Core instance can be created&quot;);
        }

        // Store reference to engine for global member access.
        s_instance = this;

        // Create a new graphics device manager.
        Graphics = new GraphicsDeviceManager(this);

        // Set the graphics defaults
        Graphics.PreferredBackBufferWidth = width;
        Graphics.PreferredBackBufferHeight = height;
        Graphics.IsFullScreen = fullScreen;

        // Apply the graphic presentation changes.
        Graphics.ApplyChanges();

        // Set the window title
        Window.Title = title;

        // Set the core's content manager to a reference of the base Game's
        // content manager.
        Content = base.Content;

        // Set the root directory for content.
        Content.RootDirectory = &quot;Content&quot;;

        // Mouse is visible by default.
        IsMouseVisible = true;

        // Exit on escape is true by default
        ExitOnEscape = true;        
    }

    protected override void Initialize()
    {
        base.Initialize();

        // Set the core's graphics device to a reference of the base Game's
        // graphics device.
        GraphicsDevice = base.GraphicsDevice;

        // Create the sprite batch instance.
        SpriteBatch = new SpriteBatch(GraphicsDevice);

        // Create a new input manager.
        Input = new InputManager();

        // Create a new audio controller.
        Audio = new AudioController();
    }

    protected override void UnloadContent()
    {
        // Dispose of the audio controller.
        Audio.Dispose();

        base.UnloadContent();
    }

    protected override void Update(GameTime gameTime)
    {
        // Update the input manager.
        Input.Update(gameTime);

        // Update the audio controller.
        Audio.Update();

        if (ExitOnEscape &amp;&amp; Input.Keyboard.WasKeyJustPressed(Keys.Escape))
        {
            Exit();
        }

        // if there is a next scene waiting to be switch to, then transition
        // to that scene.
        if (s_nextScene != null)
        {
            TransitionScene();
        }

        // If there is an active scene, update it.
        if (s_activeScene != null)
        {
            s_activeScene.Update(gameTime);
        }

        base.Update(gameTime);
    }

    protected override void Draw(GameTime gameTime)
    {
        // If there is an active scene, draw it.
        if (s_activeScene != null)
        {
            s_activeScene.Draw(gameTime);
        }

        base.Draw(gameTime);
    }

    public static void ChangeScene(Scene next)
    {
        // Only set the next scene value if it is not the same
        // instance as the currently active scene.
        if (s_activeScene != next)
        {
            s_nextScene = next;
        }
    }

    private static void TransitionScene()
    {
        // If there is an active scene, dispose of it.
        if (s_activeScene != null)
        {
            s_activeScene.Dispose();
        }

        // Force the garbage collector to collect to ensure memory is cleared.
        GC.Collect();

        // Change the currently active scene to the new scene.
        s_activeScene = s_nextScene;

        // Null out the next scene value so it does not trigger a change over and over.
        s_nextScene = null;

        // If the active scene now is not null, initialize it.
        // Remember, just like with Game, the Initialize call also calls the
        // Scene.LoadContent
        if (s_activeScene != null)
        {
            s_activeScene.Initialize();
        }
    }
}
</code></pre>
<p>The key changes here are:</p>
<ol>
<li>The <code>using MonoGameLibrary.Scenes;</code> using directive was added so we have access to the <code>Scene</code> class.</li>
<li>The fields <code>_activeScene</code> and <code>_nextScene</code> were added to track which scene is currently active and which scene, if any, to switch to.</li>
<li>In <code>Update</code>:
<ol>
<li>A check is made to see if there is a next scene, and if so, <code>TransitionScene</code> is called to gracefully switch from the current to the next.</li>
<li>A check is made to see if there is an active scene, and if so, updates it.</li>
</ol>
</li>
<li>An override for the <code>Draw</code> method was added where a check is made to see if there is an active scene, and if so, draws it.</li>
<li>The <code>ChangeScene</code> method was added which can be called when we want to tell the core to change from one scene to another one.</li>
<li>The <code>TransitionScene</code> method was added to gracefully switch from the current scene to the next by:
<ol>
<li>Checking if there is an active scene, and disposing it if so.</li>
<li>Triggering garbage collection to reclaim memory from the disposed scene.</li>
<li>Assigning the next scene as the current scene.</li>
<li>Checking if a current scene now exists, and initializing it if so.</li>
</ol>
</li>
</ol>
<div class="TIP">
<h5>Tip</h5>
<p>Notice that we use a two-step process for scene transitions with separate <code>_activeScene</code> and <code>_nextScene</code> fields. This design allows the current scene to complete its update/draw cycle before the transition occurs, preventing potential issues that could arise from changing scenes in the middle of processing. The actual transition happens at a controlled point in the game loop, ensuring clean disposal of the old scene before initializing the new one.</p>
</div>
<h2 id="updating-the-game">Updating the Game</h2>
<p>With the scene architecture in place, we are now ready to update the game by breaking it into separate scenes. We will create two scenes; a title scene and a gameplay scene.  First, however, we need to add an additional SpriteFont Description that will be used during the title scene to display the title of the game. Open the <em>Content.mgcb</em> content project file in the MGCB Editor and perform the following:</p>
<ol>
<li>Right-click the <code>fonts</code> folder and choose <code>Add &gt; New Item...</code>.</li>
<li>Select <code>SpriteFont Description (.spritefont)</code> from the options.</li>
<li>Name the file <code>04B_30_5x</code> and click <code>Create</code>.</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align: center;"><img src="./images/font_added.png" alt="Figure 17-1: The 04B_30_5x.spritefont file created in the MGCB Editor"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Figure 17-1: The <em>04B_30_5x.spritefont</em> file created in the MGCB Editor</strong></td>
</tr>
</tbody>
</table>
<p>Next, open the <em>04B_30_5x.spritefont</em> file in your code editor and make the following changes:</p>
<pre><code class="lang-xml" highlight-lines="4-5">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;XnaContent xmlns:Graphics=&quot;Microsoft.Xna.Framework.Content.Pipeline.Graphics&quot;&gt;
  &lt;Asset Type=&quot;Graphics:FontDescription&quot;&gt;
    &lt;FontName&gt;04B_30.ttf&lt;/FontName&gt;
    &lt;Size&gt;87.5&lt;/Size&gt;
    &lt;Spacing&gt;0&lt;/Spacing&gt;
    &lt;UseKerning&gt;true&lt;/UseKerning&gt;
    &lt;Style&gt;Regular&lt;/Style&gt;
    &lt;CharacterRegions&gt;
      &lt;CharacterRegion&gt;
        &lt;Start&gt;&amp;#32;&lt;/Start&gt;
        &lt;End&gt;&amp;#126;&lt;/End&gt;
      &lt;/CharacterRegion&gt;
    &lt;/CharacterRegions&gt;
  &lt;/Asset&gt;
&lt;/XnaContent&gt;
</code></pre><h3 id="the-title-scene">The Title Scene</h3>
<p>The title scene serves as the game's initial starting point; the first impression the player gets when they launch the game.  For our game, the title scene will display the text for the title of the game and a prompt to inform the player what action to take to start the game.  We will use a simple trick for the title text in order to draw it with a drop shadow to add a bit of visual flair.</p>
<div class="NOTE">
<h5>Note</h5>
<p>As the following screens are specific to our game and are not reusable bits, these will be added to your game project.</p>
<p>Although, if you do end up making screens that are completely reusable, there is nothing wrong with putting them in your Game Library, it is completely up to you.</p>
</div>
<p>To get started, first:</p>
<ol>
<li><p>In your Game project, create a new folder named <code>Scenes</code>.  We will put all of our game specific scenes here.</p>
</li>
<li><p>Add a new class file named <code>TitleScene.cs</code> to the <code>Scenes</code> folder you just created.</p>
</li>
<li><p>Add the following code as the initial structure for the class.</p>
<pre><code class="lang-csharp">using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;
using MonoGameLibrary;
using MonoGameLibrary.Scenes;

namespace DungeonSlime.Scenes;

public class TitleScene : Scene
{

}
</code></pre></li>
</ol>
<h4 id="title-scene-fields">Title Scene Fields</h4>
<p>Add the following fields to the <code>TitleScene</code> class:</p>
<pre><code class="lang-csharp">private const string DUNGEON_TEXT = &quot;Dungeon&quot;;
private const string SLIME_TEXT = &quot;Slime&quot;;
private const string PRESS_ENTER_TEXT = &quot;Press Enter To Start&quot;;

// The font to use to render normal text.
private SpriteFont _font;

// The font used to render the title text.
private SpriteFont _font5x;

// The position to draw the dungeon text at.
private Vector2 _dungeonTextPos;

// The origin to set for the dungeon text.
private Vector2 _dungeonTextOrigin;

// The position to draw the slime text at.
private Vector2 _slimeTextPos;

// The origin to set for the slime text.
private Vector2 _slimeTextOrigin;

// The position to draw the press enter text at.
private Vector2 _pressEnterPos;

// The origin to set for the press enter text when drawing it.
private Vector2 _pressEnterOrigin;
</code></pre>
<ul>
<li>Three <code>const</code> fields (<code>DUNGEON_TEXT</code>, <code>SLIME_TEXT</code>, <code>PRESS_ENTER_TEXT</code>) are added for the text that will be displayed on the title screen.</li>
<li>The <code>_font</code> field stores a reference to the <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteFont"><strong>SpriteFont</strong></a> we will use to draw the press enter prompt with.</li>
<li>The <code>_font5x</code> field stores a reference to the <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteFont"><strong>SpriteFont</strong></a> we will use to draw the dungeon and slime text with that will make up the title of the game.</li>
<li>The <code>_dungeonTextPos</code> and <code>_dungeonTextOrigin</code> fields store the position and origin we will use to draw the &quot;Dungeon&quot; text at.</li>
<li>The <code>_slimeTextPos</code> and <code>_slimeTextOrigin</code> fields store the position and origin we will draw the &quot;Slime&quot; text at.</li>
<li>The <code>_pressEnterPos</code> and <code>_pressEnterOrigin</code> fields store the position and origin we will draw the &quot;Press Enter To Start&quot; text at.</li>
</ul>
<h4 id="title-scene-methods">Title Scene Methods</h4>
<p>The <code>TitleScene</code> class will override the various methods from the base <code>Scene</code> class that it derives from to provide the initialization, content loading, update, and drawing logic.</p>
<h5 id="title-scene-initialize">Title Scene Initialize</h5>
<p>Add the following override for the <code>Initialize</code> method to the <code>TitleScene</code> class:</p>
<pre><code class="lang-csharp">public override void Initialize()
{
    // LoadContent is called during base.Initialize().
    base.Initialize();

    // While on the title screen, we can enable exit on escape so the player
    // can close the game by pressing the escape key.
    Core.ExitOnEscape = true;

    // Set the position and origin for the Dungeon text.
    Vector2 size = _font5x.MeasureString(DUNGEON_TEXT);
    _dungeonTextPos = new Vector2(640, 100);
    _dungeonTextOrigin = size * 0.5f;

    // Set the position and origin for the Slime text.
    size = _font5x.MeasureString(SLIME_TEXT);
    _slimeTextPos = new Vector2(757, 207);
    _slimeTextOrigin = size * 0.5f;

    // Set the position and origin for the press enter text.
    size = _font.MeasureString(PRESS_ENTER_TEXT);
    _pressEnterPos = new Vector2(640, 620);
    _pressEnterOrigin = size * 0.5f;
}
</code></pre>
<ul>
<li>We set the <code>Core.ExitOnEscape</code> to true to allow players to exit the game when on the title screen by pressing the escape key.</li>
<li>The position and origin for the &quot;Dungeon&quot;, &quot;Slime&quot;, and &quot;Press Enter To Start&quot; texts are set.</li>
</ul>
<div class="NOTE">
<h5>Note</h5>
<p>You can see here we are using the <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteFont.MeasureString(System.String)"><strong>MeasureString</strong></a> method for the font to work out how long the text to draw is, we then multiply this by <code>0.5</code> to work out the middle of the text so that we can properly set the origin of the text to its middle.</p>
</div>
<h5 id="title-scene-loadcontent">Title Scene LoadContent</h5>
<p>Add the following override for the <code>LoadContent</code> method to the <code>TitleScene</code> class:</p>
<pre><code class="lang-csharp">public override void LoadContent()
{
    // Load the font for the standard text.
    _font = Core.Content.Load&lt;SpriteFont&gt;(&quot;fonts/04B_30&quot;);

    // Load the font for the title text.
    _font5x = Content.Load&lt;SpriteFont&gt;(&quot;fonts/04B_30_5x&quot;);
}
</code></pre>
<ul>
<li>The <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteFont"><strong>SpriteFont</strong></a> used to draw the &quot;Press Enter To Start&quot; text is loaded using the global content manager.</li>
<li>The <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteFont"><strong>SpriteFont</strong></a> used to draw the &quot;Dungeon&quot; and &quot;Slime&quot; text is loaded using the scene's content manager.</li>
</ul>
<div class="TIP">
<h5>Tip</h5>
<p>Recall from <a href="../05_content_pipeline/index.html#contentmanager-methods">Chapter 05</a> that when a <a href="xref:Microsoft.Xna.Framework.Content.ContentManager"><strong>ContentManager</strong></a> loads an asset for the first time, it caches it internally and the subsequent calls to load that asset will return the cached one instead of performing another disk read.</p>
<p>By using a global content manager here to load assets that are used in multiple scenes, when they loaded in a different scene later, the cached version is returned instead of having to do another disk read, making the content loading more efficient.</p>
</div>
<h5 id="title-scene-update">Title Scene Update</h5>
<p>Add the following override for the <code>Update</code> method to the <code>TitleScene</code> class:</p>
<pre><code class="lang-csharp">public override void Update(GameTime gameTime)
{
    // If the user presses enter, switch to the game scene.
    if (Core.Input.Keyboard.WasKeyJustPressed(Keys.Enter))
    {
        Core.ChangeScene(new GameScene());
    }
}
</code></pre>
<ul>
<li>A check is made to see if the enter key is pressed, and if so, the <code>Core</code> is told to change to the game scene.</li>
</ul>
<div class="NOTE">
<h5>Note</h5>
<p>Your editor might show an error here since we have not created the <code>GameScene</code> class yet.  We will create it in a moment after finishing the title scene.</p>
</div>
<div class="TIP">
<h5>Tip</h5>
<p>You will also notice the Title screen is only checking if the player hits the enter key to start the game, but we are not checking if they hit escape to quit the game, that is because it is already handled in the <code>Core</code> class <code>Update</code> method, if <code>ExitOnEscape</code> is true (as it is here), the game will automatically exit.</p>
</div>
<h5 id="title-scene-draw">Title Scene Draw</h5>
<p>For the final act, add the following override for the <code>Draw</code> method to the <code>TitleScene</code> class:</p>
<pre><code class="lang-csharp">public override void Draw(GameTime gameTime)
{
    Core.GraphicsDevice.Clear(new Color(32, 40, 78, 255));

    // Begin the sprite batch to prepare for rendering.
    Core.SpriteBatch.Begin(samplerState: SamplerState.PointClamp);

    // The color to use for the drop shadow text.
    Color dropShadowColor = Color.Black * 0.5f;

    // Draw the Dungeon text slightly offset from it is original position and
    // with a transparent color to give it a drop shadow.
    Core.SpriteBatch.DrawString(_font5x, DUNGEON_TEXT, _dungeonTextPos + new Vector2(10, 10), dropShadowColor, 0.0f, _dungeonTextOrigin, 1.0f, SpriteEffects.None, 1.0f);

    // Draw the Dungeon text on top of that at its original position.
    Core.SpriteBatch.DrawString(_font5x, DUNGEON_TEXT, _dungeonTextPos, Color.White, 0.0f, _dungeonTextOrigin, 1.0f, SpriteEffects.None, 1.0f);

    // Draw the Slime text slightly offset from it is original position and
    // with a transparent color to give it a drop shadow.
    Core.SpriteBatch.DrawString(_font5x, SLIME_TEXT, _slimeTextPos + new Vector2(10, 10), dropShadowColor, 0.0f, _slimeTextOrigin, 1.0f, SpriteEffects.None, 1.0f);

    // Draw the Slime text on top of that at its original position.
    Core.SpriteBatch.DrawString(_font5x, SLIME_TEXT, _slimeTextPos, Color.White, 0.0f, _slimeTextOrigin, 1.0f, SpriteEffects.None, 1.0f);

    // Draw the press enter text.
    Core.SpriteBatch.DrawString(_font, PRESS_ENTER_TEXT, _pressEnterPos, Color.White, 0.0f, _pressEnterOrigin, 1.0f, SpriteEffects.None, 0.0f);

    // Always end the sprite batch when finished.
    Core.SpriteBatch.End();
}
</code></pre>
<ul>
<li>The back buffer is cleared.</li>
<li>A <code>dropShadowColor</code> is created which is the color black with half transparency.</li>
<li>The &quot;Dungeon&quot; text is drawn, first 10px down and to the left of the actual position using the drop shadow color, then again at its normal position overtop.  Layering this way creates the drop shadow effect.</li>
<li>The &quot;Slime&quot; text is drawn, again offset from its position first using the drop shadow color and then drawn again at its normal position overtop.</li>
<li>Finally, the &quot;Press Enter To Start&quot; text is drawn.</li>
</ul>
<p>With our Title screen in place, it is time to get started with the Game Scene, lets play.</p>
<h3 id="the-game-scene">The Game Scene</h3>
<p>The Game Scene will contain our actual gameplay logic. This scene will handle updating and rendering the slime that the player controls, the bat the slime can eat, collision detection, score tracking, and input handling. Most of this logic has already been implemented in our <code>Game1</code> class in previous chapters, but now we will move it into a dedicated scene class. In the <em>Scenes</em> folder:</p>
<ol>
<li><p>Add a new class file named <code>GameScene.cs</code> in the Game projects <code>Scenes</code> folder.</p>
</li>
<li><p>Add the following code as the initial structure for the class:</p>
<pre><code class="lang-csharp">using System;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Audio;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;
using MonoGameLibrary;
using MonoGameLibrary.Graphics;
using MonoGameLibrary.Input;
using MonoGameLibrary.Scenes;

namespace DungeonSlime.Scenes;

public class GameScene : Scene
{

}
</code></pre></li>
</ol>
<p>The following code is effectively replacing the code we have already written in the original <code>Game1.cs</code> class, so it should look very familiar.  Once complete, we can return to <code>Game1</code> and clear out all the redundant code because it is all nicely tidied up in the new <code>GameScene</code> class.</p>
<h4 id="game-scene-fields">Game Scene Fields</h4>
<p>Add the following fields to the <code>GameScene</code> class:</p>
<pre><code class="lang-csharp">// Defines the slime animated sprite.
private AnimatedSprite _slime;

// Defines the bat animated sprite.
private AnimatedSprite _bat;

// Tracks the position of the slime.
private Vector2 _slimePosition;

// Speed multiplier when moving.
private const float MOVEMENT_SPEED = 5.0f;

// Tracks the position of the bat.
private Vector2 _batPosition;

// Tracks the velocity of the bat.
private Vector2 _batVelocity;

// Defines the tilemap to draw.
private Tilemap _tilemap;

// Defines the bounds of the room that the slime and bat are contained within.
private Rectangle _roomBounds;

// The sound effect to play when the bat bounces off the edge of the screen.
private SoundEffect _bounceSoundEffect;

// The sound effect to play when the slime eats a bat.
private SoundEffect _collectSoundEffect;

// The SpriteFont Description used to draw text
private SpriteFont _font;

// Tracks the players score.
private int _score;

// Defines the position to draw the score text at.
private Vector2 _scoreTextPosition;

// Defines the origin used when drawing the score text.
private Vector2 _scoreTextOrigin;
</code></pre>
<ul>
<li>The <code>_slime</code> and <code>_bat</code> fields store the animated sprites for the player controlled slime and the bat.</li>
<li>The <code>_slimePosition</code> and <code>_batPosition</code> fields track the current position of the slime and bat.</li>
<li>The <code>MOVEMENT_SPEED</code> constant defines the base movement speed for both the slime and bat.</li>
<li>The <code>_batVelocity</code> field tracks the current velocity of the bat as it moves around the screen.</li>
<li>The <code>_tilemap</code> field stores the tilemap that we will load and draw for the level background environment.</li>
<li>The <code>_roomBounds</code> field defines a rectangular boundary that represents the boundary of the room that the slime and bat stays within.</li>
<li>The <code>_bounceSoundEffect</code> and <code>_collectSoundEffect</code> fields store the sound effects to play when the bat bounces off a screen edge or is eaten by the slime.</li>
<li>The <code>_font</code> field stores the font used to display the player's score.</li>
<li>The <code>_score</code> field tracks the player's current score, which increases when the slime eats a bat.</li>
<li>The <code>_scoreTextPosition</code> and <code>_scoreTextOrigin</code> defines the position and origin to use when drawing the score text.</li>
</ul>
<h4 id="game-scene-methods">Game Scene Methods</h4>
<p>The <code>GameScene</code> class will override the various methods from the base <code>Scene</code> class that it derives from to provide the initialization, content loading, update, and drawing logic.</p>
<h5 id="game-scene-initialize">Game Scene Initialize</h5>
<p>Add the following override for the <code>Initialize</code> method to the <code>GameScene</code> class:</p>
<pre><code class="lang-csharp">public override void Initialize()
{
    // LoadContent is called during base.Initialize().
    base.Initialize();

    // During the game scene, we want to disable exit on escape. Instead,
    // the escape key will be used to return back to the title screen
    Core.ExitOnEscape = false;

    Rectangle screenBounds = Core.GraphicsDevice.PresentationParameters.Bounds;

    _roomBounds = new Rectangle(
         (int)_tilemap.TileWidth,
         (int)_tilemap.TileHeight,
         screenBounds.Width - (int)_tilemap.TileWidth * 2,
         screenBounds.Height - (int)_tilemap.TileHeight * 2
     );

    // Initial slime position will be the center tile of the tile map.
    int centerRow = _tilemap.Rows / 2;
    int centerColumn = _tilemap.Columns / 2;
    _slimePosition = new Vector2(centerColumn * _tilemap.TileWidth, centerRow * _tilemap.TileHeight);

    // Initial bat position will the in the top left corner of the room.
    _batPosition = new Vector2(_roomBounds.Left, _roomBounds.Top);

    // Set the position of the score text to align to the left edge of the
    // room bounds, and to vertically be at the center of the first tile.
    _scoreTextPosition = new Vector2(_roomBounds.Left, _tilemap.TileHeight * 0.5f);

    // Set the origin of the text so it is left-centered.
    float scoreTextYOrigin = _font.MeasureString(&quot;Score&quot;).Y * 0.5f;
    _scoreTextOrigin = new Vector2(0, scoreTextYOrigin);

    // Assign the initial random velocity to the bat.
    AssignRandomBatVelocity();
}
</code></pre>
<ul>
<li>We set <code>Core.ExitOnEscape</code> to false because in the gameplay scene, we want to handle the escape key differently; instead of exiting the game, it will return to the title screen.</li>
<li>The room bounds is calculated using the bounds of the screen and adjusting that so that it shrinks by one tile width and height on each edge, which will match with the tilemap wall boundary.</li>
<li>The slime's initial position is set to be the center tile by calculating the center row and column.</li>
<li>The bat's initial position is placed at the top left of the room bounds.</li>
<li>The position and origin of the score text is precalculated.  The height of the text is measured to properly calculate the center origin for vertical positioning.</li>
<li>The <code>AssignRandomBatVelocity</code> method is called to give the bat its initial velocity.</li>
</ul>
<h5 id="game-scene-loadcontent">Game Scene LoadContent</h5>
<p>Add the following override for the <code>LoadContent</code> method to the <code>GameScene</code> class:</p>
<pre><code class="lang-csharp">public override void LoadContent()
{
    // Create the texture atlas from the XML configuration file.
    TextureAtlas atlas = TextureAtlas.FromFile(Core.Content, &quot;images/atlas-definition.xml&quot;);

    // Create the slime animated sprite from the atlas.
    _slime = atlas.CreateAnimatedSprite(&quot;slime-animation&quot;);
    _slime.Scale = new Vector2(4.0f, 4.0f);

    // Create the bat animated sprite from the atlas.
    _bat = atlas.CreateAnimatedSprite(&quot;bat-animation&quot;);
    _bat.Scale = new Vector2(4.0f, 4.0f);

    // Create the tilemap from the XML configuration file.
    _tilemap = Tilemap.FromFile(Content, &quot;images/tilemap-definition.xml&quot;);
    _tilemap.Scale = new Vector2(4.0f, 4.0f);

    // Load the bounce sound effect.
    _bounceSoundEffect = Content.Load&lt;SoundEffect&gt;(&quot;audio/bounce&quot;);

    // Load the collect sound effect.
    _collectSoundEffect = Content.Load&lt;SoundEffect&gt;(&quot;audio/collect&quot;);

    // Load the font.
    _font = Core.Content.Load&lt;SpriteFont&gt;(&quot;fonts/04B_30&quot;);
}
</code></pre>
<ul>
<li>The texture atlas is loaded using the global content manager, and the slime and bat animated sprites are created from it.</li>
<li>The tilemap is loaded using the scene's content manager since they are specific to the gameplay scene.</li>
<li>The sound effects are loaded using the scene's content manager since they are specific to the gameplay scene.</li>
<li>The font is loaded using the global content manager since it is used in multiple scenes.</li>
</ul>
<div class="TIP">
<h5>Tip</h5>
<p>Notice how we are following a consistent pattern across scenes: global assets are loaded with <code>Core.Instance.Content</code> while scene-specific assets are loaded with the scene's <code>Content</code> property.</p>
</div>
<h5 id="game-scene-update">Game Scene Update</h5>
<p>Add the following override for the <code>Update</code> method to the <code>GameScene</code> class:</p>
<pre><code class="lang-csharp">public override void Update(GameTime gameTime)
{
    // Update the slime animated sprite.
    _slime.Update(gameTime);

    // Update the bat animated sprite.
    _bat.Update(gameTime);

    // Check for keyboard input and handle it.
    CheckKeyboardInput();

    // Check for gamepad input and handle it.
    CheckGamePadInput();

    // Creating a bounding circle for the slime.
    Circle slimeBounds = new Circle(
        (int)(_slimePosition.X + (_slime.Width * 0.5f)),
        (int)(_slimePosition.Y + (_slime.Height * 0.5f)),
        (int)(_slime.Width * 0.5f)
    );

    // Use distance based checks to determine if the slime is within the
    // bounds of the game screen, and if it is outside that screen edge,
    // move it back inside.
    if (slimeBounds.Left &lt; _roomBounds.Left)
    {
        _slimePosition.X = _roomBounds.Left;
    }
    else if (slimeBounds.Right &gt; _roomBounds.Right)
    {
        _slimePosition.X = _roomBounds.Right - _slime.Width;
    }

    if (slimeBounds.Top &lt; _roomBounds.Top)
    {
        _slimePosition.Y = _roomBounds.Top;
    }
    else if (slimeBounds.Bottom &gt; _roomBounds.Bottom)
    {
        _slimePosition.Y = _roomBounds.Bottom - _slime.Height;
    }

    // Calculate the new position of the bat based on the velocity.
    Vector2 newBatPosition = _batPosition + _batVelocity;

    // Create a bounding circle for the bat.
    Circle batBounds = new Circle(
        (int)(newBatPosition.X + (_bat.Width * 0.5f)),
        (int)(newBatPosition.Y + (_bat.Height * 0.5f)),
        (int)(_bat.Width * 0.5f)
    );

    Vector2 normal = Vector2.Zero;

    // Use distance based checks to determine if the bat is within the
    // bounds of the game screen, and if it is outside that screen edge,
    // reflect it about the screen edge normal.
    if (batBounds.Left &lt; _roomBounds.Left)
    {
        normal.X = Vector2.UnitX.X;
        newBatPosition.X = _roomBounds.Left;
    }
    else if (batBounds.Right &gt; _roomBounds.Right)
    {
        normal.X = -Vector2.UnitX.X;
        newBatPosition.X = _roomBounds.Right - _bat.Width;
    }

    if (batBounds.Top &lt; _roomBounds.Top)
    {
        normal.Y = Vector2.UnitY.Y;
        newBatPosition.Y = _roomBounds.Top;
    }
    else if (batBounds.Bottom &gt; _roomBounds.Bottom)
    {
        normal.Y = -Vector2.UnitY.Y;
        newBatPosition.Y = _roomBounds.Bottom - _bat.Height;
    }

    // If the normal is anything but Vector2.Zero, this means the bat had
    // moved outside the screen edge so we should reflect it about the
    // normal.
    if (normal != Vector2.Zero)
    {
        normal.Normalize();
        _batVelocity = Vector2.Reflect(_batVelocity, normal);

        // Play the bounce sound effect.
        Core.Audio.PlaySoundEffect(_bounceSoundEffect);
    }

    _batPosition = newBatPosition;

    if (slimeBounds.Intersects(batBounds))
    {
        // Choose a random row and column based on the total number of each
        int column = Random.Shared.Next(1, _tilemap.Columns - 1);
        int row = Random.Shared.Next(1, _tilemap.Rows - 1);

        // Change the bat position by setting the x and y values equal to
        // the column and row multiplied by the width and height.
        _batPosition = new Vector2(column * _bat.Width, row * _bat.Height);

        // Assign a new random velocity to the bat.
        AssignRandomBatVelocity();

        // Play the collect sound effect.
        Core.Audio.PlaySoundEffect(_collectSoundEffect);

        // Increase the player's score.
        _score += 100;
    }
}
</code></pre>
<ul>
<li>The animated sprites for the slime and bat are updated.</li>
<li>Input from keyboard and gamepad is checked with dedicated methods <code>CheckKeyboardInput</code> and <code>CheckGamePadInput</code>.</li>
<li>Collision detection is performed to:
<ul>
<li>Keep the slime within the room bounds.</li>
<li>Make the bat bounce off edges of the room bounds.</li>
<li>Detect when the slime eats the bat.</li>
</ul>
</li>
<li>When the slime eats the bat, the bat respawns in a random location within the room bounds, given a new velocity, the collect sound is played, and the score is increased.</li>
</ul>
<h5 id="game-scene-helper-methods">Game Scene Helper Methods</h5>
<p>Next, add these helper methods to the <code>GameScene</code> class:</p>
<pre><code class="lang-csharp">private void AssignRandomBatVelocity()
{
    // Generate a random angle.
    float angle = (float)(Random.Shared.NextDouble() * Math.PI * 2);

    // Convert angle to a direction vector.
    float x = (float)Math.Cos(angle);
    float y = (float)Math.Sin(angle);
    Vector2 direction = new Vector2(x, y);

    // Multiply the direction vector by the movement speed
    _batVelocity = direction * MOVEMENT_SPEED;
}

private void CheckKeyboardInput()
{
    // Get a reference to the keyboard inof
    KeyboardInfo keyboard = Core.Input.Keyboard;

    // If the escape key is pressed, return to the title screen.
    if (Core.Input.Keyboard.WasKeyJustPressed(Keys.Escape))
    {
        Core.ChangeScene(new TitleScene());
    }

    // If the space key is held down, the movement speed increases by 1.5
    float speed = MOVEMENT_SPEED;
    if (keyboard.IsKeyDown(Keys.Space))
    {
        speed *= 1.5f;
    }

    // If the W or Up keys are down, move the slime up on the screen.
    if (keyboard.IsKeyDown(Keys.W) || keyboard.IsKeyDown(Keys.Up))
    {
        _slimePosition.Y -= speed;
    }

    // if the S or Down keys are down, move the slime down on the screen.
    if (keyboard.IsKeyDown(Keys.S) || keyboard.IsKeyDown(Keys.Down))
    {
        _slimePosition.Y += speed;
    }

    // If the A or Left keys are down, move the slime left on the screen.
    if (keyboard.IsKeyDown(Keys.A) || keyboard.IsKeyDown(Keys.Left))
    {
        _slimePosition.X -= speed;
    }

    // If the D or Right keys are down, move the slime right on the screen.
    if (keyboard.IsKeyDown(Keys.D) || keyboard.IsKeyDown(Keys.Right))
    {
        _slimePosition.X += speed;
    }

    // If the M key is pressed, toggle mute state for audio.
    if (keyboard.WasKeyJustPressed(Keys.M))
    {
        Core.Audio.ToggleMute();
    }

    // If the + button is pressed, increase the volume.
    if (keyboard.WasKeyJustPressed(Keys.OemPlus))
    {
        Core.Audio.SongVolume += 0.1f;
        Core.Audio.SoundEffectVolume += 0.1f;
    }

    // If the - button was pressed, decrease the volume.
    if (keyboard.WasKeyJustPressed(Keys.OemMinus))
    {
        Core.Audio.SongVolume -= 0.1f;
        Core.Audio.SoundEffectVolume -= 0.1f;
    }
}

private void CheckGamePadInput()
{
    // Get the gamepad info for gamepad one.
    GamePadInfo gamePadOne = Core.Input.GamePads[(int)PlayerIndex.One];

    // If the A button is held down, the movement speed increases by 1.5
    // and the gamepad vibrates as feedback to the player.
    float speed = MOVEMENT_SPEED;
    if (gamePadOne.IsButtonDown(Buttons.A))
    {
        speed *= 1.5f;
        GamePad.SetVibration(PlayerIndex.One, 1.0f, 1.0f);
    }
    else
    {
        GamePad.SetVibration(PlayerIndex.One, 0.0f, 0.0f);
    }

    // Check thumbstick first since it has priority over which gamepad input
    // is movement.  It has priority since the thumbstick values provide a
    // more granular analog value that can be used for movement.
    if (gamePadOne.LeftThumbStick != Vector2.Zero)
    {
        _slimePosition.X += gamePadOne.LeftThumbStick.X * speed;
        _slimePosition.Y -= gamePadOne.LeftThumbStick.Y * speed;
    }
    else
    {
        // If DPadUp is down, move the slime up on the screen.
        if (gamePadOne.IsButtonDown(Buttons.DPadUp))
        {
            _slimePosition.Y -= speed;
        }

        // If DPadDown is down, move the slime down on the screen.
        if (gamePadOne.IsButtonDown(Buttons.DPadDown))
        {
            _slimePosition.Y += speed;
        }

        // If DPapLeft is down, move the slime left on the screen.
        if (gamePadOne.IsButtonDown(Buttons.DPadLeft))
        {
            _slimePosition.X -= speed;
        }

        // If DPadRight is down, move the slime right on the screen.
        if (gamePadOne.IsButtonDown(Buttons.DPadRight))
        {
            _slimePosition.X += speed;
        }
    }
}
</code></pre>
<ul>
<li><code>AssignRandomBatVelocity</code>: Calculates a random direction and applies it to the bat's velocity.</li>
<li><code>CheckKeyboardInput</code>: Handles keyboard controls for moving the slime, toggling audio settings, and returning to the title screen.</li>
<li><code>CheckGamePadInput</code>: Handles gamepad controls for moving the slime.</li>
</ul>
<h5 id="game-scene-draw">Game Scene Draw</h5>
<p>Finally, add the following override for the <code>Draw</code> method to the <code>GameScene</code> class:</p>
<pre><code class="lang-csharp">public override void Draw(GameTime gameTime)
{
    // Clear the back buffer.
    Core.GraphicsDevice.Clear(Color.CornflowerBlue);

    // Begin the sprite batch to prepare for rendering.
    Core.SpriteBatch.Begin(samplerState: SamplerState.PointClamp);

    // Draw the tilemap
    _tilemap.Draw(Core.SpriteBatch);

    // Draw the slime sprite.
    _slime.Draw(Core.SpriteBatch, _slimePosition);

    // Draw the bat sprite.
    _bat.Draw(Core.SpriteBatch, _batPosition);

    // Draw the score.
    Core.SpriteBatch.DrawString(
        _font,              // spriteFont
        $&quot;Score: {_score}&quot;, // text
        _scoreTextPosition, // position
        Color.White,        // color
        0.0f,               // rotation
        _scoreTextOrigin,   // origin
        1.0f,               // scale
        SpriteEffects.None, // effects
        0.0f                // layerDepth
    );

    // Always end the sprite batch when finished.
    Core.SpriteBatch.End();
}
</code></pre>
<ul>
<li>The back buffer is cleared.</li>
<li>The tilemap is drawn.</li>
<li>The slime and bat animated sprites are drawn at their current positions.</li>
<li>The player's score is drawn at using its precalculated position and origin so that it is in the top left of the room bounds centered on the wall sprite.</li>
</ul>
<p>This concludes the <code>GameScene</code> class.  With all the logic for our actual gameplay now housed in a single place, we can clean up our project to use it.</p>
<h3 id="updating-the-game1-class">Updating the Game1 Class</h3>
<p>With our scene system and scene classes in place, we can now simplify our main <code>Game1</code> class to just initialize the game and start with the title scene. Open the <code>Game1.cs</code> file and replace its content with the following:</p>
<pre><code class="lang-csharp">using DungeonSlime.Scenes;
using Microsoft.Xna.Framework.Media;
using MonoGameLibrary;

namespace DungeonSlime;

public class Game1 : Core
{
    // The background theme song.
    private Song _themeSong;

    public Game1() : base(&quot;Dungeon Slime&quot;, 1280, 720, false)
    {

    }

    protected override void Initialize()
    {
        base.Initialize();

        // Start playing the background music.
        Audio.PlaySong(_themeSong);

        // Start the game with the title scene.
        ChangeScene(new TitleScene());
    }

    protected override void LoadContent()
    {
        // Load the background theme music.
        _themeSong = Content.Load&lt;Song&gt;(&quot;audio/theme&quot;);
    }
}
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>Feel free to check your homework and compare the original <code>Game1</code> class with the updated version, as well as checking the <code>GameScene</code> class did not lose any functionality (it has not, but you have to be sure!).  Refactoring code to be cleaner and more organised is a careful task.</p>
</div>
<p>The <code>Game1</code> class is now much simpler as most of the game logic has been moved to the appropriate scene classes.</p>
<p>The updates include:</p>
<ol>
<li>Sets up the game window with the constructor parameters.</li>
<li>Overrides the <code>Initialize</code> method to set the title scene as the starting scene.</li>
<li>Overrides the <code>LoadContent</code> method to load the background theme song and start playing it.</li>
</ol>
<p>Running the game now, we can see that once the game screen comes up, the title scene is displayed with the animated slime and the press enter prompt.  The background music starts playing on this scene as well.  Pressing enter from here will switch to the game scene where the game starts and we can play the game implemented thus far.</p>
<table>
<thead>
<tr>
<th style="text-align: center;"><video width="500" height="281" controls=""><source type="video/webm" src="./videos/gameplay.webm"></video></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Figure 17-2: The game launching with the title screen first, then transitioning to the game play screen when enter is pressed</strong></td>
</tr>
</tbody>
</table>
<h2 id="conclusion">Conclusion</h2>
<p>In this chapter, you accomplished the following:</p>
<ul>
<li>Learned about scene management and why it is important for organizing game code.</li>
<li>Created an abstract <code>Scene</code> base class that provides a consistent lifecycle similar to the MonoGame <a href="xref:Microsoft.Xna.Framework.Game"><strong>Game</strong></a> class.</li>
<li>Implemented the <code>IDisposable</code> interface to properly handle resource cleanup.</li>
<li>Extended the <code>Core</code> class to handle scene transitions and management.</li>
<li>Created a <code>TitleScene</code> for the main menu with text prompts and animations.</li>
<li>Created a <code>GameScene</code> that encapsulates the gameplay mechanics.</li>
<li>Refactored the main <code>Game1</code> class to be much simpler by using the scene system.</li>
</ul>
<p>The approach we have taken follows a common pattern in game development, where each scene has control over its own lifecycle and resources. This pattern simplify state management by isolating different game states from one another.  As your game grows in complexity, you could easily extend this system to include additional scenes like a pause menu or a game over screen.</p>
<p>In the next chapter, we will explore <a href="xref:Microsoft.Xna.Framework.Graphics.RenderTarget2D"><strong>RenderTarget2D</strong></a> and how we can use it to add different types of transitions when switching scenes.</p>
<h2 id="test-your-knowledge">Test Your Knowledge</h2>
<ol>
<li><p>What are the main benefits of implementing a scene management system in a game?</p>
<p>:::question-answer
The main benefits include:</p>
<ul>
<li>Improved organization by separating different parts of the game into self-contained modules.</li>
<li>Better memory management by loading assets only when needed and unloading them when leaving a scene.</li>
<li>Simplified state handling as each scene maintains its own state without affecting others.</li>
<li>Increased code reusability through the ability to create reusable scene templates.
:::</li>
</ul>
</li>
<li><p>How does the scene lifecycle in our implementation mirror the MonoGame Game class lifecycle?</p>
<p>:::question-answer
The scene lifecycle mirrors the MonoGame Game class lifecycle by implementing similar methods in the same order:</p>
<ul>
<li><code>Initialize</code> is called once when the scene becomes active.</li>
<li><code>LoadContent</code> is called at the end of the <code>Initialize</code> method.</li>
<li><code>Update</code> is called every frame to update game logic.</li>
<li><code>Draw</code> is called every frame to render the scene.</li>
<li><code>UnloadContent</code> is called when transitioning away from the scene.
:::</li>
</ul>
</li>
<li><p>What is the purpose of having a separate <a href="xref:Microsoft.Xna.Framework.Content.ContentManager"><strong>ContentManager</strong></a> for each scene?</p>
<p>:::question-answer
Having a separate <a href="xref:Microsoft.Xna.Framework.Content.ContentManager"><strong>ContentManager</strong></a> for each scene:</p>
<ul>
<li>Allows scene-specific content to be automatically unloaded when the scene is disposed.</li>
<li>Provides better organization of which assets belong to which scenes.</li>
<li>Improves memory efficiency by only loading assets that are currently needed.</li>
<li>Makes it clear which assets are meant to be used globally versus locally to a scene.
:::</li>
</ul>
</li>
<li><p>When implementing scene transitions, why do we use a two-step process with <code>_nextScene</code> and <code>_activeScene</code>?</p>
<p>:::question-answer
The two-step process with <code>_nextScene</code> and <code>_activeScene</code> is used because:</p>
<ul>
<li>It allows the current scene to complete its update/draw cycle before the transition occurs.</li>
<li>It provides a clean way to handle the disposal of the current scene before initializing the new one.</li>
<li>It ensures that scene transitions happen at a safe point in the game loop.</li>
<li>It prevents potential issues that could occur from immediately changing scenes in the middle of an update or draw operation.
:::</li>
</ul>
</li>
</ol>

</article>
                </div>

            </main>
        </div>


        <script src="https://code.jquery.com/jquery-3.6.3.min.js" integrity="sha256-pvPw+upLPUjgMXY0G+8O0xUf+/Im1MZjXxxgOcBQBXU=" crossorigin="anonymous"></script>
        <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.1/dist/umd/popper.min.js" integrity="sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN" crossorigin="anonymous"></script>
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.min.js" integrity="sha384-+sLIOodYLS7CIrQpBjl+C7nPvqq+FbNUBDunl/OZv93DB7Ln/533i8e/mZXLi/P+" crossorigin="anonymous"></script>
        <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
        <script type="text/javascript" src="../../../../../../styles/jquery.twbsPagination.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/mark.js@8.11.1/dist/jquery.mark.min.js"></script>
        <script type="text/javascript" src="../../../../../../styles/url.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/anchor-js@5.0.0/anchor.min.js"></script>
        <script type="text/javascript" src="../../../../../../styles/docfx.js"></script>
        <script type="text/javascript" src="../../../../../../styles/main.js"></script>
        <script type="text/javascript" src="../../../../../../styles/singulink.js"></script>    </body>
</html>
