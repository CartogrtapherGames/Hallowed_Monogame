<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>

    <head>
      <meta charset="utf-8">
      <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
      <title>Chapter 20: Implementing UI with Gum | hallowed </title>
      <meta name="viewport" content="width=device-width">
      <meta name="title" content="Chapter 20: Implementing UI with Gum | hallowed ">
      <meta name="generator" content="docfx ">
  
      <link rel="shortcut icon" href="../../../../../../favicon.ico">
      <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/night-owl.min.css">
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css" integrity="sha384-EvBWSlnoFgZlXJvpzS+MAUEjvN7+gcCwH+qh7GRFOGgZO0PuwOFro7qPOJnLfe7l" crossorigin="anonymous">
      <link rel="stylesheet" href="../../../../../../styles/config.css">
      <link rel="stylesheet" href="../../../../../../styles/singulink.css">
      <link rel="stylesheet" href="../../../../../../styles/main.css">
      <meta property="docfx:navrel" content="../../../../../../toc.html">
      <meta property="docfx:tocrel" content="../../../toc.html">
  
  <meta property="docfx:rel" content="../../../../../../">
  
    </head>
    <body>
        <!-- Header required for docfx anchor scroll to work -->
        <header id="head"></header>
        <div class="top-navbar">
            <a class="burger-icon" onclick="toggleMenu()">
                <svg name="Hamburger" style="vertical-align: middle;" width="34" height="34" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" clip-rule="evenodd" d="M20 6H4V9H20V6ZM4 10.999H20V13.999H4V10.999ZM4 15.999H20V18.999H4V15.999Z"></path></svg>
            </a>


            <a class="brand" href="../../../../../../index.html">
              <img src="../../../../../../logo.svg" alt="hallowed" class="logomark">
              <span class="brand-title">hallowed</span>
            </a>        </div>

        <div class="body-content">
            <div id="blackout" class="blackout" onclick="toggleMenu()"></div>

            <nav id="sidebar" role="navigation">
                <div class="sidebar">

                    <div>
                      <div class="mobile-hide">

                        <a class="brand" href="../../../../../../index.html">
                          <img src="../../../../../../logo.svg" alt="hallowed" class="logomark">
                          <span class="brand-title">hallowed</span>
                        </a>                      </div>

                      <div class="sidesearch">
                        <form id="search" role="search" class="search">
                            <i class="bi bi-search search-icon"></i>
                            <input type="text" id="search-query" placeholder="Search" autocomplete="off">
                        </form>
                      </div>

                      <div id="navbar">
                      </div>
                    </div>                    <div class="sidebar-item-separator"></div>

                        <div id="sidetoggle">
                          <div id="sidetoc"></div>
                        </div>
                </div>
                <div class="footer">
  
  <strong><a href='https://dotnet.github.io/docfx/'>DocFX</a> + <a href='https://www.singulink.com'>Singulink</a> = â™¥</strong>
                </div>            </nav>

            <main class="main-panel">

                <div id="search-results" style="display: none;">
                  <h1 class="search-list">Search Results for <span></span></h1>
                  <div class="sr-items">
                    <p><i class="bi bi-hourglass-split index-loading"></i></p>
                  </div>
                  <ul id="pagination" data-first=First data-prev=Previous data-next=Next data-last=Last></ul>
                </div>
 

                <div role="main" class="hide-when-search">

                        <div class="subnav navbar navbar-default">
                          <div class="container hide-when-search" id="breadcrumb">
                            <ul class="breadcrumb">
                              <li></li>
                            </ul>
                          </div>
                        </div>

                         <div class="contribution">
                               <a href="https://github.com/MonoGame/docs.monogame.github.io/blob/main/articles/tutorials/building_2d_games/20_implementing_ui_with_gum/index.md/#L1" class="contribution-link">Edit this page</a>
                         </div>

                    <article class="content wrap" id="_content" data-uid="">


<p>In the <a href="../19_user_interface_fundamentals/index.html">previous chapter</a> we explored the fundamental concepts of user interface design. Now we are ready to put these principles into practice by implementing a UI system for our game. While it is possible to build a UI system from scratch, we will take advantage of Gum, a specialized UI framework that simplifies many of the complex aspects of UI implementation.</p>
<p>In this chapter you will:</p>
<ul>
<li>Install and configure the Gum NuGet package.</li>
<li>Learn about Gum's core concepts including Forms and Visuals</li>
<li>Implement UI elements for our game's title scene.</li>
<li>Create a pause menu for the gameplay scene.</li>
<li>Handle input from keyboard, mouse, and gamepads</li>
<li>Integrate the UI system with our existing game architecture.</li>
</ul>
<div class="IMPORTANT">
<h5>Important</h5>
<p>While GUM is used in this tutorial it is only one of many UI libraries available to the MonoGame community, some notable others are <a href="https://github.com/EmptyKeys/UI_Engines">EmptyKeys</a>, <a href="https://github.com/RonenNess/GeonBit.UI">GeonBit.UI</a>, as well as entire Game Frameworks/Engines like <a href="https://github.com/prime31/Nez">Nez</a> that have their own built in UI systems.</p>
<p>Check out the <a href="https://monogame.net/resources/">MonoGame Resources</a> page, as well as <a href="https://github.com/aloisdeniel/awesome-monogame">awesome-monogame</a> from <a href="https://github.com/aloisdeniel">Alois Deniel</a> for even more community offerings.</p>
</div>
<h2 id="what-is-gum">What is Gum?</h2>
<p>Gum is a powerful UI layout engine and framework. It provides a flexible, efficient system capable of producing virtually any UI layout you might need in your games. While originally developed alongside the FlatRedBall game engine, Gum has evolved to work seamlessly with multiple platforms, including MonoGame, which we will be using in this tutorial.</p>
<h3 id="why-use-gum">Why Use Gum?</h3>
<p>Creating a UI system from scratch requires solving many complex problems:</p>
<ol>
<li><strong>Layout Management</strong>: Calculating positions for elements that need to adapt to different screen sizes or content changes.</li>
<li><strong>Input Handling</strong>: Detecting and responding to mouse, keyboard, and gamepad inputs across multiple UI elements.</li>
<li><strong>Visual State Management</strong>: Changing appearances based on user interactions (hovering, focusing, clicking).</li>
<li><strong>Component Hierarchy</strong>: Managing parent-child relationships between elements.</li>
</ol>
<p>Gum addresses these challenges with ready-made solutions, allowing us to focus on the specific needs of our game rather than reinventing the UI wheel. While MonoGame provides the basic tools for drawing graphics and detecting input, it does not include high-level UI abstractions; this is where tools like Gum fill the gap.</p>
<div class="IMPORTANT">
<h5>Important</h5>
<p>This tutorial uses the Gum NuGet package to help with layout and responding to user interactions. This tutorial does not require the use of the Gum editor, we will be doing everything in code.</p>
<p>Keep in mind that while it is possible to build a full UI system without any external dependencies, creating a layout engine is complicated and beyond the scope of this tutorial. Instead, we will be taking advantage of the Gum NuGet package.</p>
<p>Gum is a powerful system enabling the creation of virtually any game UI, and we will be covering some of the basics of its use in this tutorial. The full Gum documentation can be found here: <a href="https://docs.flatredball.com/gum/code/monogame">https://docs.flatredball.com/gum/code/monogame</a></p>
</div>
<h2 id="gum-concepts">Gum Concepts</h2>
<p>Before we dive into implementation, we will explore the core concepts that Gum provides.  Gum simplifies UI development by providing ready-made controls and layout systems that would otherwise require significant effort to build from scratch.</p>
<h3 id="understanding-gums-structure">Understanding Gum's Structure</h3>
<p>Gum organizes UI elements in a hierarchical tree structure, similar to how HTML organizes web elements or how GUI frameworks like WPF or JavaFX structure their interfaces. This hierarchy consists of:</p>
<ol>
<li><strong>The Root Element</strong>: The topmost container in the hierarchy that serves as the entry point for all UI elements.</li>
<li><strong>Containers</strong>: Elements that can hold other elements (like panels or screens).</li>
<li><strong>Controls</strong>: Interactive elements that respond to user input (like buttons or sliders).</li>
<li><strong>Visuals</strong>: The actual graphical representations of UI elements (like text, images, or shapes).</li>
</ol>
<p>When a game using Gum runs, this hierarchy is maintained in memory, with each element knowing its parent and children. The framework automatically handles the flow of events through this hierarchy and manages the drawing of elements according to their positions in the tree.</p>
<h3 id="gum-root-element">Gum Root Element</h3>
<p>All Gum elements must be directly or indirectly added to Gum's root container. This can be done directly wth the <code>AddToRoot()</code> method:</p>
<pre><code class="lang-cs">// Creating a panel and adding it to the root
Panel mainMenuPanel = new Panel();
mainMenuPanel.AddToRoot();
</code></pre>
<p>Or it can be done indirectly by adding a control as a child of an element that has been added to Gum's root container:</p>
<pre><code class="lang-cs">// Creating a panel and adding it to the root
Panel mainMenuPanel = new Panel();
mainMenuPanel.AddToRoot();

// Creating a button and adding it as a child element of the panel
// which indirectly connects it to Gum's root container
Button startButton = new Button();
mainMenuPanel.AddChild(startButton);
</code></pre>
<p>Gum's root element can also be cleared at any time to remove all UI elements:</p>
<pre><code class="lang-cs">// Clear all children from Gum's root container.
GumService.Default.Root.Children.Clear();
</code></pre>
<p>This can be useful when navigating between different scenes to ensure UI elements do not persist from previous scenes:</p>
<pre><code class="lang-cs">public class GameScene
{
    public override void Initialize()
    {
        // Clear all children from Gum's root container that may have been added
        // during the previous scene
        GumService.Default.Root.Children.Clear();

        // Now that it has been cleared, initialize the UI for this scene
        InitializeUI();
    }
}
</code></pre>
<h3 id="anchoring">Anchoring</h3>
<p>In the previous chapter we discussed <a href="../19_user_interface_fundamentals/index.html#anchoring">anchoring</a>, a fundamental UI concept that allows you to position elements relative to specific reference points of their parents.  Gum supports anchoring of Forms controls through the <code>Anchor()</code> method.</p>
<pre><code class="lang-cs">// Creating a panel and adding it to the root
Panel mainMenuPanel = new Panel();
mainMenuPanel.AddToRoot();

// Creating a button and adding it as a child of the panel
// anchored ot the bottom-left of the panel
Button startButton = new Button();
startButton.Anchor(Gum.Wireframe.Anchor.BottomLeft);
mainMenuPanel.AddChild(startButton);
</code></pre>
<p>The following anchor types are supported by Gum:</p>
<table>
<thead>
<tr>
<th>Anchor</th>
<th>Gum Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>TopLeft</td>
<td><code>Gum.Wireframe.Anchor.TopLeft</code></td>
</tr>
<tr>
<td>Top</td>
<td><code>Gum.Wireframe.Anchor.Top</code></td>
</tr>
<tr>
<td>TopRight</td>
<td><code>Gum.Wireframe.Anchor.TopRight</code></td>
</tr>
<tr>
<td>Left</td>
<td><code>Gum.Wireframe.Anchor.Left</code></td>
</tr>
<tr>
<td>Center</td>
<td><code>Gum.Wireframe.Anchor.Center</code></td>
</tr>
<tr>
<td>Right</td>
<td><code>Gum.Wireframe.Anchor.Right</code></td>
</tr>
<tr>
<td>BottomLeft</td>
<td><code>Gum.Wireframe.Anchor.BottomLeft</code></td>
</tr>
<tr>
<td>Bottom</td>
<td><code>Gum.Wireframe.Anchor.Bottom</code></td>
</tr>
<tr>
<td>BottomRight</td>
<td><code>Gum.Wireframe.Anchor.BottomRight</code></td>
</tr>
</tbody>
</table>
<h3 id="docking">Docking</h3>
<p>In the previous chapter, we also discussed <a href="../19_user_interface_fundamentals/index.html#docking">docking</a>, a fundamental UI concept that adjusts an element's size to fill the available space.  Gum supports the docking of Forms controls through their <code>Dock()</code> method.</p>
<pre><code class="lang-cs">// Creating a panel and adding it to the root
Panel mainMenuPanel = new Panel();
mainMenuPanel.AddToRoot();

// Docking the panel to fill the entire root space
mainMenuPanel.Dock(Gum.Wireframe.Dock.Fill);
</code></pre>
<p>The following docking modes are supported by Gum:</p>
<table>
<thead>
<tr>
<th>Anchor</th>
<th>Gum Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Top</td>
<td><code>Gum.Wireframe.Dock.Top</code></td>
<td>Anchors to the top edge and fills horizontally.</td>
</tr>
<tr>
<td>Left</td>
<td><code>Gum.Wireframe.Dock.Left</code></td>
<td>Anchors to the left edge and fills vertically.</td>
</tr>
<tr>
<td>Right</td>
<td><code>Gum.Wireframe.Dock.Right</code></td>
<td>Anchors to the ridge edge and fills vertically.</td>
</tr>
<tr>
<td>Bottom</td>
<td><code>Gum.Wireframe.Dock.Bottom</code></td>
<td>Anchors to the bottom edge and fills horizontally.</td>
</tr>
<tr>
<td>Fill</td>
<td><code>Gum.Wireframe.Dock.Fill</code></td>
<td>Anchors to the center and fills the entire parent area vertically and horizontally.</td>
</tr>
<tr>
<td>FillHorizontally</td>
<td><code>Gum.Wireframe.Dock.FillHorizontally</code></td>
<td>Stretches across the parent's width, filling horizontally.</td>
</tr>
<tr>
<td>FillVertically</td>
<td><code>Gum.Wireframe.Dock.FillVertically</code></td>
<td>Stretches across the parent's height, filling vertically.</td>
</tr>
<tr>
<td>SizeToChildren</td>
<td><code>Gum.Wireframe.Dock.SizeToChildren</code></td>
<td>Automatically sizes vertically and horizontally based on contained child element.</td>
</tr>
</tbody>
</table>
<h3 id="forms-and-visuals">Forms and Visuals</h3>
<p>Two concepts are important when working with Gum: <strong>Forms</strong> and <strong>Visuals</strong>.</p>
<ul>
<li><p><strong>Forms</strong> controls are typical interactive UI elements such as buttons, sliders, and text boxes that handle user interaction through mouse, gamepad, and keyboard inputs.  These controls come with built-in functionality; a button responds visually when focused, while a slider changes its value when clicked on its <em>track</em>.  By using these standardized components, you can maintain consistency throughout your UI implementation.</p>
</li>
<li><p><strong>Visuals</strong> are the graphical display elements that render the actual appearance of UI components. In Gum, Visual elements have the *Runtime suffix (like TextRuntime, ColoredRectangleRuntime, and NineSliceRuntime) and are used to render graphics. They handle the visual representation but have no built-in interaction behavior on their own.</p>
</li>
</ul>
<p>Forms controls provide customization through their <code>Visual</code> property, which serves as a gateway to modifying their appearance and layout. With this property, you can move, resize, restyle, and even completely replace visuals through code.  As we will see when building our UI in the next chapter, this separation between functionality and presentation allows us to create consistent behaviors while adapting the visual style to match our game's aesthetic.</p>
<p>For now, we will examine some of the Forms control types we will use in this chapter.</p>
<h4 id="panel">Panel</h4>
<p>Panels serve as invisible containers that group related UI elements together.  Unlike visible elements that display graphics, panels focus on organization and layout management.</p>
<p>A panel provides several key functions:</p>
<ul>
<li>Groups related elements for easier management.</li>
<li>Controls visibility for entire sections of UI at once.</li>
<li>Establishes a coordinate system for child elements.</li>
<li>Provides a foundation for layout management.</li>
</ul>
<p>Panels are especially useful for creating distinct UI screens, by toggling the visibility of different panels you can implement complete UI state changes with minimal code:</p>
<pre><code class="lang-cs">// Change the state of the UI by hiding one panel and showing another.
mainMenuPanel.IsVisible = false;
optionsPanel.IsVisible = true;
</code></pre>
<p>A common pattern is to set a panel's docking to <code>Fill</code>, which makes it span the entire available area:</p>
<pre><code class="lang-cs">// Make the panel fill the entire screen
mainMenuPanel.Dock(Gum.Wireframe.Dock.Fill);
</code></pre>
<p>This creates a consistent coordinate space for all child elements, allowing them to be positioned relative to the screen.</p>
<h4 id="button">Button</h4>
<p>The <code>Button</code> Forms control type is the primary interactive control for triggering actions in your UI.</p>
<p>Buttons provide:</p>
<ul>
<li>Responses to clicks from mouse, touch, keyboard, or gamepad input.</li>
<li>Visual feedback when focused or hovered.</li>
<li>Raises a <code>Click</code> event when activated.</li>
</ul>
<p>Buttons can be positioned using anchoring to create layouts that adapt to different screen sizes:</p>
<pre><code class="lang-cs">// Creating a button that is anchored to the bottom left.
Button startButton = new Button;
startButton.Anchor(Gum.Wireframe.Anchor.BottomLeft);

// Set the X and Y position so it is 20px from the left edge
// and 20px from the bottom edge.
startButton.Visual.X = 20;
startButton.Visual.Y = -20;
</code></pre>
<p>The <code>Click</code> event is raised whenever the button is activated and provides a standard way to respond regardless of input device:</p>
<pre><code class="lang-cs">startButton.Click += (sender, args) =&gt;
{
    // Handle button click...
    StartGame();
};
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>The <code>Click</code> event for a button is triggered automatically when it is left-clicked by a mouse or pushed via touch controls.  For keyboard and gamepad input, it can only be triggered when the button has focus, which typically happens when the player navigates to it using the tab key or controller.</p>
</div>
<h4 id="slider">Slider</h4>
<p>The <code>Slider</code> Forms control type allows users to select a numeric value from a continuous range.  A slider:</p>
<ul>
<li>Displays and modifies a <code>Value</code> property constrained between a <code>Minimum</code> and <code>Maximum</code> value.</li>
<li>Responds to mouse clicks on its track or by dragging its thumb.</li>
<li>Supports keyboard and gamepad input for incremental adjustments.</li>
<li>Raises events when its value changes.</li>
</ul>
<p>Basic slider setup includes defining its range and establishing event handlers:</p>
<pre><code class="lang-cs">Slider volumeSlider = new Slider();
volumeSlider.Minimum = 0.0f;
volumeSlider.Maximum = 1.0f;
volumeSlider.Value = 0.5f;
volumeSlider.SmallChange = 0.1f;
volumeSlider.LargeChange = 0.2f;
</code></pre>
<p>The <code>SmallChange</code> property sets the increment for keyboard and gamepad adjustments, while the <code>LargeChange</code> property determines the increment when clicking directly on the slider <em>track</em>.</p>
<p>Sliders provide several events for different interaction scenarios:</p>
<ul>
<li><code>ValueChanged</code>: Fires continuously as the value changes (useful for live previews).</li>
<li><code>ValueChangeCompleted</code>: Fires once when the user finishes adjusting the value (useful for applying final settings).</li>
</ul>
<pre><code class="lang-cs">volumeSlider.ValueChanged += (sender, arg) =&gt;
{
    // Handle value changed event...
    UpdateVolume(volumeSlider.Value);
};

volumeSlider.ValueChangedCompleted += (sender, arg) =&gt;
{
    // Handle value change completed event...
    UpdateVolume(volumeSlider.Value);

    // Useful to do things like this here since this fires once
    // the slider value change has completed so it is not constantly
    // triggering ui sound effects.
    PlayUISoundEffect();
};
</code></pre>
<h3 id="property-changes-vs-states">Property Changes vs States</h3>
<p>Gum allows you to customize visuals in two ways:</p>
<ul>
<li>Direct property assignment</li>
<li>Using states.</li>
</ul>
<p>With simple property changes, you can directly assign values in code.  For example, the following code example changes the width of a button:</p>
<pre><code class="lang-cs">startButton.Visual.Width = 100;
</code></pre>
<p>Direct property assignment works well for initial setup, such as positioning elements or setting their dimensions when first creating your UI.  However, when you need visual elements to respond to user interactions (like highlighting a button when it is focused), a different approach is required.</p>
<p>For these dynamic changes, Gum uses a system of <strong>states</strong> (implemented as <code>StateSave</code> objects), each Forms control maintains a collection of named states that are automatically applied in response to specific user interactions.  When a button becomes focused, for instance, Gum looks for and applies a state named &quot;Focused&quot; to alter its appearance.</p>
<div class="NOTE">
<h5>Note</h5>
<p>In the next chapter during the customization pass, we will create states to visually indicate when controls are focused, providing clear feedback to the player.</p>
</div>
<h2 id="updating-our-game-to-use-gum">Updating Our Game To Use Gum</h2>
<p>Now that we have covered the core UI concepts and how Gum will help implement them, we can integrate Gum into our game project.  We will add the framework, initialize it, and prepare it for use in our scenes.</p>
<p>For now we will use the default styling in Gum to quickly iterate and build the UI and do a customization styling pass in the next chapter.</p>
<h3 id="adding-the-gum-nuget-package">Adding the Gum NuGet Package</h3>
<p>Before we can use Gum in our project, we first need to add it using NuGet.  NuGet is a package manager for .NET projects that allows you to add third-party libraries into your project, similar to how we <a href="../04_creating_a_class_library/index.html">created and added our own class library</a>.</p>
<p>To add the Gum NuGet package to our game project, follow the instructions below based on your development environment:</p>
<div class="tabGroup" id="tabgroup_1">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_1_vscode" role="tab" aria-controls="tabpanel_1_vscode" data-tab="vscode" tabindex="0" aria-selected="true">Visual Studio Code</a>
</li>
<li role="presentation">
<a href="#tabpanel_1_vs2022" role="tab" aria-controls="tabpanel_1_vs2022" data-tab="vs2022" tabindex="-1">Visual Studio 2022</a>
</li>
<li role="presentation">
<a href="#tabpanel_1_dotnetcli" role="tab" aria-controls="tabpanel_1_dotnetcli" data-tab="dotnetcli" tabindex="-1">dotnet CLI</a>
</li>
</ul>
<section id="tabpanel_1_vscode" role="tabpanel" data-tab="vscode">

<p>To add the Gum NuGet package in Visual Studio Code:</p>
<ol>
<li>In the <a href="../02_getting_started/index.html#install-the-c-dev-kit-extension"><em>Solution Explorer</em></a> panel, right-click the <code>DungeonSlime</code> project.</li>
<li>Choose <code>Add NuGet Package</code> from the context menu.</li>
<li>Enter <code>Gum.MonoGame</code> in the <code>Add NuGet Package</code> search prompt and press Enter.</li>
<li>When the search finishes, select the <code>Gum.MonoGame</code> package in the results</li>
<li>When prompted for a version choose version <code>2025.8.3.3</code>.</li>
</ol>
</section>
<section id="tabpanel_1_vs2022" role="tabpanel" data-tab="vs2022" aria-hidden="true" hidden="hidden">

<p>To Add the Gum NuGet package in Visual Studio 2022:</p>
<ol>
<li>In the <em>Solution Explorer</em> panel, right-click the <em>DungeonSlime</em> project.</li>
<li>Choose <code>Manage Nuget Packages...</code> from the context menu.</li>
<li>In the NuGet Package Manager window, select the <code>Browse</code> tab if it is not already selected.</li>
<li>In the search box, enter <code>Gum.MonoGame</code>.</li>
<li>Select the &quot;Gum.MonoGame&quot; package from the search results.</li>
<li>On the right, in the version dropdown, select version <code>2025.8.3.3</code> and click the &quot;Install&quot; button.</li>
</ol>
</section>
<section id="tabpanel_1_dotnetcli" role="tabpanel" data-tab="dotnetcli" aria-hidden="true" hidden="hidden">

<p>To add the Gum NuGet package using the dotnet CLI:</p>
<ol>
<li><p>Open a Command Prompt or Terminal window in the same folder as the <code>DungeonSlime.csproj</code> project file.</p>
</li>
<li><p>Enter the following command:</p>
<pre><code class="lang-sh">dotnet add DungeonSlime.csproj package Gum.MonoGame --version 2025.8.3.3
</code></pre>
</li>
</ol>
</section>
</div>

<div class="TIP">
<h5>Tip</h5>
<p>You can verify the package was successfully added by examining your <code>DungeonSlime.csproj</code> file, which should now contain a reference like:</p>
<pre><code class="lang-xml">&lt;PackageReference Include=&quot;Gum.MonoGame&quot; Version=&quot;2025.8.3.3&quot; /&gt;
</code></pre>
</div>
<div class="IMPORTANT">
<h5>Important</h5>
<p>This tutorial uses version <code>2025.8.3.3</code> of Gum, which is the latest version of Gum as of this writing.  That exact version is specified to use in the section above when installing the NuGet package to ensure compatibility throughout this tutorial.  If there are newer versions of Gum available, please consult the <a href="https://docs.flatredball.com/gum/gum-tool/upgrading">Gum documentation</a> before updating in case there are any breaking changes from the code that is presented in this tutorial.</p>
</div>
<h3 id="adding-ui-sound-effect">Adding UI Sound Effect</h3>
<p>To make our UI more responsive and engaging, we will add audio feedback that plays when players interact with buttons and other UI elements. Sound effects provide immediate confirmation that an input has been recognized, creating a more engaging experience.</p>
<p>First, download the UI sound effect by right-clicking the following link and saving it as <code>ui.wav</code> in the game project's <code>Content/audio</code> folder:</p>
<ul>
<li><a href="./files/ui.wav">ui.wav</a>{download}</li>
</ul>
<p>Next, add this sound effect to your content project using the MGCB Editor:</p>
<ol>
<li>Open the <code>Content.mgcb</code> content project file in the MGCB Editor.</li>
<li>Right-click the <code>audio</code> folder and choose <code>Add &gt; Existing Item...</code>.</li>
<li>Navigate to and select the <code>ui.wav</code> file you just downloaded.</li>
<li>In the Properties panel, verify that the <code>Processor</code> is set to <code>Sound Effect</code>.</li>
<li>Save the changes and close the MGCB Editor.</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align: center;"><img src="./images/mgcb-editor.png" alt="Figure 20-1: The MGCB Editor with ui.wav added to the audio folder"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Figure 20-1: The MGCB Editor with ui.wav added to the audio folder</strong></td>
</tr>
</tbody>
</table>
<p>We will load and use this sound effect in our UI implementation to provide auditory feedback when players interact with buttons and sliders.</p>
<h3 id="initializing-gum">Initializing Gum</h3>
<p>With the Gum NuGet package added to our project, we need to initialize Gum in our game, this will enable the UI system and configure input handling for our controls.  Since this is an initialization that only needs to happen once, we can make the necessary changes to the <code>Game1</code> class.</p>
<p>First, open the <code>Game1.cs</code> file and add the following new using statements to the top:</p>
<pre><code class="lang-csharp" highlight-lines="2-5">using DungeonSlime.Scenes;
using Gum.Forms;
using Gum.Forms.Controls;
using MonoGameLibrary;
using MonoGameGum;
using Microsoft.Xna.Framework.Media;
</code></pre>
<p>Next, add the following method to the <code>Game1</code> class to encapsulate the initializations of the Gum UI service:</p>
<pre><code class="lang-csharp">private void InitializeGum()
{
    // Initialize the Gum service. The second parameter specifies
    // the version of the default visuals to use. V2 is the latest
    // version.
    GumService.Default.Initialize(this, DefaultVisualsVersion.V2);

    // Tell the Gum service which content manager to use.  We will tell it to
    // use the global content manager from our Core.
    GumService.Default.ContentLoader.XnaContentManager = Core.Content;

    // Register keyboard input for UI control.
    FrameworkElement.KeyboardsForUiControl.Add(GumService.Default.Keyboard);

    // Register gamepad input for Ui control.
    FrameworkElement.GamePadsForUiControl.AddRange(GumService.Default.Gamepads);

    // Customize the tab reverse UI navigation to also trigger when the keyboard
    // Up arrow key is pushed.
    FrameworkElement.TabReverseKeyCombos.Add(
       new KeyCombo() { PushedKey = Microsoft.Xna.Framework.Input.Keys.Up });

    // Customize the tab UI navigation to also trigger when the keyboard
    // Down arrow key is pushed.
    FrameworkElement.TabKeyCombos.Add(
       new KeyCombo() { PushedKey = Microsoft.Xna.Framework.Input.Keys.Down });

    // The assets created for the UI were done so at 1/4th the size to keep the size of the
    // texture atlas small.  So we will set the default canvas size to be 1/4th the size of
    // the game's resolution then tell gum to zoom in by a factor of 4.
    GumService.Default.CanvasWidth = GraphicsDevice.PresentationParameters.BackBufferWidth / 4.0f;
    GumService.Default.CanvasHeight = GraphicsDevice.PresentationParameters.BackBufferHeight / 4.0f;
    GumService.Default.Renderer.Camera.Zoom = 4.0f;
}
</code></pre>
<p>Finally, update the <a href="xref:Microsoft.Xna.Framework.Game.Initialize"><strong>Initialize</strong></a> method to call the <code>InitializeGum</code> method we just created:</p>
<pre><code class="lang-csharp" highlight-lines="8-9">protected override void Initialize()
{
   base.Initialize();

   // Start playing the background music
   Audio.PlaySong(_themeSong);

   // Initialize the Gum UI service
   InitializeGum();

   // Start the game with the title scene.
   ChangeScene(new TitleScene());
}
</code></pre>
<p>The following is a breakdown of this initialization process:</p>
<ol>
<li><p><strong>Basic Initialization</strong>: <code>GumService.Default.Initialize(this, DefaultVisualsVersion.V2)</code> sets up the Gum system with our game instance.  This is required for any gum project. The second parameter specifies the default visual styling. V2 is the latest version which makes it easy to style the default controls.</p>
<div class="NOTE">
<h5>Note</h5>
<p>We only need to pass our <a href="xref:Microsoft.Xna.Framework.Game"><strong>Game</strong></a> instance and the visuals version since we are using Gum as a code-first approach.  Gum also offers a visual editor that creates Gum project files. When using the editor, you will need to also pass the Gum Project file to <code>Initialize</code>. For more information on how to use the Gum visual editor, see the <a href="https://docs.flatredball.com/gum/code/monogame/tutorials/gum-project-forms-tutorial">Gum Project Forms Tutorial</a>.</p>
</div>
</li>
<li><p><strong>Content Loading</strong>: Gum needs to be made aware of which content manager to use to load assets through the content pipeline.  By setting <code>GumService.Default.ContentLoader.XnaContentManager = Core.Content</code>, we tell Gum to use our game's content manager when loading assets.  By using the game's existing content manager, Gum also gets the benefit of the caching that the content manager performs when loading assets.</p>
</li>
<li><p><strong>Input Configuration</strong>:</p>
<ul>
<li>By default, all Forms controls automatically respond to mouse and touch screen input devices.  We need to explicitly register keyboard and gamepad input devices by using th <code>FrameworkElement.KeyboardsForUiControl</code> and <code>Framework.GamePadsForUiControl</code> properties.</li>
<li>By default, Forms controls will automatically respond to tab and shift-tab for navigation. By using the <code>FrameworkElement.TabKeyCombos</code> and <code>FrameworkElement.TabReverseKeyCombos</code> properties, we can add additional key combinations for tabbing.  Here we map the Up arrow for reverse tabbing and the Down arrow for forward tabbing.</li>
</ul>
<div class="TIP">
<h5>Tip</h5>
<p>If you prefer different navigation keys, you can remove the built-in Tab/Shift+Tab navigation.</p>
<p>Simply call these methods before adding your custom combinations:</p>
<pre><code class="lang-cs">FrameworkElement.TabKeyCombos.Clear();
FrameworkElement.TabReverseKeyCombos.Clear();
</code></pre>
</div>
</li>
<li><p><strong>UI Scaling</strong>:  Gum allows us to independently scale the UI regardless of the resolution of the game.  Our game is set to a resolution of 1280x720, however as we will see during the styling section later, the UI assets created were done at one-fourth the size to reduce the size of the texture atlas.  Here, we use the <code>GumService.Default.CanvasWidth</code> and <code>GumService.Default.CanvasHeight</code>  properties to set the canvas size to one-fourth that of our game's resolution. Then using by setting the <code>GumService.Default.Renderer.Camera.Zoom</code> property to four, we effectively make it render the UI at full resolution.</p>
</li>
</ol>
<p>Gum is now fully initialized and we can use it in our scenes to add UI to our game.</p>
<h3 id="adding-titlescene-ui">Adding TitleScene UI</h3>
<p>With Gum added and initialized in our game, we can now implement UI elements for our title scene.  We will create panels for both the main menu and options menu, implement the necessary event handlers, and integrate everything with our existing title scene.</p>
<div class="NOTE">
<h5>Note</h5>
<p>When adding these sections one by one, you may see compiler errors until all sections are in place. This is normal, as some parts of the code will reference fields or methods that haven't been added yet. Once all sections are complete, these errors will resolve.</p>
</div>
<p>First, open the <em>TitleScene.cs</em> file in the game project and add the following using declarations to the top of the <code>TitleScene</code> class:</p>
<pre><code class="lang-csharp" highlight-lines="1,3,6-8">using System;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Audio;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;
using MonoGameGum;
using Gum.Forms.Controls;
using MonoGameGum.GueDeriving;
using MonoGameLibrary;
using MonoGameLibrary.Scenes;
</code></pre>
<p>Next, add the following fields to the <code>TitleScene</code> class:</p>
<pre><code class="lang-csharp">private SoundEffect _uiSoundEffect;
private Panel _titleScreenButtonsPanel;
private Panel _optionsPanel;
private Button _optionsButton;
private Button _optionsBackButton;
</code></pre><h4 id="creating-the-title-panel">Creating the Title Panel</h4>
<p>First, create a new method that builds our main menu panel with start and options buttons.</p>
<p>Add the following method to the <code>TitleScene</code> class:</p>
<pre><code class="lang-csharp">private void CreateTitlePanel()
{
    // Create a container to hold all of our buttons
    _titleScreenButtonsPanel = new Panel();
    _titleScreenButtonsPanel.Dock(Gum.Wireframe.Dock.Fill);
    _titleScreenButtonsPanel.AddToRoot();

    var startButton = new Button();
    startButton.Anchor(Gum.Wireframe.Anchor.BottomLeft);
    startButton.Visual.X = 50;
    startButton.Visual.Y = -12;
    startButton.Visual.Width = 70;
    startButton.Text = &quot;Start&quot;;
    startButton.Click += HandleStartClicked;
    _titleScreenButtonsPanel.AddChild(startButton);

    _optionsButton = new Button();
    _optionsButton.Anchor(Gum.Wireframe.Anchor.BottomRight);
    _optionsButton.Visual.X = -50;
    _optionsButton.Visual.Y = -12;
    _optionsButton.Visual.Width = 70;
    _optionsButton.Text = &quot;Options&quot;;
    _optionsButton.Click += HandleOptionsClicked;
    _titleScreenButtonsPanel.AddChild(_optionsButton);

    startButton.IsFocused = true;
}
</code></pre>
<p>Our title panel includes two buttons positioned at the bottom corners of the screen.  The &quot;Start&quot; button will allow players to begin the game while the &quot;Options&quot; button will hide the main menu and display the options menu.</p>
<div class="NOTE">
<h5>Note</h5>
<p>Notice how we use <code>Anchor</code> to position the buttons relative to the panel's edges, with the &quot;Start&quot; button anchored at the bottom left and the &quot;Options&quot; button anchored at the bottom right.  Then the positioning of the elements is adjusted relative to its anchor point.</p>
</div>
<p>Each button registers a <code>Click</code> event handler to respond when the players selects it, we should implement the event handler method for these buttons next.  First we will implement the handler for the &quot;Start&quot; button.  Add the following method to the <code>TitleScene</code> class after the <code>CreateTitlePanel</code> method:</p>
<pre><code class="lang-csharp">private void HandleStartClicked(object sender, EventArgs e)
{
    // A UI interaction occurred, play the sound effect
    Core.Audio.PlaySoundEffect(_uiSoundEffect);

    // Change to the game scene to start the game.
    Core.ChangeScene(new GameScene());
}
</code></pre>
<p>When the &quot;Start&quot; button is clicked and this method is called, it will play the UI sound effect for auditory feedback then change the scene to the game scene so the player can start playing the game.</p>
<p>Next is the handler for the &quot;Options&quot; button.  Add the following method to the <code>TitleScene</code> class after the <code>HandleStartClicked</code> method:</p>
<pre><code class="lang-csharp">private void HandleOptionsClicked(object sender, EventArgs e)
{
    // A UI interaction occurred, play the sound effect
    Core.Audio.PlaySoundEffect(_uiSoundEffect);
    
    // Set the title panel to be invisible.
    _titleScreenButtonsPanel.IsVisible = false;

    // Set the options panel to be visible.
    _optionsPanel.IsVisible = true;

    // Give the back button on the options panel focus.
    _optionsBackButton.IsFocused = true;
}
</code></pre>
<p>When the &quot;Options&quot; button is clicked and this method is called, it will play the UI sound effect for auditory feedback then hide the title panel and show the options panel.</p>
<h4 id="creating-the-options-panel">Creating the Options Panel</h4>
<p>Next, we will create the options panel with sliders to adjust the volume for music and sound effects.</p>
<p>Add the following method to the <code>TitleScene</code> class:</p>
<pre><code class="lang-csharp">private void CreateOptionsPanel()
{
    _optionsPanel = new Panel();
    _optionsPanel.Dock(Gum.Wireframe.Dock.Fill);
    _optionsPanel.IsVisible = false;
    _optionsPanel.AddToRoot();

    var optionsText = new TextRuntime();
    optionsText.X = 10;
    optionsText.Y = 10;
    optionsText.Text = &quot;OPTIONS&quot;;
    _optionsPanel.AddChild(optionsText);

    var musicSlider = new Slider();
    musicSlider.Anchor(Gum.Wireframe.Anchor.Top);
    musicSlider.Visual.Y = 30f;
    musicSlider.Minimum = 0;
    musicSlider.Maximum = 1;
    musicSlider.Value = Core.Audio.SongVolume;
    musicSlider.SmallChange = .1;
    musicSlider.LargeChange = .2;
    musicSlider.ValueChanged += HandleMusicSliderValueChanged;
    musicSlider.ValueChangeCompleted += HandleMusicSliderValueChangeCompleted;
    _optionsPanel.AddChild(musicSlider);

    var sfxSlider = new Slider();
    sfxSlider.Anchor(Gum.Wireframe.Anchor.Top);
    sfxSlider.Visual.Y = 93;
    sfxSlider.Minimum = 0;
    sfxSlider.Maximum = 1;
    sfxSlider.Value = Core.Audio.SoundEffectVolume;
    sfxSlider.SmallChange = .1;
    sfxSlider.LargeChange = .2;
    sfxSlider.ValueChanged += HandleSfxSliderChanged;
    sfxSlider.ValueChangeCompleted += HandleSfxSliderChangeCompleted;
    _optionsPanel.AddChild(sfxSlider);

    _optionsBackButton = new Button();
    _optionsBackButton.Text = &quot;BACK&quot;;
    _optionsBackButton.Anchor(Gum.Wireframe.Anchor.BottomRight);
    _optionsBackButton.X = -28f;
    _optionsBackButton.Y = -10f;
    _optionsBackButton.Click += HandleOptionsButtonBack;
    _optionsPanel.AddChild(_optionsBackButton);
}
</code></pre>
<p>This panel includes a text label, two sliders for adjusting audio volumes, and a back button for returning to the main menu. The panel is initially invisible since we start on the main menu.  Both the &quot;Music Volume&quot; slider and the &quot;Sound Effects Volume&quot; slider register events to be called when the value of the sliders change and when the value change has been completed.  The &quot;Back&quot; button registers a click event similar to the ones from the main menu.</p>
<p>Now we should implement the event handlers for these controls.  First, we will implement the handler for when the value of the sound effect volume slider changes.  Add the following method to the <code>TitleScene</code> class after the <code>CreateOptionsPanel</code> method:</p>
<pre><code class="lang-csharp">private void HandleSfxSliderChanged(object sender, EventArgs args)
{
    // Intentionally not playing the UI sound effect here so that it is not
    // constantly triggered as the user adjusts the slider's thumb on the
    // track.

    // Get a reference to the sender as a Slider.
    var slider = (Slider)sender;

    // Set the global sound effect volume to the value of the slider.;
    Core.Audio.SoundEffectVolume = (float)slider.Value;
}
</code></pre>
<p>When the value of the &quot;Sound Effects Volume&quot; slider changes and this method is called, a reference to the slider is captured and then the the global sound effect volume is adjusted based on the value of the slider.</p>
<p>Next is the handler when the &quot;Sound Effects Volume&quot; slider has completed a value change.  Add the following method to the <code>TitleScene</code> class after the <code>HandleSfxSliderChanged</code> method:</p>
<pre><code class="lang-csharp">private void HandleSfxSliderChangeCompleted(object sender, EventArgs e)
{
    // Play the UI Sound effect so the player can hear the difference in audio.
    Core.Audio.PlaySoundEffect(_uiSoundEffect);
}
</code></pre>
<p>When the value of the &quot;Sound Effects Volume&quot; slider has completed a change and this method is called, it plays the UI sound effect to provide auditory feedback so the player can hear the difference in volume.</p>
<p>Next, add the handler for changes to the 'Music Volume' slider. Place the following method in the TitleScene class, directly after the HandleSfxSliderChangeCompleted method:</p>
<pre><code class="lang-csharp">private void HandleMusicSliderValueChanged(object sender, EventArgs args)
{
    // Intentionally not playing the UI sound effect here so that it is not
    // constantly triggered as the user adjusts the slider's thumb on the
    // track.

    // Get a reference to the sender as a Slider.
    var slider = (Slider)sender;

    // Set the global song volume to the value of the slider.
    Core.Audio.SongVolume = (float)slider.Value;
}
</code></pre>
<p>Similar to how we handled the &quot;Sound Effect Volume&quot; slider value changes, when the &quot;Music Volume&quot; slider value changes and this method is called, a reference to the slider is captured and then the global music volume is adjusted based on the value of the slider.</p>
<p>Next is the handler when the &quot;Music Volume&quot; slider value has completed a value change.  Add the following method to the <code>TitleScene</code> class after the <code>HandleMusicSliderValueChanged</code> method:</p>
<pre><code class="lang-csharp">private void HandleMusicSliderValueChangeCompleted(object sender, EventArgs args)
{
    // A UI interaction occurred, play the sound effect
    Core.Audio.PlaySoundEffect(_uiSoundEffect);
}
</code></pre>
<p>When the value of the &quot;Music Volume&quot; slider has completed a change, the UI sound effect is played to provide auditory feedback.</p>
<p>Finally, we need to add the handler for when the &quot;Back&quot; button is clicked on the options panel.  Add the following method to the <code>TitleScene</code> class after the <code>HandleMusicSliderValueChangeCompleted</code> method:</p>
<pre><code class="lang-csharp">private void HandleOptionsButtonBack(object sender, EventArgs e)
{
    // A UI interaction occurred, play the sound effect
    Core.Audio.PlaySoundEffect(_uiSoundEffect);

    // Set the title panel to be visible.
    _titleScreenButtonsPanel.IsVisible = true;

    // Set the options panel to be invisible.
    _optionsPanel.IsVisible = false;

    // Give the options button on the title panel focus since we are coming
    // back from the options screen.
    _optionsButton.IsFocused = true;
}
</code></pre>
<p>This method plays the UI sound effect for auditory feedback, then hides the options panel and shows the title panel.</p>
<div class="TIP">
<h5>Tip</h5>
<p>Notice that for both sliders, we registered a method for the <code>ValueChangeCompleted</code> event.  This is so we can play the UI sound effect only when the player has finished adjusting the slider value. If we had instead played the UI sound effect in the <code>ValueChanged</code> event, then the UI sound effect would trigger constantly while the slider is being adjusted if using a mouse to drag it.</p>
</div>
<h4 id="initializing-the-ui">Initializing the UI</h4>
<p>Now that we have implemented the methods that will create both the main menu panel and the options menu panel, we need to implement the main UI initializations method that will call them.  Add the following method to the <code>TitleScene</code> class after the <code>HandleOptionsButtonBack</code> method:</p>
<pre><code class="lang-csharp">private void InitializeUI()
{
    // Clear out any previous UI in case we came here from
    // a different screen:
    GumService.Default.Root.Children.Clear();

    CreateTitlePanel();
    CreateOptionsPanel();
}
</code></pre>
<p>This method first clears any existing UI elements from Gum's root container to prevent duplication, then calls our panel creation methods to build the complete interface.</p>
<h4 id="integrating-with-the-game-loop">Integrating with the Game Loop</h4>
<p>Finally, we need to integrate our UI initialization, update, and draw with the scene's lifecycle.  First, add the call to <code>InitializeUI()</code> in the <code>Initialize</code> method by updating it to the following:</p>
<pre><code highlight-lines="27">public override void Initialize()
{
    // LoadContent is called during base.Initialize().
    base.Initialize();

    // While on the title screen, we can enable exit on escape so the player
    // can close the game by pressing the escape key.
    Core.ExitOnEscape = true;

    // Set the position and origin for the Dungeon text.
    Vector2 size = _font5x.MeasureString(DUNGEON_TEXT);
    _dungeonTextPos = new Vector2(640, 100);
    _dungeonTextOrigin = size * 0.5f;

    // Set the position and origin for the Slime text.
    size = _font5x.MeasureString(SLIME_TEXT);
    _slimeTextPos = new Vector2(757, 207);
    _slimeTextOrigin = size * 0.5f;

    // Initialize the offset of the background pattern at zero
    _backgroundOffset = Vector2.Zero;

    // Set the background pattern destination rectangle to fill the entire
    // screen background
    _backgroundDestination = Core.GraphicsDevice.PresentationParameters.Bounds;

    InitializeUI();
}
</code></pre>
<p>Next, update the <code>LoadContent</code> method to load the sound effect that will be used as auditory feedback for the UI:</p>
<pre><code highlight-lines="12-13">public override void LoadContent()
{
   // Load the font for the standard text.
   _font = Core.Content.Load&lt;SpriteFont&gt;(&quot;fonts/04B_30&quot;);

   // Load the font for the title text
   _font5x = Content.Load&lt;SpriteFont&gt;(&quot;fonts/04B_30_5x&quot;);

   // Load the background pattern texture.
   _backgroundPattern = Content.Load&lt;Texture2D&gt;(&quot;images/background-pattern&quot;);

   // Load the sound effect to play when ui actions occur.
   _uiSoundEffect = Core.Content.Load&lt;SoundEffect&gt;(&quot;audio/ui&quot;);
}
</code></pre>
<p>Next modify the <code>Update</code> method to include Gum's update logic:</p>
<pre><code highlight-lines="14">public override void Update(GameTime gameTime)
{
    // Update the offsets for the background pattern wrapping so that it
    // scrolls down and to the right.
    float offset = _scrollSpeed * (float)gameTime.ElapsedGameTime.TotalSeconds;
    _backgroundOffset.X -= offset;
    _backgroundOffset.Y -= offset;

    // Ensure that the offsets do not go beyond the texture bounds so it is
    // a seamless wrap
    _backgroundOffset.X %= _backgroundPattern.Width;
    _backgroundOffset.Y %= _backgroundPattern.Height;

    GumService.Default.Update(gameTime);
}
</code></pre>
<p>Finally, the <code>Draw</code> method needs to be updated to:</p>
<ol>
<li>Only show the text for the game title when the title panel is visible</li>
<li>Add Gum's drawing call to draw the user interface</li>
</ol>
<p>Update the <code>Draw</code> method to the following:</p>
<pre><code highlight-lines="10-34,36">public override void Draw(GameTime gameTime)
{
    Core.GraphicsDevice.Clear(new Color(32, 40, 78, 255));

    // Draw the background pattern first using the PointWrap sampler state.
    Core.SpriteBatch.Begin(samplerState: SamplerState.PointWrap);
    Core.SpriteBatch.Draw(_backgroundPattern, _backgroundDestination, new Rectangle(_backgroundOffset.ToPoint(), _backgroundDestination.Size), Color.White * 0.5f);
    Core.SpriteBatch.End();

    if (_titleScreenButtonsPanel.IsVisible)
    {
        // Begin the sprite batch to prepare for rendering.
        Core.SpriteBatch.Begin(samplerState: SamplerState.PointClamp);

        // The color to use for the drop shadow text.
        Color dropShadowColor = Color.Black * 0.5f;

        // Draw the Dungeon text slightly offset from it is original position and
        // with a transparent color to give it a drop shadow
        Core.SpriteBatch.DrawString(_font5x, DUNGEON_TEXT, _dungeonTextPos + new Vector2(10, 10), dropShadowColor, 0.0f, _dungeonTextOrigin, 1.0f, SpriteEffects.None, 1.0f);

        // Draw the Dungeon text on top of that at its original position
        Core.SpriteBatch.DrawString(_font5x, DUNGEON_TEXT, _dungeonTextPos, Color.White, 0.0f, _dungeonTextOrigin, 1.0f, SpriteEffects.None, 1.0f);

        // Draw the Slime text slightly offset from it is original position and
        // with a transparent color to give it a drop shadow
        Core.SpriteBatch.DrawString(_font5x, SLIME_TEXT, _slimeTextPos + new Vector2(10, 10), dropShadowColor, 0.0f, _slimeTextOrigin, 1.0f, SpriteEffects.None, 1.0f);

        // Draw the Slime text on top of that at its original position
        Core.SpriteBatch.DrawString(_font5x, SLIME_TEXT, _slimeTextPos, Color.White, 0.0f, _slimeTextOrigin, 1.0f, SpriteEffects.None, 1.0f);

        // Always end the sprite batch when finished.
        Core.SpriteBatch.End();
    }

    GumService.Default.Draw();
}
</code></pre>
<p>With these changes, our UI system is now fully integrated into the scene's game loop.  Gum updates its controls in the <code>Update</code> method and draws them in the <code>Draw</code> method.  This produces a fully functional title screen with buttons that allows players to start the game or adjust audio settings.</p>
<table>
<thead>
<tr>
<th style="text-align: center;"><img src="./images/title-unstyled.png" alt="Figure 20-2: Title screen with default Gum buttons"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Figure 20-2: Title screen with default Gum buttons</strong></td>
</tr>
</tbody>
</table>
<div class="NOTE">
<h5>Note</h5>
<p>You may notice that the UI elements currently use Gum's default styling, which does not match our game's visual theme.  We will explore customizing these controls to match our game's visual style in the next chapter.</p>
</div>
<h3 id="adding-gamescene-ui">Adding GameScene UI</h3>
<p>Now that we have setup the UI for the title scene, we will add a pause menu to our game scene.  This UI will start invisible but will be shown when the player presses the escape key.  For consistency, we will implement the UI for the game scene in the same order that we implemented the UI for the title scene.</p>
<div class="NOTE">
<h5>Note</h5>
<p>When adding these sections one by one, you may see compiler errors until all sections are in place. This is normal, as some parts of the code will reference fields or methods that haven't been added yet. Once all sections are complete, these errors will resolve.</p>
</div>
<p>First, open the <em>GameScene.cs</em> file in the game project and add the following using declarations to the top of the <code>GameScene</code> class.</p>
<pre><code class="lang-csharp" highlight-lines="2-3,8-10">using System;
using Gum.DataTypes;
using Gum.Wireframe;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Audio;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;
using MonoGameGum;
using Gum.Forms.Controls;
using MonoGameGum.GueDeriving;
using MonoGameLibrary;
using MonoGameLibrary.Graphics;
using MonoGameLibrary.Input;
using MonoGameLibrary.Scenes;
</code></pre>
<p>Next, add the following fields to the <code>GameScene</code> class:</p>
<pre><code class="lang-csharp">// A reference to the pause panel UI element so we can set its visibility
// when the game is paused.
private Panel _pausePanel;

// A reference to the resume button UI element so we can focus it
// when the game is paused.
private Button _resumeButton;

// The UI sound effect to play when a UI event is triggered.
private SoundEffect _uiSoundEffect;
</code></pre><h4 id="pausing-the-game">Pausing the Game</h4>
<p>To pause the game, first we will create a method that makes the pause panel visible.  Add the following method to the <code>GameScene</code> class after the <code>CheckGamePadInput</code> method:</p>
<pre><code class="lang-csharp">private void PauseGame()
{
    // Make the pause panel UI element visible.
    _pausePanel.IsVisible = true;

    // Set the resume button to have focus
    _resumeButton.IsFocused = true;
}
</code></pre>
<p>Next, update the <code>CheckKeyboardInput</code> method so that when the escape key is pressed, instead of returning to the title scene, we now pause the game:</p>
<pre><code class="lang-csharp" highlight-lines="6-10">private void CheckKeyboardInput()
{
    // Get a reference to the keyboard info
    KeyboardInfo keyboard = Core.Input.Keyboard;

    // If the escape key is pressed, pause the game.
    if (Core.Input.Keyboard.WasKeyJustPressed(Keys.Escape))
    {
        PauseGame();
    }

    // Existing keyboard input code
    // ...
</code></pre>
<p>Finally, update the <code>CheckGamePadInput</code> method so that when the start button is pressed, it pauses the game:</p>
<pre><code class="lang-csharp" highlight-lines="6-10">private void CheckGamePadInput()
{
    // Get the gamepad info for gamepad one.
    GamePadInfo gamePadOne = Core.Input.GamePads[(int)PlayerIndex.One];

    // If the start button is pressed, pause the game
    if (gamePadOne.WasButtonJustPressed(Buttons.Start))
    {
        PauseGame();
    }

    // Existing gamepad input code
    // ...
</code></pre><h4 id="creating-the-pause-panel">Creating the Pause Panel</h4>
<p>Next, we will create a method that builds our pause panel with resume and quit buttons. Add the following method to the <code>GameScene</code> class after the <code>LoadContent</code> method:</p>
<pre><code class="lang-csharp">private void CreatePausePanel()
{
    _pausePanel = new Panel();
    _pausePanel.Anchor(Anchor.Center);
    _pausePanel.Visual.WidthUnits = DimensionUnitType.Absolute;
    _pausePanel.Visual.HeightUnits = DimensionUnitType.Absolute;
    _pausePanel.Visual.Height = 70;
    _pausePanel.Visual.Width = 264;
    _pausePanel.IsVisible = false;
    _pausePanel.AddToRoot();

    var background = new ColoredRectangleRuntime();
    background.Dock(Dock.Fill);
    background.Color = Color.DarkBlue;
    _pausePanel.AddChild(background);

    var textInstance = new TextRuntime();
    textInstance.Text = &quot;PAUSED&quot;;
    textInstance.X = 10f;
    textInstance.Y = 10f;
    _pausePanel.AddChild(textInstance);

    _resumeButton = new Button();
    _resumeButton.Text = &quot;RESUME&quot;;
    _resumeButton.Anchor(Anchor.BottomLeft);
    _resumeButton.Visual.X = 9f;
    _resumeButton.Visual.Y = -9f;
    _resumeButton.Visual.Width = 80;
    _resumeButton.Click += HandleResumeButtonClicked;
    _pausePanel.AddChild(_resumeButton);

    var quitButton = new Button();
    quitButton.Text = &quot;QUIT&quot;;
    quitButton.Anchor(Anchor.BottomRight);
    quitButton.Visual.X = -9f;
    quitButton.Visual.Y = -9f;
    quitButton.Width = 80;
    quitButton.Click += HandleQuitButtonClicked;

    _pausePanel.AddChild(quitButton);
}
</code></pre>
<p>Now we should implement the event handlers for these controls. First, we will implement the handler for the &quot;Resume&quot; button. Add the following method to the <code>GameScene</code> class after the <code>CreatePausePanel</code> method:</p>
<pre><code class="lang-csharp">private void HandleResumeButtonClicked(object sender, EventArgs e)
{
    // A UI interaction occurred, play the sound effect
    Core.Audio.PlaySoundEffect(_uiSoundEffect);

    // Make the pause panel invisible to resume the game.
    _pausePanel.IsVisible = false;
}
</code></pre>
<p>This method plays the UI sound effect for auditory feedback and then hides the pause panel so that the game can resume.</p>
<p>Next is the handler for the &quot;Quit&quot; button.  Add the following method to the <code>GameScene</code> class after the <code>HandleResumeButtonClicked</code> method:</p>
<pre><code class="lang-csharp">private void HandleQuitButtonClicked(object sender, EventArgs e)
{
    // A UI interaction occurred, play the sound effect
    Core.Audio.PlaySoundEffect(_uiSoundEffect);

    // Go back to the title scene.
    Core.ChangeScene(new TitleScene());
}
</code></pre>
<p>This method as well plays the UI sound effect for auditory feedback, then quits the game by changing scenes back to the title scene.</p>
<h4 id="initializing-the-game-ui">Initializing the Game UI</h4>
<p>Now that we have implemented the method to create the pause panel, we can implement the main UI initializations method that will call them.   Add the following method to the <code>GameScene</code> class after the <code>HandleQuitButtonClicked</code> method:</p>
<pre><code class="lang-csharp">private void InitializeUI()
{
    GumService.Default.Root.Children.Clear();

    CreatePausePanel();
}
</code></pre>
<p>Just like with the <code>TitleScene</code>, we first clear any existing UI elements from Gum's root before creating the UI elements for this scene.</p>
<h4 id="integrating-with-the-game-loop-for-the-gamescreen">Integrating with the Game Loop for the GameScreen</h4>
<p>Finally, we need to integrate our UI initialization, update, and draw with the scene's lifecycle.  First add the call to <code>InitializeUI()</code> in the <code>Initialize</code> method by updating it to the following:</p>
<pre><code class="lang-csharp" highlight-lines="38">public override void Initialize()
{
    // LoadContent is called during base.Initialize().
    base.Initialize();

    // During the game scene, we want to disable exit on escape. Instead,
    // the escape key will be used to return back to the title screen
    Core.ExitOnEscape = false;

    Rectangle screenBounds = Core.GraphicsDevice.PresentationParameters.Bounds;

    _roomBounds = new Rectangle(
        (int)_tilemap.TileWidth,
        (int)_tilemap.TileHeight,
        screenBounds.Width - (int)_tilemap.TileWidth * 2,
        screenBounds.Height - (int)_tilemap.TileHeight * 2
    );

    // Initial slime position will be the center tile of the tile map.
    int centerRow = _tilemap.Rows / 2;
    int centerColumn = _tilemap.Columns / 2;
    _slimePosition = new Vector2(centerColumn * _tilemap.TileWidth, centerRow * _tilemap.TileHeight);

    // Initial bat position will the in the top left corner of the room
    _batPosition = new Vector2(_roomBounds.Left, _roomBounds.Top);

    // Set the position of the score text to align to the left edge of the
    // room bounds, and to vertically be at the center of the first tile.
    _scoreTextPosition = new Vector2(_roomBounds.Left, _tilemap.TileHeight * 0.5f);

    // Set the origin of the text so it is left-centered.
    float scoreTextYOrigin = _font.MeasureString(&quot;Score&quot;).Y * 0.5f;
    _scoreTextOrigin = new Vector2(0, scoreTextYOrigin);

    // Assign the initial random velocity to the bat.
    AssignRandomBatVelocity();

    InitializeUI();
}
</code></pre>
<p>Next, update the <code>LoadContent</code> method to load the sound effect that will be used as auditory feedback for the UI:</p>
<pre><code class="lang-csharp" highlight-lines="27-28">public override void LoadContent()
{
    // Create the texture atlas from the XML configuration file
    TextureAtlas atlas = TextureAtlas.FromFile(Core.Content, &quot;images/atlas-definition.xml&quot;);

    // Create the slime animated sprite from the atlas.
    _slime = atlas.CreateAnimatedSprite(&quot;slime-animation&quot;);
    _slime.Scale = new Vector2(4.0f, 4.0f);

    // Create the bat animated sprite from the atlas.
    _bat = atlas.CreateAnimatedSprite(&quot;bat-animation&quot;);
    _bat.Scale = new Vector2(4.0f, 4.0f);

    // Create the tilemap from the XML configuration file.
    _tilemap = Tilemap.FromFile(Content, &quot;images/tilemap-definition.xml&quot;);
    _tilemap.Scale = new Vector2(4.0f, 4.0f);

    // Load the bounce sound effect
    _bounceSoundEffect = Content.Load&lt;SoundEffect&gt;(&quot;audio/bounce&quot;);

    // Load the collect sound effect
    _collectSoundEffect = Content.Load&lt;SoundEffect&gt;(&quot;audio/collect&quot;);

    // Load the font
    _font = Core.Content.Load&lt;SpriteFont&gt;(&quot;fonts/04B_30&quot;);

    // Load the sound effect to play when ui actions occur.
    _uiSoundEffect = Core.Content.Load&lt;SoundEffect&gt;(&quot;audio/ui&quot;);
}
</code></pre>
<p>Next, modify the <code>Update</code> method to include Gum's update logic and to only update the game if it is not paused.  We will use the visibility of the pause menu to determine if the game is paused or not:</p>
<pre><code class="lang-csharp" highlight-lines="3-10">public override void Update(GameTime gameTime)
{
    // Ensure the UI is always updated
    GumService.Default.Update(gameTime);

    // If the game is paused, do not continue
    if (_pausePanel.IsVisible)
    {
        return;
    }

    // Existing game update code
    // ...
</code></pre>
<p>Finally, add Gum's drawing call to the end fo the <code>Draw</code> method:</p>
<pre><code class="lang-csharp" highlight-lines="9-10">public override void Draw(GameTime gameTime)
{
    // Existing game draw code
    // ...

    // Always end the sprite batch when finished
    Core.SpriteBatch.End();
    
    // Draw the Gum UI
    GumService.Default.Draw();
}
</code></pre>
<p>With these changes, the pause menu is now fully integrated into the game scene's game loop.  Gum updates its controls during the <code>Update</code> method and draws them during the <code>Draw</code> method.  If the game is paused, as determined by the <code>IsVisible</code> property of the pause menu, then updating the actual game logic is skipped.</p>
<table>
<thead>
<tr>
<th style="text-align: center;"><img src="./images/pause-unstyled.png" alt="Figure 20-3: The pause menu during the game scene with default Gum buttons"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Figure 20-3: The pause menu during the game scene with default Gum buttons</strong></td>
</tr>
</tbody>
</table>
<h2 id="conclusion">Conclusion</h2>
<p>In this chapter, you accomplished the following:</p>
<ul>
<li>Add and configure the Gum NuGet package in your project.</li>
<li>Understand key Gum concepts like Forms controls and Visuals.</li>
<li>Create and position UI elements using anchoring and docking.</li>
<li>Implement interactive controls like buttons and sliders.</li>
<li>Handle user input from various input devices.</li>
<li>Create transitions between different UI screens.</li>
<li>Integrate the UI system with the game's scene architecture.</li>
</ul>
<p>While this UI is now functional, you may have noticed that it uses Gum's default styling which does not match our game's visual theme.  In the next chapter, we will learn how to customize the appearance of our UI elements to create a cohesive visual style that complements our game's aesthetic.</p>
<h2 id="test-your-knowledge">Test Your Knowledge</h2>
<ol>
<li><p>What are the two main types of objects in Gum, and how do they differ?</p>
<p>:::question-answer
The two main types are:</p>
<ul>
<li><strong>Forms</strong>: Interactive UI elements like buttons, sliders, and panels that handle user input. They provide built-in functionality for common UI interactions.</li>
<li><strong>Visuals</strong>: Display elements like TextRuntime, ColoredRectangleRuntime, and NineSliceRuntime that are used to render graphics. They have no built-in interaction behavior but can be customized visually.</li>
</ul>
<p>Forms controls contain Visuals, accessible through the <code>Visual</code> property, creating a separation between functionality and presentation.
:::</p>
</li>
<li><p>How does Gum handle the parent-child relationship of UI elements, and why is this important?</p>
<p>:::question-answer
Gum implements parent-child relationships through a hierarchical structure where:</p>
<ul>
<li>UI elements must be connected to the root container to be visible</li>
<li>Children can be added directly to a parent's Visual.Children collection</li>
<li>Position coordinates of child elements are relative to their parent</li>
<li>Property changes like visibility cascade from parent to children</li>
</ul>
<p>This relationship is important because it allows for organizing related UI elements as groups, controlling entire sections of UI with a single property change, and positioning elements relative to their container rather than absolute screen coordinates.
:::</p>
</li>
<li><p>What are the two ways to customize the appearance of Gum UI elements?</p>
<p>:::question-answer
The two ways to customize Gum UI elements are:</p>
<ol>
<li><strong>Direct property assignment</strong>: Setting properties directly in code (like <code>MyButton.Visual.Width = 100</code>). This works well for initial setup and static properties.</li>
<li><strong>States</strong>: Using Gum's state system (<code>StateSave</code> objects) to define different visual states that can be applied in response to specific conditions or events. States are automatically applied by Forms controls in response to user interactions (like focus or highlighting).</li>
</ol>
<p>States are useful for dynamic changes that occur during gameplay, as they separate visual response logic from game logic.
:::</p>
</li>
<li><p>What steps are necessary to integrate Gum's UI system with MonoGame's game loop?</p>
<p>:::question-answer
To integrate Gum with MonoGame's game loop:</p>
<ol>
<li>Initialize Gum in the game's Initialize method with <code>GumService.Default.Initialize(this)</code></li>
<li>Configure content loading by setting <code>GumService.Default.ContentLoader.XnaContentManager</code></li>
<li>Set up input handling by adding keyboards and gamepads to <code>FrameworkElement.KeyboardsForUiControl</code> and <code>FrameworkElement.GamePadsForUiControl</code></li>
<li>Call <code>GumService.Default.Update()</code> in the game's Update method</li>
<li>Call <code>GumService.Default.Draw()</code> in the game's Draw method</li>
<li>For scene transitions, clear existing UI elements with <code>GumService.Default.Root.Children.Clear()</code></li>
</ol>
<p>This ensures Gum can update and render UI elements in sync with the game's main loop.
:::</p>
</li>
</ol>

</article>
                </div>

            </main>
        </div>


        <script src="https://code.jquery.com/jquery-3.6.3.min.js" integrity="sha256-pvPw+upLPUjgMXY0G+8O0xUf+/Im1MZjXxxgOcBQBXU=" crossorigin="anonymous"></script>
        <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.1/dist/umd/popper.min.js" integrity="sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN" crossorigin="anonymous"></script>
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.min.js" integrity="sha384-+sLIOodYLS7CIrQpBjl+C7nPvqq+FbNUBDunl/OZv93DB7Ln/533i8e/mZXLi/P+" crossorigin="anonymous"></script>
        <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
        <script type="text/javascript" src="../../../../../../styles/jquery.twbsPagination.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/mark.js@8.11.1/dist/jquery.mark.min.js"></script>
        <script type="text/javascript" src="../../../../../../styles/url.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/anchor-js@5.0.0/anchor.min.js"></script>
        <script type="text/javascript" src="../../../../../../styles/docfx.js"></script>
        <script type="text/javascript" src="../../../../../../styles/main.js"></script>
        <script type="text/javascript" src="../../../../../../styles/singulink.js"></script>    </body>
</html>
