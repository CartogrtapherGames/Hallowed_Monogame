<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>

    <head>
      <meta charset="utf-8">
      <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
      <title>Chapter 11: Input Management | hallowed </title>
      <meta name="viewport" content="width=device-width">
      <meta name="title" content="Chapter 11: Input Management | hallowed ">
      <meta name="generator" content="docfx ">
  
      <link rel="shortcut icon" href="../../../../../../favicon.ico">
      <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/night-owl.min.css">
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css" integrity="sha384-EvBWSlnoFgZlXJvpzS+MAUEjvN7+gcCwH+qh7GRFOGgZO0PuwOFro7qPOJnLfe7l" crossorigin="anonymous">
      <link rel="stylesheet" href="../../../../../../styles/config.css">
      <link rel="stylesheet" href="../../../../../../styles/singulink.css">
      <link rel="stylesheet" href="../../../../../../styles/main.css">
      <meta property="docfx:navrel" content="../../../../../../toc.html">
      <meta property="docfx:tocrel" content="../../../toc.html">
  
  <meta property="docfx:rel" content="../../../../../../">
  
    </head>
    <body>
        <!-- Header required for docfx anchor scroll to work -->
        <header id="head"></header>
        <div class="top-navbar">
            <a class="burger-icon" onclick="toggleMenu()">
                <svg name="Hamburger" style="vertical-align: middle;" width="34" height="34" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" clip-rule="evenodd" d="M20 6H4V9H20V6ZM4 10.999H20V13.999H4V10.999ZM4 15.999H20V18.999H4V15.999Z"></path></svg>
            </a>


            <a class="brand" href="../../../../../../index.html">
              <img src="../../../../../../logo.svg" alt="hallowed" class="logomark">
              <span class="brand-title">hallowed</span>
            </a>        </div>

        <div class="body-content">
            <div id="blackout" class="blackout" onclick="toggleMenu()"></div>

            <nav id="sidebar" role="navigation">
                <div class="sidebar">

                    <div>
                      <div class="mobile-hide">

                        <a class="brand" href="../../../../../../index.html">
                          <img src="../../../../../../logo.svg" alt="hallowed" class="logomark">
                          <span class="brand-title">hallowed</span>
                        </a>                      </div>

                      <div class="sidesearch">
                        <form id="search" role="search" class="search">
                            <i class="bi bi-search search-icon"></i>
                            <input type="text" id="search-query" placeholder="Search" autocomplete="off">
                        </form>
                      </div>

                      <div id="navbar">
                      </div>
                    </div>                    <div class="sidebar-item-separator"></div>

                        <div id="sidetoggle">
                          <div id="sidetoc"></div>
                        </div>
                </div>
                <div class="footer">
  
  <strong><a href='https://dotnet.github.io/docfx/'>DocFX</a> + <a href='https://www.singulink.com'>Singulink</a> = â™¥</strong>
                </div>            </nav>

            <main class="main-panel">

                <div id="search-results" style="display: none;">
                  <h1 class="search-list">Search Results for <span></span></h1>
                  <div class="sr-items">
                    <p><i class="bi bi-hourglass-split index-loading"></i></p>
                  </div>
                  <ul id="pagination" data-first=First data-prev=Previous data-next=Next data-last=Last></ul>
                </div>
 

                <div role="main" class="hide-when-search">

                        <div class="subnav navbar navbar-default">
                          <div class="container hide-when-search" id="breadcrumb">
                            <ul class="breadcrumb">
                              <li></li>
                            </ul>
                          </div>
                        </div>

                         <div class="contribution">
                               <a href="https://github.com/MonoGame/docs.monogame.github.io/blob/main/articles/tutorials/building_2d_games/11_input_management/index.md/#L1" class="contribution-link">Edit this page</a>
                         </div>

                    <article class="content wrap" id="_content" data-uid="">


<p>In <a href="../10_handling_input/index.html">Chapter 10</a>, you learned how to handle input from various devices like keyboard, mouse, and gamepad. While checking if an input is currently down works well for continuous actions like movement, many game actions should only happen once when an input is first pressed; think firing a weapon or jumping. To handle these scenarios, we need to compare the current input state with the previous frame's state to detect when an input changes from up to down.</p>
<p>In this chapter you will:</p>
<ul>
<li>Learn the difference between an input being down versus being pressed</li>
<li>Track input states between frames</li>
<li>Create a reusable input management system</li>
<li>Simplify handling input across multiple devices</li>
</ul>
<p>We will start by understanding the concept of input state changes and how we can detect them.</p>
<h2 id="understanding-input-states">Understanding Input States</h2>
<p>When handling input in games, there are two key scenarios we need to consider:</p>
<ul>
<li>An input is being held down (like holding a movement key).</li>
<li>An input was just pressed for one frame (like pressing a jump button).</li>
</ul>
<p>Now, we will look at the difference using keyboard input as an example. With our current implementation, we can check if a key is down using <a href="xref:Microsoft.Xna.Framework.Input.KeyboardState.IsKeyDown(Microsoft.Xna.Framework.Input.Keys)"><strong>KeyboardState.IsKeyDown</strong></a>:</p>
<pre><code class="lang-csharp">// Get the current state of keyboard input.
KeyboardState keyboardState = Keyboard.GetState();

// Check if the space key is down.
if (keyboardState.IsKeyDown(Keys.Space))
{
    // This runs EVERY frame the space key is held down
}
</code></pre>
<p>However, many game actions should not repeat while a key is held. For instance, if the Space key makes your character jump, you probably do not want them to jump repeatedly just because the player is holding the key down. Instead, you want the jump to happen only on the first frame when Space is pressed.</p>
<p>To detect this &quot;just pressed&quot; state, we need to compare two states:</p>
<ol>
<li>Is the key down in the current frame?</li>
<li>Was the key up in the previous frame?</li>
</ol>
<p>If both conditions are true, we know the key was just pressed.  If we were to modify the above code to track the previous keyboard state it would look something like this:</p>
<pre><code class="lang-csharp">// Track the state of keyboard input during the previous frame.
private KeyboardState _previousKeyboardState;

protected override void Update(GameTime gameTime)
{
    // Get the current state of keyboard input.
    KeyboardState keyboardState = Keyboard.GetState();

    // Compare if the space key is down on the current frame but was up on the previous frame.
    if (keyboardState.IsKeyDown(Keys.Space) &amp;&amp; _previousKeyboardState.IsKeyUp(Keys.Space))
    {
        // This will only run on the first frame Space is pressed and will not
        // happen again until it has been released and then pressed again.
    }

    // At the end of update, store the current state of keyboard input into the
    // previous state tracker.
    _previousKeyboardState = keyboardState;
    
    base.Update(gameTime);
}
</code></pre>
<p>If you need to know the inverse state, when the key was just released, then it is simply a matter of switching the checking of the states, for example, is the key up this frame and was it down in the previous frame.</p>
<p>This same concept applies to mouse buttons and gamepad input as well. Any time you need to detect a &quot;just pressed&quot; or &quot;just released&quot; state, you will need to compare the current input state with the previous frame's state.</p>
<p>So far, we have only been working with our game within the <code>Game1.cs</code> file.  This has been fine for the examples given.  Over time, as the game grows, we are going to have a more complex system set up with different scenes, and each scene will need a way to track the state of input over time.  We could do this by creating a lot of variables in each scene to track this information, or we can use object-oriented design concepts to create a reusable <code>InputManager</code> class to simplify this for us.</p>
<p>Before we create the <code>InputManager</code> class, we should first create classes for the keyboard, mouse, and gamepad that encapsulates the information about those inputs, which will then be exposed through the <code>InputManager</code>.</p>
<p>To get started, create a new folder called <code>Input</code> in the <em>MonoGameLibrary</em> project.  We will put all of our input related classes here.</p>
<h2 id="the-keyboardinfo-class">The KeyboardInfo Class</h2>
<p>We will start our input management system by creating a class to handle keyboard input. The <code>KeyboardInfo</code> class will encapsulate all keyboard-related functionality, making it easier to:</p>
<ul>
<li>Track current and previous keyboard states</li>
<li>Detect when keys are pressed or released</li>
<li>Check if keys are being held down</li>
</ul>
<p>In the <code>Input</code> folder of the <em>MonoGameLibrary</em> project, add a new file named <code>KeyboardInfo.cs</code> with this initial structure:</p>
<pre><code class="lang-csharp">using Microsoft.Xna.Framework.Input;

namespace MonoGameLibrary.Input;

public class KeyboardInfo { }
</code></pre><h3 id="keyboardinfo-properties">KeyboardInfo Properties</h3>
<p>To detect changes in keyboard input between frames, we need to track both the previous and current keyboard states. Add these properties to the <code>KeyboardInfo</code> class:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Gets the state of keyboard input during the previous update cycle.
/// &lt;/summary&gt;
public KeyboardState PreviousState { get; private set; }

/// &lt;summary&gt;
/// Gets the state of keyboard input during the current input cycle.
/// &lt;/summary&gt;
public KeyboardState CurrentState { get; private set; }
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>These properties use a public getter but private setter pattern. This allows other parts of the game to read the keyboard states if needed, while ensuring only the <code>KeyboardInfo</code> class can update them.</p>
</div>
<h3 id="keyboardinfo-constructor">KeyboardInfo Constructor</h3>
<p>The <code>KeyboardInfo</code> class constructor needs to initialize the keyboard states.</p>
<p>Add this constructor:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Creates a new KeyboardInfo. 
/// &lt;/summary&gt;
public KeyboardInfo()
{
    PreviousState = new KeyboardState();
    CurrentState = Keyboard.GetState();
}
</code></pre>
<p>The constructor:</p>
<ul>
<li>Creates an empty state for <code>PreviousState</code> since there is no previous input yet</li>
<li>Gets the current keyboard state as our starting point for <code>CurrentState</code></li>
</ul>
<p>This initialization ensures we have valid states to compare against in the first frame of our game, preventing any potential null reference issues when checking for input changes.</p>
<h3 id="keyboardinfo-methods">KeyboardInfo Methods</h3>
<p>The <code>KeyboardInfo</code> class needs methods both for updating states and checking key states. First, we will start with our update method:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Updates the state information about keyboard input.
/// &lt;/summary&gt;
public void Update()
{
    PreviousState = CurrentState;
    CurrentState = Keyboard.GetState();
}
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>Each time <code>Update</code> is called, the current state becomes the previous state, and we get a fresh current state. This creates our frame-to-frame comparison chain.</p>
</div>
<p>Next, we will add methods to check various key states:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Returns a value that indicates if the specified key is currently down.
/// &lt;/summary&gt;
/// &lt;param name=&quot;key&quot;&gt;The key to check.&lt;/param&gt;
/// &lt;returns&gt;true if the specified key is currently down; otherwise, false.&lt;/returns&gt;
public bool IsKeyDown(Keys key)
{
    return CurrentState.IsKeyDown(key);
}

/// &lt;summary&gt;
/// Returns a value that indicates whether the specified key is currently up.
/// &lt;/summary&gt;
/// &lt;param name=&quot;key&quot;&gt;The key to check.&lt;/param&gt;
/// &lt;returns&gt;true if the specified key is currently up; otherwise, false.&lt;/returns&gt;
public bool IsKeyUp(Keys key)
{
    return CurrentState.IsKeyUp(key);
}

/// &lt;summary&gt;
/// Returns a value that indicates if the specified key was just pressed on the current frame.
/// &lt;/summary&gt;
/// &lt;param name=&quot;key&quot;&gt;The key to check.&lt;/param&gt;
/// &lt;returns&gt;true if the specified key was just pressed on the current frame; otherwise, false.&lt;/returns&gt;
public bool WasKeyJustPressed(Keys key)
{
    return CurrentState.IsKeyDown(key) &amp;&amp; PreviousState.IsKeyUp(key);
}

/// &lt;summary&gt;
/// Returns a value that indicates if the specified key was just released on the current frame.
/// &lt;/summary&gt;
/// &lt;param name=&quot;key&quot;&gt;The key to check.&lt;/param&gt;
/// &lt;returns&gt;true if the specified key was just released on the current frame; otherwise, false.&lt;/returns&gt;
public bool WasKeyJustReleased(Keys key)
{
    return CurrentState.IsKeyUp(key) &amp;&amp; PreviousState.IsKeyDown(key);
}
</code></pre>
<p>These methods serve two distinct purposes.  For checking continuous states:</p>
<ul>
<li><code>IsKeyDown</code>: Returns true as long as the specified key is being held down.</li>
<li><code>IsKeyUp</code>: Returns true as long as the specified key is not being pressed.</li>
</ul>
<p>And for detecting state changes:</p>
<ul>
<li><code>WasKeyJustPressed</code>: Returns true only on the frame when the specified key changes from up-to-down.</li>
<li><code>WasKeyJustReleased</code>: Returns true only on the frame when the specified key changes from down-to-up.</li>
</ul>
<div class="TIP">
<h5>Tip</h5>
<p>Use continuous state checks (<code>IsKeyDown</code>/<code>IsKeyUp</code>) for actions that should repeat while a key is held, like movement. Use single-frame checks (<code>WasKeyJustPressed</code>/<code>WasKeyJustReleased</code>) for actions that should happen once per key press, like jumping or shooting.</p>
</div>
<p>That's it for the <code>KeyboardInfo</code> class, now we can move on to mouse input next.</p>
<h2 id="mousebutton-enum">MouseButton Enum</h2>
<p>Recall from the <a href="../10_handling_input/index.html#mouse-input">Mouse Input</a> section of the previous chapter that the <a href="xref:Microsoft.Xna.Framework.Input.MouseState"><strong>MouseState</strong></a> struct provides button states through properties rather than methods like <code>IsButtonDown</code>/<code>IsButtonUp</code>. To keep our input management API consistent across devices, we will create a <code>MouseButton</code> enum that lets us reference mouse buttons in a similar way to how we use <a href="xref:Microsoft.Xna.Framework.Input.Keys"><strong>Keys</strong></a> for keyboard input and <a href="xref:Microsoft.Xna.Framework.Input.Buttons"><strong>Buttons</strong></a> for gamepad input.</p>
<p>In the <code>Input</code> folder of the <em>MonoGameLibrary</em> project, add a new file named <code>MouseButton.cs</code> with the following code:</p>
<pre><code class="lang-csharp">namespace MonoGameLibrary.Input;

public enum MouseButton
{
    Left,
    Middle,
    Right,
    XButton1,
    XButton2
}
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>Each enum value corresponds directly to a button property in MouseState:</p>
<ul>
<li><code>Left</code>: Maps to <a href="xref:Microsoft.Xna.Framework.Input.MouseState.LeftButton"><strong>MouseState.LeftButton</strong></a>.</li>
<li><code>Middle</code>: Maps to <a href="xref:Microsoft.Xna.Framework.Input.MouseState.MiddleButton"><strong>MouseState.MiddleButton</strong></a>.</li>
<li><code>Right</code>: Maps to <a href="xref:Microsoft.Xna.Framework.Input.MouseState.RightButton"><strong>MouseState.RightButton</strong></a>.</li>
<li><code>XButton1</code>: Maps to <a href="xref:Microsoft.Xna.Framework.Input.MouseState.XButton1"><strong>MouseState.XButton1</strong></a>.</li>
<li><code>XButton2</code>: Maps to <a href="xref:Microsoft.Xna.Framework.Input.MouseState.XButton2"><strong>MouseState.XButton2</strong></a>.</li>
</ul>
</div>
<h2 id="the-mouseinfo-class">The MouseInfo Class</h2>
<p>To manage mouse input effectively, we need to track both current and previous states, as well as provide easy access to mouse position, scroll wheel values, and button states. The <code>MouseInfo</code> class will encapsulate all of this functionality, making it easier to:</p>
<ul>
<li>Track current and previous mouse states.</li>
<li>Track the mouse position.</li>
<li>Check the change in mouse position between frames and if it was moved.</li>
<li>Track scroll wheel changes.</li>
<li>Detect when mouse buttons are pressed or released</li>
<li>Check if mouse buttons are being held down</li>
</ul>
<p>To get started, in the <code>Input</code> folder of the <em>MonoGameLibrary</em> project, create a new file named <code>MouseInfo.cs</code> with the following initial structure:</p>
<pre><code class="lang-csharp">using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Input;

namespace MonoGameLibrary.Input;

public class MouseInfo 
{
    
}
</code></pre><h3 id="mouseinfo-properties">MouseInfo Properties</h3>
<p>The <code>MouseInfo</code> class needs properties to track both mouse states and provide easy access to common mouse information. Add the following properties to the <code>MouseInfo</code> class:</p>
<p>First, we need properties for tracking mouse states:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// The state of mouse input during the previous update cycle.
/// &lt;/summary&gt;
public MouseState PreviousState { get; private set; }

/// &lt;summary&gt;
/// The state of mouse input during the current update cycle.
/// &lt;/summary&gt;
public MouseState CurrentState { get; private set; }
</code></pre>
<p>Next, we will add properties for handling cursor position:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Gets or Sets the current position of the mouse cursor in screen space.
/// &lt;/summary&gt;
public Point Position
{
    get =&gt; CurrentState.Position;
    set =&gt; SetPosition(value.X, value.Y);
}

/// &lt;summary&gt;
/// Gets or Sets the current x-coordinate position of the mouse cursor in screen space.
/// &lt;/summary&gt;
public int X
{
    get =&gt; CurrentState.X;
    set =&gt; SetPosition(value, CurrentState.Y);
}

/// &lt;summary&gt;
/// Gets or Sets the current y-coordinate position of the mouse cursor in screen space.
/// &lt;/summary&gt;
public int Y
{
    get =&gt; CurrentState.Y;
    set =&gt; SetPosition(CurrentState.X, value);
}
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>The position properties use a <code>SetPosition</code> method that we will implement later. This method will handle the actual cursor positioning on screen.</p>
</div>
<p>These properties provide different ways to work with the cursor position:</p>
<ul>
<li><code>Position</code>: Gets/sets the cursor position as a <a href="xref:Microsoft.Xna.Framework.Point"><strong>Point</strong></a>.</li>
<li><code>X</code>: Gets/sets just the horizontal position.</li>
<li><code>Y</code>: Gets/sets just the vertical position.</li>
</ul>
<p>Next, we will add properties for determining if the mouse cursor moved between game frames and if so how much:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Gets the difference in the mouse cursor position between the previous and current frame.
/// &lt;/summary&gt;
public Point PositionDelta =&gt; CurrentState.Position - PreviousState.Position;

/// &lt;summary&gt;
/// Gets the difference in the mouse cursor x-position between the previous and current frame.
/// &lt;/summary&gt;
public int XDelta =&gt; CurrentState.X - PreviousState.X;

/// &lt;summary&gt;
/// Gets the difference in the mouse cursor y-position between the previous and current frame.
/// &lt;/summary&gt;
public int YDelta =&gt; CurrentState.Y - PreviousState.Y;

/// &lt;summary&gt;
/// Gets a value that indicates if the mouse cursor moved between the previous and current frames.
/// &lt;/summary&gt;
public bool WasMoved =&gt; PositionDelta != Point.Zero;
</code></pre>
<p>The properties provide different ways of detecting mouse movement between frames:</p>
<ul>
<li><code>PositionDelta</code>: Gets how much the cursor moved between frames as a <a href="xref:Microsoft.Xna.Framework.Point"><strong>Point</strong></a>.</li>
<li><code>XDelta</code>: Gets how much the cursor moved horizontally between frames.</li>
<li><code>YDelta</code>: Gets how much the cursor moved vertically between frames.</li>
<li><code>WasMoved</code>: Indicates if the cursor moved between frames.</li>
</ul>
<p>Finally, we will add properties for handling the scroll wheel:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Gets the cumulative value of the mouse scroll wheel since the start of the game.
/// &lt;/summary&gt;
public int ScrollWheel =&gt; CurrentState.ScrollWheelValue;

/// &lt;summary&gt;
/// Gets the value of the scroll wheel between the previous and current frame.
/// &lt;/summary&gt;
public int ScrollWheelDelta =&gt; CurrentState.ScrollWheelValue - PreviousState.ScrollWheelValue;
</code></pre>
<p>The scroll wheel properties serve different purposes:</p>
<ul>
<li><code>ScrollWheel</code>: Gets the total accumulated scroll value since game start.</li>
<li><code>ScrollWheelDelta</code>: Gets the change in scroll value just in this frame.</li>
</ul>
<div class="TIP">
<h5>Tip</h5>
<p>Use <code>ScrollWheelDelta</code> when you need to respond to how much the user just scrolled, rather than tracking the total scroll amount.</p>
</div>
<h3 id="mouseinfo-constructor">MouseInfo Constructor</h3>
<p>The <code>MouseInfo</code> class constructor needs to initialize the mouse states.</p>
<p>Add this constructor:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Creates a new MouseInfo.
/// &lt;/summary&gt;
public MouseInfo()
{
    PreviousState = new MouseState();
    CurrentState = Mouse.GetState();
}
</code></pre>
<p>The constructor:</p>
<ul>
<li>Creates an empty state for <code>PreviousState</code> since there is no previous input yet.</li>
<li>Gets the current mouse state as our starting point for <code>CurrentState</code>.</li>
</ul>
<p>This initialization ensures we have valid states to compare against in the first frame of our game, preventing any potential null reference issues when checking for input changes.</p>
<h3 id="mouseinfo-methods">MouseInfo Methods</h3>
<p>The <code>MouseInfo</code> class needs methods for updating states, checking button states, and setting the cursor position. Add the following method to the <code>MouseInfo</code> class:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Updates the state information about mouse input.
/// &lt;/summary&gt;
public void Update()
{
    PreviousState = CurrentState;
    CurrentState = Mouse.GetState();
}
</code></pre>
<p>Next, we will add methods to check various button states:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Returns a value that indicates whether the specified mouse button is currently down.
/// &lt;/summary&gt;
/// &lt;param name=&quot;button&quot;&gt;The mouse button to check.&lt;/param&gt;
/// &lt;returns&gt;true if the specified mouse button is currently down; otherwise, false.&lt;/returns&gt;
public bool IsButtonDown(MouseButton button)
{
    switch (button)
    {
        case MouseButton.Left:
            return CurrentState.LeftButton == ButtonState.Pressed;
        case MouseButton.Middle:
            return CurrentState.MiddleButton == ButtonState.Pressed;
        case MouseButton.Right:
            return CurrentState.RightButton == ButtonState.Pressed;
        case MouseButton.XButton1:
            return CurrentState.XButton1 == ButtonState.Pressed;
        case MouseButton.XButton2:
            return CurrentState.XButton2 == ButtonState.Pressed;
        default:
            return false;
    }
}

/// &lt;summary&gt;
/// Returns a value that indicates whether the specified mouse button is current up.
/// &lt;/summary&gt;
/// &lt;param name=&quot;button&quot;&gt;The mouse button to check.&lt;/param&gt;
/// &lt;returns&gt;true if the specified mouse button is currently up; otherwise, false.&lt;/returns&gt;
public bool IsButtonUp(MouseButton button)
{
    switch (button)
    {
        case MouseButton.Left:
            return CurrentState.LeftButton == ButtonState.Released;
        case MouseButton.Middle:
            return CurrentState.MiddleButton == ButtonState.Released;
        case MouseButton.Right:
            return CurrentState.RightButton == ButtonState.Released;
        case MouseButton.XButton1:
            return CurrentState.XButton1 == ButtonState.Released;
        case MouseButton.XButton2:
            return CurrentState.XButton2 == ButtonState.Released;
        default:
            return false;
    }
}

/// &lt;summary&gt;
/// Returns a value that indicates whether the specified mouse button was just pressed on the current frame.
/// &lt;/summary&gt;
/// &lt;param name=&quot;button&quot;&gt;The mouse button to check.&lt;/param&gt;
/// &lt;returns&gt;true if the specified mouse button was just pressed on the current frame; otherwise, false.&lt;/returns&gt;
public bool WasButtonJustPressed(MouseButton button)
{
    switch (button)
    {
        case MouseButton.Left:
            return CurrentState.LeftButton == ButtonState.Pressed &amp;&amp; PreviousState.LeftButton == ButtonState.Released;
        case MouseButton.Middle:
            return CurrentState.MiddleButton == ButtonState.Pressed &amp;&amp; PreviousState.MiddleButton == ButtonState.Released;
        case MouseButton.Right:
            return CurrentState.RightButton == ButtonState.Pressed &amp;&amp; PreviousState.RightButton == ButtonState.Released;
        case MouseButton.XButton1:
            return CurrentState.XButton1 == ButtonState.Pressed &amp;&amp; PreviousState.XButton1 == ButtonState.Released;
        case MouseButton.XButton2:
            return CurrentState.XButton2 == ButtonState.Pressed &amp;&amp; PreviousState.XButton2 == ButtonState.Released;
        default:
            return false;
    }
}

/// &lt;summary&gt;
/// Returns a value that indicates whether the specified mouse button was just released on the current frame.
/// &lt;/summary&gt;
/// &lt;param name=&quot;button&quot;&gt;The mouse button to check.&lt;/param&gt;
/// &lt;returns&gt;true if the specified mouse button was just released on the current frame; otherwise, false.&lt;/returns&gt;
public bool WasButtonJustReleased(MouseButton button)
{
    switch (button)
    {
        case MouseButton.Left:
            return CurrentState.LeftButton == ButtonState.Released &amp;&amp; PreviousState.LeftButton == ButtonState.Pressed;
        case MouseButton.Middle:
            return CurrentState.MiddleButton == ButtonState.Released &amp;&amp; PreviousState.MiddleButton == ButtonState.Pressed;
        case MouseButton.Right:
            return CurrentState.RightButton == ButtonState.Released &amp;&amp; PreviousState.RightButton == ButtonState.Pressed;
        case MouseButton.XButton1:
            return CurrentState.XButton1 == ButtonState.Released &amp;&amp; PreviousState.XButton1 == ButtonState.Pressed;
        case MouseButton.XButton2:
            return CurrentState.XButton2 == ButtonState.Released &amp;&amp; PreviousState.XButton2 == ButtonState.Pressed;
        default:
            return false;
    }
}
</code></pre>
<p>These methods serve two distinct purposes. For checking continuous states:</p>
<ul>
<li><code>IsButtonDown</code>: Returns true as long as the specified button is being held down.</li>
<li><code>IsButtonUp</code>: Returns true as long as the specified button is not being pressed.</li>
</ul>
<p>And for detecting state changes:</p>
<ul>
<li><code>WasButtonJustPressed</code>: Returns true only on the frame when the specified button changes from up-to-down.</li>
<li><code>WasButtonJustReleased</code>: Returns true only on the frame when the specified button changes from down-to-up.</li>
</ul>
<div class="NOTE">
<h5>Note</h5>
<p>Each method uses a switch statement to check the appropriate button property from the <a href="xref:Microsoft.Xna.Framework.Input.MouseState"><strong>MouseState</strong></a> based on which <code>MouseButton</code> enum value is provided. This provides a consistent API while handling the different button properties internally.</p>
</div>
<p>Finally, we need a method to handle setting the cursor position:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Sets the current position of the mouse cursor in screen space and updates the CurrentState with the new position.
/// &lt;/summary&gt;
/// &lt;param name=&quot;x&quot;&gt;The x-coordinate location of the mouse cursor in screen space.&lt;/param&gt;
/// &lt;param name=&quot;y&quot;&gt;The y-coordinate location of the mouse cursor in screen space.&lt;/param&gt;
public void SetPosition(int x, int y)
{
    Mouse.SetPosition(x, y);
    CurrentState = new MouseState(
        x,
        y,
        CurrentState.ScrollWheelValue,
        CurrentState.LeftButton,
        CurrentState.MiddleButton,
        CurrentState.RightButton,
        CurrentState.XButton1,
        CurrentState.XButton2
    );
}
</code></pre>
<div class="TIP">
<h5>Tip</h5>
<p>Notice that after setting the position, we immediately update the <code>CurrentState</code>. This ensures our state tracking remains accurate even when manually moving the cursor.</p>
</div>
<p>That's it for the <code>MouseInfo</code> class, next we will move onto gamepad input.</p>
<h2 id="the-gamepadinfo-class">The GamePadInfo Class</h2>
<p>To manage gamepad input effectively, we need to track both current and previous states, is the gamepad still connected, as well as provide easy access to the thumbstick values, trigger values, and button states. The <code>GamePadInfo</code> class will encapsulate all of this functionality, making it easier to:</p>
<ul>
<li>Track current and previous gamepad states.</li>
<li>Check if the gamepad is still connected.</li>
<li>Track the position of the left and right thumbsticks.</li>
<li>Check the values of the left and right triggers.</li>
<li>Detect when gamepad buttons are pressed or released.</li>
<li>Check if gamepad buttons are being held down.</li>
<li>Start and Stop vibration of a gamepad.</li>
</ul>
<p>To get started, in the <code>Input</code> folder of the <em>MonoGameLibrary</em> project, create a new file named <code>GamePadInfo.cs</code> with the following initial structure:</p>
<pre><code class="lang-csharp">using System;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Input;

namespace MonoGameLibrary.Input;

public class GamePadInfo 
{
    
}
</code></pre><h3 id="gamepadinfo-properties">GamePadInfo Properties</h3>
<p>We use vibration in gamepads to provide haptic feedback to the player.  The <a href="xref:Microsoft.Xna.Framework.Input.GamePad"><strong>GamePad</strong></a> class provides the <a href="xref:Microsoft.Xna.Framework.Input.GamePad.SetVibration(Microsoft.Xna.Framework.PlayerIndex,System.Single,System.Single)"><strong>SetVibration</strong></a> method to tell the gamepad to vibrate, but it does not provide a timing mechanism for it if we wanted to only vibrate for a certain period of time.  Add the following private field to the <code>GamePadInfo</code> class:</p>
<pre><code class="lang-csharp">private TimeSpan _vibrationTimeRemaining = TimeSpan.Zero;
</code></pre>
<p>If you recall from the <a href="../10_handling_input/index.html#gamepad-input">previous chapter</a>, a <a href="xref:Microsoft.Xna.Framework.PlayerIndex"><strong>PlayerIndex</strong></a> value needs to be supplied when calling <a href="xref:Microsoft.Xna.Framework.Input.GamePad.GetState(Microsoft.Xna.Framework.PlayerIndex)"><strong>Gamepad.GetState</strong></a>.   Doing this returns the state of the gamepad connected at that player index.  So we will need a property to track the player index this gamepad info is for.</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Gets the index of the player this gamepad is for.
/// &lt;/summary&gt;
public PlayerIndex PlayerIndex { get; }
</code></pre>
<p>To detect changes in the gamepad input between frames, we need to track both the previous and current gamepad states.  Add these properties to the <code>GamePadInfo</code> class:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Gets the state of input for this gamepad during the previous update cycle.
/// &lt;/summary&gt;
public GamePadState PreviousState { get; private set; }

/// &lt;summary&gt;
/// Gets the state of input for this gamepad during the current update cycle.
/// &lt;/summary&gt;
public GamePadState CurrentState { get; private set; }
</code></pre>
<p>There are times that a gamepad can disconnect for various reasons; being unplugged, bluetooth disconnection, or battery dying are just some examples.  To track if the gamepad is connected, add the following property:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Gets a value that indicates if this gamepad is currently connected.
/// &lt;/summary&gt;
public bool IsConnected =&gt; CurrentState.IsConnected;
</code></pre>
<p>The values of the thumbsticks and triggers can be accessed through the <code>CurrentState</code>.  However, instead of having to navigate through multiple property chains to get this information, add the following properties to get direct access to the values:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Gets the value of the left thumbstick of this gamepad.
/// &lt;/summary&gt;
public Vector2 LeftThumbStick =&gt; CurrentState.ThumbSticks.Left;

/// &lt;summary&gt;
/// Gets the value of the right thumbstick of this gamepad.
/// &lt;/summary&gt;
public Vector2 RightThumbStick =&gt; CurrentState.ThumbSticks.Right;

/// &lt;summary&gt;
/// Gets the value of the left trigger of this gamepad.
/// &lt;/summary&gt;
public float LeftTrigger =&gt; CurrentState.Triggers.Left;

/// &lt;summary&gt;
/// Gets the value of the right trigger of this gamepad.
/// &lt;/summary&gt;
public float RightTrigger =&gt; CurrentState.Triggers.Right;
</code></pre><h3 id="gamepadinfo-constructor">GamePadInfo Constructor</h3>
<p>The <code>GamePadInfo</code> class constructor needs to initialize the gamepad states.</p>
<p>Add this constructor:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Creates a new GamePadInfo for the gamepad connected at the specified player index.
/// &lt;/summary&gt;
/// &lt;param name=&quot;playerIndex&quot;&gt;The index of the player for this gamepad.&lt;/param&gt;
public GamePadInfo(PlayerIndex playerIndex)
{
    PlayerIndex = playerIndex;
    PreviousState = new GamePadState();
    CurrentState = GamePad.GetState(playerIndex);
}
</code></pre>
<p>This constructor</p>
<ul>
<li>Requires a <a href="xref:Microsoft.Xna.Framework.PlayerIndex"><strong>PlayerIndex</strong></a> value which is stored and will be used to get the states for the correct gamepad</li>
<li>Creates an empty state for <code>PreviousState</code> since there is no previous state yet.</li>
<li>Gets the current gamepad state as our starting <code>CurrentState</code>.</li>
</ul>
<p>This initialization ensures we have valid states to compare against in the first frame of our game, preventing any potential null reference issues when checking for input changes.</p>
<h3 id="gamepadinfo-methods">GamePadInfo Methods</h3>
<p>The <code>GamePadInfo</code> class needs methods for updating states, checking button states, and controlling vibration. Add the following method to the <code>GamePadInfo</code> class:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Updates the state information for this gamepad input.
/// &lt;/summary&gt;
/// &lt;param name=&quot;gameTime&quot;&gt;&lt;/param&gt;
public void Update(GameTime gameTime)
{
    PreviousState = CurrentState;
    CurrentState = GamePad.GetState(PlayerIndex);

    if (_vibrationTimeRemaining &gt; TimeSpan.Zero)
    {
        _vibrationTimeRemaining -= gameTime.ElapsedGameTime;

        if (_vibrationTimeRemaining &lt;= TimeSpan.Zero)
        {
            StopVibration();
        }
    }
}
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>Unlike keyboard and mouse input, the gamepad update method takes a <a href="xref:Microsoft.Xna.Framework.GameTime"><strong>GameTime</strong></a> parameter. This allows us to track and manage timed vibration effects.</p>
</div>
<p>Next, we will add methods to check various button states:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Returns a value that indicates whether the specified gamepad button is current down.
/// &lt;/summary&gt;
/// &lt;param name=&quot;button&quot;&gt;The gamepad button to check.&lt;/param&gt;
/// &lt;returns&gt;true if the specified gamepad button is currently down; otherwise, false.&lt;/returns&gt;
public bool IsButtonDown(Buttons button)
{
    return CurrentState.IsButtonDown(button);
}

/// &lt;summary&gt;
/// Returns a value that indicates whether the specified gamepad button is currently up.
/// &lt;/summary&gt;
/// &lt;param name=&quot;button&quot;&gt;The gamepad button to check.&lt;/param&gt;
/// &lt;returns&gt;true if the specified gamepad button is currently up; otherwise, false.&lt;/returns&gt;
public bool IsButtonUp(Buttons button)
{
    return CurrentState.IsButtonUp(button);
}

/// &lt;summary&gt;
/// Returns a value that indicates whether the specified gamepad button was just pressed on the current frame.
/// &lt;/summary&gt;
/// &lt;param name=&quot;button&quot;&gt;The gamepad button to check.&lt;/param&gt;
/// &lt;returns&gt;true if the specified gamepad button was just pressed on the current frame; otherwise, false.&lt;/returns&gt;
public bool WasButtonJustPressed(Buttons button)
{
    return CurrentState.IsButtonDown(button) &amp;&amp; PreviousState.IsButtonUp(button);
}

/// &lt;summary&gt;
/// Returns a value that indicates whether the specified gamepad button was just released on the current frame.
/// &lt;/summary&gt;
/// &lt;param name=&quot;button&quot;&gt;The gamepad button to check.&lt;/param&gt;
/// &lt;returns&gt;true if the specified gamepad button was just released on the current frame; otherwise, false.&lt;/returns&gt;
public bool WasButtonJustReleased(Buttons button)
{
    return CurrentState.IsButtonUp(button) &amp;&amp; PreviousState.IsButtonDown(button);
}
</code></pre>
<p>These methods serve two distinct purposes. For checking continuous states:</p>
<ul>
<li><code>IsButtonDown</code>: Returns true as long as a button is being held down.</li>
<li><code>IsButtonUp</code>: Returns true as long as a button is not being pressed.</li>
</ul>
<p>And for detecting state changes:</p>
<ul>
<li><code>WasButtonJustPressed</code>: Returns true only on the frame when a button changes from up-to-down.</li>
<li><code>WasButtonJustReleased</code>: Returns true only on the frame when a button changes from down-to-up.</li>
</ul>
<p>Finally, we will add methods for controlling gamepad vibration:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Sets the vibration for all motors of this gamepad.
/// &lt;/summary&gt;
/// &lt;param name=&quot;strength&quot;&gt;The strength of the vibration from 0.0f (none) to 1.0f (full).&lt;/param&gt;
/// &lt;param name=&quot;time&quot;&gt;The amount of time the vibration should occur.&lt;/param&gt;
public void SetVibration(float strength, TimeSpan time)
{
    _vibrationTimeRemaining = time;
    GamePad.SetVibration(PlayerIndex, strength, strength);
}

/// &lt;summary&gt;
/// Stops the vibration of all motors for this gamepad.
/// &lt;/summary&gt;
public void StopVibration()
{
    GamePad.SetVibration(PlayerIndex, 0.0f, 0.0f);
}
</code></pre>
<p>The vibration methods provide control over the gamepad's haptic feedback:</p>
<ul>
<li><code>SetVibration</code>: Starts vibration at the specified strength for a set duration.</li>
<li><code>StopVibration</code>: Immediately stops all vibration.</li>
</ul>
<div class="TIP">
<h5>Tip</h5>
<p>When setting vibration, you can specify both the strength (<code>0.0f</code> to <code>1.0f</code>) and duration. The vibration will automatically stop after the specified time has elapsed, so you do not need to manage stopping it manually.</p>
</div>
<p>That's it for the <code>GamePadInfo</code> class.  Next, we can create the actual input manager.</p>
<h2 id="the-inputmanager-class">The InputManager Class</h2>
<p>Now that we have classes to handle keyboard, mouse, and gamepad input individually, we can create a centralized manager class to coordinate all input handling.</p>
<p>In the <code>Input</code> folder of the <em>MonoGameLibrary</em> project, add a new file named <code>InputManager.cs</code> with this initial structure:</p>
<pre><code class="lang-csharp">using Microsoft.Xna.Framework;

namespace MonoGameLibrary.Input;

public class InputManager { }

</code></pre><h3 id="inputmanager-properties">InputManager Properties</h3>
<p>The <code>InputManager</code> class needs properties to access each type of input device. Add these properties:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Gets the state information of keyboard input.
/// &lt;/summary&gt;
public KeyboardInfo Keyboard { get; private set; }

/// &lt;summary&gt;
/// Gets the state information of mouse input.
/// &lt;/summary&gt;
public MouseInfo Mouse { get; private set; }

/// &lt;summary&gt;
/// Gets the state information of a gamepad.
/// &lt;/summary&gt;
public GamePadInfo[] GamePads { get; private set; }
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>The <code>GamePads</code> property is an array because MonoGame supports up to four gamepads simultaneously. Each gamepad is associated with a PlayerIndex (0-3).</p>
</div>
<h3 id="inputmanager-constructor">InputManager Constructor</h3>
<p>The constructor for the <code>InputManager</code> initializes the keyboard, mouse, and gamepad states.</p>
<p>Add the following constructor:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Creates a new InputManager.
/// &lt;/summary&gt;
public InputManager()
{
    Keyboard = new KeyboardInfo();
    Mouse = new MouseInfo();

    GamePads = new GamePadInfo[4];
    for (int i = 0; i &lt; 4; i++)
    {
        GamePads[i] = new GamePadInfo((PlayerIndex)i);
    }
}
</code></pre><h3 id="inputmanager-methods">InputManager Methods</h3>
<p>The <code>Update</code> method for the <code>InputManager</code> calls update for each device, so that they can update their internal states.</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Updates the state information for the keyboard, mouse, and gamepad inputs.
/// &lt;/summary&gt;
/// &lt;param name=&quot;gameTime&quot;&gt;A snapshot of the timing values for the current frame.&lt;/param&gt;
public void Update(GameTime gameTime)
{
    Keyboard.Update();
    Mouse.Update();

    for (int i = 0; i &lt; 4; i++)
    {
        GamePads[i].Update(gameTime);
    }
}
</code></pre><h2 id="implementing-the-inputmanager-class">Implementing the InputManager Class</h2>
<p>Now that we have our input management system complete, we will update our game to use it.  We will do this in two steps:</p>
<ol>
<li>First, update the <code>Core</code> class to add the <code>InputManager</code> globally.</li>
<li>Update the <code>Game1</code> class to use the global input manager from <code>Core</code>.</li>
</ol>
<h3 id="updating-the-core-class">Updating the Core Class</h3>
<p>The <code>Core</code> class serves as our base game class, so we will update it to add and expose the <code>InputManager</code> globally.  Open the <em>Core.cs</em> file in the <em>MonoGameLibrary</em> project and update it to the following:</p>
<pre><code class="lang-csharp">using System;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;
using MonoGameLibrary.Input;

namespace MonoGameLibrary;

public class Core : Game
{
    internal static Core s_instance;

    /// &lt;summary&gt;
    /// Gets a reference to the Core instance.
    /// &lt;/summary&gt;
    public static Core Instance =&gt; s_instance;

    /// &lt;summary&gt;
    /// Gets the graphics device manager to control the presentation of graphics.
    /// &lt;/summary&gt;
    public static GraphicsDeviceManager Graphics { get; private set; }

    /// &lt;summary&gt;
    /// Gets the graphics device used to create graphical resources and perform primitive rendering.
    /// &lt;/summary&gt;
    public static new GraphicsDevice GraphicsDevice { get; private set; }

    /// &lt;summary&gt;
    /// Gets the sprite batch used for all 2D rendering.
    /// &lt;/summary&gt;
    public static SpriteBatch SpriteBatch { get; private set; }

    /// &lt;summary&gt;
    /// Gets the content manager used to load global assets.
    /// &lt;/summary&gt;
    public static new ContentManager Content { get; private set; }

    /// &lt;summary&gt;
    /// Gets a reference to the input management system.
    /// &lt;/summary&gt;
    public static InputManager Input { get; private set; }

    /// &lt;summary&gt;
    /// Gets or Sets a value that indicates if the game should exit when the esc key on the keyboard is pressed.
    /// &lt;/summary&gt;
    public static bool ExitOnEscape { get; set; }

    /// &lt;summary&gt;
    /// Creates a new Core instance.
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;title&quot;&gt;The title to display in the title bar of the game window.&lt;/param&gt;
    /// &lt;param name=&quot;width&quot;&gt;The initial width, in pixels, of the game window.&lt;/param&gt;
    /// &lt;param name=&quot;height&quot;&gt;The initial height, in pixels, of the game window.&lt;/param&gt;
    /// &lt;param name=&quot;fullScreen&quot;&gt;Indicates if the game should start in fullscreen mode.&lt;/param&gt;
    public Core(string title, int width, int height, bool fullScreen)
    {
        // Ensure that multiple cores are not created.
        if (s_instance != null)
        {
            throw new InvalidOperationException($&quot;Only a single Core instance can be created&quot;);
        }

        // Store reference to engine for global member access.
        s_instance = this;

        // Create a new graphics device manager.
        Graphics = new GraphicsDeviceManager(this);

        // Set the graphics defaults.
        Graphics.PreferredBackBufferWidth = width;
        Graphics.PreferredBackBufferHeight = height;
        Graphics.IsFullScreen = fullScreen;

        // Apply the graphic presentation changes.
        Graphics.ApplyChanges();

        // Set the window title.
        Window.Title = title;

        // Set the core's content manager to a reference of the base Game's
        // content manager.
        Content = base.Content;

        // Set the root directory for content.
        Content.RootDirectory = &quot;Content&quot;;

        // Mouse is visible by default.
        IsMouseVisible = true;

        // Exit on escape is true by default
        ExitOnEscape = true;
    }

    protected override void Initialize()
    {
        base.Initialize();

        // Set the core's graphics device to a reference of the base Game's
        // graphics device.
        GraphicsDevice = base.GraphicsDevice;

        // Create the sprite batch instance.
        SpriteBatch = new SpriteBatch(GraphicsDevice);

        // Create a new input manager.
        Input = new InputManager();
    }

    protected override void Update(GameTime gameTime)
    {
        // Update the input manager.
        Input.Update(gameTime);

        if (ExitOnEscape &amp;&amp; Input.Keyboard.IsKeyDown(Keys.Escape))
        {
            Exit();
        }

        base.Update(gameTime);
    }
}
</code></pre>
<p>The key changes to the <code>Core</code> class are:</p>
<ol>
<li>Added the <code>using MonoGameLibrary.Input;</code> directive to access the <code>InputManager</code> class.</li>
<li>Added a static <code>Input</code> property to provide global access to the input manager.</li>
<li>Added a static <code>ExitOnEscape</code> property to set whether the game should exit when the Escape key on the keyboard is pressed.</li>
<li>In the <code>Core</code> constructor, <code>ExitOnEscape</code> is set to true by default to mirror how the default MonoGame <code>Game1</code> class template has this functionality by default.</li>
<li>In <code>Initialize</code> the input manager is created.</li>
<li>Added an override for the <code>Update</code> method where:
<ol>
<li>The input manager is updated</li>
<li>A check is made to see if <code>ExitOnEscape</code> is true and if the Escape keyboard key is pressed.</li>
</ol>
</li>
</ol>
<h3 id="updating-the-game1-class">Updating the Game1 Class</h3>
<p>Now we can update our <code>Game1</code> class to use the new input management system through the <code>Core</code> class.  Open <code>Game1.cs</code> in the game project and update it to the following:</p>
<pre><code class="lang-csharp" highlight-lines="1,7,73,79,85,91,97,105,110,113,117,123,125-126,131,137,143,149">using System;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;
using MonoGameLibrary;
using MonoGameLibrary.Graphics;
using MonoGameLibrary.Input;

namespace DungeonSlime;

public class Game1 : Core
{
    // Defines the slime animated sprite.
    private AnimatedSprite _slime;

    // Defines the bat animated sprite.
    private AnimatedSprite _bat;

    // Tracks the position of the slime.
    private Vector2 _slimePosition;

    // Speed multiplier when moving.
    private const float MOVEMENT_SPEED = 5.0f;

    public Game1() : base(&quot;Dungeon Slime&quot;, 1280, 720, false)
    {

    }

    protected override void Initialize()
    {
        // TODO: Add your initialization logic here

        base.Initialize();
    }

    protected override void LoadContent()
    {
        // Create the texture atlas from the XML configuration file.
        TextureAtlas atlas = TextureAtlas.FromFile(Content, &quot;images/atlas-definition.xml&quot;);

        // Create the slime animated sprite from the atlas.
        _slime = atlas.CreateAnimatedSprite(&quot;slime-animation&quot;);
        _slime.Scale = new Vector2(4.0f, 4.0f);

        // Create the bat animated sprite from the atlas.
        _bat = atlas.CreateAnimatedSprite(&quot;bat-animation&quot;);
        _bat.Scale = new Vector2(4.0f, 4.0f);
    }

    protected override void Update(GameTime gameTime)
    {
        // Update the slime animated sprite.
        _slime.Update(gameTime);

        // Update the bat animated sprite.
        _bat.Update(gameTime);

        // Check for keyboard input and handle it.
        CheckKeyboardInput();

        // Check for gamepad input and handle it.
        CheckGamePadInput();

        base.Update(gameTime);
    }

    private void CheckKeyboardInput()
    {
        // If the space key is held down, the movement speed increases by 1.5
        float speed = MOVEMENT_SPEED;
        if (Input.Keyboard.IsKeyDown(Keys.Space))
        {
            speed *= 1.5f;
        }

        // If the W or Up keys are down, move the slime up on the screen.
        if (Input.Keyboard.IsKeyDown(Keys.W) || Input.Keyboard.IsKeyDown(Keys.Up))
        {
            _slimePosition.Y -= speed;
        }

        // if the S or Down keys are down, move the slime down on the screen.
        if (Input.Keyboard.IsKeyDown(Keys.S) || Input.Keyboard.IsKeyDown(Keys.Down))
        {
            _slimePosition.Y += speed;
        }

        // If the A or Left keys are down, move the slime left on the screen.
        if (Input.Keyboard.IsKeyDown(Keys.A) || Input.Keyboard.IsKeyDown(Keys.Left))
        {
            _slimePosition.X -= speed;
        }

        // If the D or Right keys are down, move the slime right on the screen.
        if (Input.Keyboard.IsKeyDown(Keys.D) || Input.Keyboard.IsKeyDown(Keys.Right))
        {
            _slimePosition.X += speed;
        }
    }

    private void CheckGamePadInput()
    {
        GamePadInfo gamePadOne = Input.GamePads[(int)PlayerIndex.One];

        // If the A button is held down, the movement speed increases by 1.5
        // and the gamepad vibrates as feedback to the player.
        float speed = MOVEMENT_SPEED;
        if (gamePadOne.IsButtonDown(Buttons.A))
        {
            speed *= 1.5f;
            gamePadOne.SetVibration(1.0f, TimeSpan.FromSeconds(1));
        }
        else
        {
            gamePadOne.StopVibration();
        }

        // Check thumbstick first since it has priority over which gamepad input
        // is movement.  It has priority since the thumbstick values provide a
        // more granular analog value that can be used for movement.
        if (gamePadOne.LeftThumbStick != Vector2.Zero)
        {
            _slimePosition.X += gamePadOne.LeftThumbStick.X * speed;
            _slimePosition.Y -= gamePadOne.LeftThumbStick.Y * speed;
        }
        else
        {
            // If DPadUp is down, move the slime up on the screen.
            if (gamePadOne.IsButtonDown(Buttons.DPadUp))
            {
                _slimePosition.Y -= speed;
            }

            // If DPadDown is down, move the slime down on the screen.
            if (gamePadOne.IsButtonDown(Buttons.DPadDown))
            {
                _slimePosition.Y += speed;
            }

            // If DPapLeft is down, move the slime left on the screen.
            if (gamePadOne.IsButtonDown(Buttons.DPadLeft))
            {
                _slimePosition.X -= speed;
            }

            // If DPadRight is down, move the slime right on the screen.
            if (gamePadOne.IsButtonDown(Buttons.DPadRight))
            {
                _slimePosition.X += speed;
            }
        }
    }

    protected override void Draw(GameTime gameTime)
    {
        // Clear the back buffer.
        GraphicsDevice.Clear(Color.CornflowerBlue);

        // Begin the sprite batch to prepare for rendering.
        SpriteBatch.Begin(samplerState: SamplerState.PointClamp);

        // Draw the slime sprite.
        _slime.Draw(SpriteBatch, _slimePosition);

        // Draw the bat sprite 10px to the right of the slime.
        _bat.Draw(SpriteBatch, new Vector2(_slime.Width + 10, 0));

        // Always end the sprite batch when finished.
        SpriteBatch.End();

        base.Draw(gameTime);
    }
}
</code></pre>
<p>The key changes to the <code>Game1</code> class are:</p>
<ol>
<li>In <a href="xref:Microsoft.Xna.Framework.Game.Update(Microsoft.Xna.Framework.GameTime)"><strong>Update</strong></a>, the check for the gamepad back button or keyboard escape key being pressed was removed.  This is now handled by the <code>ExitOnEscape</code> property and the <code>Update</code> method of the <code>Core</code> class.</li>
<li>In <code>CheckKeyboardInput</code> and <code>CheckGamepadInput</code>, instead of getting the keyboard and gamepad states and then using the states, calls to check those devices are now done through the input.</li>
</ol>
<p>Running the game now, you will be able to control it the same as before, only now we are using our new <code>InputManager</code> class instead.</p>
<table>
<thead>
<tr>
<th style="text-align: center;"><video width="500" height="281" controls=""><source type="video/webm" src="./videos/input-moving-slime.webm"></video></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Figure 11-1: The slime moving around based on device input</strong></td>
</tr>
</tbody>
</table>
<h2 id="conclusion">Conclusion</h2>
<p>In this chapter, you accomplished the following:</p>
<ul>
<li>Detect the difference between continuous and single-frame input states.</li>
<li>Create classes to manage different input devices.</li>
<li>Build a centralized <code>InputManager</code> to coordinate all input handling that is:
<ul>
<li>Reusable across different game projects</li>
<li>Easy to maintain and extend</li>
<li>Consistent across different input devices</li>
</ul>
</li>
<li>Integrate the input system into the <code>Core</code> class for global access.</li>
<li>Update the game to use the new input management system.</li>
</ul>
<h2 id="test-your-knowledge">Test Your Knowledge</h2>
<ol>
<li><p>What is the difference between checking if an input is &quot;down&quot; versus checking if it was &quot;just pressed&quot;?</p>
<p>:::question-answer
&quot;Down&quot; checks if an input is currently being held, returning true every frame while held. &quot;Just pressed&quot; only returns true on the first frame when the input changes from up to down, requiring comparison between current and previous states.
:::</p>
</li>
<li><p>Why do we track both current and previous input states?</p>
<p>:::question-answer
Tracking both states allows us to detect when input changes occur by comparing the current frame's state with the previous frame's state. This is essential for implementing &quot;just pressed&quot; and &quot;just released&quot; checks.
:::</p>
</li>
<li><p>What advantage does the <code>InputManager</code> provide over handling input directly?</p>
<p>:::question-answer
The <code>InputManager</code> centralizes all input handling, automatically tracks states between frames, and provides a consistent API across different input devices. This makes the code more organized, reusable, and easier to maintain.
:::</p>
</li>
</ol>

</article>
                </div>

            </main>
        </div>


        <script src="https://code.jquery.com/jquery-3.6.3.min.js" integrity="sha256-pvPw+upLPUjgMXY0G+8O0xUf+/Im1MZjXxxgOcBQBXU=" crossorigin="anonymous"></script>
        <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.1/dist/umd/popper.min.js" integrity="sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN" crossorigin="anonymous"></script>
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.min.js" integrity="sha384-+sLIOodYLS7CIrQpBjl+C7nPvqq+FbNUBDunl/OZv93DB7Ln/533i8e/mZXLi/P+" crossorigin="anonymous"></script>
        <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
        <script type="text/javascript" src="../../../../../../styles/jquery.twbsPagination.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/mark.js@8.11.1/dist/jquery.mark.min.js"></script>
        <script type="text/javascript" src="../../../../../../styles/url.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/anchor-js@5.0.0/anchor.min.js"></script>
        <script type="text/javascript" src="../../../../../../styles/docfx.js"></script>
        <script type="text/javascript" src="../../../../../../styles/main.js"></script>
        <script type="text/javascript" src="../../../../../../styles/singulink.js"></script>    </body>
</html>
