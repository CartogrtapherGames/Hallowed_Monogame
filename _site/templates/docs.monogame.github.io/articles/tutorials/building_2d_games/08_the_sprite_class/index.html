<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>

    <head>
      <meta charset="utf-8">
      <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
      <title>Chapter 08: The Sprite Class | hallowed </title>
      <meta name="viewport" content="width=device-width">
      <meta name="title" content="Chapter 08: The Sprite Class | hallowed ">
      <meta name="generator" content="docfx ">
  
      <link rel="shortcut icon" href="../../../../../../favicon.ico">
      <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/night-owl.min.css">
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css" integrity="sha384-EvBWSlnoFgZlXJvpzS+MAUEjvN7+gcCwH+qh7GRFOGgZO0PuwOFro7qPOJnLfe7l" crossorigin="anonymous">
      <link rel="stylesheet" href="../../../../../../styles/config.css">
      <link rel="stylesheet" href="../../../../../../styles/singulink.css">
      <link rel="stylesheet" href="../../../../../../styles/main.css">
      <meta property="docfx:navrel" content="../../../../../../toc.html">
      <meta property="docfx:tocrel" content="../../../toc.html">
  
  <meta property="docfx:rel" content="../../../../../../">
  
    </head>
    <body>
        <!-- Header required for docfx anchor scroll to work -->
        <header id="head"></header>
        <div class="top-navbar">
            <a class="burger-icon" onclick="toggleMenu()">
                <svg name="Hamburger" style="vertical-align: middle;" width="34" height="34" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" clip-rule="evenodd" d="M20 6H4V9H20V6ZM4 10.999H20V13.999H4V10.999ZM4 15.999H20V18.999H4V15.999Z"></path></svg>
            </a>


            <a class="brand" href="../../../../../../index.html">
              <img src="../../../../../../logo.svg" alt="hallowed" class="logomark">
              <span class="brand-title">hallowed</span>
            </a>        </div>

        <div class="body-content">
            <div id="blackout" class="blackout" onclick="toggleMenu()"></div>

            <nav id="sidebar" role="navigation">
                <div class="sidebar">

                    <div>
                      <div class="mobile-hide">

                        <a class="brand" href="../../../../../../index.html">
                          <img src="../../../../../../logo.svg" alt="hallowed" class="logomark">
                          <span class="brand-title">hallowed</span>
                        </a>                      </div>

                      <div class="sidesearch">
                        <form id="search" role="search" class="search">
                            <i class="bi bi-search search-icon"></i>
                            <input type="text" id="search-query" placeholder="Search" autocomplete="off">
                        </form>
                      </div>

                      <div id="navbar">
                      </div>
                    </div>                    <div class="sidebar-item-separator"></div>

                        <div id="sidetoggle">
                          <div id="sidetoc"></div>
                        </div>
                </div>
                <div class="footer">
  
  <strong><a href='https://dotnet.github.io/docfx/'>DocFX</a> + <a href='https://www.singulink.com'>Singulink</a> = â™¥</strong>
                </div>            </nav>

            <main class="main-panel">

                <div id="search-results" style="display: none;">
                  <h1 class="search-list">Search Results for <span></span></h1>
                  <div class="sr-items">
                    <p><i class="bi bi-hourglass-split index-loading"></i></p>
                  </div>
                  <ul id="pagination" data-first=First data-prev=Previous data-next=Next data-last=Last></ul>
                </div>
 

                <div role="main" class="hide-when-search">

                        <div class="subnav navbar navbar-default">
                          <div class="container hide-when-search" id="breadcrumb">
                            <ul class="breadcrumb">
                              <li></li>
                            </ul>
                          </div>
                        </div>

                         <div class="contribution">
                               <a href="https://github.com/MonoGame/docs.monogame.github.io/blob/main/articles/tutorials/building_2d_games/08_the_sprite_class/index.md/#L1" class="contribution-link">Edit this page</a>
                         </div>

                    <article class="content wrap" id="_content" data-uid="">


<p>In <a href="../07_optimizing_texture_rendering/index.html">Chapter 07</a>, you learned how to use texture atlases to optimize rendering performance. While this solved the issue of texture swapping, managing individual sprites and their properties becomes increasingly complex as your game grows. Even in our simple example with just a slime and a bat, we would eventually need to track various properties for each sprite:</p>
<ul>
<li>Color mask for tinting.</li>
<li>Origin for rotation and scale.</li>
<li>Scale for size adjustments.</li>
<li>Rotation for orientation.</li>
<li>Sprite effects to flip horizontally and/or vertically.</li>
<li>Layer depth for draw order layering.</li>
</ul>
<p>Imagine scaling this up to dozens of sprites, each with multiple instances on screen.  Tracking all these properties through individual variables quickly becomes unmanageable. In this chapter, we will solve this by creating a class that encapsulates sprite information and handles rendering.</p>
<h2 id="the-sprite-class">The Sprite Class</h2>
<p>A sprite in our game represents a visual object created from a texture region, along with its rendering properties. While multiple sprites might use the same texture region (like multiple enemies of the same type), each sprite can have unique properties that control how it appears on screen; its position, rotation, scale, and other visual characteristics.</p>
<p>By creating a <code>Sprite</code> class, we can encapsulate both the texture region and its rendering parameters into a single, reusable component. This not only makes our code more organized but also makes it easier to manage multiple instances of the same type of sprite.</p>
<p>In the <em>Graphics</em> folder within the <em>MonoGameLibrary</em> project, add a new file named <code>Sprite.cs</code> and add the following code for the foundation of the <code>Sprite</code> class to the file:</p>
<pre><code class="lang-csharp">using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;

namespace MonoGameLibrary.Graphics;

public class Sprite 
{

}
</code></pre><h3 id="properties">Properties</h3>
<p>The <code>Sprite</code> class will utilize properties that mirror the parameters used in <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteBatch.Draw(Microsoft.Xna.Framework.Graphics.Texture2D,Microsoft.Xna.Framework.Vector2,System.Nullable%7BMicrosoft.Xna.Framework.Rectangle%7D,Microsoft.Xna.Framework.Color,System.Single,Microsoft.Xna.Framework.Vector2,System.Single,Microsoft.Xna.Framework.Graphics.SpriteEffects,System.Single)"><strong>SpriteBatch.Draw</strong></a> so the rendering parameter for each sprite is self contained.  Add the following properties:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Gets or Sets the source texture region represented by this sprite.
/// &lt;/summary&gt;
public TextureRegion Region { get; set; }

/// &lt;summary&gt;
/// Gets or Sets the color mask to apply when rendering this sprite.
/// &lt;/summary&gt;
/// &lt;remarks&gt;
/// Default value is Color.White
/// &lt;/remarks&gt;
public Color Color { get; set; } = Color.White;

/// &lt;summary&gt;
/// Gets or Sets the amount of rotation, in radians, to apply when rendering this sprite.
/// &lt;/summary&gt;
/// &lt;remarks&gt;
/// Default value is 0.0f
/// &lt;/remarks&gt;
public float Rotation { get; set; } = 0.0f;

/// &lt;summary&gt;
/// Gets or Sets the scale factor to apply to the x- and y-axes when rendering this sprite.
/// &lt;/summary&gt;
/// &lt;remarks&gt;
/// Default value is Vector2.One
/// &lt;/remarks&gt;
public Vector2 Scale { get; set; } = Vector2.One;

/// &lt;summary&gt;
/// Gets or Sets the xy-coordinate origin point, relative to the top-left corner, of this sprite.
/// &lt;/summary&gt;
/// &lt;remarks&gt;
/// Default value is Vector2.Zero
/// &lt;/remarks&gt;
public Vector2 Origin { get; set; } = Vector2.Zero;

/// &lt;summary&gt;
/// Gets or Sets the sprite effects to apply when rendering this sprite.
/// &lt;/summary&gt;
/// &lt;remarks&gt;
/// Default value is SpriteEffects.None
/// &lt;/remarks&gt;
public SpriteEffects Effects { get; set; } = SpriteEffects.None;

/// &lt;summary&gt;
/// Gets or Sets the layer depth to apply when rendering this sprite.
/// &lt;/summary&gt;
/// &lt;remarks&gt;
/// Default value is 0.0f
/// &lt;/remarks&gt;
public float LayerDepth { get; set; } = 0.0f;

/// &lt;summary&gt;
/// Gets the width, in pixels, of this sprite. 
/// &lt;/summary&gt;
/// &lt;remarks&gt;
/// Width is calculated by multiplying the width of the source texture region by the x-axis scale factor.
/// &lt;/remarks&gt;
public float Width =&gt; Region.Width * Scale.X;

/// &lt;summary&gt;
/// Gets the height, in pixels, of this sprite.
/// &lt;/summary&gt;
/// &lt;remarks&gt;
/// Height is calculated by multiplying the height of the source texture region by the y-axis scale factor.
/// &lt;/remarks&gt;
public float Height =&gt; Region.Height * Scale.Y;
</code></pre>
<p>The <code>TextureRegion</code> property works to provide the texture and source rectangle when rendering the sprite. Other properties directly correspond to <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteBatch.Draw(Microsoft.Xna.Framework.Graphics.Texture2D,Microsoft.Xna.Framework.Vector2,System.Nullable%7BMicrosoft.Xna.Framework.Rectangle%7D,Microsoft.Xna.Framework.Color,System.Single,Microsoft.Xna.Framework.Vector2,System.Single,Microsoft.Xna.Framework.Graphics.SpriteEffects,System.Single)"><strong>SpriteBatch.Draw</strong></a> parameters with the same default values, making it easy to understand how each property affects the sprite's appearance.</p>
<div class="TIP">
<h5>Tip</h5>
<p>The calculated <code>Width</code> and <code>Height</code> properties make it easier to position sprites relative to each other without manually applying scale factors.</p>
</div>
<h3 id="constructors">Constructors</h3>
<p>The <code>Sprite</code> class provides two ways to create a new sprite.</p>
<p>Add the following constructors:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Creates a new sprite.
/// &lt;/summary&gt;
public Sprite() { }

/// &lt;summary&gt;
/// Creates a new sprite using the specified source texture region.
/// &lt;/summary&gt;
/// &lt;param name=&quot;region&quot;&gt;The texture region to use as the source texture region for this sprite.&lt;/param&gt;
public Sprite(TextureRegion region)
{
    Region = region;
}
</code></pre>
<ul>
<li>The default constructor creates an empty sprite that can be configured later.</li>
<li>The parameterized constructor allows you to specify the source texture region for the sprite.</li>
</ul>
<h3 id="methods">Methods</h3>
<p>Finally, add the following two method to the <code>Sprite</code> class:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Sets the origin of this sprite to the center.
/// &lt;/summary&gt;
public void CenterOrigin()
{
    Origin = new Vector2(Region.Width, Region.Height) * 0.5f;
}

/// &lt;summary&gt;
/// Submit this sprite for drawing to the current batch.
/// &lt;/summary&gt;
/// &lt;param name=&quot;spriteBatch&quot;&gt;The SpriteBatch instance used for batching draw calls.&lt;/param&gt;
/// &lt;param name=&quot;position&quot;&gt;The xy-coordinate position to render this sprite at.&lt;/param&gt;
public void Draw(SpriteBatch spriteBatch, Vector2 position)
{
    Region.Draw(spriteBatch, position, Color, Rotation, Origin, Scale, Effects, LayerDepth);
}
</code></pre>
<ul>
<li><p><code>CenterOrigin</code>: Sets the origin point of the sprite to its center.</p>
<div class="NOTE">
<h5>Note</h5>
<p>The origin needs to be set based on the width and height of the source texture region itself, regardless of the scale the sprite is rendered at.</p>
</div>
</li>
<li><p><code>Draw</code>: Uses the <code>TextureRegion</code> property to submit the sprite for rendering using the properties of the sprite itself.</p>
</li>
</ul>
<h2 id="create-sprites-with-the-textureatlas-class">Create Sprites With The TextureAtlas Class</h2>
<p>While the <code>GetRegion</code> method of the <code>TextureAtlas</code> class we created in <a href="../07_optimizing_texture_rendering/index.html#the-textureatlas-class">Chapter 07</a> works well for retrieving regions, creating sprites requires multiple steps:</p>
<ol>
<li>Get the region by name.</li>
<li>Store it in a variable.</li>
<li>Create a new sprite with that region.</li>
</ol>
<p>We can simplify this process by adding a sprite creation method to the <code>TextureAtlas</code> class. Open the <code>TextureAtlas.cs</code> and add the following method:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Creates a new sprite using the region from this texture atlas with the specified name.
/// &lt;/summary&gt;
/// &lt;param name=&quot;regionName&quot;&gt;The name of the region to create the sprite with.&lt;/param&gt;
/// &lt;returns&gt;A new Sprite using the texture region with the specified name.&lt;/returns&gt;
public Sprite CreateSprite(string regionName)
{
    TextureRegion region = GetRegion(regionName);
    return new Sprite(region);
}
</code></pre><h2 id="using-the-sprite-class">Using the Sprite Class</h2>
<p>Now we can adjust our game to use the <code>Sprite</code> class instead of just the texture regions.  Update the contents of <code>Game1.cs</code> with the following:</p>
<pre><code class="lang-csharp" highlight-lines="11-15,34-40,61-65">using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;
using MonoGameLibrary;
using MonoGameLibrary.Graphics;

namespace DungeonSlime;

public class Game1 : Core
{
    // Defines the slime sprite.
    private Sprite _slime;

    // Defines the bat sprite.
    private Sprite _bat;

    public Game1() : base(&quot;Dungeon Slime&quot;, 1280, 720, false)
    {

    }

    protected override void Initialize()
    {
        // TODO: Add your initialization logic here

        base.Initialize();
    }

    protected override void LoadContent()
    {
        // Create the texture atlas from the XML configuration file.
        TextureAtlas atlas = TextureAtlas.FromFile(Content, &quot;images/atlas-definition.xml&quot;);

        // Create the slime sprite from the atlas.
        _slime = atlas.CreateSprite(&quot;slime&quot;);
        _slime.Scale = new Vector2(4.0f, 4.0f);

        // Create the bat sprite from the atlas.
        _bat = atlas.CreateSprite(&quot;bat&quot;);
        _bat.Scale = new Vector2(4.0f, 4.0f);
    }

    protected override void Update(GameTime gameTime)
    {
        if (GamePad.GetState(PlayerIndex.One).Buttons.Back == ButtonState.Pressed || Keyboard.GetState().IsKeyDown(Keys.Escape))
            Exit();

        // TODO: Add your update logic here

        base.Update(gameTime);
    }

    protected override void Draw(GameTime gameTime)
    {
        // Clear the back buffer.
        GraphicsDevice.Clear(Color.CornflowerBlue);

        // Begin the sprite batch to prepare for rendering.
        SpriteBatch.Begin(samplerState: SamplerState.PointClamp);

        // Draw the slime sprite.
        _slime.Draw(SpriteBatch, Vector2.One);

        // Draw the bat sprite 10px to the right of the slime.
        _bat.Draw(SpriteBatch, new Vector2(_slime.Width + 10, 0));

        // Always end the sprite batch when finished.
        SpriteBatch.End();

        base.Draw(gameTime);
    }
}
</code></pre>
<p>The key changes in this implementation are:</p>
<ul>
<li>The <code>_slime</code> and <code>_bat</code> members were changed from <code>TextureRegion</code>  to <code>Sprite</code>.</li>
<li>In <a href="xref:Microsoft.Xna.Framework.Game.LoadContent"><strong>LoadContent</strong></a>
<ul>
<li>The <code>_slime</code> and <code>_bat</code> sprites are now created using the new <code>TextureAtlas.CreateSprite</code> method.</li>
<li>Both the <code>_slime</code> and <code>_bat</code> sprites are given a scale of 4.0f.</li>
</ul>
</li>
<li>In <a href="xref:Microsoft.Xna.Framework.Game.Draw(Microsoft.Xna.Framework.GameTime)"><strong>Draw</strong></a>, the draw calls were updated to use the <code>Sprite.Draw</code> method.</li>
</ul>
<p>Running the game now will produce the same result as in the previous chapter.</p>
<table>
<thead>
<tr>
<th style="text-align: center;"><img src="./images/slime-and-bat-rendered.png" alt="Figure 8-1: The slime and bat sprites being rendered in the upper-left corner of the game window"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Figure 8-1: The slime and bat sprites being rendered in the upper-left corner of the game window</strong></td>
</tr>
</tbody>
</table>
<div class="NOTE">
<h5>Note</h5>
<p>Notice how even though we increased the scale of both sprites, the bat sprite is still only 10px to the right of the slime.  This is because the <code>Width</code> property we created for the <code>Sprite</code> class takes into account the scale factor of the sprite as well.</p>
</div>
<p>Try adjusting the various properties available for the slime and the bat sprites to see how they affect the rendering.</p>
<h2 id="conclusion">Conclusion</h2>
<p>In this chapter, we created a reusable <code>Sprite</code> class that encapsulates the properties for each sprite that we would render.  The <code>TextureAtlas</code> class was updated to simplify sprite creation based on the <code>Sprite</code> class we created.</p>
<p>In the next chapter, we will build upon the <code>Sprite</code> class to create an <code>AnimatedSprite</code> class that will allow us to bring our sprites to life through animation.</p>
<h2 id="test-your-knowledge">Test Your Knowledge</h2>
<ol>
<li><p>What is the benefit of using a Sprite class instead of managing texture regions directly?</p>
<p>:::question-answer
The <code>Sprite</code> class encapsulates all rendering properties (position, rotation, scale, etc.) into a single, reusable component. This makes it easier to manage multiple instances of the same type of sprite without having to track properties through individual variables.
:::</p>
</li>
<li><p>Why do the <code>Width</code> and <code>Height</code> properties of a Sprite take the Scale property into account?</p>
<p>:::question-answer
The <code>Width</code> and <code>Height</code> properties account for scaling to make it easier to position sprites relative to each other without having to manually calculate the scaled dimensions. This is particularly useful when sprites are rendered at different scales.
:::</p>
</li>
<li><p>When using the <code>CenterOrigin</code> method, why is the origin calculated using the region's dimensions rather than the sprite's scaled dimensions?</p>
<p>:::question-answer
The origin needs to be set based on the texture region's actual dimensions because it represents the point around which scaling and rotation are applied. Using the scaled dimensions would result in incorrect positioning since the origin would change based on the current scale factor.
:::</p>
</li>
<li><p>What advantage does the <code>TextureAtlas.CreateSprite</code> method provide over using <code>GetRegion</code>?</p>
<p>:::question-answer
The <code>CreateSprite</code> method simplifies sprite creation by combining multiple steps (getting the region, storing it, creating a sprite) into a single method call. This reduces code repetition and makes sprite creation more straightforward.
:::</p>
</li>
</ol>

</article>
                </div>

            </main>
        </div>


        <script src="https://code.jquery.com/jquery-3.6.3.min.js" integrity="sha256-pvPw+upLPUjgMXY0G+8O0xUf+/Im1MZjXxxgOcBQBXU=" crossorigin="anonymous"></script>
        <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.1/dist/umd/popper.min.js" integrity="sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN" crossorigin="anonymous"></script>
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.min.js" integrity="sha384-+sLIOodYLS7CIrQpBjl+C7nPvqq+FbNUBDunl/OZv93DB7Ln/533i8e/mZXLi/P+" crossorigin="anonymous"></script>
        <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
        <script type="text/javascript" src="../../../../../../styles/jquery.twbsPagination.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/mark.js@8.11.1/dist/jquery.mark.min.js"></script>
        <script type="text/javascript" src="../../../../../../styles/url.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/anchor-js@5.0.0/anchor.min.js"></script>
        <script type="text/javascript" src="../../../../../../styles/docfx.js"></script>
        <script type="text/javascript" src="../../../../../../styles/main.js"></script>
        <script type="text/javascript" src="../../../../../../styles/singulink.js"></script>    </body>
</html>
